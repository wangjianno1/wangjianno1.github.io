---
title: JAVA中JVM垃圾回收算法与垃圾收集器
date: 2018-12-05 01:16:55
tags: JAVA虚拟机
categories: JAVA
---

# 判断对象是否还被使用的算法

判断对象是否还在被使用的算法有：

## 引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能被使用的。但是Java语言中没有选用引用计数算法来管理内存，其最主要原因是它很难解决对象之间的相互循环引用的问题。

## 根搜索算法

通过一系列的名为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链相连，按照图论的话来说就是从`GC Roots`到这个对象不可达时，则证明此对象是不可用的。

![](/images/java_gc_1_1.png)

# 垃圾回收/收集算法

## 标记-清除算法

算法分为“标记”和“清除”阶段。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题，一是效率问题， 二是空间问题（标记清除后会产生大量不连续的碎片）。

![](/images/java_gc_1_2.png)

## 复制算法

为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

![](/images/java_gc_1_3.png)

## 标记-整理算法

根据老年代的特点推出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

![](/images/java_gc_1_4.png)

## 分代回收算法

当前商业的虚拟机都采用的是“分代回收算法”。分代回收算法根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾回收时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成垃圾回收。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

# 垃圾回收/收集器

垃圾回收算法是内存回收的方法论，垃圾回收器则是内存回收的具体实现。Java虚拟机规范中对垃圾收集器的实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。如下为Sun HotSpot虚拟机所提供的所有收集器：

![](/images/java_gc_1_5.png)

备注：如果两个收集器之前存在连线，则说明它们可以搭配在一起使用。

## Serial收集器

Serial收集器是最基本、历史最悠久的收集器，在JDK 1.3.1版本前是虚拟机新生代垃圾收集的唯一选择。Serial收集器是一个单线程的收集器，而且在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。如下为Serial/Serial Old收集器的运行过程：

![](/images/java_gc_1_6.png)

新生代采用复制算法，老年代采用标记-整理算法。虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。当然Serial收集器也有优于其他垃圾收集器的地方，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。

## ParNew收集器

ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。ParNew收集器的工作过程如下图所示：

![](/images/java_gc_1_7.png)

新生代采用复制算法，老年代采用标记-整理算法。它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器配合工作。

## Parallel Scavenge收集器

Parallel Scavenge收集器类似于ParNew收集器。Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。

![](/images/java_gc_1_8.png)

新生代采用复制算法，老年代采用标记-整理算法。

## Serial Old收集器

Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途，一种用途是在JDK 1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。

## Parallel Old收集器

Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。

## CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它是非常符合在注重用户体验的应用上使用。CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种“标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

（1）初始标记
暂停所有的其他线程，并记录下直接与root相连的对象，速度很快。

（2）并发标记

同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

（3）重新标记

重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。

（4）并发清除

开启用户线程，同时GC线程开始对为标记的区域做清扫。

![](/images/java_gc_1_9.png)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点，一是对CPU资源敏感，二是无法处理浮动垃圾，三是它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

## G1收集器

G1（Garbage-First）是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：

（1）并行与并发

G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。

（2）分代收集

虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。

（3）空间整合

与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器，从局部上来看是基于“复制”算法实现的。

（4）可预测的停顿

这是G1相对于CMS的另一个大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。

G1收集器的运作大致分为以下几个步骤：

    初始标记 =》 并发标记 =》 最终标记 =》 筛选回收

G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region（这也就是它的名字Garbage-First的由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

# Minor GC、 Major GC、 Full GC

## Minor GC

Minor GC指对年轻代的堆内存进行垃圾回收。

Minor GC触发条件是Eden区域满了。Minor GC的工作内容主要有：

（1）将Eden中没有引用的对象直接被GC掉，其他还有引用的对象会复制到To Survivor区域。

（2）会将From Survivor中还存活的对象，一部分复制到To Survivor，一部分满足条件（这个条件后面会说明）的对象复制到年老代。

（3）From Survivor和To Survivor互换角色，From Survivor会变成To Survivor，To Survivor会变成From Survivor。
经过一次Minor GC后，Eden区域被清空了，From Survivor会被清空，且会变成To Survivor。

## Major GC

Major GC指对年老代的堆内存进行垃圾回收。

## Full GC

Full GC指即对年轻代又对年老代堆内存进行垃圾回收。Full GC时会同时进行Major GC和Minor GC。Full GC触发条件如下：

（1）调用System.GC时，系统建议执行Full GC，但是不必然执行

（2）老年代空间不足

（3）方法去空间不足

（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存

## 一点补充

Survivor中的对象进入年老代的满足如下条件之一即可：

（1）部分对象会在From Survivor和To Survivor区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认是15），最终如果还是存活，就存入到老年代。

（2）如果对象的大小大于Eden的二分之一会直接分配在年老代

（3）动态年龄判断，大于等于某个年龄的对象超过了Survivor空间一半，这些大于等于某个年龄的对象直接进入老年代

