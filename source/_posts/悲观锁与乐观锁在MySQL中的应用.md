---
title: 悲观锁与乐观锁在MySQL中的应用
date: 2019-02-14 00:47:17
tags: MySQL
categories: 数据库
---

# 数据库中的悲观锁与乐观锁

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像Memcache、Hibernate、Tair等都有类似的概念。

针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（**行锁、表锁、排他锁、共享锁**）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。

# 乐观锁

## 乐观锁简介

在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。

乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般实现乐观锁的方式就是记录数据版本。

数据版本为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。

实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。

## 使用版本号实现乐观锁

使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。

```sql
/*1.查询出商品信息*/
select (status,status,version) from t_goods where id=#{id}
/*2.根据商品信息生成订单*/
/*3.修改商品status为2*/
update t_goods set status=2,version=version+1 where id=#{id} and version=#{version};
```

## 乐观锁的优缺点

乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

# 悲观锁

## 悲观锁简介

在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

MySQL InnoDB存储引擎中，共享锁和排它锁是两种悲观锁。

## 排它锁

排他锁，exclusive lock（也叫writer lock）又称写锁。排它锁是悲观锁的一种。若事务1对数据对象A加上排它锁，事务1可以读A也可以修改A，其他事务不能再对A加任何锁，直到事务1释放A上的锁。这保证了其他事务在事务1释放A上的锁之前不能再读取和修改A。

要使用悲观锁，我们必须关闭MySQL数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。使用语句`set autocommit=0;`可以关闭autocommit模式。

```sql
/*1.关闭MySQL自动提交功能*/
set autocommit=0;
/*2.开始事务*/
begin;
/*3.查询出商品信息，for update加上排它锁*/
select status from t_goods where id=1 for update;
/*4.根据商品信息生成订单*/
insert into t_orders (id,goods_id) values (null,1);
/*5.修改商品status为2*/
update t_goods set status=2;
/*6.提交事务*/
commit;
```

上面的查询语句中，我们使用了`select … for update`的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。

上面我们提到，使用`select … for update`会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。

## 共享锁

共享锁，read lock，又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排它锁），直到已释放所有共享锁。

如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获得共享锁的事务只能读数据，不能修改数据。

在查询语句后面增加LOCK IN SHARE MODE，MySQL会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排它锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。

下面是具体使用共享锁的例子：

打开第一个查询窗口，

```sql
/*1.开启事务*/
begin;
/*2.lock in share mode，加上共享锁*/
SELECT * from t_goods where id = 1 lock in share mode;
```

然后在另一个查询窗口中，对id为1的数据进行更新，

```sql
update t_goods set name="www.souyunku.com" where id =1;
```

此时，操作界面进入了卡顿状态，过了超时间，提示错误信息。但是如果在超时前，执行commit，此更新语句就会成功。

    [SQL]update  test_one set name="www.souyunku.com" where id =1;
    [Err] 1205 - Lock wait timeout exceeded; try restarting transaction

## 悲观锁的优缺点

悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。

# 行锁和表锁

前面提到过，在InnoDB引擎中共享锁和排它锁都存在行锁和表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？ 当SQL语句的条件使用到索引了，InnoDB才使用行级锁，否则，InnoDB将使用表锁。

在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是，由于需要请求大量的锁资源，所以速度慢，内存消耗大。

学习资料参考于：
https://www.hollischuang.com/archives/934
https://mp.weixin.qq.com/s/gWR1-511SAwVAHrtGrsZ8g
https://www.souyunku.com/2018/07/30/mysql/
