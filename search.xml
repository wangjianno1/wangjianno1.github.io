<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL性能优化工具之执行计划Explain</title>
      <link href="/2022/03/28/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92Explain/"/>
      <url>/2022/03/28/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92Explain/</url>
      
        <content type="html"><![CDATA[<h1 id="Explian简介"><a href="#Explian简介" class="headerlink" title="Explian简介"></a>Explian简介</h1><p>MySQL提供了一个EXPLAIN命令, 它可以对SELECT语句进行分析, 并输出SELECT执行的详细信息, 以供开发人员针对性优化。Explain模拟SQL优化器执行SQL查询语句，并不会去真正的执行这条SQL，从而知道MySQL是如何处理你的SQL语句的。可用来分析你的查询语句或是表结构的性能瓶颈。通过Explain的执行计划可以得到如下的一些信息：</p><pre><code>表的读取顺序数据读取操作的操作类型哪些索引可以使用哪些索引被实际使用表之间的引用每张表有多少行被优化器查询</code></pre><h1 id="Explain使用"><a href="#Explain使用" class="headerlink" title="Explain使用"></a>Explain使用</h1><p>执行执行<code>explain + Select语句</code>即可。输出结果大概如下：</p><p><img src="/images/mysql_explain_1_1.png" alt></p><p>（1）id</p><p>// todo 待补充。。。</p><p>学习资料参考于：<br><a href="https://blog.csdn.net/qq_43332570/article/details/106860200" target="_blank" rel="noopener">https://blog.csdn.net/qq_43332570/article/details/106860200</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA设计模式之其他模式</title>
      <link href="/2022/03/21/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/21/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>单例类只能有一个实例。单例类必须自己创建自己的唯一实例。单例类必须给所有其他对象提供这一实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式，线程不安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式，线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：还有一些其他构建单例类的改进方式。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>（1）定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）定义多个实现类</p><p>定义一个矩形，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个三角形，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）创建工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）使用工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape shape = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模版模式"><a href="#模版模式" class="headerlink" title="模版模式"></a>模版模式</h1><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p><p>（1）创建一个抽象类，它的模板方法被设置为final</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//模板</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//初始化游戏</span></span><br><span class="line">      initialize();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//开始游戏</span></span><br><span class="line">      startPlay();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//结束游戏</span></span><br><span class="line">      endPlay();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建扩展了上述类的实体类Cricket和Football</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cricket Game Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cricket Game Initialized! Start playing."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cricket Game Started. Enjoy the game!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Football Game Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Football Game Initialized! Start playing."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Football Game Started. Enjoy the game!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用Game的模板方法play()来演示游戏的定义方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game game = <span class="keyword">new</span> Cricket();</span><br><span class="line">        game.play();</span><br><span class="line">        System.out.println();</span><br><span class="line">        ame = <span class="keyword">new</span> Football();</span><br><span class="line">        game.play();      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Design Pattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开源软件发布的一些版本代号</title>
      <link href="/2022/03/21/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E5%8F%91%E5%B8%83%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%88%E6%9C%AC%E4%BB%A3%E5%8F%B7/"/>
      <url>/2022/03/21/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E5%8F%91%E5%B8%83%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%88%E6%9C%AC%E4%BB%A3%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h1><p><img src="/images/bkm_1_1.png" alt></p><h1 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h1><p>（1）GA<br>General Availability，正式发布的版本，官方开始推荐广泛使用，国外有的用GA来表示release版本。</p><p>（2）RELEASE</p><p>正式发布版，官方推荐使用的版本，有的用GA来表示。比如Spring。</p><p>（3）Stable</p><p>稳定版，开源软件有的会用stable来表示正式发布的版本。比如Nginx。</p><p>（4）Final</p><p>最终版，也是正式发布版的一种表示方法。比如Hibernate。</p><p>（5）SNAPSHOT</p><p>SNAPSHOT，快照版，可以稳定使用，且仍在继续改进版本。使用Maven时，需要的jar包去仓库Nexus中找，一个仓库一般分为RELEASE仓和SNAPSHOT仓快照版，前者理解，稳定正式版本，后者如何？Maven在构建项目时，会优先去远程仓库中查看是否有最新的example-1.0-SNAPSHOT.jar，如果有则下载下来使用，即使本地仓库中已经有了example-1.0-SNAPSHOT.jar，它也会尝试去远程仓库中查看同名的jar是否是最新的。如此依赖，开源软件通过SNAPSHOT版本，可以微更新，而不用修改版本号。</p><p>（6）RC</p><p>Release Candidate，发行候选版本，基本不再加入新的功能，主要修复bug。是最终发布成正式版的前一个版本，将bug修改完就可以发布成正式版了。</p><p>（7）M1/M2/M3</p><p>M1/M2/M3中的M是Milestone的简写，这个单词是里程碑的意思。</p><p>（8）Alpha</p><p>α是希腊字母的第一个，表示最早的版本，内部测试版，一般不向外部发布，bug会比较多，功能也不全，一般只有测试人员使用。</p><p>（9）Beta</p><p>β是希腊字母的第二个，公开测试版，比alpha版本晚些，主要会有“粉丝用户”测试使用，该版本仍然存在很多bug，但比alpha版本稳定一些。这个阶段版本还会不断增加新功能。分为Beta1、Beta2等，直到逐渐稳定下来进入RC版本。</p><h1 id="其他闲杂"><a href="#其他闲杂" class="headerlink" title="其他闲杂"></a>其他闲杂</h1><p>LTS，Long Term Support，长期支持。软件的发行版本若被标注为LTS，表示软件的所有者会持续优化/修改这个软件版本。</p>]]></content>
      
      
      <categories>
          
          <category> 杂货铺 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内存溢出|内存泄露</title>
      <link href="/2022/03/04/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
      <url>/2022/03/04/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h1><p>内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。</p><h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>内存泄露memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中文件句柄泄露</title>
      <link href="/2022/03/04/Linux%E4%B8%AD%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%B3%84%E9%9C%B2/"/>
      <url>/2022/03/04/Linux%E4%B8%AD%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="句柄-文件描述符"><a href="#句柄-文件描述符" class="headerlink" title="句柄|文件描述符"></a>句柄|文件描述符</h1><p>文件描述符，File Descriptor，简称FD。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。socket返回的也是文件描述符。值得注意的是，文件描述符是一个整数，它和指针不是一回事，但是他们之间可以通过一些函数进行转换。</p><p>在Linux系列的操作系统上，由于Linux的设计思想便是把一切设备都视作文件。因此，文件描述符为在该系列平台上进行设备相关的编程实际上提供了一个统一的方法。</p><p>特别需要注意的是，在Windows平台下，将文件描述符、信号量以及互斥锁等等内核对象都记做句柄handle，因此这里说的Linux下的句柄泄漏并不靠谱，应该是Linux下的文件描述符泄漏，在Windows平台下才叫句柄泄漏。</p><h1 id="文件句柄泄露"><a href="#文件句柄泄露" class="headerlink" title="文件句柄泄露"></a>文件句柄泄露</h1><p>在Linux中，如果一个文件正在被某个进程占用，用户操作rm删除该文件后，我们ls后发现文件已经不存在了，但实际上该文件仍然在磁盘上。直到使用它的进程退出后，文件占用的磁盘空间才会被释放。</p><p>这是因为，在Linux中，每个文件都有2个计数器，i_count和i_nlink。i_count表示文件正在被调用的数量。i_nlink表示硬链接的数量。可以理解为i_count为内存的引用计数器，i_nlink为磁盘的引用计数器。当一个文件被某一个进程引用时，对应i_count数就会增加；当创建文件的硬链接的时候，对应i_nlink数就会增加。rm操作是将文件的i_nlink减少了，如果没有其它的硬链接i_nlink就为0了；但由于该文件依然被进程引用，因此，此时文件对应的i_count并不为0，所以即使执行rm操作，但系统并没有真正删除这个文件，当只有i_nlink及i_count都为0的时候，这个文件才会真正被删除。也就是说，还需要解除该进程的对该文件的调用才行。</p><p>因此，在这种情况下，就需要使用lsof工具来查看文件被哪些进程的占用情况了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程语言修炼通用步骤</title>
      <link href="/2022/03/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%BF%AE%E7%82%BC%E9%80%9A%E7%94%A8%E6%AD%A5%E9%AA%A4/"/>
      <url>/2022/03/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%BF%AE%E7%82%BC%E9%80%9A%E7%94%A8%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="基本语法的学习步骤"><a href="#基本语法的学习步骤" class="headerlink" title="基本语法的学习步骤"></a>基本语法的学习步骤</h1><p>（1）基本数据类型</p><p>整型（包括字符型）、浮点型、布尔型等</p><p>（2）操作符/运算符</p><p>加、减、乘、除等</p><p>（3）表达式</p><p>算术表达式、逻辑表达式、关系表达式等等</p><p>（4）基本语句</p><p>例如if语句、while语句以及for语句等等</p><p>（5）函数</p><p>（6）ADT</p><p>例如，类、枚举、结构体、接口以及@interface等等。字符串，数组也算吧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂货铺 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议</title>
      <link href="/2022/03/01/ARP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/03/01/ARP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="ARP工作过程"><a href="#ARP工作过程" class="headerlink" title="ARP工作过程"></a>ARP工作过程</h1><p><img src="/images/network_arp_1_1.png" alt></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>（1）每一个主机上都设有一个ARP高速缓存（ARP cache），里面有本局域网LAN上的各主机和路由器的IP地址到MAC地址的映射表。有点类似IP层的路由表，这是MAC地址缓存表。</p><p>（2）ARP报文的目的MAC地址是广播地址FF-FF-FF-FF-FF-FF。交换机会将报文从交换机的所有端口转发出去，ARP报文会在整个网络上传播，该网络中所有主机包括网关都会接收到此ARP报文，网关将会阻止该ARP报文发送到其他网络上。如果只有一个VLAN的话，ARP报文会传到到子网中的所有设备，直到路由器/网关为止。这个报文走过的边边角角就是一个广播域。</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP/1.x与HTTP/2协议协商机制</title>
      <link href="/2022/02/27/HTTP-1-x%E4%B8%8EHTTP-2%E5%8D%8F%E8%AE%AE%E5%8D%8F%E5%95%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/02/27/HTTP-1-x%E4%B8%8EHTTP-2%E5%8D%8F%E8%AE%AE%E5%8D%8F%E5%95%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议协商机制简介"><a href="#HTTP协议协商机制简介" class="headerlink" title="HTTP协议协商机制简介"></a>HTTP协议协商机制简介</h1><p>HTTP协议协商机制指的是，客户端与服务端协商使用HTTP/1.x还是HTTP/2来进行通信。其实HTTP/2可以运行在TLS上，也可以不使用TLS，也即对应如下两种：</p><p>（1）HTTP/2 over TLS，h2</p><p>字符串”h2”标识HTTP/2使用传输层安全性(TLS)的协议。该标识符用于TLS应用层协议协商（ALPN）扩展TLS-ALPN字段以及识别HTTP/2 over TLS的任何地方。</p><p>（2）HTTP/2 over TCP，h2c</p><p>字符串”h2c”标识通过明文TCP运行HTTP/2的协议。此标识符用于HTTP/1.1升级标头字段以及标识HTTP/2 over TCP的任何位置。</p><p>相应地，HTTP协议版本协商机制也有两种，一种HTTP Upgrade；另一种是TLS ALPN扩展来协商。</p><h1 id="HTTP-Upgrade机制"><a href="#HTTP-Upgrade机制" class="headerlink" title="HTTP Upgrade机制"></a>HTTP Upgrade机制</h1><p>为了更方便地部署新协议，HTTP/1.1引入了Upgrade机制，它使得客户端和服务端之间可以借助已有的HTTP语法升级到其它协议。</p><p>要发起HTTP/1.1协议升级，客户端必须在请求头部中指定这两个字段：</p><pre><code>Connection: UpgradeUpgrade: protocol-name[/protocol-version]</code></pre><p>客户端通过Upgrade头部字段列出所希望升级到的协议和版本，多个协议之间用英文逗号和空格（0x2C, 0x20）隔开。除了这两个字段之外，一般每种新协议还会要求客户端发送额外的新字段，这里略过不写。</p><p>如果服务端不同意升级或者不支持Upgrade所列出的协议，直接忽略即可（当成HTTP/1.1请求，以HTTP/1.1响应）；如果服务端同意升级，那么需要这样响应：</p><pre><code>HTTP/1.1 101 Switching ProtocolsConnection: upgradeUpgrade: protocol-name[/protocol-version][... data defined by new protocol ...]</code></pre><p>可以看到，HTTP Upgrade响应的状态码是101，并且响应正文可以使用新协议定义的数据格式。</p><p>举例来说，</p><pre><code>GET / HTTP/1.1Host: example.comConnection: Upgrade, HTTP2-SettingsUpgrade: h2cHTTP2-Settings: &lt;base64url encoding of HTTP/2 SETTINGS payload&gt;</code></pre><p>在HTTP Upgrade机制中，HTTP/2的协议名称是h2c，代表HTTP/2 ClearText。如果服务端不支持HTTP/2，它会忽略Upgrade字段，直接返回HTTP/1.1响应，例如：</p><pre><code>HTTP/1.1 200 OKContent-Length: 243Content-Type: text/html...</code></pre><p>如果服务端支持HTTP/2，那就可以回应101状态码及对应头部，并且在响应正文中可以直接使用HTTP/2二进制帧：</p><pre><code>HTTP/1.1 101 Switching ProtocolsConnection: UpgradeUpgrade: h2c[ HTTP/2 connection … ]</code></pre><p>以下是通过HTTP Upgrade机制将HTTP/1.1升级到HTTP/2的Wireshark抓包：</p><p><img src="/images/http2_1_9.png" alt></p><p>根据HTTP/2协议中的描述，额外补充几点：</p><p>（1）41号包中，客户端发起的协议升级请求中，必须通过HTTP2-Settings指定一个经过Base64编码过的HTTP/2 SETTINGS帧；</p><p>（2）45号包中，服务端同意协议升级，响应正文中必须包含HTTP/2 SETTING帧（二进制格式，不需要Base64编码）；</p><p>（3）62号包中，客户端可以开始发送各种HTTP/2帧，但第一个帧必须是Magic帧（内容固定为<code>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code>），做为协议升级的最终确认；</p><p>HTTP Upgrade机制本身没什么问题，但很容易受网络中间环节影响。例如不能正确处理Upgrade头部的代理节点，很可能造成最终升级失败。之前我们统计过WebSocket的连通情况，发现大量明明支持WebSocket的浏览器却无法升级，只能使用降级方案。</p><h1 id="TLS-ALPN扩展"><a href="#TLS-ALPN扩展" class="headerlink" title="TLS ALPN扩展"></a>TLS ALPN扩展</h1><p>HTTP/2协议本身并没有要求它必须基于HTTPS（TLS部署，但是出于以下三个原因，实际使用中，HTTP/2和HTTPS几乎都是捆绑在一起：</p><p>（1）HTTP数据明文传输，数据很容易被中间节点窥视或篡改，HTTPS可以保证数据传输的保密性、完整性和不被冒充；</p><p>（2）正因为HTTPS传输的数据对中间节点保密，所以它具有更好的连通性。基于HTTPS部署的新协议具有更高的连接成功率；</p><p>（3）当前主流浏览器，都只支持基于HTTPS部署的HTTP/2；</p><p>如果前面两个原因还不足以说服你，最后这个绝对有说服力，除非你的HTTP/2服务只打算给自己客户端用。</p><p>基于HTTPS的协议协商非常简单，多了TLS之后，双方必须等到成功建立TLS连接之后才能发送应用数据。而要建立TLS连接，本来就要进行CipherSuite等参数的协商。引入HTTP/2之后，需要做的只是在原本的协商机制中把对HTTP协议版本的协商加进去。</p><p>Google在SPDY协议中开发了一个名为NPN（Next Protocol Negotiation，下一代协议协商）的TLS扩展。随着SPDY被HTTP/2取代，NPN也被官方修订为ALPN（Application Layer Protocol Negotiation，应用层协议协商）。二者的目标和实现原理基本一致，这里只介绍后者。如图：</p><p><img src="/images/http2_1_10.png" alt></p><p>可以看到，客户端在建立TLS连接的ClientHello握手中，通过ALPN扩展列出了自己支持的各种应用层协议。其中，HTTP/2协议名称是h2。</p><p><img src="/images/http2_1_11.png" alt></p><p>如果服务端支持HTTP/2，在ServerHello中指定ALPN的结果为h2就可以了；如果服务端不支持HTTP/2，从客户端的ALPN列表中选一个自己支持的即可。</p><p>并不是所有HTTP/2客户端都支持ALPN，理论上建立TLS连接后，依然可以再通过HTTP Upgrade进行协议升级，只是这样会额外引入一次往返。</p><h1 id="其他闲杂问题"><a href="#其他闲杂问题" class="headerlink" title="其他闲杂问题"></a>其他闲杂问题</h1><p>HTTP/2需要基于HTTPS部署是当前主流浏览器的要求。如果你的HTTP/2服务要支持浏览器访问，那就必须基于HTTPS部署；如果只给自己客户端用，可以不部署HTTPS（这个页面列举了很多支持h2c的HTTP/2服务端、客户端实现）。</p><p>支持HTTP/2的Web Server基本都支持HTTP/1.1。这样，即使浏览器不支持HTTP/2，双方也可以协商出可用的HTTP版本，没有兼容性问题。如下表：</p><p><img src="/images/http2_1_12.png" alt></p><p>学习资料参考于：<br><a href="https://imququ.com/post/protocol-negotiation-in-http2.html" target="_blank" rel="noopener">https://imququ.com/post/protocol-negotiation-in-http2.html</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据加密技术和数字签名技术小结</title>
      <link href="/2022/02/27/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%92%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/"/>
      <url>/2022/02/27/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%92%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="数据加密技术"><a href="#数据加密技术" class="headerlink" title="数据加密技术"></a>数据加密技术</h1><p>数据加密技术，根据加密密钥和解密密钥是否相同划分成两种。一种是对称密钥密码体制；一种是公钥密码体制。</p><h2 id="对称密钥密码体制"><a href="#对称密钥密码体制" class="headerlink" title="对称密钥密码体制"></a>对称密钥密码体制</h2><p>对称密钥密码体制中，A端的加密密钥和B端的解密密钥是相同的。此类常用加密算法有DES，IDEA，AES等。数据加密模型如下：</p><p><img src="/images/security_encrypt_1_1.jpeg" alt></p><h2 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h2><p>公钥密码体制，也称非对称密钥密码体制。公钥密码体制中，加密密钥和解密密钥是不相同的。RSA和DSA加密算法属于非对称的加密算法。公钥密码体制的图如下：</p><p><img src="/images/security_encrypt_1_2.jpeg" alt></p><p>在接收者B端通过密钥对产生器生成一对密钥，即加密密钥PK和解密密钥SK。发送者A用的PK就是在接收者B那里产生的。</p><p>密钥对生成器生成的密钥对中，加密密钥PK，是向公众公开的，所以简称为公钥。而解密秘钥SK是需要保密的，所以简称为私钥。</p><p>目前最著名的公钥密码体制的加密算法是由美国三位科学家Rivest,Shamir和Adleman于1976-1978年提出的RSA加密算法，这个算法是基于数论中的大数分解问题的。</p><h1 id="数字签名技术"><a href="#数字签名技术" class="headerlink" title="数字签名技术"></a>数字签名技术</h1><h2 id="数字签名简介"><a href="#数字签名简介" class="headerlink" title="数字签名简介"></a>数字签名简介</h2><p>数字签名技术，也称数字鉴别技术。假设A和B之间进行通讯，数字签名就是让接收者B在收到数据的时候，可以断定数据是来自发送者A的。数字签名的实现图如下：</p><p><img src="/images/security_sign_1_1.jpeg" alt></p><p>这里是D运算和E运算，如上面插图中不一样，因为意义不同。数字签名是非对称加密的相关的过程，这个只有鉴别作用，没有加密作用。只是用来鉴别数据是来自某个主体。网络上任何人都可以用公钥去解密这个数字签名。</p><p>如下是用数据的摘要信息来进行数据签名的机制图：</p><p><img src="/images/security_sign_1_3.png" alt></p><h2 id="常用的数据签名认证算法"><a href="#常用的数据签名认证算法" class="headerlink" title="常用的数据签名认证算法"></a>常用的数据签名认证算法</h2><p>（1）DSA</p><p>DSA全称Digital Signature Algorithm，DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只能用于数字签名，所以它比RSA要快很多，其安全性与RSA相比差不多。</p><p>（2）ECDSA</p><p><img src="/images/security_sign_1_4.png" alt></p><h2 id="具有加密作用的数字签名的图解"><a href="#具有加密作用的数字签名的图解" class="headerlink" title="具有加密作用的数字签名的图解"></a>具有加密作用的数字签名的图解</h2><p><img src="/images/security_sign_1_5.jpeg" alt></p><h1 id="数据加密和数字签名的区别联系"><a href="#数据加密和数字签名的区别联系" class="headerlink" title="数据加密和数字签名的区别联系"></a>数据加密和数字签名的区别联系</h1><p>以RSA算法来实现数据加密和数字签名来说明。</p><p>（1）RSA的加密解密机制原理</p><p>RSA公钥加密体制包含如下3个算法：KeyGen（密钥生成算法），Encrypt（加密算法）以及Decrypt（解密算法）。详细如下：</p><p><img src="/images/security_encrypt_1_3.png" alt></p><p>所以，从算法描述中我们也可以看出，公钥用于对数据进行加密，私钥用于对数据进行解密。当然了，这个也可以很直观的理解，公钥就是公开的密钥，其公开了大家才能用它来加密数据。私钥是私有的密钥，谁有这个密钥才能够解密密文。否则大家都能看到私钥，就都能解密，那不就乱套了。</p><p>（2）RSA的签名认证机制原理</p><p>签名体制同样包含3个算法：KeyGen（密钥生成算法），Sign（签名算法），Verify（验证算法）。其中秘钥生成算法和RSA加密解密中的秘钥生成算法是一样的。</p><p><img src="/images/security_sign_1_2.png" alt></p><p>对于签名和认证的M，可以是原始的信息的报文摘要。在HTTPS中，CA对也是对证书的某些信息的报文摘要进行签名的。所以，在签名算法中，私钥用于对数据进行签名，公钥用于对签名进行验证。这也可以直观地进行理解，对一个文件签名，当然要用私钥，因为我们希望只有自己才能完成签字。验证过程当然希望所有人都能够执行，大家看到签名都能通过验证证明确实是我自己签的。</p><p>（3）RSA加密解密机制和签名认证机制的区别和联系</p><p>假设RSA加密解密系统中，将加密函数称为E，将解码函数称为D。在加密过程中，我们使用公钥PK和E函数，将报文加密，然后在对端使用私钥SK和D函数将密文解密，得到原始的报文。</p><p>而在签名认证的过程中，我们使用私钥SK和D函数进行报文的签名，然后在对端使用公钥PK和E函数进行认证。注意的是，这里的D和E和上面的D和E函数是一样的。</p><p>因为，在RSA加密系统中，以任意顺序应用D和E函数时，两者都会相互抵消。因此<code>E(D(stuff))=stuff</code>，就像<code>D(E(stuff))=stuff</code>一样。只是习惯上，E和D在加密过程中，称为加密函数和解码函数；而在签名认证过程中，称为签名函数和认证函数，其实是一样的。</p><p>学习资料来源于：<br><a href="https://www.zhihu.com/question/25912483" target="_blank" rel="noopener">https://www.zhihu.com/question/25912483</a><br><a href="https://juejin.im/post/5a67f3836fb9a01c9b661bd3" target="_blank" rel="noopener">https://juejin.im/post/5a67f3836fb9a01c9b661bd3</a></p>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket技术调研</title>
      <link href="/2022/02/27/WebSocket%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2022/02/27/WebSocket%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h1><p>WebSocket是一种网络通信协议。在2009年诞生，于2011年被IETF定为标准RFC 6455通信标准。并由RFC7936补充规范。WebSocket API也被W3C定为标准。</p><p>WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工（full-duplex）通讯的协议。没有了Request和Response的概念，两者地位完全平等，连接一旦建立，就建立了真正的持久性连接，双方可以随时向对方发送数据。</p><p><img src="/images/websocket_1_1.png" alt></p><p>简单总结WebSocket，WebSocket是HTML5开始提供的一种独立在单个TCP连接上进行全双工通讯的有状态的协议（它不同于无状态的HTTP），并且还能支持二进制帧、扩展协议、部分自定义的子协议、压缩等特性。</p><p>目前看来，WebSocket是可以完美替代AJAX轮询和Comet。但是某些场景还是不能替代SSE，WebSocket和SSE各有所长。</p><h1 id="WebSocket的特点"><a href="#WebSocket的特点" class="headerlink" title="WebSocket的特点"></a>WebSocket的特点</h1><p>WebSocket最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p><p><img src="/images/websocket_1_2.png" alt></p><p>其他特点包括：</p><p>（1）建立在TCP协议之上，服务器端的实现比较容易。</p><p>（2）与HTTP协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是URL，形如<code>ws://example.com:80/some/path</code>。</p><p><img src="/images/websocket_1_3.png" alt></p><h1 id="WebSocket编程"><a href="#WebSocket编程" class="headerlink" title="WebSocket编程"></a>WebSocket编程</h1><p>（1）WebSocket客户端编写</p><pre><code class="javascript"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"wss://echo.websocket.org"</span>);ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>{     <span class="built_in">console</span>.log(<span class="string">"Connection open ..."</span>);     ws.send(<span class="string">"Hello WebSockets!"</span>);};ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>{    <span class="built_in">console</span>.log( <span class="string">"Received Message: "</span> + evt.data);    ws.close();};ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>{    <span class="built_in">console</span>.log(<span class="string">"Connection closed."</span>);};</code></pre><h1 id="WebSocket与长链接的HTTP的联系区别"><a href="#WebSocket与长链接的HTTP的联系区别" class="headerlink" title="WebSocket与长链接的HTTP的联系区别"></a>WebSocket与长链接的HTTP的联系区别</h1><p>（1）WebSocket是也是基于TCP长连接技术上的，值得注意的是，WebSocket也是使用的是80/443端口。</p><p>（2）HTTP和WebSocket都是应用层协议。</p><p>（3）WebSocket协议有两部分阶段，一是握手阶段；另一个是数据传输阶段。WebSocket的握手阶段是基于HTTP Upgrade机制的，将HTTP协议协议升级到WebSocket协议。然后WebSocket数据传输阶段就和HTTP没关系了，使用的WebSocket协议。</p><p><img src="/images/websocket_1_4.png" alt></p><h1 id="nginx支持websocket"><a href="#nginx支持websocket" class="headerlink" title="nginx支持websocket"></a>nginx支持websocket</h1><p>nginx已支持websocket，只需要开启nginx的Upgrade机制即可。</p><p>学习资料参考于：<br><a href="https://halfrost.com/websocket/" target="_blank" rel="noopener">https://halfrost.com/websocket/</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP/3技术调研</title>
      <link href="/2022/02/27/HTTP-3%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2022/02/27/HTTP-3%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-3简介"><a href="#HTTP-3简介" class="headerlink" title="HTTP/3简介"></a>HTTP/3简介</h1><p>虽然HTTP/2解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的TCP协议造成的。</p><p>上文提到HTTP/2使用了多路复用，一般来说同一域名下只需要使用一个TCP连接。但当这个连接中出现了丢包的情况，那就会导致HTTP/2的表现情况反倒不如HTTP/1了。</p><p>因为在出现丢包的情况下，整个TCP都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于HTTP/1.1来说，可以开启多个TCP连接，出现这种情况反到只会影响其中一个连接，剩余的TCP连接还可以正常传输数据。</p><p>那么可能就会有人考虑到去修改TCP协议，其实这已经是一件不可能完成的任务了。因为TCP存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</p><p>基于这个原因，Google就另起炉灶搞了一个基于UDP协议的QUIC协议，并且使用在了HTTP/3上，HTTP/3之前名为HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3最大的改造就是使用了QUIC。</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP/2技术调研</title>
      <link href="/2022/02/27/HTTP-2%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2022/02/27/HTTP-2%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-2简介"><a href="#HTTP-2简介" class="headerlink" title="HTTP/2简介"></a>HTTP/2简介</h1><p>2015年，HTTP/2发布。HTTP/2是现行HTTP协议（HTTP/1.x）的替代，但它不是重写，HTTP方法/状态码/语义都与HTTP/1.x一样。HTTP/2基于SPDY3，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）。</p><p>HTTP/2没有改动HTTP的应用语义。 HTTP方法、状态代码、URI和标头字段等核心概念一如往常。 不过相较于HTTP/1.1来说，HTTP/2提供有如下新特性：</p><p>（1）多路复用</p><p>HTTP/2使用多路复用技术，同一个TCP连接可以并发处理多个请求。</p><p>（2）首部压缩</p><p>HTTP/1.1的首部带有大量信息，而且每次都要重复发送。HTTP/2.0要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。</p><p>（3）服务端推送</p><p>HTTP/2在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求index.html页面，服务端就把index.js一起发给客户端。</p><p>（4）二进制分帧</p><p>HTTP/1.1的解析是基于文本的，而HTTP/2采用二进制格式。</p><h1 id="HTTP-2二进制分帧层"><a href="#HTTP-2二进制分帧层" class="headerlink" title="HTTP/2二进制分帧层"></a>HTTP/2二进制分帧层</h1><p>在不改动HTTP/1.x的语义、方法、状态码、URI以及首部字段等情况下, HTTP/2是如何做到「突破HTTP1.1的性能限制，改进传输性能，实现低延迟和高吞吐量」的？关键之一就是在应用层（HTTP/2）和传输层（TCP/UDP）之间增加一个二进制分帧层。</p><p><img src="/images/http2_1_1.png" alt></p><p>在二进制分帧层中， HTTP/2会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到HEADER frame，而相应的Request Body则封装到DATA frame里面。</p><p>HTTP/2通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。</p><p>在过去， HTTP性能优化的关键并不在于高带宽，而是低延迟。TCP连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为TCP慢启动。由于这种原因，让原本就具有突发性和短时性的HTTP连接变的十分低效。HTTP/2通过让所有数据流共用同一个连接，可以更有效地使用TCP连接，让高带宽也能真正的服务于HTTP的性能提升。</p><p>总结，单连接多资源的方式，减少服务端的链接压力，内存占用更少，连接吞吐量更大；由于TCP连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少，使拥塞和丢包恢复速度更快。</p><p><img src="/images/http2_1_2.png" alt></p><p><img src="/images/http2_1_3.png" alt></p><p>备注：Stream Identifier编号，表示了不同的HTTP请求/响应交互。</p><p>帧的种类有如下几种：</p><p><img src="/images/http2_1_4.png" alt></p><h1 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h1><p>多路复用，代替原来的序列和阻塞机制。所有的请求都是通过一个TCP连接并发完成。 HTTP 1.x中，如果想并发多个请求，必须使用多个TCP链接，且浏览器为了控制资源，还会对单个域名有6-8个的TCP链接请求限制。比如Chrome有个机制，对于同一个域名，默认允许同时建立6个TCP持久连接。使用持久连接时，虽然能共用一个TCP管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态，如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。</p><p>HTTP/2可以很容易的去实现多流并行而不用依赖建立多个TCP连接。如下图，红色圈出来的请求就因域名链接数已超过限制，而被挂起等待了一段时间：</p><p><img src="/images/http2_1_5.png" alt></p><p><img src="/images/http2_1_6.png" alt></p><p><img src="/images/http2_1_7.png" alt></p><h1 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h1><p>服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如客户端向服务端请求index.html页面，html页面中嵌有JS和CSS文件，服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。</p><p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。</p><p><img src="/images/http2_1_8.png" alt></p><h1 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h1><p>HTTP/1.1请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续被发送。HTTP/2对消息头采用HPACK（专为HTTP/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。</p><h1 id="HTTP-2开启方法"><a href="#HTTP-2开启方法" class="headerlink" title="HTTP/2开启方法"></a>HTTP/2开启方法</h1><p>（1）服务端开启HTTP/2</p><p>在Nginx的配置文件nginx.conf增加如下内容：</p><pre><code>listen [::]:443 ssl http2 ipv6only=on; listen 443 ssl http2;</code></pre><p>（2）客户端开启HTTP/2</p><p>主流浏览器都支持了HTTP/2啦。是否使用HTTP/2通信，还需要浏览器和服务端进行协商才可以啦。</p><p>学习资料参考于：<br><a href="https://www.infoq.cn/article/kU4OkqR8vH123a8dLCCJ" target="_blank" rel="noopener">https://www.infoq.cn/article/kU4OkqR8vH123a8dLCCJ</a><br><a href="https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/" target="_blank" rel="noopener">https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>低版本浏览器对HTTPS支持问题</title>
      <link href="/2022/02/27/%E4%BD%8E%E7%89%88%E6%9C%AC%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9HTTPS%E6%94%AF%E6%8C%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/27/%E4%BD%8E%E7%89%88%E6%9C%AC%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9HTTPS%E6%94%AF%E6%8C%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>各个浏览器对HTTPS相关的支持情况，可以在<a href="https://www.ssllabs.com/ssltest/clients.html" target="_blank" rel="noopener">《Qualys ssltest页面》</a>查看，也可以通过<a href="https://www.ssllabs.com/ssltest/viewClient.html?name=IE&amp;version=6&amp;platform=XP&amp;key=18" target="_blank" rel="noopener">《Qualys兼容性页面》</a>查看某个浏览器对HTTPS支持的非常详细的一些属性。</p><p>老旧浏览器不兼容HTTPS主要体现在如下几个方面：</p><p>（1）只支持SSLv2/SSLv3协议</p><p>IE 6只支持SSLv2和SSLv3，也就是说HTTPS网站要支持IE 6，就必须启用SSLv3。</p><p>（2）加密套件不匹配</p><p>有些浏览器仅仅支持有限的CipherSuite，而这些有限的加密套件由于安全问题或其他原因在有些网站的服务器中并不支持，导致在TLS握手中，因为没有协商出客户端和服务端都能支持的加密套件而导致握手失败。</p><p>（3）不支持SNI</p><p>现在还有一定用户量的Windows XP IE6-8、Android 2.x Webview都不支持SNI。如果要避免在这些浏览器中出现证书错误，只能将使用不同证书的HTTPS站点部署在不同IP上，最简单的做法是分开部署到不同机器上。</p><p>（4）证书不支持</p><p>简单来说，就是客户端拿到证书后，由于不支持高版本的哈希函数，导致无法进行证书签名验证，从而直接失败。HTTPS网站需要通过CA取得合法证书，证书通过数字签名技术确保第三方无法伪造。证书的简单原理如下：</p><p>A）根据版本号、序列号、签名算法标识、发行者名称、有效期、证书主体名、证书主体公钥信息、发行商唯一标识、主体唯一标识、扩展生成 TBSCertificate（待签名证书To Be Signed Certificate）信息；</p><p>B）签发数字签名：使用 HASH 函数对 TBSCertificate 计算得到消息摘要，用 CA 的私钥对消息摘要进行加密，得到签名；</p><p>C）校验数字签名：使用相同的 HASH 函数对 TBSCertificate 计算得到消息摘要，与使用 CA 公钥解密签名得到内容相比较；</p><p>使用SHA-1做为HASH函数的证书被称之为SHA-1证书，由于目前已经找到SHA-1的碰撞条件，将证书换成使用更安全的SHA-2做为HASH函数的SHA-2证书被提上日程。</p><p>实际上，微软已经宣称自2017年1月1日起，将全面停止对SHA-1证书的支持。届时在最新版本的Windows系统中，SHA-1证书将不被信任。而根据Chrome官方博客的文章，使用SHA-1证书且证书有效期在2016年1月1号至2016年12月31号之间的站点会被给予「安全的，但存在漏洞」的提示，也就是地址栏的小锁不再是绿色的，并且会有一个黄色小三角。而使用SHA-1证书且证书有效期超过2017年1月1号的站点会被给予「不安全」的红色警告，小锁上直接显示一个红色的叉。</p><p>然而，并不是所有的终端都支持SHA-2证书，服务端不支持还好办，浏览器只能依赖于用户升级了。下面是常见浏览器支持SHA-2证书的最低版本：</p><p><img src="/images/https_compatibility_1_1.png" alt></p><p>可以看到，如果要照顾没有打XP SP3补丁的IE6用户，只能继续使用SHA-1证书。</p><p>另外有些浏览器对ECC这种新型的证书支持度更差，也会导致失败哦。</p><p>学习资料参考于：<br><a href="https://linux.cn/article-6900-1.html" target="_blank" rel="noopener">https://linux.cn/article-6900-1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>椭圆曲线密码学ECC简介</title>
      <link href="/2022/02/27/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6ECC%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/02/27/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6ECC%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="椭圆曲线密码学"><a href="#椭圆曲线密码学" class="headerlink" title="椭圆曲线密码学"></a>椭圆曲线密码学</h1><p>ECC，全称为Elliptic Curve Cryptography，中文名为椭圆曲线密码学，是一种基于椭圆曲线数学的非对称加密算法。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。ECC的主要优势是在某些情况下它比其他的算法（比如RSA加密算法）使用更小的密钥并提供相当的或更高等级的安全。</p><p>椭圆曲线可以用于3个方面：一类是基于椭圆曲线的公钥密码；一类是基于椭圆曲线的数字签名；一类是基于椭圆曲线的密钥交换。</p><p>目前比较常用的两个曲线是P-256（secp256r1，在OpenSSL称为prime256v1）和x25519。P-256是NIST（美国国家标准技术研究所）和NSA（美国国家安全局）推荐使用的曲线，而x25519被认为是最安全、最快速的曲线。但密码学界普遍不信任NIST和NSA，所以一般都使用x25519。</p><h1 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h1><p><img src="/images/security_ecc_1_1.png" alt></p><p>椭圆曲线下图所示：</p><p><img src="/images/security_ecc_1_2.png" alt></p><p>现在，我们来定义椭圆曲线上的加法。现在有椭圆曲线y^2=x^3-x，曲线上的点P和Q。过P和Q做一条直线，交椭圆曲线为点R’,再过R’点做垂直于X轴的直线，交曲线另一点为R，定义P + Q = R。如下图所示：</p><p><img src="/images/security_ecc_1_3.png" alt></p><p>若P=Q,则为过P点的切线交于椭圆曲线为R’。如下图所示：</p><p><img src="/images/security_ecc_1_4.png" alt></p><p>这样，称R = 2P。类似的，3P = P + P + P = P + 2P = P + R。也就是说，当给定点P时，“已知数x求点xG的运算”不难，因为有加法的性质，运算起来可以比较快。但反过来，“已知点xG求x的问题”则非常困难，因为只能遍历每一个x做运算。这就是椭圆曲线密码中所利用的“椭圆曲线上的离散对数问题”。</p><p>椭圆曲线密码利用了上述“运算”中的“椭圆曲线上的离散对数问题”的复杂度，就像RSA利用了“大数质因数分解”的复杂度，以及EIGamal密码的Diffie-Hellman密钥交换利用了“有限域上的离散对数问题”的复杂度一样。</p><p>椭圆曲线上的离散对数问题：</p><p><img src="/images/security_ecc_1_5.png" alt></p><p>这个问题的难度保证了椭圆曲线密码的安全性。</p><h1 id="椭圆曲线的公钥和私钥"><a href="#椭圆曲线的公钥和私钥" class="headerlink" title="椭圆曲线的公钥和私钥"></a>椭圆曲线的公钥和私钥</h1><p>在椭圆曲线加密中，给定椭圆曲线E，基点G和点xG，我们称xG为公钥，x值为私钥。由椭圆曲线性质可知，已知私钥求公钥很简单，而已知公钥求私钥几乎是不可能的事情。</p><p>学习资料参考于：<br><a href="https://halfrost.com/asymmetric_encryption/" target="_blank" rel="noopener">https://halfrost.com/asymmetric_encryption/</a><br><a href="https://juejin.im/post/5a67f3836fb9a01c9b661bd3" target="_blank" rel="noopener">https://juejin.im/post/5a67f3836fb9a01c9b661bd3</a></p>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS中Keyless SSL方案</title>
      <link href="/2022/02/27/HTTPS%E4%B8%ADKeyless-SSL%E6%96%B9%E6%A1%88/"/>
      <url>/2022/02/27/HTTPS%E4%B8%ADKeyless-SSL%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>Keyless SSL方案，也即HTTPS卸载。</p><p>在使用第三方CDN的HTTPS服务时，如果要使用自己的域名，需要把对应的证书私钥给第三方，这也是一件风险很高的事情。CloudFlare公司针对这种场景研发了Keyless SSL技术。你可以不把证书私钥给第三方，改为提供一台实时计算的Key Server即可。CDN要用到私钥时，通过加密通道将必要的参数传给Key Server，由Key Server算出结果并返回即可。整个过程中，私钥都保管在自己的Key Server之中，不会暴露给第三方。</p><p>SSL协议是基于密码学的基础上，解决通信双方加密信道和身份鉴权的安全问题。SSL协议的算法本身是公开的，但是算法本身的输入参数（key）是由通信双方私自保存。在非对称加密中，服务端保存有一对公钥/私钥对，用于服务端鉴权和加密通信。服务端的私钥泄露会导致恶意攻击者伪造虚假的服务器和客户端通信。特别是源站把业务迁移到云或者CDN上，私钥的安全保存要求更高。</p><p>Keyless在方案，把服务器的私钥统一管理，并且把服务器的公钥算法中密钥协商的相关计算过程，加密解密的计算等，统一放在一组单独的机器上，这些机器在硬件或软件上都比较特殊，比如这些带有QAT硬件加速卡的机器，我们称这些机器为“Keyless Server”。</p><p><img src="/images/https_keyless_1_1.png" alt></p><p><img src="/images/https_keyless_1_2.png" alt></p><p><img src="/images/https_keyless_1_3.png" alt></p><p>备注：像akamai那边把CDN侧的加解密计算，放在单独的Key Server来处理，这些Key Server在资源和底层硬件资源上都有特殊的地方，从而整体提高HTTPS的性能。</p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用的密钥协商Key Agreement算法介绍</title>
      <link href="/2022/02/27/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86Key-Agreement%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/02/27/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86Key-Agreement%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="密钥协商算法简介"><a href="#密钥协商算法简介" class="headerlink" title="密钥协商算法简介"></a>密钥协商算法简介</h1><p>密钥协商算法主要有三类：</p><p>（1）依靠非对称加密算法</p><p>（2）依靠专门的密钥交换算法</p><p>（3）依靠通讯双方事先已经共享的秘密（如PSK）等</p><h1 id="DH，Diffie-Hellman算法"><a href="#DH，Diffie-Hellman算法" class="headerlink" title="DH，Diffie-Hellman算法"></a>DH，Diffie-Hellman算法</h1><p>Diffie-Hellman密钥交换（Diffie-Hellman key exchange）是1976年由Whitfield Diffie和Martin Hellman共同发明的一种算法。使用这种算法，通信双方仅通过交换一些可以公开的信息就能生成出共享的对称密码的密钥。虽然这种算法叫“密钥交换”，但是实际上并没有真正的交换密钥，而是通过计算生成出了一个相同的共享密钥。准确的来说，应该叫Diffie-Hellman密钥协商（Diffie-Hellman key agreement）。</p><p>DH协商算法的过程如下：</p><p><img src="/images/https_negotiate_1_1.png" alt></p><p>（1）Alice向Bob发送两个质数P和G</p><p>P是一个非常大的质数，G是一个较小的数字，称为生成元。P和G可以公开，P和G的生成也可以由任何一方生成。</p><p>（2）Alice生成一个随机数A</p><p>A是<code>1~(P-2)</code>之间的整数，这个数只有Alice知道。</p><p>（3）Bob生成一个随机数B</p><p>B是<code>1~(P-2)</code>之间的整数，这个数只有Bob知道。</p><p>（4）Alice把(G^A mod P)的结果发送给Bob</p><p>这个数被窃听了也没有关系。</p><p>（5）Bob把(G^B mod P)的结果发送给Alice</p><p>这个数被窃听了也没有关系。</p><p>（6）Alice用Bob发过来的数计算A次方并求mod P</p><p>这个数就是最终的共享密钥，如下：</p><pre><code>(G^B mod P)^A mod P = G^(B*A) mod P = G^(A*B) mod P</code></pre><p>（7）Bob用Alice发过来的数计算B次方并求mod P</p><p>这个数就是最终的共享密钥，如下：</p><pre><code>(G^A mod P)^B mod P = G^(A*B) mod P</code></pre><p>至此，A和B计算出来的密钥是一致的。</p><p>窃听者能获取到的信息有P、G、G^A mod P、G^B mod P。通过这4个值想计算出<code>G^(A*B) mod P</code>是非常困难的。</p><p>如果能知道A和B任意一个数，就可以破解上面所有步骤，并算出最后的共享密钥。但是窃听者只能获取到G^A mod P、G^B mod P，这里的mod P是关键，如果是知道G^A也可以算出A，但是这里是推算不出A和B的，因为这是有限域(finite field)上的离散对数问题。</p><p>使用DH算法，即使协商过程中被别人全程偷窥（比如“网络嗅探”），偷窥者也【无法】知道协商得出的密钥是啥。但是DH算法本身也有缺点，即不支持数字认证。也就是无法对抗中间人攻击MITM，因为缺乏身份认证，必定会遭到中间人攻击。为了避免遭遇MITM攻击，DH需要与其它签名算法（比如RSA、DSA、ECDSA）配合，靠签名算法帮忙来进行身份认证。当DH与RSA配合使用，称之为DH-RSA，与DSA配合则称为DH-DSA，以此类推。反之，如果DH没有配合某种签名算法，则称为DH-ANON（ANON是洋文“匿名”的简写），此时会遭遇中间人攻击/MITM。</p><h1 id="使用RSA作为密钥协商算法"><a href="#使用RSA作为密钥协商算法" class="headerlink" title="使用RSA作为密钥协商算法"></a>使用RSA作为密钥协商算法</h1><p><img src="/images/https_negotiate_1_2.png" alt></p><p>RSA算法流程文字描述如下：</p><p>（1）任意客户端对服务器发起请求，服务器首先发回复自己的公钥到客户端（公钥明文传输）。</p><p>（2）客户端使用随机数算法，生成一个密钥S，使用收到的公钥进行加密，生成C，把C发送到服务器。</p><p>（3）服务器收到C，使用公钥对应的私钥进行解密，得到S。</p><p>（4）上述交换步骤后，客户端和服务器都得到了S，S为密钥（预主密钥）。</p><h1 id="使用DHE密钥协商算法"><a href="#使用DHE密钥协商算法" class="headerlink" title="使用DHE密钥协商算法"></a>使用DHE密钥协商算法</h1><p>DHE是DH的扩展。</p><p><img src="/images/https_negotiate_1_3.png" alt></p><p>DHE算法流程文字描述如下：</p><p>（1）客户端计算一个随机值Xa，使用Xa作为指数，即计算<code>Pa = q^Xa mod p</code>，其中q和p是全世界公认的一对值。客户端把Pa发送至服务器，Xa作为自己私钥，仅且自己知道。</p><p>（2）服务器和客户端计算流程一样，生成一个随机值Xb，使用Xb作为指数，计算<code>Pb = q^Xb mod p</code>，将结果Pb发送至客户端，Xb仅自己保存。</p><p>（3）客户端收到Pb后计算<code>Sa = Pb ^Xa mod p</code>；服务器收到Pa后计算<code>Sb = Pa^Xb mod p</code></p><p>（4）算法保证了Sa = Sb = S，故密钥交换成功，S为密钥（预主密钥）</p><h1 id="使用ECDHE密钥协商算法"><a href="#使用ECDHE密钥协商算法" class="headerlink" title="使用ECDHE密钥协商算法"></a>使用ECDHE密钥协商算法</h1><p>ECDHE是基于椭圆曲线EC的DHE密钥协商算法。</p><p><img src="/images/https_negotiate_1_4.png" alt></p><p>ECDHE算法流程文字描述如下：</p><p>（1）客户端随机生成随机值Ra，计算<code>Pa(x, y) = Ra * Q(x, y)</code>，Q(x, y)为全世界公认的某个椭圆曲线算法的基点。将Pa(x, y)发送至服务器（其中Pa(x, y)相当于客户端的公钥）</p><p>备注：根据椭圆曲线，由xG和G不能推算出x，也就有Pa(x,y)和Q(x,y)无法推算出来随机数Ra。</p><p>（2）服务器随机生成随机值Rb，计算<code>Pb(x,y) = Rb * Q(x, y)</code>。将Pb(x, y)发送至客户端（其中Pb(x, y)相当于客户端的公钥）</p><p>（3）客户端计算<code>Sa(x, y) = Ra * Pb(x, y)</code>；服务器计算<code>Sb(x, y) = Rb * Pa(x, y)</code></p><p>（4）算法保证了Sa = Sb = S，提取其中的S的x向量作为密钥（预主密钥）</p><p>备注：根据椭圆曲线性质可知，获取到Pb(x,y)和Pa(x,y)，是无法计算出对应的随机数Ra或Rb的。随意窃听者拿到公开的信息后，是根本无法计算出对称加密阶段的密钥的，所以很安全。</p><p>学习资料参考于：<br><a href="https://halfrost.com/cipherkey/" target="_blank" rel="noopener">https://halfrost.com/cipherkey/</a><br><a href="https://blog.csdn.net/mrpre/article/details/78025940" target="_blank" rel="noopener">https://blog.csdn.net/mrpre/article/details/78025940</a><br><a href="https://program-think.blogspot.com/2016/09/https-ssl-tls-3.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2016/09/https-ssl-tls-3.html</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>加密套件Cipher Suites</title>
      <link href="/2022/02/26/%E5%8A%A0%E5%AF%86%E5%A5%97%E4%BB%B6Cipher-Suites/"/>
      <url>/2022/02/26/%E5%8A%A0%E5%AF%86%E5%A5%97%E4%BB%B6Cipher-Suites/</url>
      
        <content type="html"><![CDATA[<h1 id="加密套件Cipher-Suites简介"><a href="#加密套件Cipher-Suites简介" class="headerlink" title="加密套件Cipher Suites简介"></a>加密套件Cipher Suites简介</h1><p>Cipher Suite加密套件。在HTTPS的交互过程中，需要有“密钥协商算法”、“数字签名算法”，“对称加密算法”以及“数据散列算法（数字签名生产和验证的时候会使用）”。常用的加密套件有：</p><p><img src="/images/https_suites_1_1.png" alt></p><p>Cipher Suite中包含了多种技术，包括认证算法Authentication、加密算法Encryption、消息认证码算法Message Authentication Code（MAC）、密钥交换算法Key Exchange和密钥衍生算法Key Derivation Function。</p><p>SSL的CipherSuite协商机制具有良好的扩展性，每个Cipher Suite都需要在IANA注册，并被分配两个字节的标志。全部CipherSuite可以在IANA的<a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4" target="_blank" rel="noopener">《TLS Cipher Suite Registry页面》</a>中查看。</p><p>OpenSSL库支持的全部Cipher Suite可以通过以下命令查看：</p><p><img src="/images/https_suites_1_2.png" alt></p><p>以TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256来说，ECDHE是秘钥交换算法，RSA身份验证算法，即数字签名算法，AES_128_GCM对称加密算法，SHA256摘要算法。</p><p>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384来说，ECDHE是密钥协商算法，ECDSA是身份验证算法，AES_256_GCM是加密模式，由于GCM是属于AEAD加密模式，所以整个密码套件无须另外的HMAC，SHA384指的是伪随机数生成函数PRF算法。</p><p><img src="/images/https_suites_1_3.png" alt></p><h1 id="TLS1-3支持的加密套件"><a href="#TLS1-3支持的加密套件" class="headerlink" title="TLS1.3支持的加密套件"></a>TLS1.3支持的加密套件</h1><p>在TLS1.3中，将Cipher Suites拆成两个部分，一个是Cipher Suites，另一个是密钥协商算法KeyAgreement。也就是TLS1.3的Cipher Suites没有密钥协商相关的信息了。</p><p>目前来说，TLS1.3只支持DHE和ECDHE两种密钥协商算法了。TLS 1.3规范中只支持5种密钥套件，TLS13-AES-256-GCM-SHA384、TLS13-CHACHA20-POLY1305-SHA256、TLS13-AES-128-GCM-SHA256、TLS13-AES-128-CCM-8-SHA256、TLS13-AES-128-CCM-SHA256，隐藏了密钥协商算法，因为默认都是椭圆曲线密钥协商，即DHE或ECDHE。</p><h1 id="映射表"><a href="#映射表" class="headerlink" title="映射表"></a>映射表</h1><p><img src="/images/https_suites_1_4.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TLS1.3握手交互过程分析</title>
      <link href="/2022/02/26/TLS1-3%E6%8F%A1%E6%89%8B%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2022/02/26/TLS1-3%E6%8F%A1%E6%89%8B%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="TLS1-3首次完整握手过程-1-RTT"><a href="#TLS1-3首次完整握手过程-1-RTT" class="headerlink" title="TLS1.3首次完整握手过程(1-RTT)"></a>TLS1.3首次完整握手过程(1-RTT)</h1><p>TLS1.3版本以DH密钥协商的过程如下：</p><p><img src="/images/https_handshake13_1_1.png" alt></p><p><img src="/images/https_handshake13_1_2.png" alt></p><p>support_groups提供了Client所能支持的所有密钥协商算法，然后Client通过key_share将各个密钥协商算法对应client的共享参数，提前发送给服务端，然后由服务端来选择使用那个密钥协商算法和共享参数。</p><p>首次完整握手完成以后，还会发送NewSessionTicket消息。在TLS1.3中，这个消息中会带early_data的扩展。如果有early_data这个扩展，就表明Server可以支持0-RTT。如果没有带这个扩展，表明Server不支持0-RTT，Client在下次会话恢复的时候不要发送early_data扩展。</p><h1 id="TLS1-3会话恢复-1-RTT-0-RTT"><a href="#TLS1-3会话恢复-1-RTT-0-RTT" class="headerlink" title="TLS1.3会话恢复(1-RTT/0-RTT)"></a>TLS1.3会话恢复(1-RTT/0-RTT)</h1><p>网上很多文章对TLS1.3第二次握手（会话恢复）有误解。TLS1.3在宣传的时候就以0-RTT为主，大家都会认为TLS 1.3在第二次握手的时候都是0-RTT 的，包括网上一些分析的文章里面提到的最新的PSK密钥协商，PSK密钥协商并非是0-RTT的。</p><p>TLS1.3再次握手其实是分两种，一种是普通会话恢复模式，另一种是0-RTT模式。非0-RTT的会话恢复模式和TLS 1.2的会话恢复在耗时上没有提升，都是1-RTT，只不过比TLS 1.2更加安全了。只有在0-RTT的会话恢复模式下，TLS 1.3才比TLS 1.2有提升。具体提升对比见下表：</p><p><img src="/images/https_handshake13_1_3.png" alt></p><p>在TLS1.3完整握手中，Client在收到Finished消息以后，还会收到Server发过来的NewSessionTicket消息。需要注意的是，TLS 1.2中NewSessionTicket是主密钥，而TLS 1.3的NewSessionTicket中只是一个PSK。</p><h2 id="基于1-RTT的PSK会话恢复模式"><a href="#基于1-RTT的PSK会话恢复模式" class="headerlink" title="基于1-RTT的PSK会话恢复模式"></a>基于1-RTT的PSK会话恢复模式</h2><p>TLS 1.3中更改了会话恢复机制，废除了原有的SessionID和SessionTicket的方式，而是使用PSK的机制，同时NewSessionTicket中添加了过期时间。TLS 1.2中的SessionTicket不包含过期时间。</p><p>在经历了一次完整握手以后，生成了PSK，下次握手就会进入会话恢复模式，在ClientHello中，先在本地Cache中查找ServerName对应的PSK，找到后在ClientHello的pre_shared_key扩展中带上两部分内容：</p><pre><code>* Identity: NewSessionTicket中加密的ticket* Binder: 由PSK导出binder_key，使用binder_key对不包含binder list部分的ClientHello作HMAC计算</code></pre><p>Server收到带有PSK的ClientHello以后，生成协商之后的key_share，并检查Client hello中的pre_shared_key扩展，解密PskIdentity.identity(即ticket)，查看该ticket是否过期，各项检查通过以后，由PSK导出binder_key并计算ClientHello的HMAC，检查binder是否正确。验证完ticket和binder之后，在ServerHello扩展中带上pre_shared_key扩展，标识使用哪个PSK进行会话恢复。和Client一样，从Resumtion Secret开始导出PSK，最终导出earlyData使用的密钥。后续的密钥导出规则和完整握手是一样的，唯一的区别就是会话恢复多了PSK，它是作为early secret的输入密钥材料IKM。</p><p>整个过程如下：</p><p><img src="/images/https_handshake13_1_4.png" alt></p><p><img src="/images/https_handshake13_1_5.png" alt></p><h2 id="基于0-RTT的会话恢复模式"><a href="#基于0-RTT的会话恢复模式" class="headerlink" title="基于0-RTT的会话恢复模式"></a>基于0-RTT的会话恢复模式</h2><p>据Google统计，全网有60%的网站访问流量是来自于新访问的网站和过去曾经访问过但是隔了一段时间再次访问。这部分流量在TLS 1.3的优化下，已经从2-RTT降低到1-RTT了。剩下40%的网站访问流量是来自于会话恢复，TLS 1.3废除了之前的SessionID和SessionTicket的会话恢复的方式，统一成了PSK方式，使得原有会话恢复变的更加安全。但是TLS 1.3的会话恢复并没有降低RTT，依旧停留在了1-RTT。为了进一步降低延迟，于是提出了0-RTT的概念。0-RTT能让用户有更快更顺滑更好的用户体验，在移动网络上更加明显。</p><p>TLS 1.3的里程碑标志就是添加了0-RTT会话恢复模式。也就是说，当Client和Server共享一个PSK（从外部获得或通过一个以前的握手获得）时，TLS 1.3允许Client在第一个发送出去的消息中携带数据（”early data”）。Client使用这个PSK生成client_early_traffic_secret并用它加密early data。Server收到这个ClientHello之后，用ClientHello扩展中的PSK导出client_early_traffic_secret并用它解密early data。</p><p>想实现0-RTT也是有一些条件的，条件比较苛刻，如果条件有一条不满足，会话恢复都只能是1-RTT的PSK会话恢复模式。0-RTT的开启条件是：</p><p>（1）Server在前一次完整握手中，发送了NewSessionTicket，并且SessionTicket中存在max_early_data_size扩展表示愿意接受early data。如果没有这个扩展，0-RTT无法开启。</p><p>（2）在PSK会话恢复的过程中，ClientHello的扩展中配置了early data扩展，表示Client想要开启0-RTT模式。</p><p>（3）Server在Encrypted Extensions消息中携带了early data扩展表示同意读取early data。0-RTT模式开启成功。</p><p>只有同时满足了上面3个条件，才能开启0-RTT会话恢复模式。否则握手会是1-RTT的会话恢复模式。</p><p>0-RTT握手的流程图如下：</p><p><img src="/images/https_handshake13_1_6.png" alt></p><p><img src="/images/https_handshake13_1_7.png" alt></p><p>Client发送完early_data数据以后，还需要回一个EndOfEarlyData的子消息。</p><p>需要说明的是，目前不少浏览器虽然支持TLS 1.3协议，但是还不支持发送early data，所以它们也没法启用0-RTT模式的会话恢复。</p><p>备注：我理解0-RTT会话恢复中的early data应该是真实的应用数据，如HTTP GET/POST请求。</p><p>学习资料参考于：<br><a href="https://halfrost.com/https_tls1-3_handshake/" target="_blank" rel="noopener">https://halfrost.com/https_tls1-3_handshake/</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md" target="_blank" rel="noopener">https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TLS协议中扩展Extension简介</title>
      <link href="/2022/02/26/TLS%E5%8D%8F%E8%AE%AE%E4%B8%AD%E6%89%A9%E5%B1%95Extension%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/02/26/TLS%E5%8D%8F%E8%AE%AE%E4%B8%AD%E6%89%A9%E5%B1%95Extension%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="扩展Extensions简介"><a href="#扩展Extensions简介" class="headerlink" title="扩展Extensions简介"></a>扩展Extensions简介</h1><p>扩展是TLS比较重要的一个知识点。它的存在能让Client和Server在不更新TLS版本的基础上，获得新的能力。Extension是TLS中的一系列可水平扩展的插件，是TLS中握手协议中ClientHello和ServerHello报文中的字段信息。</p><p>Client在ClientHello中申明多个自己可以支持的Extension，以向Server表示自己有以下这些能力，或者向Server协商某些协议。Server收到ClientHello以后，依次解析Extension，有些如果需要立即回应，就在ServerHello中作出回应，有些不需要回应，或者Server不支持的Extension就不用响应，忽略不处理。</p><p>如下是Extension在ClientHello/ServerHello报文中的位置结构如下：</p><p><img src="/images/https_extend_1_2.png" alt></p><h1 id="TLS1-2中一些扩展Extension"><a href="#TLS1-2中一些扩展Extension" class="headerlink" title="TLS1.2中一些扩展Extension"></a>TLS1.2中一些扩展Extension</h1><p>（1）server_name</p><p>我们知道，在Nginx中可以通过指定不同的server_name来配置多个站点。HTTP/1.1协议请求头中的Host字段可以标识出当前请求属于哪个站点。但是对于HTTPS网站来说，要想发送HTTP数据，必须等待SSL握手完成，而在握手阶段服务端就必须提供网站证书。对于在同一个IP部署不同HTTPS站点，并且还使用了不同证书的情况下，服务端怎么知道该发送哪个证书？</p><p>Server Name Indication，简称为SNI，是TLS的一个扩展，为解决这个问题应运而生。有了SNI，服务端可以通过ClientHello中的SNI扩展拿到用户要访问网站的Server Name，进而发送与之匹配的证书，顺利完成SSL握手。</p><p>server_name扩展比较简单，存储的就是Server的名字。</p><p>TLS没有为Client提供一种机制来告诉Server它正在建立链接的Server的名称。Client可能希望提供此信息以促进与在单个底层网络地址处托管多个“虚拟”服务的Server的安全连接。</p><p>当Client连接HTTPS网站的时候，解析出IP地址以后，就能创建TLS连接，在握手完成之前，Server接收到的消息中并没有Host HTTP的头部。如果这个Server有多个虚拟的服务，每个服务都有一张证书，那么此时Server不知道该用哪一张证书。</p><p>于是为了解决这个问题，增加了SNI扩展。用这个扩展就能区别出各个服务对应的证书了。</p><p>（2）supported_groups</p><p>这个扩展原名叫”elliptic_curves”，后来更名成”supported_groups”。从原名的意思就能看出来这个扩展的意义。它标识了Client支持的椭圆曲线的种类。举例来说，Client支持椭圆曲线有x25519、secp256r1、secp384r1、secp521r1等等。</p><p>（3）SessionTicket TLS</p><p>这个扩展表明了Client端是否有上次会话保存的SessionTicket，如果有，则表明Client希望基于SessionTicket的方式进行会话恢复。</p><p>（4）application_layer_protocol_negotiation，ALPN</p><p>Application Layer Protocol Negotiation，ALPN应用层协议扩展。由于应用层协议存在多个版本，Client在TLS握手的时候想知道应用层用的什么协议。基于这个目的，ALPN协议就出现了。ALPN希望能协商出双方都支持的应用层协议，应用层底层还是基于TLS/SSL协议的。</p><p><img src="/images/https_extend_1_1.png" alt></p><p>（5）signature_algorithms</p><p>Client使用”signature_algorithms”扩展来向Server表明哪个签名/hash算法对会被用于数字签名。这个扩展的”extension_data”域包含了一个”supported_signature_algorithms”值。</p><h1 id="TLS1-3中的一些特有扩展Extension"><a href="#TLS1-3中的一些特有扩展Extension" class="headerlink" title="TLS1.3中的一些特有扩展Extension"></a>TLS1.3中的一些特有扩展Extension</h1><p>（1）supported_versions</p><p>在TLS 1.3中，ClientHello中的supported_versions扩展非常重要。因为TLS 1.3是根据这个字段的值来协商是否支持TLS 1.3 。在TLS 1.3规范中规定，ClientHello中的legacy_version必须设置为0x0303，这个值代表的是TLS 1.2。这样规定是为了对网络中间件做的一些兼容。如果此时ClientHello中不携带supported_versions这个扩展，那么注定只能协商TLS 1.2了。</p><p>Client在ClientHello的supported_versions扩展中发送自己所能支持的TLS版本。Server收到以后，在ServerHello中的supported_versions扩展响应Client，告诉Client接下来进行哪个TLS版本的握手。</p><p>（2）supported groups</p><p>当Client发送”supported_groups”扩展时，是为了表明了Client支持的用于密钥交换的命名组。按照优先级从高到低。说白了，就是Client支持的密钥协商的(EC)DHE的具体名称。</p><p>（3）key_share</p><p>在TLS 1.3中，之所以能比TLS 1.2快的原因，原因之一就在key_share这个扩展上。key_share扩展内包含了(EC)DHE groups需要协商密钥参数，这样不需要再次花费1-RTT进行协商了。</p><p>“supported_groups”的扩展和”key_share”扩展配合使用。“supported_groups”这个扩展表明了Client支持的(EC)DHE groups，”key_share”扩展表明了Client是否包含了对应“supported_groups”的一些或者全部的（EC）DHE共享参数。说白了，就是将TLS1.2中ClientKeyExchange中的共享参数，在TLS1.3中直接通过ClientHello传递给Server，这也是TLS1.3的首次完整握手能降低到1-RTT的原因。</p><p>（3）psk_key_exchange_modes</p><p>在TLS 1.3会话恢复中出现。为了使用PSK，Client还必须发送一个”psk_key_exchange_modes”扩展。这个扩展语意是Client仅支持使用具有这些模式的PSK。这就限制了在这个ClientHello中提供的PSK的使用，也限制了Server通过NewSessionTicket提供的PSK的使用。</p><p>如果Client提供了”pre_shared_key”扩展，那么它必须也要提供”psk_key_exchange_modes”扩展。如果Client发送不带”psk_key_exchange_modes”扩展名的”pre_shared_key”，Server必须立即中止握手。Server不能选择一个Client没有列出的密钥交换模式。此扩展还限制了与PSK恢复使用的模式。Server也不能发送与建议的modes不兼容的NewSessionTicket。不过如果Server一定要这样做，影响的只是Client在尝试恢复会话的时候会失败。</p><p>Server不能发送”psk_key_exchange_modes”扩展。</p><p>（4）pre_shared_key</p><p>在TLS 1.3会话重建恢复中出现。”pre_shared_key”预共享密钥和”psk_key_exchange_modes”扩展配合使用。预共享密钥扩展包含了Client可以识别的对称密钥标识。”psk_key_exchange_modes”扩展表明了可能可以和psk一起使用的密钥交换模式。</p><p>（5）early_data</p><p>在TLS1.3会话恢复中出现。当使用PSK并且PSK允许使用early_data的时候，Client可以在其第一个消息中发送应用数据。如果Client选择这么做，则必须发送”pre_shared_key”和”early_data”扩展。</p><h1 id="其他的一些扩展"><a href="#其他的一些扩展" class="headerlink" title="其他的一些扩展"></a>其他的一些扩展</h1><p>（1）padding</p><p>属于一个填充扩展，目的是让ClientHello的达到指定的大小，以避免一些异常情况，填充的内容就是0比特。这个扩展是在ClientHello的最后面。可以参见<a href="https://tools.ietf.org/html/rfc7685" target="_blank" rel="noopener">IETF官方说明</a></p><p>学习资料参考于：<br><a href="https://halfrost.com/https-extensions/" target="_blank" rel="noopener">https://halfrost.com/https-extensions/</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TLS1.2中会话恢复机制中SessionID和SessionTicket</title>
      <link href="/2022/02/26/TLS1-2%E4%B8%AD%E4%BC%9A%E8%AF%9D%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6%E4%B8%ADSessionID%E5%92%8CSessionTicket/"/>
      <url>/2022/02/26/TLS1-2%E4%B8%AD%E4%BC%9A%E8%AF%9D%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6%E4%B8%ADSessionID%E5%92%8CSessionTicket/</url>
      
        <content type="html"><![CDATA[<h1 id="SSL中会话Session简介"><a href="#SSL中会话Session简介" class="headerlink" title="SSL中会话Session简介"></a>SSL中会话Session简介</h1><p>SSL中的Session会跟HTTP的Session类似，都是用来保存客户端和服务端之间交互的一些记录。在SSL协议中一次TLS握手（密钥协商）的结果是建立了一条对称加密的数据通道，这条对称加密的数据通道的相关参数都是可以保存的，我们把这个信息称为TLS中Session信息，使用这个Session信息就可以直接复原对称加密的通信通道，从而省去了密钥协商的过程。</p><p>不管是SessionCache，SessionTicket，还是TLS1.3中的PSK，都是为了解决对称加密通道的快速恢复问题。</p><p>SessionID是RFC5246引入，SessionTicket是RFC5077引入。</p><h1 id="SessionID-SessionCache"><a href="#SessionID-SessionCache" class="headerlink" title="SessionID/SessionCache"></a>SessionID/SessionCache</h1><p>当SSL的Session保存在服务端时，服务端OpenSSL会给每个Session分配一个SessionID，并将这个SessionID发送给客户端。当客户端再次请求（Client Hello）到达的时候，客户端携带SessionID，服务端就可以根据这个SessionID找到该客户端上次和服务端SSL加密通信的上下文信息，从而直接复原对称加密信道了，而不用再进行SSL握手密钥协商了。</p><p>需要注意的是，该种方式下，服务端需要为每个客户端都维护一个Session，服务端有一个专门维护Session信息的OpenSSL组件，即OpenSSL SessionCache，服务端去管理这些Session信息，会消耗大量的服务器内存资源。</p><p>备注：SessionID机制在服务端这边就涉及到各服务器或各集群要实现Session共享。若不支持客户端和服务端的SSL回话恢复的成功率就低了，因为当下一次请求解析到另外的服务端IP时，服务端是没有Session信息的。</p><h1 id="SessionTicket"><a href="#SessionTicket" class="headerlink" title="SessionTicket"></a>SessionTicket</h1><p>从上面看到，Session Cache的一些问题，即SessionCache需要消耗大量的服务器存储资源。对称加密的上下文并不是一个非常轻量级的内容，当数目很大的时候，内存资源的消耗就会很可观，另外由服务器管理这个上下文也带来了极大的管理成本。另外一个思路就是将这件事情交给客户端。因为客户端和服务端对已经建立的加密信道拥有相同的知识，所以客户端完全可以做到存储这个上下文，但是这也不能使得服务端完全的从这个事物中解脱，因为服务端如果伪造一个上下文，就失去了认证的作用了。所以客户端存储的对称加密的上下文是要用服务器的私有密钥（Session Ticket Encryption Key，简写为STEK）加密过的，也就是经过服务器传输给客户端的。这样服务器在收到一个SessionTicket的时候，自己能够正常的解密就能证明确实是自己颁发的，从而杜绝了伪造。</p><p>也就是说，服务端发送给客户端的SessionTicket，只有服务端自己能解密，当客户端发送给服务端后，服务端用密钥解密，即可以恢复与该客户端的加密数据通道，即对称加密通道，而不再需要SSL握手密钥协商了。</p><p>SessionTicket相对于SessionID/SessionCache机制，它的最大优势是给服务端减轻压力，把一部分计算放在了客户端。因为服务端会解密SessionTicket，从而复原出对称加密的上下文，所以对于服务端来说这个开销也是很小。由于其天然的不需要在服务端存储内容，所以服务端当要组成集群的时候，只需要定期换一下SessionTicket用来加密的key即可。不像SessionCache那样需要自己做一个分布式的缓存。</p><p>客户端保存的SessionTicket是由服务端通过SSL握手协议中的NewSessionTicket报文传送给客户端的。</p><p>TLS1.2中的NewSessionTicket报文格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    uint32 ticket_lifetime_hint; </span><br><span class="line">    opaque ticket&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;; </span><br><span class="line">&#125; NewSessionTicket;</span><br></pre></td></tr></table></figure><p>其中一个字段是ticket_lifetime_hint，其单位是秒，用来告知客户端这个sessionticket的生命周期（老化时间），sessionticket就是主要包含了主秘钥等其他信息（客户端认证的话可能还包含客户端的证书）。</p><p>LS1.3中的NewSessionTicket报文格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    uint32 ticket_lifetime;</span><br><span class="line">    uint32 ticket_age_add;</span><br><span class="line">    opaque ticket_nonce&lt;<span class="number">0.</span><span class="number">.255</span>&gt;;</span><br><span class="line">    opaque ticket&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">    Extension extensions&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-2</span>&gt;;</span><br><span class="line">&#125; NewSessionTicket;</span><br></pre></td></tr></table></figure><p>其中ticket_lifetime和TLS 1.2中的ticket_lifetime_hint含义一样，用以告知客户端ticket的老化时间。</p><h1 id="SessionID与SessionTicket对比"><a href="#SessionID与SessionTicket对比" class="headerlink" title="SessionID与SessionTicket对比"></a>SessionID与SessionTicket对比</h1><p>SessionID机制有一些弊端，负载均衡中，服务端多个主机IP之间往往没有同步Session信息，如果客户端两次请求没有落在同一台机器上就无法找到匹配的Session信息。然后服务端存储SessionID对应的信息不好控制失效时间，太短起不到作用，太长又占用服务端大量资源。</p><p>而SessionTicket可以解决这些问题，SessionTicket是用只有服务端知道的安全密钥加密过的会话信息，最终保存在浏览器端。浏览器如果在ClientHello时带上了SessionTicket，只要服务器能成功解密就可以完成快速握手，即服务端很容易在多个主机IP间共享Session信息。</p><p>Github上有一个名为<a href="https://github.com/vincentbernat/rfc5077" target="_blank" rel="noopener">《rfc5077》</a>的项目，非常适合用来测试服务端对SessionID和SessionTicket这两种TLS会话复用机制的支持情况。编译完成后，当前目录会出现多个可执行文件。这里我们只会用到rfc5077-client，它的用法举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rfc5077-client -s imququ.com 114.215.116.12 139.162.98.188</span><br></pre></td></tr></table></figure><p><img src="/images/https_session_1_1.png" alt></p><p>从以上结果可以看出，禁用SessionTicket时，每次连接到不同IP都会导致Session无法复用；而启用SessionTicket后，不同IP之间也可以复用Session。符合前面的结论。值得注意的是，为了让一台服务器生成的SessionTicket能被另外服务器承认，往往需要对WebServer进行额外配置。例如在Nginx中，就需要通过ssl_session_ticket_key参数让多台机器使用相同的key文件（其实这里的可以就是服务端加密和解密SessionTicket的密钥），否则Nginx会使用随机生成的key文件，无法复用SessionTicket。出于安全考虑，key文件应该定期更换，并且确保换下来的key文件被彻底销毁。</p><p>需要注意的是，SessionTicket在服务端的多个主机IP间都能复用，也是需要服务端去做配置支持的哦。</p><h1 id="SessionID和SessionTicket的生成"><a href="#SessionID和SessionTicket的生成" class="headerlink" title="SessionID和SessionTicket的生成"></a>SessionID和SessionTicket的生成</h1><p>SessionID是服务端生成，通过ServerHello报文中的SessionID字段将信息传递给客户端。SessionTicket是服务端生成，当客户端和服务端完成完整的SSL握手过程后，服务端会发送一个NewSessionTicket的报文给客户端，也即是SessionTicket啦。</p><h1 id="Nginx中SessionID和SessionTicket的配置"><a href="#Nginx中SessionID和SessionTicket的配置" class="headerlink" title="Nginx中SessionID和SessionTicket的配置"></a>Nginx中SessionID和SessionTicket的配置</h1><p>（1）Nginx SessionCache的配置</p><p>SessionCache在Apache中可以通过SSLSessionCache来配置，在Nginx中可以通过ssl_session_cache来进行设置。举例来说：</p><pre><code>ssl_session_cache shared:SSL:50m;ssl_session_timeout 1d;</code></pre><p>上述配置表示共享缓存，缓存大小为50MB，会话的缓存时间1天，超过1天就过期失效了。</p><p>ssl_session_cache设置储存SSL会话的缓存类型和大小。默认值为ssl_session_cache off，off为关闭，还有一些其它的缓存类型，不过这里建议使用shared共享缓存类型，这种方法更为有效。</p><p>ssl_session_timeout客户端能够反复使用储存在缓存中的会话参数时间。</p><p>（2）Nginx SessionTicket的配置</p><p>SessionTicket在Apache中可以通过SSLTicketKeyDefault来配置，在Nginx中可以通过ssl_session_tickets来进行设置。举例来说：</p><pre><code>ssl_session_tickets on;ssl_session_ticket_key current.key;ssl_session_ticket_key previous.key;</code></pre><p>Nginx中使用ssl_session_ticket_key file来配置用于加密和解密SSL SessionTicket的密钥，如果用了多个指令文件，则仅第一个指令文件中的密钥用来加密和解密；其它的密钥文件（下面的）用来解密，这样的原因是，我们最好定期轮换加解密的key，轮换的时候把旧的放在下面用来解密旧的SessionTicket，第一个放新的，用来加解密新的请求。如果没有配置key文件，则openssl默认会在ssl初始化的时候生成随机数的key；这种时候只有在重启web server的时候才会重新生成随机key。</p><h1 id="TLS1-3中PSK"><a href="#TLS1-3中PSK" class="headerlink" title="TLS1.3中PSK"></a>TLS1.3中PSK</h1><p>在TLS1.3中，SessionCache和SessionTicket都被完全的取消，取而代之的是PSK（Pre Shared Key）。这个PSK并不是说每个客户端都要和服务端提前共享一个密钥，而是与握手相同的首先使用非对称加密方法直接提前协商一个密钥出来（psk_dhe_ke ），或者直接从之前协商出来的密钥参数中得出一个密钥（psk_ke）。</p><h1 id="国内外主流CDN厂商对SessionID和SessionTicket的支持情况"><a href="#国内外主流CDN厂商对SessionID和SessionTicket的支持情况" class="headerlink" title="国内外主流CDN厂商对SessionID和SessionTicket的支持情况"></a>国内外主流CDN厂商对SessionID和SessionTicket的支持情况</h1><p><img src="/images/https_session_1_2.png" alt></p><p>学习资料参考于：<br><a href="https://zhuanlan.zhihu.com/p/37826359" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37826359</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TLS1.2握手交互过程分析</title>
      <link href="/2022/02/26/TLS1-2%E6%8F%A1%E6%89%8B%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2022/02/26/TLS1-2%E6%8F%A1%E6%89%8B%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="TLS1-2首次完整握手过程-2-RTT"><a href="#TLS1-2首次完整握手过程-2-RTT" class="headerlink" title="TLS1.2首次完整握手过程(2-RTT)"></a>TLS1.2首次完整握手过程(2-RTT)</h1><p>TLS1.2版本以RSA密钥协商的过程如下：</p><p><img src="/images/https_handshake12_1_1.png" alt></p><p>TLS1.2版本以DH密钥协商的过程如下：</p><p><img src="/images/https_handshake12_1_2.png" alt></p><p><img src="/images/https_handshake12_1_3.png" alt></p><p>备注：带星号<code>*</code>是表示是非必须的，可选择的，如客户端给服务端发送证书这个就是可选，不是所有的都需要双向验证的。其中ServerKeyExchange/ClientKeyExchange这两个报文是双方用来交换一些参数的，这些参数将来会用来生成对称密钥的。其中带中括号[]的ChangeCipherSpec表示它不是一个HandShake协议的一种报文，而是一个独立的ChangeCipherSpec协议。</p><p>HTTPS TLS1.2首次握手交互（2-RTT）过程文字描述如下：</p><p>（1）客户端发送一个ClientHello的信息到服务端，这个包含信息主要包含了客户端所支持的加密套件（cipher_suites）、支持的TLS版本（client_version）、会话ID（session_id）等数据。</p><p>（2）服务器在收到这个ClientHello后，会选择一个合适的加密套件cipher suites，然后返回一个ServerHello的信息，这当中包括了选中的加密套件。除此以外，还会发送证书以及密钥交换（ServerKeyExchange）。密钥交换的数据由选中的加密套件决定，比如使用ECDHE时，发送数据有椭圆曲线域参数、公钥的值（详情见RFC 4492 section 5.4）。</p><p>（3）客户端收到ServerHello后，会对收到的证书进行验证。如果验证通过，则继续进行密钥交换流程，将客户端生成的公钥和服务端的结合，计算出本次会话的密钥，然后把公钥发送给服务端，最后再发送一个Finished信息。</p><p>（4）服务器收到客户端公钥信息，也会计算得出密钥，然后发送Finished信息。</p><p>（5）至此，握手阶段结束，加密连接开始。</p><p>从中可以看出，整个握手流程需要2-RTT，这在网络延迟较高的情况下是非常糟糕的，可能导致握手延迟增加几百毫秒。更糟糕的是，握手阶段的数据（如ServerHello阶段的信息），并不是加密的，中间人稍加利用，从中选择比较弱的加密算法，就可以带来降级攻击（Downgrade Attack）。</p><h1 id="TLS1-2会话恢复-1-RTT"><a href="#TLS1-2会话恢复-1-RTT" class="headerlink" title="TLS1.2会话恢复(1-RTT)"></a>TLS1.2会话恢复(1-RTT)</h1><p>Client和Server只要一关闭连接，短时间内再次访问HTTPS网站的时候又需要重新连接。新的连接会造成网络延迟，并消耗双方的计算能力。有没有办法能复用之前的TLS连接呢？办法是有的，这就涉及到了TLS会话复用机制。Client和Server可以选择一个以前的会话或复制一个现存的会话，从而避免完整的握手交互过程。在TLS1.2中有两种会话恢复的机制，一种是基于SessionID，另一种是基于SessionTicket的。</p><p>（1）基于SessionID的会话恢复</p><p>Client发送的ClientHello中包含了之前已经建立了TLS连接的会话的SessionID，Server检查它的会话缓存SessionCache以进行匹配。如果匹配成功，并且Server愿意在指定的会话状态下重建连接，它将会发送一个带有相同SessionID值的ServerHello消息。这时，Client和Server必须都发送ChangeCipherSpec消息并且直接发送Finished消息。一旦重建立完成，Client和Server可以开始交换应用层数据（见下面的流程图）。如果一个SessionID不匹配，Server会产生一个新的SessionID，然后TLS Client和Server需要进行一次完整的握手。</p><p><img src="/images/https_handshake12_1_4.png" alt></p><p><img src="/images/https_handshake12_1_5.png" alt></p><p>（2）基于SessionTicket的会话恢复</p><p>用来替代SessionID会话恢复的方案是使用会话票证（SessionTicket）。使用这种方式，除了所有的状态都保存在客户端（与HTTP Cookie的原理类似）之外，其消息流与服务器会话缓存是一样的。</p><p>其思想是服务器取出它的所有会话数据（状态）并进行加密（密钥只有服务器知道），再以票证的方式发回客户端。在接下来的连接中，客户端恢复会话时在ClientHello的扩展字段session_ticket中携带加密信息将票证提交回服务器，由服务器检查票证的完整性，解密其内容，再使用其中的信息恢复会话。</p><p>对于Server来说，解密SessionTicket就可以得到主密钥。对于Client来说，完整握手的时候收到Server下发的NewSessionTicket子消息的时候，Client会将SesionTicket和对应的预备主密钥存在Client缓存中，简短握手的时候，一旦Server验证通过，可以进行简单握手的时候，Client通过本地存储的预备主密钥生成主密钥，最终再生成会话密钥（对称加密密钥）。</p><p>这种方法有可能使扩展服务器集群更为简单，因为如果不使用这种方式，就需要在服务集群的各个节点之间同步SessionCache。SessionTicket需要服务器和客户端都支持，属于一个扩展字段，占用服务器资源很少。</p><p>当Client本地获取了SessionTicket以后，下次想要进行简短握手，就可以使用这个SessionTicket了。Client在ClientHello的扩展中包含非空的SessionTicket扩展，如果Server支持SessionTicket会话恢复，则会在ServerHello中回复一个空的SessionTicket扩展（注意Sever一定要带上一个空的SessionTicket扩展，如果不带上这个扩展，表示Sever端不支持SessionTicket这个机制）。Server将会话信息进行加密保护，生成一个新的SessionTicket，通过NewSessionTicket子消息报文发给Client。发送完NewSessionTicket消息以后，紧跟着发送ChangeCipherSpec和Finished消息。Client收到上述消息以后，回应ChangeCipherSpec和Finished消息，会话恢复成功。</p><p><img src="/images/https_handshake12_1_6.png" alt></p><p><img src="/images/https_handshake12_1_7.png" alt></p><p>备注：客户端的SessionTicket是在双方在首次握手的完成后，是由Server通过NewSessionTicket消息报文发送给客户端的哦。</p><p>（3）一点特殊情况</p><p>如果Client在ClientHello中同时发送了SessionID和SessionTicket TLS扩展，Server必须是用ClientHello中相同的SessionID进行响应。但是在校验SessionTicket时，Sever不能依赖这个特定的SessionID，即不能用ClientHello中的SessionID判断是否可以会话恢复。Server优先使用SessionTicket进行会话恢复（SessionTicket优先级高于SessionID），如果SessionTicket校验通过，就继续发送ChangeCipherSpec和Finished消息。如果SessionTicket没有校验通过，那么服务端才会尝试使用SessionCache机制来恢复会话。</p><p>说白了，就是当客户端发出的ClientHello中既有SessionID又有非空的SessionTicket扩展时，Server端会优先尝试校验SessionTicket看是否可以恢复会话。若Server端校验SessionTicket成功后，会在ServerHello中带上和ClientHello中相同的SessionID作为响应，但是ServerHello中不会带上SessionTicket TLS扩展。若Server端校验SessionTicket失败后，Server端不会继续使用SessionID来重试会话重建，在返回的SeverHello报文中会带上一个空的SessionTicket扩展（注意，ClientHello中不会有SessionID信息），表示要进行完整SSL握手，且完整握手结束后，会发送新的NewSessionTicket报文给Client端。</p><p><img src="/images/https_handshake12_1_8.png" alt></p><p>学习资料参考于：<br><a href="https://halfrost.com/https_tls1-2_handshake/" target="_blank" rel="noopener">https://halfrost.com/https_tls1-2_handshake/</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS中TLS/SSL协议结构分析</title>
      <link href="/2022/02/26/HTTPS%E4%B8%ADTLS-SSL%E5%8D%8F%E8%AE%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2022/02/26/HTTPS%E4%B8%ADTLS-SSL%E5%8D%8F%E8%AE%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="TLS-SSL协议结构"><a href="#TLS-SSL协议结构" class="headerlink" title="TLS/SSL协议结构"></a>TLS/SSL协议结构</h1><p>TLS/SSL协议位于应用层和传输层TCP协议之间。</p><p><img src="/images/https_protocol_1_1.png" alt></p><p>TLS粗略地又可以划分为两层：</p><p>（1）靠近应用层的握手协议TLS Handshaking Protocols</p><p>（2）靠近TCP的记录层协议TLS Record Protocol</p><p>TLS握手协议TLS Handshaking Protocols还能细分为5个子协议：</p><p>（1）change_cipher_spec (在TLS 1.3中这个协议已经删除，为了兼容TLS老版本，可能还会存在)</p><p>（2）alert</p><p>（3）handshake</p><p>（4）application_data</p><p>（5）heartbeat（这个是TLS 1.3新加的，TLS 1.3之前的版本没有这个协议）</p><p>这些子协议之间的关系可以用下图来表示：</p><p><img src="/images/https_protocol_1_2.png" alt></p><p>备注：当双方通过密钥协商过程得到会话密钥后，传输的加密数据，就走到了“应用数据协议”。</p><h1 id="TLS记录层协议"><a href="#TLS记录层协议" class="headerlink" title="TLS记录层协议"></a>TLS记录层协议</h1><p>记录层将上层的信息块分段为TLSPlaintext记录，TLSPlaintext中包含2^14字节或更少字节块的数据。</p><p><img src="/images/https_protocol_1_3.png" alt></p><p>备注：上图中Protocol Version是一个字段，占2个字节；length length也是一个字段，占两个字段。相关结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    invalid(<span class="number">0</span>),</span><br><span class="line">    change_cipher_spec(<span class="number">20</span>),</span><br><span class="line">    alert(<span class="number">21</span>),</span><br><span class="line">    handshake(<span class="number">22</span>),</span><br><span class="line">    application_data(<span class="number">23</span>),</span><br><span class="line">    heartbeat(<span class="number">24</span>),  <span class="comment">/* RFC 6520 */</span></span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; ContentType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TLS记录层的完整结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ContentType type;</span><br><span class="line">    ProtocolVersion legacy_record_version;</span><br><span class="line">    uint16 length;</span><br><span class="line">    opaque fragment[TLSPlaintext.length];</span><br><span class="line">&#125; TLSPlaintext;</span><br></pre></td></tr></table></figure><p>opaque fragment应该指的就是change_cipher_spec，handshake，application_data以及alert等这些子协议的内容了。</p><h1 id="TLS密码切换协议"><a href="#TLS密码切换协议" class="headerlink" title="TLS密码切换协议"></a>TLS密码切换协议</h1><p>change_cipher_spec（以下简称CCS协议） 协议，是TLS记录层对应用数据是否进行加密的分界线。客户端或者服务端一旦收到对端发来的CCS协议，就表明接下来传输数据过程中可以对应用数据协议进行加密了。</p><p>经过TLS记录层包装以后（<strong>也就是说下面的结构是TLS记录层的完整结构，下面的Message Header头也是TLS记录层的协议头。然后后面的其他子协议都是一样的哦</strong>），结构如下:</p><p><img src="/images/https_protocol_1_4.png" alt></p><p>TLS密码切换协议数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; </span><br><span class="line">    change_cipher_spec(<span class="number">1</span>), </span><br><span class="line">    (<span class="number">255</span>) </span><br><span class="line">    &#125; type;</span><br><span class="line">&#125; ChangeCipherSpec;</span><br></pre></td></tr></table></figure><h1 id="TLS警告协议"><a href="#TLS警告协议" class="headerlink" title="TLS警告协议"></a>TLS警告协议</h1><p>经过TLS记录层包装以后，结构如下:</p><p><img src="/images/https_protocol_1_5.png" alt></p><p>TLS警告协议数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; </span><br><span class="line">    warning(<span class="number">1</span>), </span><br><span class="line">    fatal(<span class="number">2</span>), </span><br><span class="line">    (<span class="number">255</span>) </span><br><span class="line">&#125; AlertLevel;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AlertLevel level;</span><br><span class="line">    AlertDescription description;</span><br><span class="line">&#125; Alert;</span><br></pre></td></tr></table></figure><p>TLS 1.2的所有警告描述信息如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    close_notify(<span class="number">0</span>),</span><br><span class="line">    unexpected_message(<span class="number">10</span>),</span><br><span class="line">    bad_record_mac(<span class="number">20</span>),</span><br><span class="line">    decryption_failed_RESERVED(<span class="number">21</span>),</span><br><span class="line">    record_overflow(<span class="number">22</span>),</span><br><span class="line">    decompression_failure(<span class="number">30</span>),</span><br><span class="line">    handshake_failure(<span class="number">40</span>),</span><br><span class="line">    no_certificate_RESERVED(<span class="number">41</span>),</span><br><span class="line">    bad_certificate(<span class="number">42</span>),</span><br><span class="line">    unsupported_certificate(<span class="number">43</span>),</span><br><span class="line">    certificate_revoked(<span class="number">44</span>),</span><br><span class="line">    certificate_expired(<span class="number">45</span>),</span><br><span class="line">    certificate_unknown(<span class="number">46</span>),</span><br><span class="line">    illegal_parameter(<span class="number">47</span>),</span><br><span class="line">    unknown_ca(<span class="number">48</span>),</span><br><span class="line">    access_denied(<span class="number">49</span>),</span><br><span class="line">    decode_error(<span class="number">50</span>),</span><br><span class="line">    decrypt_error(<span class="number">51</span>),</span><br><span class="line">    export_restriction_RESERVED(<span class="number">60</span>),</span><br><span class="line">    protocol_version(<span class="number">70</span>),</span><br><span class="line">    insufficient_security(<span class="number">71</span>),</span><br><span class="line">    internal_error(<span class="number">80</span>),</span><br><span class="line">    user_canceled(<span class="number">90</span>),</span><br><span class="line">    no_renegotiation(<span class="number">100</span>),</span><br><span class="line">    unsupported_extension(<span class="number">110</span>),  <span class="comment">/* new */</span></span><br><span class="line">       (<span class="number">255</span>)</span><br><span class="line">&#125; AlertDescription;</span><br></pre></td></tr></table></figure><p>TLS 1.3的所有警告描述信息如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    close_notify(<span class="number">0</span>),</span><br><span class="line">    unexpected_message(<span class="number">10</span>),</span><br><span class="line">    bad_record_mac(<span class="number">20</span>),</span><br><span class="line">    decryption_failed_RESERVED(<span class="number">21</span>),</span><br><span class="line">    record_overflow(<span class="number">22</span>),</span><br><span class="line">    decompression_failure_RESERVED(<span class="number">30</span>),</span><br><span class="line">    handshake_failure(<span class="number">40</span>),</span><br><span class="line">    no_certificate_RESERVED(<span class="number">41</span>),</span><br><span class="line">    bad_certificate(<span class="number">42</span>),</span><br><span class="line">    unsupported_certificate(<span class="number">43</span>),</span><br><span class="line">    certificate_revoked(<span class="number">44</span>),</span><br><span class="line">    certificate_expired(<span class="number">45</span>),</span><br><span class="line">    certificate_unknown(<span class="number">46</span>),</span><br><span class="line">    illegal_parameter(<span class="number">47</span>),</span><br><span class="line">    unknown_ca(<span class="number">48</span>),</span><br><span class="line">    access_denied(<span class="number">49</span>),</span><br><span class="line">    decode_error(<span class="number">50</span>),</span><br><span class="line">    decrypt_error(<span class="number">51</span>),</span><br><span class="line">    export_restriction_RESERVED(<span class="number">60</span>),</span><br><span class="line">    protocol_version(<span class="number">70</span>),</span><br><span class="line">    insufficient_security(<span class="number">71</span>),</span><br><span class="line">    internal_error(<span class="number">80</span>),</span><br><span class="line">    inappropriate_fallback(<span class="number">86</span>),</span><br><span class="line">    user_canceled(<span class="number">90</span>),</span><br><span class="line">    no_renegotiation_RESERVED(<span class="number">100</span>),</span><br><span class="line">    missing_extension(<span class="number">109</span>),</span><br><span class="line">    unsupported_extension(<span class="number">110</span>),</span><br><span class="line">    certificate_unobtainable_RESERVED(<span class="number">111</span>),</span><br><span class="line">    unrecognized_name(<span class="number">112</span>),</span><br><span class="line">    bad_certificate_status_response(<span class="number">113</span>),</span><br><span class="line">    bad_certificate_hash_value_RESERVED(<span class="number">114</span>),</span><br><span class="line">    unknown_psk_identity(<span class="number">115</span>),</span><br><span class="line">    certificate_required(<span class="number">116</span>),</span><br><span class="line">    no_application_protocol(<span class="number">120</span>),</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; AlertDescription;</span><br></pre></td></tr></table></figure><h1 id="TLS握手协议"><a href="#TLS握手协议" class="headerlink" title="TLS握手协议"></a>TLS握手协议</h1><p>握手协议是整个TLS协议簇中最最核心的协议，HTTPS能保证安全也是因为它的功劳。经过TLS记录层包装以后，结构如下:</p><p><img src="/images/https_protocol_1_6.png" alt></p><p>TLS 1.2握手协议数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    hello_request(<span class="number">0</span>), </span><br><span class="line">    client_hello(<span class="number">1</span>), </span><br><span class="line">    server_hello(<span class="number">2</span>),</span><br><span class="line">    certificate(<span class="number">11</span>), </span><br><span class="line">    server_key_exchange (<span class="number">12</span>),</span><br><span class="line">    certificate_request(<span class="number">13</span>), </span><br><span class="line">    server_hello_done(<span class="number">14</span>),</span><br><span class="line">    certificate_verify(<span class="number">15</span>), </span><br><span class="line">    client_key_exchange(<span class="number">16</span>),</span><br><span class="line">    finished(<span class="number">20</span>)</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; HandshakeType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HandshakeType msg_type;</span><br><span class="line">    uint24 length;</span><br><span class="line">    select (HandshakeType) &#123;</span><br><span class="line">        <span class="keyword">case</span> hello_request:       HelloRequest;</span><br><span class="line">        <span class="keyword">case</span> client_hello:        ClientHello;</span><br><span class="line">        <span class="keyword">case</span> server_hello:        ServerHello;</span><br><span class="line">        <span class="keyword">case</span> certificate:         Certificate;</span><br><span class="line">        <span class="keyword">case</span> server_key_exchange: ServerKeyExchange;</span><br><span class="line">        <span class="keyword">case</span> certificate_request: CertificateRequest;</span><br><span class="line">        <span class="keyword">case</span> server_hello_done:   ServerHelloDone;</span><br><span class="line">        <span class="keyword">case</span> certificate_verify:  CertificateVerify;</span><br><span class="line">        <span class="keyword">case</span> client_key_exchange: ClientKeyExchange;</span><br><span class="line">        <span class="keyword">case</span> finished:            Finished;</span><br><span class="line">    &#125; body;</span><br><span class="line">&#125; Handshake;</span><br></pre></td></tr></table></figure><p>TLS 1.3协议数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    hello_request_RESERVED(<span class="number">0</span>),</span><br><span class="line">    client_hello(<span class="number">1</span>),</span><br><span class="line">    server_hello(<span class="number">2</span>),</span><br><span class="line">    hello_verify_request_RESERVED(<span class="number">3</span>),</span><br><span class="line">    new_session_ticket(<span class="number">4</span>),</span><br><span class="line">    end_of_early_data(<span class="number">5</span>),</span><br><span class="line">    hello_retry_request_RESERVED(<span class="number">6</span>),</span><br><span class="line">    encrypted_extensions(<span class="number">8</span>),</span><br><span class="line">    certificate(<span class="number">11</span>),</span><br><span class="line">    server_key_exchange_RESERVED(<span class="number">12</span>),</span><br><span class="line">    certificate_request(<span class="number">13</span>),</span><br><span class="line">    server_hello_done_RESERVED(<span class="number">14</span>),</span><br><span class="line">    certificate_verify(<span class="number">15</span>),</span><br><span class="line">    client_key_exchange_RESERVED(<span class="number">16</span>),</span><br><span class="line">    finished(<span class="number">20</span>),</span><br><span class="line">    certificate_url_RESERVED(<span class="number">21</span>),</span><br><span class="line">    certificate_status_RESERVED(<span class="number">22</span>),</span><br><span class="line">    supplemental_data_RESERVED(<span class="number">23</span>),</span><br><span class="line">    key_update(<span class="number">24</span>),</span><br><span class="line">    message_hash(<span class="number">254</span>),</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; HandshakeType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HandshakeType msg_type;    <span class="comment">/* handshake type */</span></span><br><span class="line">    uint24 length;             <span class="comment">/* bytes in message */</span></span><br><span class="line">    select (Handshake.msg_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> client_hello:          ClientHello;</span><br><span class="line">        <span class="keyword">case</span> server_hello:          ServerHello;</span><br><span class="line">        <span class="keyword">case</span> end_of_early_data:     EndOfEarlyData;</span><br><span class="line">        <span class="keyword">case</span> encrypted_extensions:  EncryptedExtensions;</span><br><span class="line">        <span class="keyword">case</span> certificate_request:   CertificateRequest;</span><br><span class="line">        <span class="keyword">case</span> certificate:           Certificate;</span><br><span class="line">        <span class="keyword">case</span> certificate_verify:    CertificateVerify;</span><br><span class="line">        <span class="keyword">case</span> finished:              Finished;</span><br><span class="line">        <span class="keyword">case</span> new_session_ticket:    NewSessionTicket;</span><br><span class="line">        <span class="keyword">case</span> key_update:            KeyUpdate;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; Handshake;</span><br></pre></td></tr></table></figure><h1 id="TLS应用数据协议"><a href="#TLS应用数据协议" class="headerlink" title="TLS应用数据协议"></a>TLS应用数据协议</h1><p>应用数据协议就是TLS上层的各种协议，TLS主要保护的数据就是应用数据协议的数据。经过TLS记录层包装以后，结构如下:</p><p><img src="/images/https_protocol_1_7.png" alt></p><h1 id="TLS心跳协议"><a href="#TLS心跳协议" class="headerlink" title="TLS心跳协议"></a>TLS心跳协议</h1><p>经过TLS记录层包装以后，结构如下:</p><p><img src="/images/https_protocol_1_8.png" alt></p><p>协议数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    heartbeat_request(<span class="number">1</span>),</span><br><span class="line">    heartbeat_response(<span class="number">2</span>),</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; HeartbeatMessageType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HeartbeatMessageType type;</span><br><span class="line">    uint16 payload_length;</span><br><span class="line">    opaque payload[HeartbeatMessage.payload_length];</span><br><span class="line">    opaque padding[padding_length];</span><br><span class="line">&#125; HeartbeatMessage;</span><br></pre></td></tr></table></figure><h1 id="其他闲杂知识"><a href="#其他闲杂知识" class="headerlink" title="其他闲杂知识"></a>其他闲杂知识</h1><p>（1）一个TCP包中可以包含多个TLS报文</p><p><img src="/images/https_protocol_1_9.png" alt></p><p>学习资料参考于：<br><a href="https://halfrost.com/https-begin/" target="_blank" rel="noopener">https://halfrost.com/https-begin/</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS技术基础</title>
      <link href="/2022/02/26/HTTPS%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/26/HTTPS%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="SSL简介"><a href="#SSL简介" class="headerlink" title="SSL简介"></a>SSL简介</h1><p>SSL是Secure socket Layer英文缩写，它的中文意思是安全套接层协议。SSL是Netscape所研发，用以保障在Internet上数据传输的安全的一个协议。SSL因为应用广泛，成为互联网的事实标准，然后IETF组织就把SSL进行标准化，标准化后改名为TLS（全称为Transport Layer Security），所以SSL和TLS一般被并列称呼为SSL/TLS，两者可以视作同一个东西的不同阶段。</p><h1 id="SSL-TLS协议版本的演进及二者的关系"><a href="#SSL-TLS协议版本的演进及二者的关系" class="headerlink" title="SSL/TLS协议版本的演进及二者的关系"></a>SSL/TLS协议版本的演进及二者的关系</h1><p>（1）SSL1.0、SSL2.0与SSL3.0</p><p>SSL，Secure Sockets Layer是网景公司（Netscape）设计的主要用于Web的安全传输协议，这种协议在Web上获得了广泛的应用。SSL基础算法由作为网景公司的首席科学家塔希尔·盖莫尔（Taher Elgamal）编写，他被人称为“SSL之父”。SSL的版本演进：</p><p>SSL 1.0版本从未公开过，因为存在严重的安全漏洞。</p><p>SSL 2.0版本在1995年2月发布，但因为存在数个严重的安全漏洞而被3.0版本替代。</p><p>SSL 3.0版本在1996年发布，是由网景工程师Paul Kocher、Phil Karlton和Alan Freier完全重新设计的。</p><p>（2）TLS 1.0</p><p>IETF将SSL标准化，即RFC 2246，并将其称为TLS（Transport Layer Security）。从技术上讲，TLS 1.0与SSL 3.0的差异非常微小。</p><p>（3）TLS 1.1</p><p>TLS 1.1在RFC 4346中定义，于2006年4月发表，它是基于TLS 1.0的更新。在此版本中的差异包括：添加对CBC攻击的保护、隐式IV被替换成一个显式的IV、更改分组密码模式中的填充错误以及支持IANA登记的参数等等。</p><p>（4）TLS 1.2</p><p>TLS 1.2在RFC 5246中定义，于2008年8月发表。它基于更早的TLS 1.1规范。主要区别包括：</p><pre><code>可使用密码组合选项指定伪随机函数使用SHA-256替换MD5-SHA-1组合;可使用密码组合选项指定在完成消息的哈希认证中使用SHA-256替换MD5-SHA-1算法，但完成消息中哈希值的长度仍然被截断为96位;在握手期间MD5-SHA-1组合的数字签名被替换为使用单一Hash方法，默认为SHA-1;增强服务器和客户端指定Hash和签名算法的能力;扩大经过身份验证的加密密码，主要用于GCM和CCM模式的AES加密的支持;添加TLS扩展定义和AES密码组合</code></pre><p>（5）TLS 1.3</p><p>截至2016年1月，TLS 1.3还是一个互联网草案，细节尚属临时并且不完整。它基于更早的TLS 1.2规范，与TLS 1.2的主要区别包括：</p><pre><code>移除脆弱和较少使用的命名椭圆曲线支持移除MD5和SHA-224密码散列函数的支持请求数字签名，即便使用之前的配置集成HKDF和半短暂DH提议替换使用PSK和票据的恢复支持1-RTT握手和初步支持0-RTT放弃许多不安全或过时特性的支持，包括数据压缩、重新协商、非AEAD密码本、静态RSA和静态DH密钥交换、自定义DHE分组、点格式协商、更改密码本规范的协议、UNIX时间的Hello消息，以及长度字段AD输入到AEAD密码本禁止用于向后兼容性的SSL和RC4协商集成会话散列的使用弃用记录层版本号和冻结数以改进向后兼容性将一些安全相关的算法细节从标准移动到标准，并将ClientKeyShare降级到附录添加Curve25519和Ed25519到TLS标准。</code></pre><p><img src="/images/https_basic_1_1.png" alt></p><p>补充说明：</p><p>A）所有TLS版本在2011年3月发布的RFC 6176中删除了对SSL的兼容，这样TLS会话将永远无法协商使用的SSL 2.0以避免安全问题</p><p>B）2014年10月，Google发布在SSL 3.0中发现设计缺陷，建议禁用此一协议。攻击者可以向TLS发送虚假错误提示，然后将安全连接强行降级到过时且不安全的SSL 3.0，然后就可以利用其中的设计漏洞窃取敏感信息。Google在自己公司相关产品中陆续禁止向后兼容，强制使用TLS协议。Mozilla也在11月25日发布的Firefox 34中彻底禁用了SSL 3.0。微软同样发出了安全通告。</p><h1 id="SSL协议所涉及到协议安全机制"><a href="#SSL协议所涉及到协议安全机制" class="headerlink" title="SSL协议所涉及到协议安全机制"></a>SSL协议所涉及到协议安全机制</h1><p>（1）数据传输加密：利用加密算法对传输的数据进行加密</p><p>（2）身份验证机制：基于证书，利用数据签名方法对服务器和客户端进行身份验证。其中客户端的验证是可选的。</p><p>（3）消息完整性验证：消息传输过程中使用MAC算法来检验消息的完整性，以防止传输数据被他人篡改。</p><h1 id="SSL证书的申请和部署流程"><a href="#SSL证书的申请和部署流程" class="headerlink" title="SSL证书的申请和部署流程"></a>SSL证书的申请和部署流程</h1><p>（1）生成私钥和CSR文件</p><p>CSR是Cerificate Signing Request的英文缩写，即证书请求文件。证书申请者在申请数字证书时需要生成私钥，也需要生成证书请求文件，证书申请者只要把CSR文件提交给证书颁发机构后，证书颁发机构就会依据此来为证书请求者颁发数字证书。私钥则需要证书申请者自己保管。生成CSR的工具可以是openssl，也可以是证书颁发机构提供的工具或web在线生成工具。</p><p>（2）在服务器端安装数字证书</p><p>以Nginx的SSL配置为例，将私钥server.key以及数字证书server.pem文件放到Nginx的conf目录中。然后在nginx.conf配置文件添加如下配置：</p><pre><code>server {    listen       443;    server_name  localhost;    ssl                  on;    ssl_certificate      server.pem;    ssl_certificate_key  server.key;    ssl_session_timeout  5m;    ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;#启用TLS1.1、TLS1.2要求OpenSSL1.0.1及以上版本，若您的OpenSSL版本低于要求，请使用 ssl_protocolsTLSv1;    ssl_ciphers HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM;    ssl_prefer_server_ciphers   on;    location / {        root   html;        index  index.html index.htm;    }}</code></pre><h1 id="HTTPS交互过程"><a href="#HTTPS交互过程" class="headerlink" title="HTTPS交互过程"></a>HTTPS交互过程</h1><p>HTTPS交互过程如下：</p><p>（1）客户端发起HTTPS请求</p><p>用户在浏览器里输入一个HTTPS网址。</p><p>（2）服务器传送证书</p><p>服务器端将数字证书以及证书的数字签名发送给浏览器。</p><p>（3）浏览器端对数字证书进行验证</p><p>CA在颁发证书时，首先使用哈希函数对待签名内容进行安全哈希，生成消息摘要，然后使用CA自己的私钥对消息摘要进行签名。浏览器端使用CA的公钥（一般来说，CA的证书已经内置安装到浏览器中啦，所以浏览器很容易获知CA的公钥哦）进行签名验证，如果验证通过，说明数字证书确实是CA机构颁发的，同时也获取到了消息摘要M1。然后使用相同的哈希算法对证书中的内容计算出消息摘要M2，若M1和M2如果一样，则说明数字证书是完整的。</p><p>（4）浏览器使用服务器端数字证书中的公钥将“对称加密的秘钥”发送给服务端。</p><p>（5）服务端使用私钥解析浏览器发过来的数据，得到后面需要用到的对称加密的秘钥。</p><p>（6）服务器和浏览端之间就开始使用对称加密的方式来进行应用数据的传递。</p><p><img src="/images/https_basic_1_2.png" alt></p><p>备注：HTTPS交互主要有两个过程，一个是秘钥协商阶段（亦叫密钥交换或SSL握手），一个是应用数据传输阶段。在秘钥协商阶段使用非对称加密来交互，而在应用数据传输阶段使用对称加密的方式。非对称加密计算量占整个握手过程的90%以上。而对称加密的计算量只相当于非对称加密的0.1%，如果应用层数据也使用非对称加解密，性能开销太大，无法承受。</p><p>有一个更完整的过程图如下：</p><p><img src="/images/https_basic_1_3.png" alt></p><h1 id="秘钥协商阶段的非对称加密算法"><a href="#秘钥协商阶段的非对称加密算法" class="headerlink" title="秘钥协商阶段的非对称加密算法"></a>秘钥协商阶段的非对称加密算法</h1><p>在客户端和服务器开始交换TLS所保护的加密信息之前，他们必须安全地交换或协定加密密钥和加密数据时要使用的密码。用于密钥交换的方法包括：</p><p>（1）TLS_RSA</p><p>使用RSA算法生成公钥和私钥（在TLS 握手协议中被称为TLS_RSA）</p><p>（2）TLS_DH</p><p>Diffie-Hellman（在TLS握手协议中被称为TLS_DH）</p><p>（3）TLS_DHE</p><p>临时Diffie-Hellman（在TLS握手协议中被称为TLS_DHE）</p><p>（4）TLS_ECDH</p><p>椭圆曲线迪菲-赫尔曼（在TLS握手协议中被称为TLS_ECDH）</p><p>（5）TLS_ECDHE</p><p>临时椭圆曲线Diffie-Hellman（在TLS握手协议中被称为TLS_ECDHE）</p><p>（6）TLS_DH_anon</p><p>匿名Diffie-Hellman（在TLS握手协议中被称为TLS_DH_anon）</p><p>（7）TLS_PSK</p><p>预共享密钥（在TLS握手协议中被称为TLS_PSK）</p><p>详细的算法如下：</p><p><img src="/images/https_basic_1_4.png" alt></p><h1 id="数据传输阶段的对称加密算法"><a href="#数据传输阶段的对称加密算法" class="headerlink" title="数据传输阶段的对称加密算法"></a>数据传输阶段的对称加密算法</h1><p><img src="/images/https_basic_1_5.png" alt></p><h1 id="关于SSL的一点闲话"><a href="#关于SSL的一点闲话" class="headerlink" title="关于SSL的一点闲话"></a>关于SSL的一点闲话</h1><p>（1）HTTPS，Hypertext Transfer Protocol Secure，安全超文本传输协议。是HTTP协议的安全版本。HTTPS是基于SSL安全连接的HTTP协议。HTTPS通过SSL提供的数据加密、身份验证和消息完整性验证等安全机制，为Web访问提供了安全性保证，广泛应用于网上银行、电子商务等领域。</p><p>（2）OpenSSL是一个开放源代码的SSL协议的产品实现，它采用C语言作为开发语言，具备了跨系统的性能。在系统中调用OpenSSL的函数就可以实现一个SSL加密的安全数据传输通道，配合使用USBKey来储存key等机密信息，从而达到秘密性，完整性，认证性的目的。</p><p>学习资料参考于：<br><a href="http://blog.csdn.net/zhuyingqingfen/article/details/7610098" target="_blank" rel="noopener">http://blog.csdn.net/zhuyingqingfen/article/details/7610098</a><br><a href="http://blog.csdn.net/angela_615/article/details/5358280" target="_blank" rel="noopener">http://blog.csdn.net/angela_615/article/details/5358280</a><br><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0</a><br><a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="noopener">https://www.ssllabs.com/ssltest/</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP分块传输chunked</title>
      <link href="/2022/02/26/HTTP%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93chunked/"/>
      <url>/2022/02/26/HTTP%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93chunked/</url>
      
        <content type="html"><![CDATA[<h1 id="分块传输简介"><a href="#分块传输简介" class="headerlink" title="分块传输简介"></a>分块传输简介</h1><p>分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，它允许HTTP由网页服务器发送给客户端应用的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。</p><p>通常情况下，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度。数据的长度很重要，因为客户端需要知道哪里是应答消息的结束，以及后续应答消息的开始。然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。</p><h1 id="分块传输编码使用场景"><a href="#分块传输编码使用场景" class="headerlink" title="分块传输编码使用场景"></a>分块传输编码使用场景</h1><p>当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-Length消息首部字段告诉客户端需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用<code>Transfer-Encoding：chunk</code>模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用<code>Transfer-Encoding: chunked</code>这样的方式来代替Content-Length。在进行chunked编码传输时，在回复消息的头部有<code>Transfer-Encoding: chunked</code>。</p><p>简单来说，使用分块传输，就是服务器在一定时间内计算不出来响应内容的长度，如果不返回Content-Length的话，应用层可能就不知道一个HTTP报文的结尾，而解析不了。</p><h1 id="分块传输编码格式"><a href="#分块传输编码格式" class="headerlink" title="分块传输编码格式"></a>分块传输编码格式</h1><p>分块传输编码使用若干个chunk组成，由一个标明长度为0的chunk结束。每个chunk有两部分组成，第一部分是该chunk的长度，第二部分就是指定长度的内容，每个部分用CR/LF隔开。在最后一个长度为0的chunk中的内容是称为footer的内容，是一些没有写的头部内容。chunk编码格式如下：</p><pre><code>[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]</code></pre><p>chunk size是以十六进制的ASCII码表示，比如头部是3134这两个字节，表示的是1和4这两个ASCII字符，被HTTP协议解释为十六进制数14，也就是十进制的20，后面紧跟<a href="0d 0a">\r\n</a>，再接着是连续的20个字节的chunk正文。chunk数据以0长度的chunk块结束，也就是（30 0d 0a 0d 0a）。</p><p>需要注意的是，使用HTTP chunked将HTTP的响应正文拆分成很多的块，但他们还是在一个HTTP响应报文中哦，而不是不同的分块用不同的HTTP报文来封装哦。</p><h1 id="分块编码传输译码过程"><a href="#分块编码传输译码过程" class="headerlink" title="分块编码传输译码过程"></a>分块编码传输译码过程</h1><p>首选需要确认收到的数据时使用的chunked编码，也就是找到Transfer-Encoding: chunked，如果你找到了，好的，那接下来就可以按照下面的步骤开始进行解析了。</p><p>（1）需要找到数据开始地方，也就是第一个chunk size开始的地方，这个地方的标识符为\r\n\r\n。</p><p>（2）要成功获取到这一块的数据长度，这个地方需要注意了，十六进制的ASCII码表示。是的，字符串转成数字，你想起来函数atoi()了吗？恭喜你，你函数选择错了，atoi()只能识别数字0-9，遇到A-F就截断了，不过不用担心，还有一个函数叫做strtol(), 它可以随意的转换2-36进制。</p><p>（3）获取到数据块长度了，就可以copy数据了是吧，是不是很简单，但是如果你使用了<code>str***</code>相关的函数，那么恭喜你，你又错了，他们遇到\0就会停止，而你需要copy的数据可能会遇到很多个\0，还好有memcpy()这一类的函数可以使用。如果数据时写到指针里面，多次copy数据时记得指针的偏移。</p><p>（4）接下就跳过\r\n去获取下一个数据块长度，然后copy数据吧，直到你遇到一个数据块的长度为0,到这里数据就完全获取成功了。</p><h1 id="Nginx关闭chunked模式"><a href="#Nginx关闭chunked模式" class="headerlink" title="Nginx关闭chunked模式"></a>Nginx关闭chunked模式</h1><p>Nginx关闭chunked模式配置如下：</p><pre><code>chunked_transfer_encoding off;</code></pre><h1 id="关于分块传输的一些闲杂知识"><a href="#关于分块传输的一些闲杂知识" class="headerlink" title="关于分块传输的一些闲杂知识"></a>关于分块传输的一些闲杂知识</h1><p>（1）服务端选择使用chunked传输，那么服务端是无法知道消息体的长度的，也就是不确定Content-Length的大小。因此使用chunked传输时，HTTP响应Header中是没有Content-Length的。若端上依赖Content-Length则会有一些问题。</p><p>（2）目前，CDN使用非常普遍，若客户端请求压缩格式gzip的内容，即请求Header中包含Content-Encoding: gzip，若请求到达CDN时，CDN没有缓存压缩格式为gzip的内容，则服务端需要将内容压缩为gzip返回客户端，服务端为了响应速度，会使用chunked模式传输，这时响应Header中也将没有Content-Length。相反，若客户端不支持gzip压缩，而CDN只缓存了压缩后的数据，那CDN可能也会选择使用chunked模式来传输。</p><p>（3）Content-Encoding是消息内容编码，比如br、gzip等等。Transfer-Encoding是消息传输时编码，比如chunked，二者有很大的不同，需要注意一下。</p><p>学习资料参考于：<br><a href="https://blog.csdn.net/whatday/article/details/7571451" target="_blank" rel="noopener">https://blog.csdn.net/whatday/article/details/7571451</a><br><a href="https://blog.csdn.net/u012175637/article/details/82467130" target="_blank" rel="noopener">https://blog.csdn.net/u012175637/article/details/82467130</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP内容协商及Vary头部介绍</title>
      <link href="/2022/02/25/HTTP%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E5%8F%8AVary%E5%A4%B4%E9%83%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/02/25/HTTP%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E5%8F%8AVary%E5%A4%B4%E9%83%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP内容协商机制简介"><a href="#HTTP内容协商机制简介" class="headerlink" title="HTTP内容协商机制简介"></a>HTTP内容协商机制简介</h1><p>要了解Vary的作用，先得了解HTTP内容协商机制。有时候，同一个URL可以提供多份不同的文档，这就要求服务端和客户端之间有一个选择最合适版本的机制，这就是内容协商。<br>协商方式有两种，一种是服务端把文档可用版本列表发给客户端让用户选，这可以使用300 Multiple Choices状态码来实现。这种方案有不少问题，首先多一次网络往返；其次服务端同一文档的某些版本可能是为拥有某些技术特征的客户端准备的，而普通用户不一定了解这些细节。举个例子，服务端通常可以将静态资源输出为压缩和未压缩两个版本，压缩版显然是为支持压缩的客户端而准备的，但如果让普通用户选，很可能选择错误的版本。所以HTTP的内容协商通常使用另外一种方案，服务端根据客户端发送的请求头中某些字段自动发送最合适的版本。可以用于这个机制的请求头字段又分两种：内容协商专用字段（Accept/Accept-XXX字段）、其他字段（User Agent/Cookies等）。</p><p>首先来看Accept/Accept-XXX字段，详见下表：</p><p><img src="/images/http_vary_1_1.png" alt></p><p>例如，客户端发送以下请求头：</p><pre><code>Accept:*/*Accept-Encoding:gzip,deflate,sdchAccept-Language:zh-CN,en-US;q=0.8,en;q=0.6</code></pre><p>分别表示它可以接受任何MIME类型的资源；支持采用gzip、deflate或sdch压缩过的资源；可以接受zh-CN、en-US和en三种语言，并且zh-CN的权重最高（q取值0-1，最高为1，最低为0，默认为1），服务端应该优先返回语言等于zh-CN的版本。</p><p>浏览器的响应头可能是这样的：</p><pre><code>Content-Type: text/javascriptContent-Encoding: gzip</code></pre><p>表示这个文档确切的MIME类型是<code>text/javascript</code>；文档内容进行了gzip压缩；响应头没有Content-Language字段，通常说明返回版本的语言正好是请求头Accept-Language中权重最高的那个。</p><p>有时候，上面四个Accept字段并不够用，例如要针对特定浏览器如IE6输出不一样的内容，就需要用到请求头中的User-Agent字段。类似的，请求头中的Cookie也可能被服务端用做输出差异化内容的依据。</p><p>备注：Content-Encoding是消息内容编码，比如br、gzip等等。Transfer-Encoding是消息传输时编码，比如chunked，二者有很大的不同，需要注意一下。</p><h1 id="HTTP-Vary头部"><a href="#HTTP-Vary头部" class="headerlink" title="HTTP Vary头部"></a>HTTP Vary头部</h1><p>在上面的内容协商的机制中，当客户端和服务端之间可能存在一个或多个中间实体（比如有多级缓存服务器），而缓存服务最基本的要求是给用户返回正确的文档。如果源站服务端根据不同User-Agent返回不同内容，而中间的缓存服务器把IE6用户的响应缓存下来，并返回给使用其他浏览器的用户，肯定会出问题。</p><p>因此HTTP协议规定，如果源站服务端提供的内容取决于User-Agent这样「常规Accept协商字段之外」的请求头字段，那么响应头中必须包含Vary字段，且Vary的内容必须包含User-Agent。同理，如果服务端同时使用请求头中User-Agent和Cookie这两个字段来生成内容，那么响应中的Vary字段看上去应该是这样的：</p><pre><code>Vary: User-Agent, Cookie</code></pre><p>也就是说Vary字段用于列出一个响应字段列表，告诉缓存服务器遇到同一个URL对应着不同版本文档的情况时，如何缓存和筛选合适的版本。</p><p>举例来说，首次请求没命中缓存服务，详细过程如下：</p><p><img src="/images/http_vary_1_2.png" alt></p><p>再次请求时，命中缓存服务器，其交互过程如下：</p><p><img src="/images/http_vary_1_3.png" alt></p><p>简单来说，Vary响应头的值是一个或多个请求头。Vary响应头，是源站服务器用来告诉缓存服务器的，需要将Vary响应头中指定的请求头加入了缓存服务器的缓存Key中。</p><h1 id="Nginx中配置Vary"><a href="#Nginx中配置Vary" class="headerlink" title="Nginx中配置Vary"></a>Nginx中配置Vary</h1><p>Nginx中的<code>gzip_vary on | off;</code>配置可以打开Nginx的响应Vary头部功能。</p><p>学习资料参考于：<br><a href="https://imququ.com/post/vary-header-in-http.html" target="_blank" rel="noopener">https://imququ.com/post/vary-header-in-http.html</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP请求/响应报文结构</title>
      <link href="/2022/02/25/HTTP%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/"/>
      <url>/2022/02/25/HTTP%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h1><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式：</p><pre><code>＜request-line＞＜headers＞＜blank line＞[＜request-body＞]</code></pre><h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><p>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如<code>GET /index.html HTTP/1.1</code>。HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p><p>（1）GET请求</p><p>最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&amp;op=bind,这样通过GET方式传递的数据直接表示在地址中，所以我们可以把请求结果以链接的形式发送给好友。</p><p><img src="/images/http_message_1_1.png" alt></p><p>以用google搜索domety为例，Request格式如下：</p><pre><code>GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1  Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, application/x-silverlight, application/x-shockwave-flash, */*  Referer: http://www.google.cn/  Accept-Language: zh-cn  Accept-Encoding: gzip, deflate  User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  Host: www.google.cn  Connection: Keep-Alive  Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g;NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r  </code></pre><p>可以看到，GET方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址中”?”之后的部分就是通过GET发送的请求数据，我们可以在地址栏中清楚的看到，各个数据之间用”&amp;”符号隔开。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。</p><p>（2）POST请求</p><p>对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。</p><p><img src="/images/http_message_1_2.png" alt></p><p>还以上面的搜索domety为例，如果使用POST方式的话，格式如下：</p><pre><code>POST /search HTTP/1.1  Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint,application/msword, application/x-silverlight, application/x-shockwave-flash, */*  Referer: http://www.google.cn/Accept-Language: zh-cn  Accept-Encoding: gzip, deflate  User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  Host: www.google.cnConnection: Keep-Alive  Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g;NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r  hl=zh-CN&amp;source=hp&amp;q=domety </code></pre><p>可以看到，POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;”符号隔开。POST方式大多用于页面的表单中。因为POST也能完成GET的功能，因此多数人在设计表单的时候一律都使用POST方式，其实这是一个误区。GET方式也有自己的特点和优势，我们应该根据不同的情况来选择是使用GET还是使用POST。</p><p>（3）HEAD请求</p><p>HTTP HEAD方法请求资源的首部信息，并且这些首部与HTTP GET方法请求时返回的一致。该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载，以此可以节约带宽资源。以<code>curl -I</code>发起的HEAD HTTP请求为例来说明：</p><p><img src="/images/http_message_1_5.png" alt></p><p>HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</p><h2 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h2><p>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p><pre><code>User-Agent：产生请求的浏览器类型Accept：客户端可识别的内容类型列表Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机</code></pre><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p><h2 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h2><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p><h1 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h1><p>HTTP响应也由三个部分组成，分别是状态行、消息报头、空行、响应正文。如下所示，HTTP响应的格式与请求的格式十分类似：</p><pre><code>＜status-line＞＜headers＞＜blank line＞[＜response-body＞]</code></pre><p>正如你所见，在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p><p>通用格式为如下：</p><p><img src="/images/http_message_1_3.png" alt></p><p><img src="/images/http_message_1_4.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis技术调研</title>
      <link href="/2022/02/25/Redis%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2022/02/25/Redis%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis是一个key-value的非关系型数据库（NoSQL），现在在各种系统中的使用越来越多，大部分情况下是因为其高性能的特性，被当做缓存使用。Redis应用广泛，尤其是被作为缓存使用，Redis由于其丰富的数据结构也可以被应用到其他场景。Redis的具有很多优势：</p><p>（1）读写性能高，10w次/s+的读速度，8w次/s+的写速度</p><p>（2）K-V，value支持的数据类型很多，包括字符串String、队列List、哈希Hash、集合Sets以及有序集合Sorted Sets五种不同的数据类型</p><p>（3）原子性，Redis的所有操作都是单线程原子性的</p><p>（4）特性丰富，支持订阅/发布模式，具有通知、设置key过期等特性</p><p>（5）在Redis 3.0版本引入了Redis集群，可用于分布式部署</p><p>Redis的功能有缓存，分布式锁以及消息队列。</p><h1 id="Redis的一些特性"><a href="#Redis的一些特性" class="headerlink" title="Redis的一些特性"></a>Redis的一些特性</h1><p>（1）value支持的数据类型有很多，如字符串、哈希以及集合等等</p><p>（2）Redis实例支持多数据库，一个Redis实例最多支持16个数据库，编号从0到15</p><p>（3）支持事务，multi指示事务的开始，exec指示事务的执行，discard指示事务的丢弃。所有的指令在exec之前都不执行，只是被缓存到服务器的一个队列里，只有在收到exec指令后才开始执行</p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>即将内存的数据持久化磁盘上，这样重启Redis进程之后，缓存的数据就不会丢失。当然也可以设置让Redis不做持久化，这样数据只会在内存中存在，当Redis进程重启时，数据就会丢失。关于Redis持久化有如下两种方式：</p><p>（1）RDB方式，即快照</p><p>RDB持久化方式会在一个特定的间隔保存那个时间点的数据快照。</p><p>（2）AOF方式，即追加式文件</p><p>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。</p><h1 id="Redis的速度为什么快"><a href="#Redis的速度为什么快" class="headerlink" title="Redis的速度为什么快"></a>Redis的速度为什么快</h1><p>Redis采用的是基于内存的采用的是单进程单线程模型的KV数据库，由C语言编写。Redis之所以快的原因主要有：</p><p>（1）完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。</p><p>（2）数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。</p><p>（3）采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。需要注意的是，Redis新版本开始支持了多线程了。</p><p>（4）使用多路I/O复用的Reactor模型，非阻塞IO<br>需要注意的是，Redis是单线程的，只是在处理网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的。例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）。至于Redis处理请求时使用单线程，官方解释说，Redis的瓶颈不在CPU，而在内存和网络带宽。</p><p>正是由于Redis处理请求是单线程的，所以不能充分利用CPU多核的特性。如果要想利用CPU多核特性，我们可以在一台机器上启动多个Redis实例就好了。</p><h1 id="Redis客户端"><a href="#Redis客户端" class="headerlink" title="Redis客户端"></a>Redis客户端</h1><p>Redis命令用于在redis服务上执行操作。要在redis服务上执行命令需要一个redis客户端。Redis安装之后自带redis-cli，就是Redis的客户端。</p><p>（1）连接本地redis服务</p><pre><code>$ redis-cliredis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; PINGPONG</code></pre><p>（2）连接远程redis服务</p><p>以下实例演示了如何连接到主机为127.0.0.1，端口为6379 ，密码为mypass的redis服务上。</p><pre><code>$redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; PINGPONG</code></pre><p>备注：redis也有账号密码，这块待研究。</p><h1 id="Redis整体的数据结构以及支持的数据类型"><a href="#Redis整体的数据结构以及支持的数据类型" class="headerlink" title="Redis整体的数据结构以及支持的数据类型"></a>Redis整体的数据结构以及支持的数据类型</h1><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis内部整体的存储结构是一个大的hashmap（和Java中的HashMap结构很相似），内部是数组实现的hash，key冲突通过挂链表去实现，每个dictEntry为一个key/value对象，value为定义的redisObject。</p><p><img src="/images/redis_1_3.png" alt></p><p>dictEntry是存储key-&gt;value的地方，再让我们看一下dictEntry结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 指向具体redisObject</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>因此通过dictEntry结构看到，redis中的value是一个redisObject，下面是redis中定义的redisObject结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型 4bits</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码方式 4bits</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// LRU 时间（相对于 server.lruclock） 24bits</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">// 引用计数 Redis里面的数据可以通过引用计数进行共享 32bits</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向对象的值 64-bit</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>如上<code>*ptr</code>指向具体的数据结构的地址；type表示该对象的类型，即String/List/Hash/Set/Zset中的一个，但为了提高存储效率与程序执行效率，每种对象的底层数据结构实现都可能不止一种，encoding表示对象底层所使用的编码，也就是<code>*ptr</code>指向的数据类型，是Redis的内部数据类型，有如下八种：</p><pre><code>REDIS_ENCODING_INT（long 类型的整数）REDIS_ENCODING_EMBSTR embstr （编码的简单动态字符串）REDIS_ENCODING_RAW （简单动态字符串）REDIS_ENCODING_HT （字典）REDIS_ENCODING_LINKEDLIST （双端链表）REDIS_ENCODING_ZIPLIST （压缩列表）REDIS_ENCODING_INTSET （整数集合）REDIS_ENCODING_SKIPLIST （跳跃表和字典）</code></pre><p>总结来说，String/List/Hash/Set/Zset是Redis对外提供的数据类型，而Redis实际存储时用的是内部类型，如下是对外类型和内部类型的对应关系：</p><p><img src="/images/redis_1_2.png" alt></p><p>可以使用<code>OBJECT ENCODING key</code>命令来查看某个key存储的value的底层数据类型。</p><p>举例来说，String类型内部使用了int/embstr/raw类型，这也就是Redis能用String类型存储整型/浮点型数据的原因了。</p><h2 id="Redis支持的五种数据类型"><a href="#Redis支持的五种数据类型" class="headerlink" title="Redis支持的五种数据类型"></a>Redis支持的五种数据类型</h2><p>Redis支持的五种数据类型，string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><h2 id="Redis命令简介"><a href="#Redis命令简介" class="headerlink" title="Redis命令简介"></a>Redis命令简介</h2><p>Redis命令格式如下：</p><pre><code>COMMAND KEY_NAME [VALUE] [OPTION]</code></pre><p>Redis的命令可以根据数据类型分为几类，常用的有：</p><pre><code>SETGETDELEXISTSEXPIRETTL...</code></pre><p><a href="https://redis.io/commands" target="_blank" rel="noopener">Redis支持命令完整版参见官网</a></p><h2 id="与keys相关操作命令"><a href="#与keys相关操作命令" class="headerlink" title="与keys相关操作命令"></a>与keys相关操作命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DEL key    <span class="comment">#该命令用于在 key 存在时删除 key</span></span><br><span class="line">DUMP key   <span class="comment">#序列化给定 key ，并返回被序列化的值</span></span><br><span class="line">EXISTS key <span class="comment">#检查给定 key 是否存在</span></span><br><span class="line">EXPIRE key seconds       <span class="comment">#为给定 key 设置过期时间，以秒计</span></span><br><span class="line">EXPIREAT key timestamp   <span class="comment">#EXPIREAT的作用和EXPIRE类似，都用于为key设置过期时间。 不同在于EXPIREAT命令接受的时间参数是UNIX时间戳(unix timestamp)</span></span><br><span class="line">PEXPIRE key milliseconds <span class="comment">#设置 key 的过期时间以毫秒计</span></span><br><span class="line">PEXPIREAT key milliseconds-timestamp <span class="comment">#设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</span></span><br><span class="line">KEYS pattern <span class="comment">#查找所有符合给定模式( pattern)的 key</span></span><br><span class="line">MOVE key db  <span class="comment">#将当前数据库的 key 移动到给定的数据库 db 当中</span></span><br><span class="line">PERSIST key  <span class="comment">#移除 key 的过期时间，key 将持久保持</span></span><br><span class="line">PTTL key     <span class="comment">#以毫秒为单位返回 key 的剩余的过期时间</span></span><br><span class="line">TTL key      <span class="comment">#以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)</span></span><br><span class="line">RANDOMKEY    <span class="comment">#从当前数据库中随机返回一个 key</span></span><br><span class="line">RENAME key newkey    <span class="comment">#修改 key 的名称</span></span><br><span class="line">RENAMENX key newkey  <span class="comment">#仅当 newkey 不存在时，将 key 改名为 newkey</span></span><br><span class="line">SCAN cursor [MATCH pattern] [COUNT count]  <span class="comment">#迭代数据库中的数据库键</span></span><br><span class="line">TYPE key             <span class="comment">#返回 key 所储存的值的类型</span></span><br></pre></td></tr></table></figure><h2 id="与string相关操作命令"><a href="#与string相关操作命令" class="headerlink" title="与string相关操作命令"></a>与string相关操作命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SET key value           <span class="comment">#设置指定 key 的值</span></span><br><span class="line">GET key                 <span class="comment">#获取指定 key 的值</span></span><br><span class="line">GETRANGE key start end  <span class="comment">#返回 key 中字符串值的子字符</span></span><br><span class="line">GETSET key value        <span class="comment">#将给定 key 的值设为 value ，并返回 key 的旧值(old value)</span></span><br><span class="line">GETBIT key offset       <span class="comment">#对 key 所储存的字符串值，获取指定偏移量上的位(bit)</span></span><br><span class="line">MGET key1 [key2..]      <span class="comment">#获取所有(一个或多个)给定 key 的值</span></span><br><span class="line">SETBIT key offset value <span class="comment">#对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)</span></span><br><span class="line">SETEX key seconds value <span class="comment">#将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)</span></span><br><span class="line">SETNX key value           <span class="comment">#只有在 key 不存在时设置 key 的值</span></span><br><span class="line">SETRANGE key offset value <span class="comment">#用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</span></span><br><span class="line">STRLEN key   <span class="comment">#返回 key 所储存的字符串值的长度</span></span><br><span class="line">MSET key value [key value ...]   <span class="comment">#同时设置一个或多个 key-value 对</span></span><br><span class="line">MSETNX key value [key value ...] <span class="comment">#同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</span></span><br><span class="line">PSETEX key milliseconds value    <span class="comment">#这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位</span></span><br><span class="line">INCR key     <span class="comment">#将 key 中储存的数字值增一</span></span><br><span class="line">INCRBY key increment      <span class="comment">#将 key 所储存的值加上给定的增量值（increment）</span></span><br><span class="line">INCRBYFLOAT key increment <span class="comment">#将 key 所储存的值加上给定的浮点增量值（increment）</span></span><br><span class="line">DECR key                  <span class="comment">#将 key 中储存的数字值减一</span></span><br><span class="line">DECRBY key decrement      <span class="comment">#key 所储存的值减去给定的减量值（decrement）</span></span><br><span class="line">APPEND key value          <span class="comment">#如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾</span></span><br></pre></td></tr></table></figure><h2 id="与list相关操作命令"><a href="#与list相关操作命令" class="headerlink" title="与list相关操作命令"></a>与list相关操作命令</h2><p>list即是链表。操作list的常用命令有rpush，lpop，lpush，rpop，lrange，llen等。命令举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpush myList value1         <span class="comment">#向list的头部（右边）添加元素</span></span><br><span class="line">rpush myList value2 value3  <span class="comment">#向list的头部（最右边）添加多个元素</span></span><br><span class="line">lpop myList                 <span class="comment">#将list的尾部(最左边)元素取出</span></span><br><span class="line">lrange myList 0 1           <span class="comment">#查看对应下标的list列表， 0为start，1为end</span></span><br><span class="line">lrange myList 0 -1          <span class="comment">#查看列表中的所有元素，-1表示倒数第一</span></span><br></pre></td></tr></table></figure><p><img src="/images/redis_1_1.png" alt></p><h2 id="与hash相关操作命令"><a href="#与hash相关操作命令" class="headerlink" title="与hash相关操作命令"></a>与hash相关操作命令</h2><p>hash类似于JDK1.8前的HashMap。操作hash的常用命令有hset，hmset，hexists，hget，hgetall，hkeys，hvals等。命令举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hmset userInfoKey name <span class="string">"guide"</span> description <span class="string">"dev"</span> age “24”  <span class="comment">#初始化一个hash对象</span></span><br><span class="line">hexists userInfoKey name  <span class="comment">#查看key对应的value中指定的字段是否存在</span></span><br><span class="line">hget userInfoKey name     <span class="comment">#获取存储在哈希表中指定字段的值</span></span><br><span class="line">hgetall userInfoKey       <span class="comment">#获取在哈希表中指定key的所有字段和值</span></span><br><span class="line">hkeys userInfoKey         <span class="comment">#获取key列表</span></span><br><span class="line">hvals userInfoKey         <span class="comment">#获取value列表</span></span><br><span class="line">hset userInfoKey name <span class="string">"GuideGeGe"</span>  <span class="comment">#修改某个字段对应的值</span></span><br></pre></td></tr></table></figure><h2 id="与set相关操作命令"><a href="#与set相关操作命令" class="headerlink" title="与set相关操作命令"></a>与set相关操作命令</h2><p>set类似于Java中的HashSet。Redis中的set类型是一种无序集合，集合中的元素没有先后顺序。操作set的常用命令有sadd，spop，smembers，sismember，scard，sinterstore，sunion等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sadd mySet value1 value2  <span class="comment">#添加元素进去</span></span><br><span class="line">sadd mySet value1         <span class="comment">#不允许有重复元素</span></span><br><span class="line">smembers mySet            <span class="comment">#查看set中所有的元素</span></span><br><span class="line">scard mySet               <span class="comment">#查看set的长度</span></span><br><span class="line">sismember mySet value1    <span class="comment">#检查某个元素是否存在set中，只能接收单个元素</span></span><br><span class="line"></span><br><span class="line">sadd mySet2 value2 value3</span><br><span class="line">sinterstore mySet3 mySet mySet2  <span class="comment">#获取mySet和mySet2的交集并存放在mySet3中</span></span><br></pre></td></tr></table></figure><h2 id="与sorted-set相关操作命令"><a href="#与sorted-set相关操作命令" class="headerlink" title="与sorted set相关操作命令"></a>与sorted set相关操作命令</h2><p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，还可以通过score的范围来获取元素的列表。操作sorted set的常用命令有zadd，zcard，zscore，zrange，zrevrange，zrem等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zadd myZset 3.0 value1             <span class="comment">#添加元素到sorted set中3.0为权重</span></span><br><span class="line">zadd myZset 2.0 value2 1.0 value3  <span class="comment">#一次添加多个元素</span></span><br><span class="line">zcard myZset          <span class="comment">#查看sorted set中的元素数量</span></span><br><span class="line">zscore myZset value1  <span class="comment">#查看某个value的权重</span></span><br><span class="line">zrange myZset 0 -1    <span class="comment">#顺序输出某个范围区间的元素，0-1表示输出所有元素</span></span><br><span class="line">zrange myZset 0 1     <span class="comment">#顺序输出某个范围区间的元素，0为start，1为stop</span></span><br><span class="line">zrevrange myZset 0 1  <span class="comment">#逆序输出某个范围区间的元素，0为start，1为stop</span></span><br></pre></td></tr></table></figure><h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p>redis发布与订阅是一种消息通信的模式，发送者（pub）发送消息，订阅者（sub）接收消息。这使Redis可以用作消息队列。</p><p><img src="/images/redis_1_4.png" alt></p><p><img src="/images/redis_1_5.png" alt></p><p>第一个redis客户端设置订阅某频道的消息：</p><pre><code>redis 127.0.0.1:6379&gt; SUBSCRIBE runoobChatReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;runoobChat&quot;3) (integer) 1</code></pre><p>第二个redis客户端往某频道发布消息：</p><pre><code>redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Redis PUBLISH test&quot;(integer) 1redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Learn redis by runoob.com&quot;(integer) 1# 订阅者的客户端会显示如下消息1) &quot;message&quot;2) &quot;runoobChat&quot;3) &quot;Redis PUBLISH test&quot;1) &quot;message&quot;2) &quot;runoobChat&quot;3) &quot;Learn redis by runoob.com&quot;</code></pre><p>备注：订阅客户端订阅频道还支持模式匹配，如<code>PUBLISH a.*</code>，则该客户端会订阅a.b，a.c等等频道。</p><h1 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h1><p>在Redis中，我们可以通过server.maxmemory去设置Redis最大使用内存大小，而当Redis内存数据集大小上升到一定程度的时候（Redis的内存已经快放不下了），Redis就会施行数据淘汰机制。Redis提供了一下6种数据淘汰机制：</p><p>Redis内存淘汰机制，保证Redis中的数据都是热点数据。Redis提供6种数据淘汰策略如下：</p><p>（1）volatile-lru（least recently used）</p><p>从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。</p><p>（2）volatile-ttl</p><p>从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。</p><p>（3）olatile-random</p><p>从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。</p><p>（4）allkeys-lru（least recently used）</p><p>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的） </p><p>（5）allkeys-random</p><p>从数据集（server.db[i].dict）中任意选择数据淘汰。</p><p>（6）no-eviction</p><p>禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</p><p>当Redis要淘汰key并回收内存时，也有两种方式，一种是惰性删除（即不会立即删除，等下次来访问的时候再删除）；一种是定期删除要淘汰的部分key。</p><h1 id="Redis部署方式"><a href="#Redis部署方式" class="headerlink" title="Redis部署方式"></a>Redis部署方式</h1><p>（1）单机部署模式</p><p>（2）Master-Slave + Sentinel选举模式</p><p>（3）Redis Cluster模式</p><h1 id="缓存几个可用性问题"><a href="#缓存几个可用性问题" class="headerlink" title="缓存几个可用性问题"></a>缓存几个可用性问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。解决方法如下：</p><p>（1）接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</p><p>（2）从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。</p><p>（3）布隆过滤器。类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。解决方案如下：</p><p>（1）设置热点数据永远不过期。</p><p>（2）接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</p><p>（3）加互斥锁</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。解决方案如下：</p><p>（1）缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p><p>（2）如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</p><p>（3）设置热点数据永远不过期</p><h1 id="SpringBoot集成Redis"><a href="#SpringBoot集成Redis" class="headerlink" title="SpringBoot集成Redis"></a>SpringBoot集成Redis</h1><p>使用Spring Data Redis模块，构造RedisTemplate对象访问Redis实例，底层使用的是Jredis客户端，不过SpringBoot2.x开始，已经默认使用Lettuce客户端了。</p><h1 id="其他闲杂"><a href="#其他闲杂" class="headerlink" title="其他闲杂"></a>其他闲杂</h1><p>（1）Redisson是一个企业级的开源Redis Client，这个推荐使用。且这个Client还带有分布式锁支持，从而避免使用原生Client API实现分布式锁时考虑的一些复杂问题。</p><p>（2）从Redis 2.6版本起，Redis开始支持Lua脚本，通过内嵌支持Lua环境，执行脚本的常用命令为EVAL。整个Lua脚本中所有redis命令集合是一个原子性操作。Redis分布式的实现一般来说会用到Lua脚本。但是不保证事务（也就是部分命令失败，不会回滚），只能保证Lua脚本中命令集中间不会插入其他命令执行。至于事务，需要业务自己去保证。</p><p>学习资料参考于：<br><a href="https://mp.weixin.qq.com/s/7ct-mvSIaT3o4-tsMaKRWA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7ct-mvSIaT3o4-tsMaKRWA</a></p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由选择协议</title>
      <link href="/2021/05/25/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/05/25/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="自治系统AS概念"><a href="#自治系统AS概念" class="headerlink" title="自治系统AS概念"></a>自治系统AS概念</h1><p>AS，英文全称为Autonomous System，中文为自治系统。在互联网中，一个自治系统是指在一个（有时是多个）实体管辖下的所有IP网络和路由器的全体，每个自治系统都被分配一个唯一的自治系统编号（ASN）。各个自治系统通过边界网关协议组成了全球互联网。</p><h1 id="路由表的生成"><a href="#路由表的生成" class="headerlink" title="路由表的生成"></a>路由表的生成</h1><p>路由器中路由表中的路由记录可以有动态路由和静态路由两种。静态路由是由人工配置的，而动态路由是根据路由选择协议自动计算生成的。</p><h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><p>路由选择协议分为内部网关协议IGP以及外部网关协议EGP两种。内部网关协议是用在一个自治系统内部的路由选择，外部网关协议是用在不同自治系统间的路由选择，来实现不同自治系统间的互联互通。</p><p>（1）内部网关协议IGP</p><p>内部网关协议IGP有RIP、OSPF等。</p><p>（2）外部网关协议EGP</p><p>若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议EGP。目前使用最多的外部网关协议是BGP的版本4。</p><h1 id="一点闲杂"><a href="#一点闲杂" class="headerlink" title="一点闲杂"></a>一点闲杂</h1><p>（1）BGP机房</p><p>BGP主要用于互联网AS（自治系统）之间的互联，BGP的最主要功能在于控制路由的传播和选择最好的路由。中国网通 、中国电信、中国铁通和一些大的民营IDC运营商都具有AS号，全国各大网络运营商多数都是通过BGP协议与自身的AS号来实现多线互联的。所谓BGP机房作为一个自治系统（就相当于一个运营商的自治系统），通过BGP协议来与其他运营商互联互通。</p><p>BGP机房需要在CNNIC（中国互联网信息中心）或APNIC（亚太网络信息中心）申请自己的IP地址段和AS号，然后通过BGP协议将此段IP地址广播到其它的网络运营商的网络中。</p><p>BGP机房的好处是它可以很容易地和各个运营商（包括三大运营商以及一些小运营商）互联互通，避免像一个纯粹的联通IDC在和电信的网络连通时出现这样那样的问题。BGP机房和小运营商可以直接连通，避免需要经过三大运营商的网络来互联。</p><p>在实际生产中，有一些所谓的“双线机房”，比如说一个IDC即接入电信的光纤也接入联通的光纤，来实现一个IDC和多个运营商连通。因此，“双线机房”和BGP机房有本质的区别。</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>交换机工作原理</title>
      <link href="/2021/05/25/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2021/05/25/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="交换机简介"><a href="#交换机简介" class="headerlink" title="交换机简介"></a>交换机简介</h1><p>交换机是工作在数据链路层的设备，是二层的网络设备。</p><h1 id="交换机的MAC地址转发表"><a href="#交换机的MAC地址转发表" class="headerlink" title="交换机的MAC地址转发表"></a>交换机的MAC地址转发表</h1><p>交换机有一个很重要的东东，就是MAC地址转发表（不是ARP协议中的IP-MAC映射表）主要包含两个信息：</p><ul><li>一个是设备的MAC地址，就是目标MAC地址</li><li>另一个是该设备连接在交换机的哪个端口上</li></ul><p><img src="/images/hardware_switch_1_1.png" alt></p><p>交换机收到数据帧后，会先查询这个MAC地址转发表，若能查到匹配的，就将数据帧通过相应的端口转发出去。举例来说，如果收到的包的接收方MAC地址为00-02-B3-1C-9C-F9，则与图中表中的第3行匹配，根据端口列的信息，可知这个地址位于3号端口上，然后就可以通过交换电路将包发送到相应的端口了。</p><p>若在MAC地址表找不到匹配的目标MAC地址，可能是因为拥有该MAC地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。然后只有拥有该MAC地址的接收者才能接收包，而其他设备则会忽略这个包。</p><h1 id="一些闲杂"><a href="#一些闲杂" class="headerlink" title="一些闲杂"></a>一些闲杂</h1><p>（1）如果数据帧中的目标MAC地址是一个广播地址，那么交换机会将包发送到除源端口之外的所有端口。以下两个属于广播地址：</p><pre><code>MAC地址中的FF:FF:FF:FF:FF:FFIP地址中的255.255.255.255</code></pre><p>（2）对服务器来说，服务器网卡本身具有MAC地址，并通过核对收到的包的目标MAC地址是不是发给自己的，如果不是发给自己的则丢弃；而对交换机而言，交换机的端口不核对接收方MAC地址，而是直接接收所有的MAC包并存放到缓冲区中。需要注意的是，和服务器的网卡不同，交换机的端口不具有MAC地址。</p>]]></content>
      
      
      <categories>
          
          <category> HardWare </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中synchronized关键字及线程间协调通信机制</title>
      <link href="/2021/05/19/JAVA%E4%B8%ADsynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8D%8F%E8%B0%83%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/05/19/JAVA%E4%B8%ADsynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8D%8F%E8%B0%83%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="synchronized关键字简介"><a href="#synchronized关键字简介" class="headerlink" title="synchronized关键字简介"></a>synchronized关键字简介</h1><p>JAVA中synchronized关键字是用来增加和释放排他锁的，这把锁可以是Java中的一些对象，比如this，变量以及Class对象等等。只有获取到了这把锁才可以去修改多线程/进程中的共享变量。举例来说，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中lock是锁对象，n是多任务的共享变量。锁和共享对象也可以是同一个东东，应该是没问题的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(lock) &#123;</span><br><span class="line">   lock.n = lock.n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的，synchronized关键字不仅仅是修饰代码块，最主要有以下3种应用方式：</p><p>（1）修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁，相当于synchronized(this)，锁是实例本身。</p><p>（2）修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁，相当于synchronized(XXX.class)，锁是该类的类对象。</p><p>（3）修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。<code>synchronized(param)</code>中param会指定加锁的对象，可以是this，也可以是一个ArrayList对象等，锁可以是自定义的任何obj。</p><p>我们来概括一下如何使用synchronized：</p><pre><code>（1）找出修改共享变量的线程代码块（2）选择一个实例作为锁（3）使用`synchronized(lockObject) { … }`</code></pre><h1 id="synchronized和wait-notify-notifyAll配合使用"><a href="#synchronized和wait-notify-notifyAll配合使用" class="headerlink" title="synchronized和wait/notify/notifyAll配合使用"></a>synchronized和wait/notify/notifyAll配合使用</h1><p>在多任务/线程操作共享对象时，有两个问题需要处理。一个是共享对象的操作安全问题，即共享对象加锁的机制的；另一个是多任务/线程之间地协调问题，即线程/进程间通信问题（比如生产者生产了内容，需要通知消费者获取内容消费）。synchronized关键字是解决第一个问题的，第二个问题需要wait/notify/notifyAll来解决。</p><p>（1）wait/notify/notifyAll是基类Object类中的方法，也就是Java中所有对象都有这几个方法</p><p>（2）wait/notify/notifyAll必须用在synchronized修饰的代码块或方法中，否则JVM会被java.lang.IllegalMonitorStateException:current thread not owner错误。且需要调用synchronized的锁对象的wait/notify/notifyAll方法。比如synchronized(this){}，那就是this.wait/notify/notifyAll；比如synchronized(obj){}，那就是obj.wait/notify/notifyAll方法</p><p>（3）调用obj.wait首先会把当前线程挂起，且释放synchronized的锁对象，其他线程可以抢占锁对象了，然后等待obj.notify/notifyAll来唤醒，唤醒之后重新抢占锁对象，获取到锁对象后，接着之前的挂起的语句继续执行</p><p>（4）obj.notify唤醒一个被obj.wait挂起的线程，并释放锁对象，当前线程不会挂起</p><p>（5）obj.notifyAll唤醒所有被obj.wait挂起的线程，并释放锁对象，当前线程不会挂起</p><p>代码举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List linkedList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Runoob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除共享池中的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeElement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 列表为空就等待</span></span><br><span class="line">            <span class="keyword">while</span> (linkedList.isEmpty()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"List is empty..."</span>);</span><br><span class="line">                lock.wait();</span><br><span class="line">                System.out.println(<span class="string">"Waiting..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String element = (String) linkedList.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向共享池中添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(String element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Opening..."</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 添加一个元素，并通知元素已存在</span></span><br><span class="line">            linkedList.add(element);</span><br><span class="line">            System.out.println(<span class="string">"New Element:'"</span> + element + <span class="string">"'"</span>);</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">            System.out.println(<span class="string">"notifyAll called!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Closing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Runoob demo = <span class="keyword">new</span> Runoob(); <span class="comment">//demo是一个多线程共享资源</span></span><br><span class="line">        Runnable runA = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String item = demo.removeElement();</span><br><span class="line">                    System.out.println(<span class="string">""</span> + item);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ix) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Interrupted Exception!"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Exception thrown."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable runB = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="comment">// 执行添加元素操作，并开始循环</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                demo.addElement(<span class="string">"Hello!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread threadA1 = <span class="keyword">new</span> Thread(runA, <span class="string">"Google"</span>);</span><br><span class="line">            threadA1.start();</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            Thread threadA2 = <span class="keyword">new</span> Thread(runA, <span class="string">"Runoob"</span>);</span><br><span class="line">            threadA2.start();</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            Thread threadB = <span class="keyword">new</span> Thread(runB, <span class="string">"Taobao"</span>);</span><br><span class="line">            threadB.start();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            threadA1.interrupt();</span><br><span class="line">            threadA2.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JAVA中的线程安全"><a href="#JAVA中的线程安全" class="headerlink" title="JAVA中的线程安全"></a>JAVA中的线程安全</h1><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的Counter类就是线程安全的。Java标准库的<code>java.lang.StringBuffer</code>也是线程安全的。还有一些不变类，例如String，Integer，LocalDate，它们的所有成员变量都是final，多线程同时访问时只能读不能写，这些不变类也是线程安全的。最后，类似Math这些只提供静态方法，没有成员变量的类，也是线程安全的。除了上述几种少数情况，大部分类，例如ArrayList，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么ArrayList是可以安全地在线程间共享的。</p><p>一般来说，没有特殊说明时，一个类默认是非线程安全的。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2P技术BitTorrent协议</title>
      <link href="/2019/06/23/P2P%E6%8A%80%E6%9C%AFBitTorrent%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/06/23/P2P%E6%8A%80%E6%9C%AFBitTorrent%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="基于BT协议的P2P技术组成"><a href="#基于BT协议的P2P技术组成" class="headerlink" title="基于BT协议的P2P技术组成"></a>基于BT协议的P2P技术组成</h1><p>基于BT协议的文件分发系统由以下几个实体构成：</p><p>（1）一个Web服务器</p><p>用于保存种子文件，供P2P网络中的下载者下载。</p><p>（2）一个种子文件（.torrent文件）</p><p>.torrent文件使用B encode表示，整个是一个字典数据结构，它有多个key值，包括一些是可选的，这里介绍最关键的几个键值对：</p><pre><code>info：存储资源文件的元信息    piece length    pieces    name/pathannounce：描述tracker服务器的URL</code></pre><p>info键对应的值又是一个字典结构，BT协议将一个文件分成若干片，便于客户端从各个主机下载各个片。其中的piece length键值对表示一个片的长度，通畅情况下是2的n次方，根据文件大小有所权衡，通长越大的文件piece length越大以减少piece的数量，降低数量一方面降低了.torrent保存piece信息的大小，一方面也减少了下载需要对片做的确认操作，加快下载速度。目前通常是256kB，512kB或者1MB。</p><p>pieces则是每个piece的正确性验证信息，每一片均对应一个唯一的SHA1散列值，该键对应的值是所有的20字节SHA1散列值连接而成的字符串。</p><p>name/path比较笼统的说，就是具体文件的信息。因为BitTorrent协议允许将数个文件和文件夹作为一个BitTorrent下载进行发布，因此下载方可以根据需要勾选某一些下载文件。注意，这里将数个文件也砍成一个数据流，因此一个piece如果在文件边界上，可能包含不同文件的信息。</p><p>announce保存的是tracker服务器的URL，也就是客户端拿到.torrent文件首先要访问的服务器，在一些扩展协议中，announce可以保存多个tracker服务器作为备选。</p><p>（3）一个Tracker服务器</p><p>Tracker服务器，又称索引服务器，其实也算是P2P的调度服务器。Tracker服务器核心功能记录了哪些下载者有资源可以下载，并提供给其他下载者。</p><p>（4）一个原始文件提供者</p><p>（5）一个或多个下载者</p><h1 id="BT协议分享过程"><a href="#BT协议分享过程" class="headerlink" title="BT协议分享过程"></a>BT协议分享过程</h1><p><img src="/images/bittorrent_1_1.png" alt></p><h2 id="原始文件提供者分享过程"><a href="#原始文件提供者分享过程" class="headerlink" title="原始文件提供者分享过程"></a>原始文件提供者分享过程</h2><p>假设原始资源提供者要分享“海贼王.flv”这个视频文件，那么过程为：</p><p>（1）使用BitTorrent客户端工具，生成.torrent文件</p><p>.torrent文件是有一定格式标准的，主要的信息包括文件资源的基本信息、文件分片信息、分片的HASH值、Tracker服务器的地址等等。</p><p>（2）连接Tracker服务器</p><p>生成好.torrent文件之后，发布者需要先作为下载者一样根据.torrent文件进行下载，这样就会连接到Tracker服务器。由于发布者已经有了完整的资源文件，Tracker服务器会得知这是一个完全下载完成的用户，会把发布者的信息保存在Tracker服务器中。</p><p>（3）原始资源提供者将.torrent种子文件上传到WEB服务器</p><p>发布者还要做的最后一件事就是将.torrent文件放在服务器上，可以通过HTTP或者FTP协议供用户下载这个.torrent文件。相比于直接将整个资源文件提供给用户下载，只传输一个.torrent文件大大降低了服务器的负荷。</p><h2 id="文件下载者下载资源过程"><a href="#文件下载者下载资源过程" class="headerlink" title="文件下载者下载资源过程"></a>文件下载者下载资源过程</h2><p>（1）搜索和下载.torrent种子文件</p><p>可以通过HTTP或者FTP协议直接从服务器上得到.torrent文件。</p><p>（2）解析.torrent种子文件</p><p>使用BitTorrent软件客户端打开.torrent文件，软件会根据.torrent的name/path元信息告诉我这个.torrent文件可以下载到一个.mkv文件，一个字幕文件，在这个阶段我可以进行一些勾选，选择下载某些而不是全部的资源。同时，根据.torrent种子文件，获取到Tracker服务器的地址信息。</p><p>（3）连接Tracker服务器获取Peers信息</p><p>客户端的第一步任务根据.torrent上的URL使用HTTP GET请求，这个请求包含了很多参数，这里只介绍从客户端发送到Tracker的请求最关键的几个参数：</p><pre><code>info_hashpeer_idipport</code></pre><p>info_hash是元信息.torrent文件中info键所对应的值的SHA1散列，可以被Tracker服务器用来索引唯一的对应资源。</p><p>peer_id是20Byte的串，没有任何要求，被Tracker服务器用于记录客户端的名字。</p><p>ip可以从HTTP GET请求中直接获取，放在参数中可以解决使用代理进行HTTP GET的情况，Tracker服务器可以记录客户端的IP地址。</p><p>port客户端监听的端口号，用于接收response。一般情况下为BitTorrent协议保留的端口号是6881-6889，Tracker服务器会记录下端口号用于通知其他客户端。</p><p>在Tracker服务器收到客户端的HTTP GET请求后，会返回B encode形式的text/plain文本，同样是一个字典数据结构，其中最关键的一个键值对是peers，它的值是个字典列表结构，列表中的每一项都是如下的字典结构。</p><pre><code>peers    peer_id    ip    port</code></pre><p>这些信息在每个客户端连接Tracker服务器的时候都发送过，并且被Tracker服务器保存了下来。</p><p>（4）开始下载分片和提供分享</p><p>BT客户端根据Tracker服务器提供的Peers信息，直接去与这些Peers客户端连接，下载相应的分片，当某些分片下载完成后，也会被Tracker记录下来，后面其他的BT客户端也会从连接本客户端，从而本客户端也称为了资源分享者。</p><p>备注：一般说来，下载者和WEB服务器使用HTTP/FTP协议进行种子文件的获取与上传。下载者和Tracker服务器之间是通过HTTP协议。下载者和下载者之间是通过BT协议，也就是TCP/UDP协议来进行数据的传输。</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>（1）P2P打洞问题</p><p>我们知道，在P2P网络中，没有Peer点所处的网络都不太一样，有的是在NAT服务后面，有的是在公网环境中。要想做到Peer到Peer的数据分享和传输，就必须让Peer和Peer能够建立网络连接。这个在P2P技术领域里面就叫做“打洞穿透”。</p><p><img src="/images/bittorrent_1_2.png" alt></p><p>（2）…….</p><p>学习资料参考于：<br><a href="https://blog.azard.me/2015/10/24/introduction-to-bittorrent/" target="_blank" rel="noopener">https://blog.azard.me/2015/10/24/introduction-to-bittorrent/</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac上抓取移动设备iPhone数据包</title>
      <link href="/2019/06/22/Mac%E4%B8%8A%E6%8A%93%E5%8F%96%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87iPhone%E6%95%B0%E6%8D%AE%E5%8C%85/"/>
      <url>/2019/06/22/Mac%E4%B8%8A%E6%8A%93%E5%8F%96%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87iPhone%E6%95%B0%E6%8D%AE%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac抓取移动设备数据包"><a href="#Mac抓取移动设备数据包" class="headerlink" title="Mac抓取移动设备数据包"></a>Mac抓取移动设备数据包</h1><p>在Mac上抓取iPhone手机上的数据包，前提条件是，iPhone上的数据包要经过Mac电脑。一般来说，使用Mac抓取iPhone数据包有如下三种方式：</p><ul><li>代理软件</li><li>Mac共享网络</li><li>远程虚拟接口RVI</li></ul><h1 id="代理软件"><a href="#代理软件" class="headerlink" title="代理软件"></a>代理软件</h1><p>在Mac上搭建HTTP代理软件，然后在手机上网络设置代理请求到Mac电脑，通常来说，可以使用代理软件有Charles、Flidder for Mono以及Andiparos等，它们在Mac上建立HTTP代理服务器。</p><h1 id="Mac上WiFi热点共享"><a href="#Mac上WiFi热点共享" class="headerlink" title="Mac上WiFi热点共享"></a>Mac上WiFi热点共享</h1><p>使用Mac的网络共享功能将Mac的网络通过WiFi共享给iPhone连接。简单来说，就是在Mac上建立WiFi热点，然后手机联系该热点。对于网络共享的方式还要求Mac本身的网络不能使用WiFi，而且在iPhone上只能使用WiFi连接，无法抓取到xG（2G/3G/4G）网络包。</p><p>备注：Mac也可以通过蓝牙的方式，共享网络给iPhone手机，不过好像网络很慢的。</p><h1 id="手机USB连接Mac"><a href="#手机USB连接Mac" class="headerlink" title="手机USB连接Mac"></a>手机USB连接Mac</h1><p>苹果在iOS 5中新引入了远程虚拟接口（Remote Virtual Interface，RVI）的特性，可以在Mac中建立一个虚拟网络接口来作为iOS设备的网络栈，这样所有经过iOS设备的流量都会经过此虚拟接口。此虚拟接口只是监听iOS设备本身的协议栈，但并没有将网络流量中转到Mac本身的网络连接上（前两种方式都需要iPhone通过Mac的网络上网，该方式不需要哦），所有网络连接都是iOS设备本身的，与Mac电脑本身联不联网或者联网类型无关。iOS设备本身可以为任意网络类型（WiFi/xG），这样在Mac电脑上使用任意抓包工具（tcpdump/WireShark/CPA）抓取RVI接口上的数据包就实现了对iPhone的抓包。具体步骤如下：</p><p>（1）iPhone手机通过USB接口连接到电脑上</p><p>（2）在Mac上为iPhone手机设置一个远程虚拟接口</p><p>使用<code>rvictl -s &lt;UDID&gt;</code>命令为iPhone手机新建远程虚拟接口，其中UDID代表连接到Mac电脑的设备ID，可以通过<code>iTunes-&gt;Summary</code>或者<code>Xcode-&gt;Organizer-&gt;Devices</code>获取iPhone的UDID。创建成功后，在终端通过ifconfig命令可以看到多了一个rvi0接口。当有多个iOS设备连接Mac时，依次是rvi1、rvi2等等。</p><p>使用<code>rvictl -l</code>命令可以列出所有挂接的远程虚拟接口。</p><p>使用<code>rvictl -x</code>命令可以删除指定的远程虚拟接口。</p><p>备注：Mac电脑中若没有rvictl命令工具，安装Xcode就好啦。</p><p><img src="/images/itunes_1_1.png" alt></p><p><img src="/images/itunes_1_2.png" alt></p><p>（3）启动WireShark监听步骤（2）中为iPhone设备新建的远程虚拟接口</p><p>（4）手机打开APP上网</p><p>学习资料参考于：<br><a href="https://blog.csdn.net/phunxm/article/details/38590561" target="_blank" rel="noopener">https://blog.csdn.net/phunxm/article/details/38590561</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络抓包工具之tcpdump</title>
      <link href="/2019/06/22/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E4%B9%8Btcpdump/"/>
      <url>/2019/06/22/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E4%B9%8Btcpdump/</url>
      
        <content type="html"><![CDATA[<h1 id="tcpdump简介"><a href="#tcpdump简介" class="headerlink" title="tcpdump简介"></a>tcpdump简介</h1><p>tcpdump可以根据使用者的定义对网络上的数据包进行截获并分析。tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p><h1 id="tcpdump的使用方法"><a href="#tcpdump的使用方法" class="headerlink" title="tcpdump的使用方法"></a>tcpdump的使用方法</h1><p>（1）使用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump [options] [-i 网络接口] [-w 数据包dump到的目标文件] [-c 监听次数] [-r dump出来的文件] [数据包筛选规则]</span><br></pre></td></tr></table></figure><p>（2）重要的选项</p><pre><code>-i           #指定要监听的网络接口，如eth0，eth1，lo等。若指定为any，表示监听所有的网卡接口-nn          #直接以ip和port显示，而非主机名或服务名称-w filename  #将监听所得的数据包存储到文件中-r filename  #从指定tcpdump出来的文件中读取dump文件-c num       #指定监听的数据包数，如果不指定-c，那么tcpdump会持续不断的监听</code></pre><h1 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#监听eth0接口</span></span><br><span class="line">tcpdump -i eth0 -nn</span><br><span class="line"><span class="comment">#监听eth0接口且满足“port为21的数据包”的筛选规则</span></span><br><span class="line">tcpdump -i eth0 -nn <span class="string">'port 21'</span></span><br><span class="line"><span class="comment">#监听eth0接口且满足“port为22且源主机为192.168.1.101的数据包”的筛选规则</span></span><br><span class="line">tcpdump -i eth0 -nn <span class="string">'port 22 and src host 192.168.1.101'</span></span><br><span class="line"><span class="comment">#只抓取所有网卡的icmp协议数据包，并直接打印到终端上，也可以只抓取tcp/udp/arp等</span></span><br><span class="line">tcpdump -nni any <span class="string">'icmp'</span></span><br><span class="line"><span class="comment">#抓取网卡eth0的数据包，并输出到wireshark.cap文件中</span></span><br><span class="line">tcpdump -nni eth0 -w wireshark.cap</span><br></pre></td></tr></table></figure><h1 id="闲杂"><a href="#闲杂" class="headerlink" title="闲杂"></a>闲杂</h1><p>WireShark是图形化的数据包抓取工具，和tcpdump实现的功能是一致的。使用tcpdump的-w选项将tcpdump的输出到一个cap命名的文件中，然后用WireShark打开该文件，则可以用WireShark分析tcpdump抓取的数据包。</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络抓包工具之WireShark</title>
      <link href="/2019/06/22/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E4%B9%8BWireShark/"/>
      <url>/2019/06/22/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E4%B9%8BWireShark/</url>
      
        <content type="html"><![CDATA[<h1 id="WireShark简介"><a href="#WireShark简介" class="headerlink" title="WireShark简介"></a>WireShark简介</h1><p>WireShark，前称Ethereal，是当今世界最流行的网络协议嗅探、抓包和分析工具，它使我们得以窥探网络上流动的数据及其协议细节。网络管理员使用WireShark来检测网络问题；网络安全工程师使用WireShark来检查网络安全相关问题；开发者可以使用WireShark来开发调试新的通信协议；普通使用者可以使用WireShark来学习网络协议栈相关的知识。</p><p>Wireshark是捕获机器上的某一块网卡的所有网络包，当你的机器上有多块网卡的时候，你需要指定选择一个网卡。</p><p>如下是WireShark的界面分布：</p><p><img src="/images/wireshark_1_1.png" alt></p><h1 id="WireShark中的过滤器"><a href="#WireShark中的过滤器" class="headerlink" title="WireShark中的过滤器"></a>WireShark中的过滤器</h1><p>WireShark中有两个过滤器，一个是“捕捉过滤器”，用于决定将什么样的Packets需要被WireShark捕获，可以点击“捕获”|“捕获过滤器”中设定，只有满足了捕获过滤器中的条件的Packets才会被WireShark所捕获；另一种是“显示过滤器”（即主界面中的过滤框），是对WireShark已经捕获的Packets做一下过滤，即显示部分的抓包结果。</p><h1 id="显式过滤器支持的一些条件表达式"><a href="#显式过滤器支持的一些条件表达式" class="headerlink" title="显式过滤器支持的一些条件表达式"></a>显式过滤器支持的一些条件表达式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcp/udp/dns/http/tls          #满足指定协议的包     </span><br><span class="line">ip.addr == 192.168.0.108      #源地址或目标地址中包含了192.168.0.108的包</span><br><span class="line">ip.src == 192.168.0.108       #源地址是192.168.0.108的包</span><br><span class="line">ip.dst == 192.168.0.108       #目标地地是192.168.0.108的包</span><br><span class="line">tcp.port == 80                #tcp的端口是80的包</span><br><span class="line">http.request.method == &quot;GET&quot;  #只显示HTTP GET方法的包</span><br><span class="line">tcp.stream eq 6               #追踪流，Follow TCP Stream</span><br><span class="line">tls.handshake.extensions_server_name contains apple.com  #匹配到包含指定字符串的包</span><br><span class="line">http.request.uri matches &quot;.gif$&quot;   #匹配过滤HTTP的请求URI中含有&quot;.gif&quot;字符串，并且以.gif结尾（4个字节）的http请求数据包（$是正则表达式中的结尾表示符）</span><br><span class="line">tls.handshake.type eq 1            #过滤出tls中ClientHello报文</span><br><span class="line">tls.handshake.type eq 1 &amp;&amp; tls.handshake.extensions_server_name eq v1-dy.ixigua.com    #过滤出指定域名的ClientHello报文，然后使用WireShark追踪流功能筛选出此次握手的报文交互过程</span><br><span class="line">tls.handshake.type eq 1 &amp;&amp; tls.handshake.extensions_server_name contains ixigua.com    #过滤出指定域名的ClientHello报文，然后使用WireShark追踪流功能筛选出此次握手的报文交互过程</span><br></pre></td></tr></table></figure><p>备注：如上的条件可以通过逻辑运算and/or进行组合使用。另外，and和&amp;&amp;等价，or和||等价，not和!等价，==和eq等价，matches表示模糊正则匹配某字符串，contains表示包含某字符串。</p><h1 id="WireShark中追踪流功能"><a href="#WireShark中追踪流功能" class="headerlink" title="WireShark中追踪流功能"></a>WireShark中追踪流功能</h1><p>在WireShark中，会将TCP协议层中每个TCP包生成一个WireShark私有的编号（仅存在于WireShark中的编号），即stream index编号。对于“srcip1:srcport1和dstip2:dstport2”，或“srcip2:srcport2和dstip1:dstport1”的TCP数据包，它们的stream index一样的。我们可以利用这一点可以将一个网络会话直接筛选出来，有两种方式来达到这个目的。</p><p>（1）Follow TCP Stream菜单开启</p><p>当我们在一个数据包上右键选择“追踪流”|“TCP流”时，即追踪TCP流，就把“请求源ip1:port1和请求目标ip2:port2”，或“请求源ip2:port2和请求目标ip1:port1”的所有数据包筛选出来，也即相当于把固定的双方的会话过程筛选出来了。</p><p>（2）利用显式过滤器</p><p>首先查看某个TCP报文的stream index，然后在显示过滤器中输入tcp.stream eq 6或tcp.stream == 6</p><p><img src="/images/wireshark_1_2.png" alt></p><h1 id="使用WireShark抓取浏览器访问一张jpeg图片的过程"><a href="#使用WireShark抓取浏览器访问一张jpeg图片的过程" class="headerlink" title="使用WireShark抓取浏览器访问一张jpeg图片的过程"></a>使用WireShark抓取浏览器访问一张jpeg图片的过程</h1><h2 id="访问一张HTTP图片"><a href="#访问一张HTTP图片" class="headerlink" title="访问一张HTTP图片"></a>访问一张HTTP图片</h2><p>数据包过程如下：</p><p>（1）TCP三次握手建立连接</p><p>（2）浏览器发送/GET的HTTP请求报文</p><p>（3）服务器通过N个TCP包直接将图片的内容发送给浏览器（因为应用层是一个完整的HTTP响应报文，HTTP响应报文在TCP层会被分片，所以只有一个TCP包的数据部分才有HTTP层的resp header）</p><p>（4）服务器发送一个HTTP的响应报文，报文中有标识图片文件的起始位置，编码格式等等（按说TCP分片HTTP报文时，包含HTTP resp header的应该在第一个TCP报文中的，为啥是在最后的一个TCP包中呢，待确认？）</p><p>（5）四次握手断开连接</p><p><img src="/images/wireshark_1_3.png" alt></p><h2 id="访问一张HTTPS图片"><a href="#访问一张HTTPS图片" class="headerlink" title="访问一张HTTPS图片"></a>访问一张HTTPS图片</h2><p>（1）TCP三次握手建立连接</p><p>（2）HTTPS协商阶段，包括ClientHello，ServerHello以及Change Cipher Spec等。在该阶段中，看到的都是TLS协议层的报文，不过一些随机数是可以在报文中看到的。</p><p>（3）HTTPS应用数据传输阶段，各种TLS的Application Data的报文。在该阶段中，HTTP报文已经被加密的了，看不到任何HTTP header和body的相关内容啦。</p><p>（4）四次握手断开连接</p><p><img src="/images/wireshark_1_5.png" alt></p><h1 id="WireShark闲杂"><a href="#WireShark闲杂" class="headerlink" title="WireShark闲杂"></a>WireShark闲杂</h1><p>（1）修改抓包列表中时间戳显示格式</p><p>点击“视图”|“时间显示格式”|“日期和时间”，可以将抓包中的时间显示为常规的可读性好的时间格式。</p><p>（2）着色规则的修改</p><p>在WireShark的抓包列表中可以看到各种颜色的报文，可以通过点击“视图”|“着色规则”来进行查看和修改。</p><p><img src="/images/wireshark_1_4.png" alt></p><p>（3）获取字段名称用于显式过滤器的条件</p><p>在“封包详细信息”中展开各字段，在要关注的字段上右击选择Copy|Field Name即可将字段的名称复制到剪贴板中，然后在显式过滤器框中输入条件即可。</p><h1 id="tcpdump与WireShark关系"><a href="#tcpdump与WireShark关系" class="headerlink" title="tcpdump与WireShark关系"></a>tcpdump与WireShark关系</h1><p>tcpdump是命令行界面CUI，WireShark是图形用户界面GUI，WireShark相对tcpdump而言，界面更友好、功能更强大。</p><p>Unix平台（包括Mac OS）下的WireShark是基于libpcap实现的，Window平台下的WireShark则是基于winpcap实现的。libpcap，Packet Capture Libray，即数据包捕获函数库，源于tcpdump项目。最开始是由tcpdump中剥离出的抓包、过滤、capture file的读写代码提炼而成，现在也是由tcpdump项目的开发组织tcpdump.org维护。</p><p>捕获抓包机制是在数据链路层增加一个旁路处理（并不干扰系统自身的网络协议栈的处理），对发送和接收的数据包通过Unix内核做过滤和缓冲处理，最后直接传递给上层应用程序。一个包的捕捉分为三个主要部分，包括面向底层包捕获、面向中间层的数据包过滤和面向应用层的用户接口。</p><p>libpcap作为捕捉网络数据包的库，它是一个独立于系统的用户级API接口，为底层网络检测提供了一个可移植的框架。</p><p>鉴于WireShark和tcpdump都共同使用libpcap作为其底层抓包的库，可以用WireShark打开tcpdump抓包保存的pcap文件进行分析。</p><p>WireShark使用详细参考：<br><a href="https://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html" target="_blank" rel="noopener">https://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多平台抓包工具Charles</title>
      <link href="/2019/06/22/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles/"/>
      <url>/2019/06/22/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles/</url>
      
        <content type="html"><![CDATA[<h1 id="多平台抓包工具Charles简介"><a href="#多平台抓包工具Charles简介" class="headerlink" title="多平台抓包工具Charles简介"></a>多平台抓包工具Charles简介</h1><p>Charles是在Windows/Mac/Linux多平台下常用的网络封包截取工具，尤其在做移动开发项目时，为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析，而Charles就是一个很好的抓包分析工具。</p><p>Charles是收费软件，可以免费试用30天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过30分钟，并且启动时将会有10秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为Charles强制关闭而遇到影响。</p><p>Charles通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。简单来说，Charles可以理解为一个HTTP/HTTPS的代理服务器。Charles主要的功能包括：</p><ul><li>截取HTTP和HTTPS网络封包</li><li>支持重发网络请求，方便后端调试</li><li>支持修改网络请求参数</li><li>支持网络请求的截获并动态修改</li><li>支持模拟慢速网络</li></ul><h1 id="Charles使用流程"><a href="#Charles使用流程" class="headerlink" title="Charles使用流程"></a>Charles使用流程</h1><p>（1）在Mac/Windows上安装Charles工具，并启动。然后在<code>help-&gt;Local Address</code>查看Charles监听的IP和Port。</p><p>（2）在无线网络或WiFi中配置代理。</p><p>（3）在手机上发起各种网络访问，然后就可以在Charles看到被截获的各种数据包。</p><h1 id="Charles的几种代理模式"><a href="#Charles的几种代理模式" class="headerlink" title="Charles的几种代理模式"></a>Charles的几种代理模式</h1><h2 id="HTTP正向代理"><a href="#HTTP正向代理" class="headerlink" title="HTTP正向代理"></a>HTTP正向代理</h2><p>（1）普通代理</p><p>若HTTP请求到达Charles代理时，有Charles向服务端发起HTTP请求，并将HTTP响应数据返回给客户端。这种情况下，因为HTTP都是明文的，Charles代理就能捕获所有的HTTP请求报文。</p><p><img src="/images/charles_1_1.png" alt></p><p>普通代理下，浏览器/代理/服务端的网络交互过程如下（假设代理的IP:Port为192.168.2.100:8888）：</p><pre><code>浏览器与代理(192.168.2.100:8888)建立TCP连接（设置了代理，浏览器就不会再发起域名的DNS解析请求了）浏览器向代理(192.168.2.100:8888)发送HTTP GET/POST请求代理解析出HTTP请求中的域名，DNS解析拿到域名IP，然后建立代理和该IP对应的服务器80端口的TCP连接代理向服务器发送HTTP GET/POST请求代理收到服务器返回的HTTP响应报文代理将服务器的响应报文再发送给浏览器</code></pre><p>（2）隧道代理</p><p>浏览器通过HTTP CONNECT方法请求“隧道代理”创建一条到达任意目标服务器和端口的TCP连接，并对浏览器和服务器之间的后继数据进行转发。</p><p><img src="/images/charles_1_2.png" alt></p><p>隧道代理下，客户端/代理/服务端的网络交互过程如下（假设代理的IP:Port为192.168.2.100:8888）：</p><pre><code>浏览器与代理(192.168.2.100:8888)建立TCP连接（设置了代理，浏览器就不会再发起域名的DNS解析请求了）浏览器向代理(192.168.2.100:8888)发送HTTP CONNECT方法请求，主要请求的参数就是域名和端口，如www.baidu.com:443代理解析出HTTP CONNECT请求中的域名，DNS解析拿到域名IP，然后建立代理和该IP对应的服务器的443端口的TCP连接代理和服务器TCP连接建立完成后，代理向浏览器发送一个HTTP 200的Connection established的HTTP响应报文浏览器向代理(192.168.2.100:8888)发送TLS ClientHello报文代理将浏览器发过来的报文，修改一下SRCIP:SRCPORT为代理的IP和PORT之后，直接转发出去，也就是数据包会发送给服务端服务端收到TLS ClientHello报文，响应TLS ServerHello报文给代理。代理收到服务端的ServerHello报文，将DESTIP:DESTPORT修改为浏览器的IP和PORT后，直接转发给浏览器后面的流程类似，都是代理直接包报文转发出去就可以了，直至TLS握手完成，然后开始应用数据加密传输都是这个过程。。。</code></pre><p>以上过程都可以通过WireShark抓包验证，在本地启动Charles，代理地址是127.0.0.1:8888，如下是使用WireShark在本地loopback网卡上的抓包结果：</p><p><img src="/images/charles_1_6.png" alt></p><p>所以这种代理，理论上适用于任意基于TCP的应用层协议，HTTPS网站使用的TLS协议当然可以使用这种方式啦。这也是这种代理为什么被称为隧道的原因。对于HTTPS来说，浏览器透过代理直接跟服务端进行TLS握手协商密钥，所以依然是安全的。</p><p>使用隧道代理模式中，一个HTTPS请求，Charles只能抓取到一条HTTP CONNECT报文，其他报文都抓取不到。这是因为，第一在TLS握手阶段没有HTTP报文，第二在应用数据加密传输阶段，HTTP报文被加密然后被TLS协议封装，所以Charles也解析不出来HTTP报文了，对于Charles只能解析应用层是HTTP协议的报文的缘故，所以只有一条HTTP CONNECT请求。要想抓取HTTPS完整报文，且看下面的“HTTPS/SSL代理“部分。</p><h2 id="SOCKS代理"><a href="#SOCKS代理" class="headerlink" title="SOCKS代理"></a>SOCKS代理</h2><p>待补充。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>待补充。</p><h2 id="HTTPS-SSL代理（HTTPS中间人攻击）"><a href="#HTTPS-SSL代理（HTTPS中间人攻击）" class="headerlink" title="HTTPS/SSL代理（HTTPS中间人攻击）"></a>HTTPS/SSL代理（HTTPS中间人攻击）</h2><h3 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h3><p>由于普通代理和隧道代理中，我们无法获取HTTPS报文的详细信息，因此我们可以开启Charles的SSL代理模式，这种Charles就相当于一个攻击中间人，来获取HTTPS的报文信息。首先浏览器或手机需要安装并信任Charles签发的CA根证书。浏览器或手机与Charles之间建立SSL连接，使用的是Charles自己签发的假证书。然后Charles和服务端也建立SSL连接，使用的是真实的后端服务发过来的证书。</p><p>在这种情况下，Charles就可以截获HTTPS详细的报文信息。</p><p>HTTPS代理开启下，浏览器/代理/服务端的网络交互过程如下：</p><pre><code>浏览器与代理(192.168.2.100:8888)建立TCP连接（设置了代理，浏览器就不会再发起域名的DNS解析请求了）浏览器向代理(192.168.2.100:8888)发送HTTP CONNECT方法请求，主要请求的参数就是域名和端口，如www.baidu.com:443代理解析出HTTP CONNECT请求中的域名，DNS解析拿到域名IP，然后建立代理和该IP对应的服务器的443端口的TCP连接代理和服务器TCP连接建立完成后，代理向浏览器发送一个HTTP 200的Connection established的HTTP响应报文浏览器向代理(192.168.2.100:8888)发送TLS ClientHello报文代理开始与浏览器通过Charles私有证书开始建立TLS连接，并解析浏览器发过来的ClientHello报文，然后重新封装Charles自己的ClientHello报文，发给服务端，开始建立TLS连接。最终浏览器和代理TLS握手成功，代理和服务端TLS握手成功应用数据加密传输阶段，代理收到浏览器的TLS报文，直接解密出明文，然后重新封装TLS报文，发送给服务端。服务端返回的TLS报文，也是由代理先解密出明文，然后重新封装TLS报文，返回给浏览器</code></pre><p>由此可见，对于“HTTPS/SSL代理”和“隧道代理”来说，浏览器的处理方式是一样的，也就浏览器发现本地设置了HTTPS代理，先向代理发起HTTP CONNECT请求，然后开始向代理发送TLS握手报文，以及应用传输阶段的TLS报文。然后两种模式下，Charles代理侧却是不一样的处理。</p><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>HTTPS/SSL代理配置详细过程如下（客户端为iOS，Charles部署在MAC电脑上）：</p><p>（1）将Charles自签发的根证书安装到移动设备iOS上</p><p>在Charles上点击<code>Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate on Mobile Device or Remote Browser…</code>这时会弹出一个对话框，如下：</p><p><img src="/images/charles_1_3.png" alt></p><p>我们在IOS的Safari浏览器中输入<code>chls.pro/ssl</code>或<code>http://charlesproxy.com/getssl将证书安装到IOS上</code>。</p><p>（2）在IOS上信任新证书</p><p>首先在<code>设置-&gt;通用-&gt;描述文件与设备管理</code>中，安装刚刚下载的证书描述文件。然后在<code>设置-&gt;通用-&gt;关于本机-&gt;证书信任设置</code>中信任Charles的根证书。</p><p><img src="/images/charles_1_4.png" alt></p><p>（3）在Charles的<code>Proxy-&gt;SSL Proxying Settings</code>中勾选Enable SSL Proxying，然后添加要抓取的域名和端口：</p><p><img src="/images/charles_1_5.png" alt></p><p>（4）在IOS的无线局域网中设置代理即可大功告成。</p><h1 id="APP禁止Charles抓包原因和解决方案"><a href="#APP禁止Charles抓包原因和解决方案" class="headerlink" title="APP禁止Charles抓包原因和解决方案"></a>APP禁止Charles抓包原因和解决方案</h1><p>部分大厂的APP的HTTP客户端禁止使用HTTP/HTTPS代理，导致无法使用Charles抓包。代理抓包的关键就是需要HTTP客户端按照要求去连接代理服务器，通常HTTP客户端都是按要求去实现的，在进行HTTP请求前会先检查系统代理，如果有设置代理，客户端会直接去连接代理服务器。然后有些APP使用一些HTTP客户端，使用了NO Proxy配置，导致有代理时，不会去连接代理，从而也就是无法使用Charles抓包。一些网络库，如OKhttp很容易设置不走系统代理的。</p><p>还有的APP，一部分请求的HTTP客户端禁用了代理，而一部分请求的HTTP客户端又会使用代理，这种情况下，就会抓取到该APP部分请求的数据包。</p><p>针对上面的这种原因，网上说可以在本地启VPN服务， 然后再代理到Charles，没具体研究过，后续有需要再研究。</p><p>另外需要注意的是，有些APP端上固定绑定了证书，是不信任Charles代理发过来的证书的，所以在APP和Charles之间的TLS握手阶段会失败。针对这种问题，比较难搞，网上说可以用“证书逆向”啥的，没具体研究过，有需要再研究。</p><h1 id="闲杂"><a href="#闲杂" class="headerlink" title="闲杂"></a>闲杂</h1><p>（1）HTTP CONNECT Method是HTTP的一个特殊请求方法，就是直接给使用了正向代理的HTTP客户端（浏览器）来使用的。</p><p>（2）点击Charles的<code>Proxy-&gt;macOSProxy</code>，可以快速将MacOS系统的本地代理设置为该Charles。然后系统上所有APP的特定协议的请求（如HTTP/HTTPS）会被Charles代理。如下为点击了菜单<code>Proxy-&gt;macOSProxy</code>之后，MacOS系统的代理配置截图：</p><p><img src="/images/charles_1_7.png" alt></p><p>默认Charles仅代理HTTP/HTTPS协议，其他应用层协议的报文不会被Charles代理。</p><p>学习资料参考于：<br><a href="https://blog.devtang.com/2015/11/14/charles-introduction/" target="_blank" rel="noopener">https://blog.devtang.com/2015/11/14/charles-introduction/</a><br><a href="https://bigzuo.github.io/2018/12/15/nginx-https-forward-proxy/" target="_blank" rel="noopener">https://bigzuo.github.io/2018/12/15/nginx-https-forward-proxy/</a><br><a href="https://www.jianshu.com/p/a83b19a36a8b" target="_blank" rel="noopener">https://www.jianshu.com/p/a83b19a36a8b</a><br><a href="https://imququ.com/post/web-proxy.html" target="_blank" rel="noopener">https://imququ.com/post/web-proxy.html</a><br><a href="https://www.jianshu.com/p/468e2905a3e1" target="_blank" rel="noopener">https://www.jianshu.com/p/468e2905a3e1</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP常见请求方法/状态码说明</title>
      <link href="/2019/06/09/HTTP%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95-%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/06/09/HTTP%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95-%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h1><p>（1）GET</p><p>向特定的资源发出请求。</p><p>（2）POST</p><p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</p><p>（3）HEAD</p><p>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。使用cURL命令中的<code>curl -I</code>参数就是发起的HEAD HTTP请求。</p><p>（4）PUT</p><p>向指定资源位置上传其最新内容。</p><p>（5）DELETE</p><p>请求服务器删除Request-URL所标识的资源。</p><p>（6）OPTIONS</p><p>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送<code>*</code>的请求来测试服务器的功能性。</p><p>（7）TRACE</p><p>回显服务器收到的请求，主要用于测试或诊断。</p><p>（8）CONNECT</p><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><h1 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h1><p>（1）502</p><p>502，名称为Bad Gateway，表示作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p><p>（2）503</p><p>HTTP 503，Service Unavailable，服务器不可用。</p><p>（3）504</p><p>504，名称为Gateway Time-out，表示网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。说白了，504即Nginx代理超过了自己设置的超时时间，不等待上游的返回结果，直接给客户端返回504错误。注意：某些代理服务器在DNS查询超时时会返回400或者500错误。</p><p>通俗的来说，nginx作为一个代理服务器，将请求转发到其他服务器或者php-cgi来处理，当nginx收到了无法理解的响应时，就返回502。当nginx超过自己配置的超时时间还没有收到请求时，就返回504错误。</p><p>（4）206</p><p>HTTP范围请求Range Requsets以及部分响应(partial responses)，HTTP 206表示Range Request HTTP请求中，正常返回部分内容Partial Content，和200是差不多的。服务器已经成功处理了部分GET请求。该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。</p><p>（5）416</p><p>HTTP 416 Range Not Satisfiable错误状态码意味着服务器无法处理所请求的数据区间。最常见的情况是所请求的数据区间不在文件范围之内，也就是说，Range首部的值，虽然从语法上来说是没问题的，但是从语义上来说却没有意义。</p><p>416响应报文包含一个Content-Range首部，提示无法满足的数据区间（用星号<code>*</code>表示），后面紧跟着一个“/”，再后面是当前资源的长度。例如：<code>Content-Range: */12777</code>，遇到这一错误状态码时，浏览器一般有两种策略：要么终止操作（例如，一项中断的下载操作被认为是不可恢复的），要么再次请求整个文件。</p><p>（6）429</p><p>在HTTP协议中，429状态码表示Too Many Requests，表示在一定的时间内用户发送了太多的请求，超出了“频次限制”，即被服务端流控了。</p><p>（7）499</p><p>499状态码表示“client has closed connection”，这很有可能是因为服务器端处理的时间过长，客户端“不耐烦”了。要解决此问题，就需要在程序上面做些优化了。</p><p>（8）400</p><p>Bad Request。</p><p>学习资料参考于：<br><a href="https://juejin.im/entry/589148f92f301e00690e863d" target="_blank" rel="noopener">https://juejin.im/entry/589148f92f301e00690e863d</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP范围请求Range Request使用</title>
      <link href="/2019/06/09/HTTP%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82Range-Request%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/06/09/HTTP%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82Range-Request%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP范围请求"><a href="#HTTP范围请求" class="headerlink" title="HTTP范围请求"></a>HTTP范围请求</h1><p>HTTP协议范围请求允许服务器只发送HTTP消息的一部分到客户端。范围请求在传送大的媒体文件，或者与文件下载的断点续传功能搭配使用时非常有用。类似于FlashGet或者迅雷这类的HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p><h1 id="检测服务器端是否支持范围请求"><a href="#检测服务器端是否支持范围请求" class="headerlink" title="检测服务器端是否支持范围请求"></a>检测服务器端是否支持范围请求</h1><p>假如在响应中存在Accept-Ranges首部（并且它的值不为 “none”），那么表示该服务器支持范围请求。例如，你可以使用 cURL 发送一个HEAD请求来进行检测。</p><pre><code>curl -I http://i.imgur.com/z4d4kWk.jpgHTTP/1.1 200 OK...Accept-Ranges: bytesContent-Length: 146515</code></pre><p>在上面的响应中， Accept-Ranges: bytes表示界定范围的单位是 bytes 。这里 Content-Length也是有效信息，因为它提供了要检索的图片的完整大小。<br>如果站点未发送Accept-Ranges首部，那么它们有可能不支持范围请求。一些站点会明确将其值设置为”none”，以此来表明不支持。在这种情况下，某些应用的下载管理器会将暂停按钮禁用。</p><pre><code>curl -I https://www.youtube.com/watch?v=EwTZ2xpQwpAHTTP/1.1 200 OK...Accept-Ranges: none</code></pre><h1 id="向服务端发送范围请求"><a href="#向服务端发送范围请求" class="headerlink" title="向服务端发送范围请求"></a>向服务端发送范围请求</h1><p>假如服务器支持范围请求的话，你可以使用Range首部来生成该类请求。该首部指示服务器应该返回文件的哪一或哪几部分。</p><h2 id="单一范围"><a href="#单一范围" class="headerlink" title="单一范围"></a>单一范围</h2><p>我们可以请求资源的某一部分。这次我们依然用cURL来进行测试。”-H”可以在请求中追加一个首部行，在这个例子中，是用Range首部来请求图片文件的前1024个字节。</p><pre><code>curl http://i.imgur.com/z4d4kWk.jpg -i -H &quot;Range: bytes=0-1023&quot;</code></pre><p>这样生成的请求如下：</p><pre><code>GET /z4d4kWk.jpg HTTP/1.1Host: i.imgur.comRange: bytes=0-1023</code></pre><p>服务器端会返回状态码为206 Partial Content的响应：</p><pre><code>HTTP/1.1 206 Partial ContentContent-Range: bytes 0-1023/146515Content-Length: 1024...(binary content)</code></pre><p>在这里，Content-Length首部现在用来表示先前请求范围的大小（而不是整张图片的大小）。Content-Range响应首部则表示这一部分内容在整个资源中所处的位置。</p><h2 id="多重范围"><a href="#多重范围" class="headerlink" title="多重范围"></a>多重范围</h2><p>Range头部也支持一次请求文档的多个部分。请求范围用一个逗号分隔开。</p><pre><code>curl http://www.example.com -i -H &quot;Range: bytes=0-50, 100-150&quot;</code></pre><p>服务器返回206 Partial Content状态码和Content-Type：multipart/byteranges; boundary=3d6b6a416f9b5头部，Content-Type：multipart/byteranges表示这个响应有多个byterange。每一部分byterange都有他自己的Centen-type头部和Content-Range，并且使用boundary参数对body进行划分。</p><pre><code>HTTP/1.1 206 Partial ContentContent-Type: multipart/byteranges; boundary=3d6b6a416f9b5Content-Length: 282--3d6b6a416f9b5Content-Type: text/htmlContent-Range: bytes 0-50/1270&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Example Do--3d6b6a416f9b5Content-Type: text/htmlContent-Range: bytes 100-150/1270eta http-equiv=&quot;Content-type&quot; content=&quot;text/html; c--3d6b6a416f9b5--</code></pre><h2 id="条件式范围请求"><a href="#条件式范围请求" class="headerlink" title="条件式范围请求"></a>条件式范围请求</h2><p>当（中断之后）重新开始请求更多资源片段的时候，必须确保自从上一个片段被接收之后该资源没有进行过修改。增加If-Range请求首部可以用来生成条件式范围请求，假如条件满足的话，条件请求就会生效，服务器会返回状态码为206 Partial的响应，以及相应的消息主体。假如条件未能得到满足，那么就会返回状态码为200 OK的响应，同时返回整个资源。该首部可以与Last-Modified验证器或者ETag一起使用，但是二者不能同时使用。</p><pre><code>If-Range: Wed, 21 Oct 2015 07:28:00 GMT</code></pre><h1 id="范围请求的响应"><a href="#范围请求的响应" class="headerlink" title="范围请求的响应"></a>范围请求的响应</h1><p>与范围请求相关的有三种状态：</p><p>（1）在请求成功的情况下，服务器会返回206 Partial Content状态码。</p><p>（2）在请求的范围越界的情况下（范围值超过了资源的大小），服务器会返回416Requested Range Not Satisfiable（请求的范围无法满足）状态码。</p><p>（3）在不支持范围请求的情况下，服务器会返回200 OK状态码。</p><p>学习资料参考于：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程语言分类（编译型|解释型|静态类型|动态类型|强类型|弱类型）</title>
      <link href="/2019/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB%EF%BC%88%E7%BC%96%E8%AF%91%E5%9E%8B-%E8%A7%A3%E9%87%8A%E5%9E%8B-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B-%E5%BC%BA%E7%B1%BB%E5%9E%8B-%E5%BC%B1%E7%B1%BB%E5%9E%8B%EF%BC%89/"/>
      <url>/2019/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB%EF%BC%88%E7%BC%96%E8%AF%91%E5%9E%8B-%E8%A7%A3%E9%87%8A%E5%9E%8B-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B-%E5%BC%BA%E7%B1%BB%E5%9E%8B-%E5%BC%B1%E7%B1%BB%E5%9E%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="按是否需要编译分类"><a href="#按是否需要编译分类" class="headerlink" title="按是否需要编译分类"></a>按是否需要编译分类</h1><p>（1）解释型编程语言（就是脚本语言？）</p><p>（2）编译型编程语言</p><h1 id="按是否需要指定变量类型"><a href="#按是否需要指定变量类型" class="headerlink" title="按是否需要指定变量类型"></a>按是否需要指定变量类型</h1><p>（1）静态类型语言/动态类型语言</p><p>（2）强类型/弱类型</p><p><img src="/images/software_type_1_1.jpg" alt></p><p>学习资料参考于：<br><a href="https://www.jianshu.com/p/336f19772046" target="_blank" rel="noopener">https://www.jianshu.com/p/336f19772046</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂货铺 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用户体系及用户访问控制HTTP Authorization|OAuth|JWT|SSO等</title>
      <link href="/2019/04/12/%E7%94%A8%E6%88%B7%E4%BD%93%E7%B3%BB%E5%8F%8A%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6HTTP-Authorization-OAuth-JWT-SSO%E7%AD%89/"/>
      <url>/2019/04/12/%E7%94%A8%E6%88%B7%E4%BD%93%E7%B3%BB%E5%8F%8A%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6HTTP-Authorization-OAuth-JWT-SSO%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h1 id="开放授权OAuth"><a href="#开放授权OAuth" class="headerlink" title="开放授权OAuth"></a>开放授权OAuth</h1><p>OAuth，Open Authorization，中文名是开放授权。OAuth协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAuth是安全的。</p><p>通俗的讲，OAuth是为解决不同公司的不同产品实现登陆的一种简便授权方案，通常这些授权服务都是由大客户网站提供的，如QQ，新浪微博，人人网等。而使用这些服务的客户可能是大客户网站，也可能是小客户网站。使用OAuth授权的好处是，在为用户提供某些服务时，可减少或避免因用户懒于注册而导致的用户流失问题。</p><p>OAuth是一个关于授权（Authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。作为互联网用户，我们很容易就看到有关OAuth的授权认证，例如我们登录某个网站或APP时，往往我们可以用第三方的平台的账户和密码（QQ、淘宝、百度或者新浪微博等账号体系）来登录。在这种情况下，该网站和APP就不需要维护一套用户体系，只需要使用一些大平台提供的OAuth服务就可以啦，透过OAuth可以获取一些用户基本的信息。</p><h1 id="HTTP-Authorization-Header"><a href="#HTTP-Authorization-Header" class="headerlink" title="HTTP Authorization Header"></a>HTTP Authorization Header</h1><p>在HTTP Authentication是一种用来允许网页浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。如HTTP Basic Authorization的请求格式，在HTTP的请求头中加入字段格式是<code>Authorization: Basic base64(username:password)</code>，如下：</p><p><img src="/images/http_auth_1_1.png" alt></p><p>显然这种是不安全的，很容易被第三方截获用户名和密码。当然是用https协议就可以避免这个问题啦，因为HTTPS会将HTTP Header/Body都加密，第三方截取了HTTPS数据包也解密不出来啦。</p><p>当访问一个需要HTTP Basic Authentication的URL的时候，如果你没有提供用户名和密码，服务器就会返回401。在发送请求的时候添加HTTP Basic Authentication认证信息到请求中，有如下几种方法：</p><p>（1）直接在浏览器中打开，浏览器会弹出表单，提示你输入用户名和密码。当填写完成并提交后，浏览器会自动将用户名和密码组装到HTTP Authorization Header中，发送给服务端。</p><p>（2）在请求头中添加Authorization请求头，即<code>Authorization: &quot;Basic 用户名和密码的base64加密字符串&quot;</code></p><p><img src="/images/http_auth_1_2.png" alt></p><p>（3）在URL中添加用户名和密码，形如：</p><pre><code>http://username:password@api.minicloud.com.cn/statuses/friends_timeline.xml</code></pre><h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>（1）JWT简介</p><p>JSON Web Token，简写JWT，是目前最流行的HTTP认证解决方案。我们知道HTTP session会将sessionid存储到客户端Cookie中，所以会面临两个问题，一个是浏览器禁用Cookie，另一个是若后端是多实例的架构，就涉及到session共享问题。而JWT可以解决这里面的一些问题。JWT将客户端的信息完全存储到浏览器端，服务器不需要保存session数据了，所有数据都保存在客户端，每次请求都将数据发回服务器。</p><p>（2）JWT原理</p><p>JWT的原理是，服务器认证以后，生成一个JSON对象，发回给浏览器，这个JSON对象的格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"姓名"</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="attr">"角色"</span>: <span class="string">"管理员"</span>,</span><br><span class="line">  <span class="attr">"到期时间"</span>: <span class="string">"2018年7月1日0点0分"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个JSON对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。这样服务器就不保存任何session数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><p>（3）JWT的数据结构</p><p>JWT的三个部分依次如下，</p><pre><code>Header，头部Payload，负载Signature，签名</code></pre><p>写成一行，就是下面的样子：</p><pre><code>Header.Payload.Signature</code></pre><p><img src="/images/http_auth_1_3.png" alt></p><p>（4）JWT的使用方式</p><p>客户端收到服务器返回的JWT，可以储存在Cookie里面，也可以储存在localStorage。此后，客户端每次与服务器通信，都要带上这个JWT。你可以把它放在Cookie里面自动发送，但是这样不能跨域，所以更好的做法是放在HTTP请求的头信息Authorization字段里面。</p><pre><code>Authorization: Bearer &lt;token&gt;</code></pre><p>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</p><h1 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h1><p>集中式认证服务，英文名称为Central Authentication Service，缩写CAS，是一种针对万维网的单点登录协议。它的目的是允许一个用户访问多个应用程序，而只需提供一次凭证（如用户名和密码）。它还允许web应用程序在没有获得用户的安全凭据（如密码）的情况下对用户进行身份验证。</p><p>Single Sign On，简称SSO，SSO使得在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。SSO主要技术点是CAS。</p><p><img src="/images/http_auth_1_4.png" alt></p><p>从图中可以看出，用户第一次访问helloservice，helloservice发现客户端没有携带ticket，随即将用户请求重定向到SSO/CAS的登录页面，然后用户数据用户名和密码，并将请求提交到CAS Server，CAS Server对用户信息进行校验，若通过校验，CAS Server会返回给浏览器一个Ticket，并将页面重定向到helloservice的回调页面。这时，浏览器携带着Ticket再次访问helloserivce，helloservice获取到客户端发过来的Ticket，而这是helloservice并不知道这个Ticket是不是靠谱，然后helloservice会将Ticket发给CAS Server进行认证，最终Cas Server将认证结果返回给helloservice，helloservice根据认证结果决定是否返回正常结果给客户端。在此之后，客户端再访问其他的系统时，如helloservice1，helloservice2，同样会携带这个Ticket，若Ticket经由helloservice1，helloservice2提交给Cas Service且验证通过，用户可以直接访问这些系统，而不用再次输入用户名和密码啦。</p><p>简单来说，SSO就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。单点登录在大型网站里使用得非常频繁，例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯掉。</p><h1 id="常看到的一种API用户验证管理API-KEY"><a href="#常看到的一种API用户验证管理API-KEY" class="headerlink" title="常看到的一种API用户验证管理API KEY"></a>常看到的一种API用户验证管理API KEY</h1><p>（1）客户端侧</p><p>client向服务端申请两个ID，一个是Api_key，另一个是Security_key。其中Api_key是客户端的唯一标识，Security_key仅仅是用来生成Signature串的因子，Security_key不会在调用HTTP API的时候传递给服务端，服务端会通过Api_key找出对应的Security_key。客户端生成url串的过程如下（生成签名串时，会将url的参数按字母大小写排序，这样服务端才能做同样的操作）：</p><p><img src="/images/http_auth_1_5.png" alt></p><p>（2）服务端侧</p><p>服务端在收到请求后，通过Api_key找出Security_key，并使用和客户端同样的方法计算出签名串，然后和url传递过来的签名串进行比较，若一样则说明client身份是正确的，且url请求没被第三方拦截修改。</p><p><img src="/images/http_auth_1_6.png" alt></p><h1 id="SSO和OAuth的区别"><a href="#SSO和OAuth的区别" class="headerlink" title="SSO和OAuth的区别"></a>SSO和OAuth的区别</h1><p>OAuth是一种授权协议，只是为用户资源的授权提供了一个安全的、开放而又简易的标准。OAuth 2.0为客户端开发者开发Web应用，桌面端应用程序，移动应用及客厅设备提供特定的授权流程。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。<br>通俗的讲，OAuth是为解决不同公司的不同产品实现登陆的一种简便授权方案，通常这些授权服务都是由大客户网站提供的，如QQ，新浪微博，人人网等。而使用这些服务的客户可能是大客户网站，也可能是小客户网站。使用OAuth授权的好处是，在为用户提供某些服务时，可减少或避免因用户懒于注册而导致的用户流失问题。SSO通常处理的是一个公司的不同应用间的访问登陆问题。如企业应用有很多业务子系统，只需登陆一个系统，就可以实现不同子系统间的跳转，而避免了登陆操作。</p><p>学习资料参考于：<br><a href="https://www.imooc.com/learn/557" target="_blank" rel="noopener">https://www.imooc.com/learn/557</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a><br><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB引擎中事务|事务隔离级别|MVCC</title>
      <link href="/2019/04/11/InnoDB%E5%BC%95%E6%93%8E%E4%B8%AD%E4%BA%8B%E5%8A%A1-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-MVCC/"/>
      <url>/2019/04/11/InnoDB%E5%BC%95%E6%93%8E%E4%B8%AD%E4%BA%8B%E5%8A%A1-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-MVCC/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><p>MySQL事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务。</p><p>关于MySQL事务操作，需要注意如下几点：</p><p>（1）在MySQL中只有使用了InnoDB存储引擎的数据库或表才支持事务</p><p>（2）事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行</p><p>（3）MySQL事务是必须满足4个条件（ACID），即原子性Atomicity、一致性Consistency、隔离性Isolation以及持久性Durability</p><h1 id="MySQL事务操作"><a href="#MySQL事务操作" class="headerlink" title="MySQL事务操作"></a>MySQL事务操作</h1><p>MySQL事务操作主要有两种方法：</p><p>（1）用BEGIN/ROLLBACK/COMMIT等事务控制语句来实现显式控制事务（显式事务）</p><pre><code>BEGIN开始一个事务ROLLBACK事务回滚COMMIT事务确认</code></pre><p>更详细的说明如下：</p><pre><code>BEGIN或START TRANSACTION显式地开启一个事务COMMIT也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，使已对数据库进行的所有修改成为永久性的ROLLBACK也可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改SAVEPOINT identifier，SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINTRELEASE SAVEPOINT identifier删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常ROLLBACK TO identifier把事务回滚到标记点SET TRANSACTION用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE</code></pre><p>（2）MySQL AUTOCOMMIT自动提交模式（隐式事务）</p><p>在MySQL命令行的默认设置下，事务都是自动提交的，即执行一条SQL语句后就会马上执行COMMIT操作。</p><pre><code>SET AUTOCOMMIT=0禁止自动提交SET AUTOCOMMIT=1开启自动提交</code></pre><p>举例来说，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开始事务，提交事务</span></span><br><span class="line"><span class="comment">-- 所以1被插入</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先回滚事务，再提交事务</span></span><br><span class="line"><span class="comment">-- 所以2没有被插入</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先回滚到s1，再提交事务</span></span><br><span class="line"><span class="comment">-- 所以3被插入，4没有被插入</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">savepoint</span> s1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> s1;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚事务，事务未提交</span></span><br><span class="line"><span class="comment">-- 所以5没有被插入</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自动提交，再回滚</span></span><br><span class="line"><span class="comment">-- 所以6会被插入</span></span><br><span class="line"><span class="keyword">set</span> autocommit=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 禁止自动提交，再回滚</span></span><br><span class="line"><span class="comment">-- 所以7未被插入</span></span><br><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">value</span>(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h1 id="事务提交的类型（一个事务被结束的几种方式）"><a href="#事务提交的类型（一个事务被结束的几种方式）" class="headerlink" title="事务提交的类型（一个事务被结束的几种方式）"></a>事务提交的类型（一个事务被结束的几种方式）</h1><h2 id="显式提交"><a href="#显式提交" class="headerlink" title="显式提交"></a>显式提交</h2><p>所有的数据操纵语句都是要显式提交的，所谓显式提交就是要执行commit/rollback。数据操纵语句执行完后，处理的数据都会放在回滚段中，等待用户进行提交或者回滚，当用户执行commit/rollback后，放在回滚段中的数据就会被删除。显式提交是由你决定是否提交，这种事务允许你自己决定哪批工作必须成功完成，否则所有部分都不能完成。</p><h2 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h2><p>MySQL数据库隐式提交的三种情况：</p><pre><code>正常执行完数据定义语言（DDL）包括create，alter，drop，truncate，rename正常执行完数据控制语言（DCL）包括grant，revoke正常退出MySQL客户端，没有明确发出commit/rollback</code></pre><p>隐式事务又称自动提交事务，在遇到上面的各种操作之前，由系统自动帮你完成事务的提交。</p><h2 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h2><p>若把AUTOCOMMIT设置为ON，在插入、修改、删除语句（即部分的DML）执行后，系统将自动进行提交。</p><h1 id="事务并发可能出现的情况"><a href="#事务并发可能出现的情况" class="headerlink" title="事务并发可能出现的情况"></a>事务并发可能出现的情况</h1><p>（1）脏读（Dirty Read）</p><p><img src="/images/innodb_trx_1_6.png" alt></p><p>会话B开启一个事务，把id=1的name为武汉市修改成温州市，此时另外一个会话A也开启一个事务，读取id=1的name，此时的查询结果为温州市，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。脏读只在读未提交隔离级别才会出现。</p><p>（2）不可重复读（Non-Repeatable Read）</p><p><img src="/images/innodb_trx_1_7.png" alt></p><p>会话A开启一个事务，查询id=1的结果，此时查询的结果name为武汉市。接着会话B把id=1的name修改为温州市（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），此时会话A的事务再一次查询id=1的结果，读取的结果name为温州市。会话B再此修改id=1的name为杭州市，会话A的事务再次查询id=1，结果name的值为杭州市，这种现象就是不可重复读。</p><p>（3）幻读（Phantom）</p><p><img src="/images/innodb_trx_1_8.png" alt></p><p>会话A开启一个事务，查询id&gt;0的记录，此时会查到name=武汉市的记录。接着会话B插入一条name=温州市的数据（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），这时会话A的事务再以刚才的查询条件（id&gt;0）再一次查询，此时会出现两条记录（name为武汉市和温州市的记录），这种现象就是幻读。</p><h1 id="事务的四种隔离级别"><a href="#事务的四种隔离级别" class="headerlink" title="事务的四种隔离级别"></a>事务的四种隔离级别</h1><p>简单来说，所以事务的隔离级别，是事务与事务间的冲突处理机制。</p><h2 id="读未提交（READ-UNCOMMITTED）"><a href="#读未提交（READ-UNCOMMITTED）" class="headerlink" title="读未提交（READ UNCOMMITTED）"></a>读未提交（READ UNCOMMITTED）</h2><p><img src="/images/innodb_trx_1_1.png" alt></p><p>在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。</p><p>读未提交解决了更新丢失，但可能发生<strong>脏读、不可重复读和幻读问题</strong>，一般很少使用此隔离级别。</p><h2 id="读已提交（READ-COMMITTED）"><a href="#读已提交（READ-COMMITTED）" class="headerlink" title="读已提交（READ COMMITTED）"></a>读已提交（READ COMMITTED）</h2><p><img src="/images/innodb_trx_1_2.png" alt></p><p>在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。</p><p>读已提交隔离级别解决了脏读的问题，但可能发生<strong>不可重复读和幻读</strong>问题，一般很少使用此隔离级别。</p><h2 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h2><p><img src="/images/innodb_trx_1_3.png" alt></p><p>在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。</p><p>可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生<strong>幻读</strong>问题。</p><p>MySQL InnoDB默认使用可重复读隔离级别。</p><h2 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h2><p><img src="/images/innodb_trx_1_4.png" alt></p><p><img src="/images/innodb_trx_1_9.png" alt></p><p><img src="/images/innodb_trx_1_10.png" alt></p><p><img src="/images/innodb_trx_1_11.png" alt></p><p>各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。</p><h1 id="事务隔离级别底层原理MVCC"><a href="#事务隔离级别底层原理MVCC" class="headerlink" title="事务隔离级别底层原理MVCC"></a>事务隔离级别底层原理MVCC</h1><p>（1）MVCC简介</p><p>所谓的MVCC，全称为Multi Version Concurrency Control，中文为多版本并发控制。</p><p>（2）版本链</p><p>对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（row_id并不是必要的，我们创建的表中有主键或者非NULL唯一键时都不会包含row_id列）：</p><ul><li>trx_id：每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><p><img src="/images/innodb_trx_1_5.png" alt></p><p>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id。需要注意的是，上面的事务都可能是活跃的事务，也就是并未被提交的事务。</p><p>（3）ReadView</p><p>InnoDB提出了一个ReadView的概念，这个ReadView中主要包含当前系统中还有哪些活跃的读写事务（即还未提交的事务），把它们的事务id放到一个列表中，我们把这个列表命名为为m_ids。这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>如果被访问版本的trx_id属性值小于m_ids列表中最小的事务id，表明生成该版本的事务在生成ReadView前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值大于m_ids列表中最大的事务id，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值在m_ids列表中最大的事务id和最小事务id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li><li>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本，如果最后一个版本也不可见的话，那么就意味着该条记录对该事务不可见，查询结果就不包含该记录。</li></ul><p><img src="/images/innodb_trx_1_12.png" alt></p><p>简单来说，MySQL会通过undo日志记录所有操作的，每个时刻的数据都会可追溯的，然后根据所设定的不同事务之间的隔离级别，来决定当前事务能看到哪个版本的数据。</p><h1 id="MySQL数据库隔离级别操作"><a href="#MySQL数据库隔离级别操作" class="headerlink" title="MySQL数据库隔离级别操作"></a>MySQL数据库隔离级别操作</h1><p>（1）查看MySQL数据库当前隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 方法一</span><br><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'transaction_isolation'</span>;</span><br><span class="line"></span><br><span class="line">// 方法三</span><br><span class="line"><span class="keyword">select</span> @@transaction_isolation;</span><br></pre></td></tr></table></figure><p>备注：MySQL默认的隔离级别是REPEATABLE READ。</p><p>（2）设置当前数据库的隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span>|<span class="keyword">SESSION</span>] <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">level</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中level有4种值：</span></span><br><span class="line"><span class="comment"># level: &#123;</span></span><br><span class="line"><span class="comment">#     READ UNCOMMITTED</span></span><br><span class="line"><span class="comment">#   | READ COMMITTED</span></span><br><span class="line"><span class="comment">#   | REPEATABLE READ</span></span><br><span class="line"><span class="comment">#   | SERIALIZABLE</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure><p>学习资料参考于：<br>我们都是小青蛙的<a href="https://mp.weixin.qq.com/s/Jeg8656gGtkPteYWrG5_Nw" target="_blank" rel="noopener">《MySQL事务隔离级别和MVCC》</a><br><a href="https://developer.aliyun.com/article/743691" target="_blank" rel="noopener">https://developer.aliyun.com/article/743691</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB引擎的存储结构及索引原理</title>
      <link href="/2019/04/07/InnoDB%E5%BC%95%E6%93%8E%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
      <url>/2019/04/07/InnoDB%E5%BC%95%E6%93%8E%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB引擎的存储结构"><a href="#InnoDB引擎的存储结构" class="headerlink" title="InnoDB引擎的存储结构"></a>InnoDB引擎的存储结构</h1><p><img src="/images/mysql_innodb_1_1.png" alt></p><p>InnoDB的存储结构是有表空间TableSpace、段Segment、区Extent、页Page、行Row组成。数据库中所有记录可以放到一个表空间中（称为共享表空间），也可以每一张表放到不同的表空间中（称为独立表空间）。</p><p>在InnoDB中每个页Page的大小是16KB，页Page是InnoDB磁盘管理的最小单位。</p><p>行Row就是我们一条的数据记录。</p><h1 id="InnoDB聚集索引"><a href="#InnoDB聚集索引" class="headerlink" title="InnoDB聚集索引"></a>InnoDB聚集索引</h1><p><img src="/images/mysql_innodb_1_2.png" alt></p><p>如上就是InonDB的聚集索引，它有如下的特点：</p><p>（1）聚集索引是一个B+树的数据结构，B+树每个节点就是InnoDB中一个页Page</p><p>（2）B+数的叶子节点存储的是一张表的完整数据记录。B+树的非叶子节点存储的是为了快速检索数据的目录数据，非实际的数据记录</p><p>（3）所有页Page内的记录是按照主键的大小顺序排成一个单向链表</p><p>（4）每一层的所有页Page按主键大小顺序排成一个双向链表</p><p>我们把具有如上特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的去创建，InnoDB存储引擎会自动地为我们在主键上创建聚簇索引。如果表没有主键，InnoDB会选择一个非NULL且唯一索引作为聚集索引。若主键和非NULL且唯一索引都不存在，InnoDB将会自动增加一个6字节(48位)的整数列，被叫做ROWID，聚集数据将在这个隐藏列上创建，需要注意的是，ROWID既不能通过任何查询获取到也不能做像基于行复制的任何内部操作，是看不到的。</p><p>另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（一张表所有的数据记录都存储在了叶子节点），也就是所谓的索引即数据。</p><p>简单来说，InnoDB中每一种表都自动有一个聚集索引，而该聚集索引也完整的包括了该表的所有数据记录，而并非是一个快速查找数据的目录而已。</p><h1 id="InnoDB索引的一些概念"><a href="#InnoDB索引的一些概念" class="headerlink" title="InnoDB索引的一些概念"></a>InnoDB索引的一些概念</h1><h2 id="聚集索引（主键索引）"><a href="#聚集索引（主键索引）" class="headerlink" title="聚集索引（主键索引）"></a>聚集索引（主键索引）</h2><p>聚集索引，也成为主键索引。其他的索引统称为非聚集索引。</p><h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>普通索引，也称二级索引，也是一个B+树的结构，但是普通索引有如下几点不同：</p><p>（1）普通索引需要人为显式地在数据表中某一列上创建</p><p>（2）在数据表某字段上创建普通索引，索引中各种排序链表，是按照该字段的值进行排序</p><p>（3）普通索引的B+树的叶子节点对应页Page的记录，就不是数据表中完整的记录，只包含被索引列的值和主键值，而记录中其他字段是不存储的</p><p>因此当我们执行一条select语句用到一个普通索引时，会在普通索引的B+树结构中，找到对应被索引列的值和主键值。然后再通过主键值，去聚集索引中查找到最终的完整数据记录。这个过程应该叫回表查询。</p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>它是普通索引中的一种。</p><p>联合索引，也称复合索引或组合索引，是我们在数据表的多个列上创建一个索引。如在f1和f2列上创建联合索引，那么联合索引对应的B+树中链表排序，是先根据f1进行排序，若f1相同再根据f2进行排序。当我们执行一条select语句用到一个组合索引时，会在组合索引的B+树结构中，也是先找到对应多个被索引列的值和主键值。然后再通过主键值，去聚集索引中查找到最终的完整数据记录。</p><p>举例来说，我们在表myTable上的三个字段（vc_Name，vc_City，i_Age） 创建一个组合索引里如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`myTable`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> <span class="string">`name_city_age`</span> (vc_Name(<span class="number">10</span>),vc_City,i_Age);</span><br></pre></td></tr></table></figure><p>这就相当于分别建立了三个组合索引如下：</p><pre><code>vc_Name,vc_City,i_Agevc_Name,vc_Cityvc_Name</code></pre><p>为什么没有vc_City,i_Age等这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引。</p><p>因此若执行<code>SELECT * FROM myTable WHREE vc_Name=”erquan” AND vc_City=”郑州”;</code>SQL语句，是会用到上面的组合索引。若执行<code>SELECT * FROM myTable WHREE i_Age=20 AND vc_City=”郑州”;</code>SQL语句是不会用到上面的组合索引。</p><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>它是普通索引中的一种。当要索引的列字符很长时，索引则会很大且变慢，而我们又需要在此字段上创建索引来提供查询效率，这时可以在该字段的前N个字符上创建索引，节约索引空间，从而提高索引效率，这也成为前缀索引。</p><p>假设有如下一个test表：</p><p><img src="/images/mysql_innodb_1_3.png" alt></p><p>执行<code>alter table test add index(area(5));</code>SQL语句就可以在在area字段的前5个字符上创建了前缀索引。创建前缀索引时，一定要注意索引长度和重复度的权衡选择。</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>并非一种索引哦。</p><p>若我们只想查询数据表的某些列，并非是记录的所有列，且要查询的列正好包含在索引列中，也就是索引的B+树的叶子节点中已经包含了这些列的值，那么不用在透过主键去聚集索引中去在查找一遍啦，直接返回就好了。这种情形也叫“覆盖索引”。</p><p>比如<code>select income from user where imcome&gt;40;</code>时，因income字段上建立了索引，索引文件中已经有income字段的内容了，这时就不用拿着主键再去聚集索引中做回表查询啦。</p><h1 id="其他闲杂知识"><a href="#其他闲杂知识" class="headerlink" title="其他闲杂知识"></a>其他闲杂知识</h1><p>（1）一般说来，在InnoDB的索引B+树中，最多需要四层就可以满足啦</p><p>（2）上面说的都是InnoDB的存储结构以及索引原理，不同的存储引擎会表现的稍有不同。如MyISAM的聚集索引B+树的叶子节点，只存储了主键值和行号。数据查询会通过聚集索引找到主键值和行号，然后再通过行号（也就物理位置的偏移量）找到完整的数据记录。</p><p>学习资料参考于：<br>我们都是小青蛙的<a href="https://mp.weixin.qq.com/s/vtIHUlR92GQVG6UW74PEqQ" target="_blank" rel="noopener">《InnoDB记录存储结构》</a><br>我们都是小青蛙的<a href="https://mp.weixin.qq.com/s/GYRuFhty5gDLAmDXw7AluA" target="_blank" rel="noopener">《InnoDB数据页结构》</a><br>我们都是小青蛙的<a href="https://mp.weixin.qq.com/s/9gloKNtZrYlGsBODCckQrw" target="_blank" rel="noopener">《MySQL的索引》</a><br>我们都是小青蛙的<a href="https://mp.weixin.qq.com/s/ktEBA03Kip4bYYkp2ktiIQ" target="_blank" rel="noopener">《MySQL的索引（中）》</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一致性哈希算法</title>
      <link href="/2019/03/27/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/27/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一致性哈希简介"><a href="#一致性哈希简介" class="headerlink" title="一致性哈希简介"></a>一致性哈希简介</h1><p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点（Hot Spot）问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。 </p><p>一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：</p><p>（1）平衡性（Balance）</p><p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p><p>（2）单调性（Monotonicity）</p><p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 </p><p>（3）分散性（Spread）</p><p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </p><p>（4）负载（Load）</p><p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p><p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的<code>hash(object)%N</code>算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。</p><p>简单来说，在一个多节点的集群中，数据对象按照Hash算法分布到不同的机器节点上，简单的Hash算法如下：</p><pre><code>server = serverlist[hash(object)%serverlist.length]</code></pre><p>这样的情况下，当有机器增加或删除时，所有的数据对象都被会重新Hash到不同的机器节点上。而一致性哈希算法就是为了解决这个问题的，当有机器节点增加或删除时，仅会影响到部分数据对象被Hash到不同的机器节点上，而大部分数据对象是不会被重新Hash的。</p><h1 id="一致性哈希原理"><a href="#一致性哈希原理" class="headerlink" title="一致性哈希原理"></a>一致性哈希原理</h1><p>（1）环形Hash空间概念</p><p>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即<code>0~(2^32)-1</code>的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图：</p><p><img src="/images/ds_dht_1_1.png" alt></p><p>（2）把数据对象通过hash算法映射到环上<br>现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图：</p><pre><code>Hash(object1) = key1Hash(object2) = key2Hash(object3) = key3Hash(object4) = key4</code></pre><p><img src="/images/ds_dht_1_2.png" alt></p><p>（3）将机器节点通过hash算法映射到环上</p><p>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。</p><p>假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：</p><pre><code>Hash(NODE1) = KEY1Hash(NODE2) = KEY2Hash(NODE3) = KEY3</code></pre><p><img src="/images/ds_dht_1_3.png" alt></p><p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动object1存储到了NODE1中，object3存储到了NODE2中，object2、object4存储到了NODE3中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。</p><p>备注：（2）和（3）使用的hash算法函数是一样的哦</p><h1 id="一致性哈希算法下机器节点变更下数据迁移现象"><a href="#一致性哈希算法下机器节点变更下数据迁移现象" class="headerlink" title="一致性哈希算法下机器节点变更下数据迁移现象"></a>一致性哈希算法下机器节点变更下数据迁移现象</h1><p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。</p><p>（1）节点（机器）的删除</p><p>以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：</p><p><img src="/images/ds_dht_1_4.png" alt></p><p>（2）节点（机器）的添加</p><p>如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图：</p><p><img src="/images/ds_dht_1_5.png" alt></p><p>通过按顺时针迁移的规则，那么object2被迁移到了NODE4中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p><h1 id="一致性hash算法的应用"><a href="#一致性hash算法的应用" class="headerlink" title="一致性hash算法的应用"></a>一致性hash算法的应用</h1><p>（1）在nginx的ngx_http_upstream_module模块中有一个<code>hash key [consistent]</code>的指令，就是哈希一致性算法的一个应用。当upstream组新增或下线了机器，一致性hash算法能保证尽量少的请求会被重新映射到其他机器上，从而保证机器增减时，缓存的命中率不会有非常大的波动。</p><p>（2）数据库的水平拆分时，可以考虑使用一致性Hash，避免后续扩展时，需要全局迁移数据。</p><p>（3）Redis集群也是采用的一致性哈希算法。</p><p>学习资料参考于：<br><a href="https://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">https://blog.csdn.net/cywosp/article/details/23397179</a><br><a href="https://www.jianshu.com/p/570dc8913c20" target="_blank" rel="noopener">https://www.jianshu.com/p/570dc8913c20</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django系列（10）_中间件Middleware技术</title>
      <link href="/2019/03/25/Django%E7%B3%BB%E5%88%97%EF%BC%8810%EF%BC%89-%E4%B8%AD%E9%97%B4%E4%BB%B6Middleware%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/03/25/Django%E7%B3%BB%E5%88%97%EF%BC%8810%EF%BC%89-%E4%B8%AD%E9%97%B4%E4%BB%B6Middleware%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="django中间件简介"><a href="#django中间件简介" class="headerlink" title="django中间件简介"></a>django中间件简介</h1><p>django中间件是django的请求/响应处理过程中的钩子框架，它是一个用于全局修改Django输入或输出的轻量、低级的“插件”系统。每个中间件组件负责一些特定的功能。例如，django包含一个中间件组件， AuthenticationMiddleware，它使用会话关联请求和用户。</p><p>django中间件是一个普通的类或者函数，需要注意的是，在django1.10之前和之后中间件的定义有些异同，不过从原理层面来说还是相通的。一般说来，每个中间件中包括了如下几个函数：</p><p>（1）process_request(self, request)</p><p>该方法在HTTP请求到达django框架时被调用</p><p>（2）process_view(self, request, fnc, arg, kwarg)</p><p>该方法在views.py中的函数被调用之前被调用</p><p>（3）process_response(self, request, response)</p><p>该方法在执行完view函数，准备将响应结果发到客户端之前被执行</p><p>（4）process_exception(self, request, exception)</p><p>view函数在抛出异常时该函数被调用，得到的exception参数是实际上抛出的异常实例，通过此方法可以进行很好的错误控制，提供友好的用户界面。</p><p>（5）process_template_response</p><h1 id="django中间件在整个请求处理过程的执行逻辑"><a href="#django中间件在整个请求处理过程的执行逻辑" class="headerlink" title="django中间件在整个请求处理过程的执行逻辑"></a>django中间件在整个请求处理过程的执行逻辑</h1><p>假设项目settings.py中MIDDLEWARE字段配置如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那么当请求进来先从上到下执行一遍各中间件的process_request方法，接下来再从上下执行一遍各中间件的process_view方法，接下来执行view函数。若view函数执行异常，则从下往上执行一遍各中间件的process_exception函数。若view函数执行无异常，则从下往上执行一遍各中间件的process_template_response方法，接下来再从下往上执行一遍各中间件的process_response方法。</p><p><img src="/images/django_10_1.png" alt></p><p>因此，各中间件在settings.py中MIDDLEWARE数组中的位置会决定了各中间件中函数被执行的顺序。</p><p>另外，我们也可以自定义中间件。</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SaltStack目标Target的指定</title>
      <link href="/2019/03/20/SaltStack%E7%9B%AE%E6%A0%87Target%E7%9A%84%E6%8C%87%E5%AE%9A/"/>
      <url>/2019/03/20/SaltStack%E7%9B%AE%E6%A0%87Target%E7%9A%84%E6%8C%87%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="通过minion-id来全局或正则表达式匹配"><a href="#通过minion-id来全局或正则表达式匹配" class="headerlink" title="通过minion-id来全局或正则表达式匹配"></a>通过minion-id来全局或正则表达式匹配</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">salt <span class="string">'*'</span> test.ping</span><br><span class="line">salt <span class="string">'*-wahaha'</span> test.ping</span><br><span class="line">salt <span class="string">'wahaha-???'</span> test.ping</span><br><span class="line">salt <span class="string">'[a-z]-wahaha'</span> test.ping</span><br><span class="line">salt -E <span class="string">'web\d+.(dev|qa|prod).loc'</span> test.ping  <span class="comment">#正则表达式时，需要加上-E选项</span></span><br></pre></td></tr></table></figure><h1 id="通过minion-id来列表匹配"><a href="#通过minion-id来列表匹配" class="headerlink" title="通过minion-id来列表匹配"></a>通过minion-id来列表匹配</h1><p>有些我们只想匹配一个指定列表里面的主机并进行远程执行操作，这个时候全局匹配和正则表达式匹配就无法满足了。这时我们可以使用列表匹配，就需要用-L参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salt -L <span class="string">'node2.51yuki.cn,node3.51yuki.cn'</span> test.ping</span><br></pre></td></tr></table></figure><h1 id="通过Grains信息来确定target"><a href="#通过Grains信息来确定target" class="headerlink" title="通过Grains信息来确定target"></a>通过Grains信息来确定target</h1><p>Grains是描述salt-minion本身固有属性的静态数据（是在salt-minion启动的时候收集），如salt-minion端的操作系统版本、内存大小、硬盘及网卡信息等。如果salt-minion端的数据发生改变后，就必须要重启salt-minion，否则就不会生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salt -G <span class="string">'roles:apache'</span> cmd.run <span class="string">'sudo systemctl restart httpd'</span> <span class="comment">#-G参数指定使用Grains来确定target</span></span><br></pre></td></tr></table></figure><h1 id="通过Pillar信息来确定target"><a href="#通过Pillar信息来确定target" class="headerlink" title="通过Pillar信息来确定target"></a>通过Pillar信息来确定target</h1><p>Pillar数据同Grains相似，不同之处是Pillar数据可以定义为动态的。给特定的salt-minion指定特定的数据，只有指定salt-minion自己能看到自己的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salt -I <span class="string">'apache:httpd'</span> cmd.run <span class="string">'df -h'</span> <span class="comment">#-I参数指定使用Pillar来确定target</span></span><br></pre></td></tr></table></figure><h1 id="通过子网或IP来确定target"><a href="#通过子网或IP来确定target" class="headerlink" title="通过子网或IP来确定target"></a>通过子网或IP来确定target</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salt -S 10.2.11.228 cmd.run <span class="string">'df -h'</span></span><br><span class="line">salt -S 10.2.11.0/24 cmd.run <span class="string">'df -h'</span></span><br></pre></td></tr></table></figure><p>备注：使用-S参数来表明使用子网或IP来确定target</p><h1 id="组合匹配"><a href="#组合匹配" class="headerlink" title="组合匹配"></a>组合匹配</h1><p>举例来说，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salt -C <span class="string">'S@10.2.11.0/24 and G@os:CentOS'</span> cmd.run <span class="string">'df -h'</span>  <span class="comment">#-C表示使用组合匹配来确定target，本例是Grains信息和网段的组合来确定target</span></span><br></pre></td></tr></table></figure><h1 id="NodeGroup"><a href="#NodeGroup" class="headerlink" title="NodeGroup"></a>NodeGroup</h1><p>在salt-master的主配置文件/etc/salt/master中加入类似如下的分组信息：</p><pre><code>nodegroups:    group1: &apos;L@foo.domain.com,bar.domain.com,baz.domain.com or bl*.domain.com&apos;    group2: &apos;G@os:Debian and N@group1&apos;    group3: &apos;E@test2(1[1-9]|3[1-2]).company.com&apos;</code></pre><p>然后使用-N来指定一个nodegroup来作为target，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salt -N group2 cmd.run <span class="string">'df -h'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SaltStack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python开发中一些闲杂知识</title>
      <link href="/2019/03/18/Python%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%97%B2%E6%9D%82%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/03/18/Python%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%97%B2%E6%9D%82%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Python语言特点"><a href="#Python语言特点" class="headerlink" title="Python语言特点"></a>Python语言特点</h1><p>Python语言是一种解释型的、面向对象的、带有动态语义的高级程序设计语言。其中解释型语言对应于编译型语言。</p><p>Remarks：解释型语言有awk、Perl、Python、Ruby、Shell等等</p><h1 id="IDLE"><a href="#IDLE" class="headerlink" title="IDLE"></a>IDLE</h1><p>IDLE是集成开发环境IDE，而Python安装目录下面的python_dir/python.exe才是Python语言的解释器。</p><h1 id="Python中type-函数"><a href="#Python中type-函数" class="headerlink" title="Python中type()函数"></a>Python中type()函数</h1><p>Python中type()函数可以查看一个Python对象的数据类型。</p><h1 id="Python中None"><a href="#Python中None" class="headerlink" title="Python中None"></a>Python中None</h1><p>python中没有null，但是None。python中None的含义和其他语言中null是一样的。</p><h1 id="Python没有自增自减运算符"><a href="#Python没有自增自减运算符" class="headerlink" title="Python没有自增自减运算符"></a>Python没有自增自减运算符</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">a++     <span class="comment">#不合法</span></span><br><span class="line">a--     <span class="comment">#不合法</span></span><br><span class="line">a += <span class="number">1</span>  <span class="comment">#合法</span></span><br><span class="line">a -= <span class="number">2</span>  <span class="comment">#合法</span></span><br></pre></td></tr></table></figure><h1 id="py和-pyw异同"><a href="#py和-pyw异同" class="headerlink" title="*.py和*.pyw异同"></a><code>*.py</code>和<code>*.pyw</code>异同</h1><p>直接双击<code>*.py</code>文件运行Python文件，会出现一个类似于DOS的窗口。而直接双击<code>*.pyw</code>文件运行Python文件就不会出现这个DOS窗口。</p><h1 id="一些Pythonic例子"><a href="#一些Pythonic例子" class="headerlink" title="一些Pythonic例子"></a>一些Pythonic例子</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a  <span class="comment">#交换两个变量的值</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C/C++中的值传递|指针传递|引用传递</title>
      <link href="/2019/03/17/C-C-%E4%B8%AD%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92-%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
      <url>/2019/03/17/C-C-%E4%B8%AD%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92-%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-中的对象传递"><a href="#C-C-中的对象传递" class="headerlink" title="C/C++中的对象传递"></a>C/C++中的对象传递</h1><p>C/C++中有三种对象传递：</p><pre><code>值传递指针传递引用传递</code></pre><p>其中引用传递是引用者是被引用者的一个别名，他们在内存中指向同一个东东。</p><h1 id="其他闲杂知识"><a href="#其他闲杂知识" class="headerlink" title="其他闲杂知识"></a>其他闲杂知识</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b       <span class="comment">//给对象a重新赋值</span></span><br><span class="line">a.attr = <span class="number">5</span>  <span class="comment">//修改对象a的内部状态</span></span><br></pre></td></tr></table></figure><p>注意，有些对象类型，比如int，bool，string等是无法修改对象的内部的属性的。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL服务端和客户端命令行工具小结</title>
      <link href="/2019/03/15/MySQL%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/15/MySQL%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL服务端命令行工具"><a href="#MySQL服务端命令行工具" class="headerlink" title="MySQL服务端命令行工具"></a>MySQL服务端命令行工具</h1><p><img src="/images/mysql_tools_1_1.png" alt></p><p>备注：mysqld工具可能不在bin目录下，可能在<code>${mysql安装目录}/mysql/libexec</code>下。</p><h1 id="MySQL客户端命令行工具"><a href="#MySQL客户端命令行工具" class="headerlink" title="MySQL客户端命令行工具"></a>MySQL客户端命令行工具</h1><p><img src="/images/mysql_tools_1_2.png" alt></p><h1 id="MySQL官方图形化管理工具MySQL-Workbench"><a href="#MySQL官方图形化管理工具MySQL-Workbench" class="headerlink" title="MySQL官方图形化管理工具MySQL Workbench"></a>MySQL官方图形化管理工具MySQL Workbench</h1><p>MySQL Workbenck也有两个版本：</p><pre><code>MySQL Workbench Community Edition，也就是社区版本MySQL Workbench Standard Edition，也就是商业版本，是按年收取费用的</code></pre><p>备注：Sequel Pro/Navicat也是很好用的图形管理界面哦。</p><h1 id="其他MySQL附带工具"><a href="#其他MySQL附带工具" class="headerlink" title="其他MySQL附带工具"></a>其他MySQL附带工具</h1><p>（1）mysql_config</p><p>MySQL在安装完后，一般在<code>${MYSQL_HOME}/bin</code>目录下有mysql_config工具，它不是一个二进制文件，是一个脚本工具。当我们在编译自己的mysql客户端时，可用通过mysql_config工具获取很多的有用的编译参数，例如使用<code>mysql_config --include</code>可以获取mysql的mysql在安装时的一些头文件位置，或者<code>mysql_config --libs</code>可以获取mysql的头文件及共享库等编译参数。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql_config --include   <span class="comment">#得到-I/usr/include/mysql</span></span><br><span class="line">mysql_config --libs      <span class="comment">#得到-L/usr/lib/mysql-lmysqlclient -lz -lcrypt -lnsl -lm -L/usr/lib -lssl -lcrypto</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中文件洞或稀释文件</title>
      <link href="/2019/03/14/Linux%E4%B8%AD%E6%96%87%E4%BB%B6%E6%B4%9E%E6%88%96%E7%A8%80%E9%87%8A%E6%96%87%E4%BB%B6/"/>
      <url>/2019/03/14/Linux%E4%B8%AD%E6%96%87%E4%BB%B6%E6%B4%9E%E6%88%96%E7%A8%80%E9%87%8A%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="文件洞的概念"><a href="#文件洞的概念" class="headerlink" title="文件洞的概念"></a>文件洞的概念</h1><p>在数据库之类的应用程序中，可能会提前分配一个固定大小的文件，但是并不立即往其中写入数据。数据只有在真正需要的时候才会写入到文件中。如果为这些根本不包含数据的文件立即分配数据块，那就势必会造成磁盘空间的浪费。为了解决这个问题，传统的Unix系统中引入了文件洞的概念，文件洞就是普通文件中包含空字符的那部分内容，在磁盘上并不会使用任何数据块来保存这部分数据。也就是说，包含文件洞的普通文件被划分成两部分，一部分是真正包含数据的部分，这部分数据保存在磁盘上的数据块中；另外一部分就是这些文件洞。</p><p>在Windows操作系统上也存在类似的概念，不过并没有使用文件洞这个概念，而是称之为稀疏文件。</p><p>ext2文件系统也对文件洞有着很好的支持，其实现是建立在动态数据块分配原则之上的，也就是说，在ext2文件系统中，只有当进程需要向文件中写入数据时，才会真正为这个文件分配数据块。</p><p>在ext2文件系统中，inode的数据结构是ext2_inode，ext2_inode有两个与文件大小有关的域：<code>i_size</code>和<code>i_blocks</code>，二者分别表示文件的实际大小和存储该文件时真正在磁盘上占用的数据块的个数，其单位分别是字节和块个数。通常来说，<code>i_blocks</code>与块大小的乘积可能会大于或等于<code>i_size</code>的值，这是因为文件大小并不都是数据块大小的整数倍，因此分配给该文件的部分数据块可能并没有存满数据。但是在存在文件洞的文件中，<code>i_blocks</code>与块大小的乘积反而可能会小于<code>i_size</code>的值。</p><h1 id="创建有‘洞’的文件"><a href="#创建有‘洞’的文件" class="headerlink" title="创建有‘洞’的文件"></a>创建有‘洞’的文件</h1><p>创建带有文件洞的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">"X"</span> | dd of=/tmp/<span class="built_in">test</span>/hole bs=1024 seek=7</span><br><span class="line">ls -li /tmp/<span class="built_in">test</span>/hole</span><br></pre></td></tr></table></figure><p>输出结果为：</p><pre><code>15 -rw-r--r-- 1 root root 7169 Nov 26 11:03 /tmp/test/hole</code></pre><p>执行命令<code>hexdump /tmp/test/hole</code>分析结果如下：</p><pre><code>0000000 0000 0000 0000 0000 0000 0000 0000 0000*0001c00 0058                                   0001c01</code></pre><p>第一个命令生成的<code>/tmp/test/hole</code>文件大小是7169字节，其前7168字节都为空，第7169字节的内容是字母X。正常来讲，7169字节的文件需要占用两个数据块来存储，第一个数据块全部为空，第二个数据块的第3073字节为字母X，其余字节都为空。显然，第一个数据块就是一个文件洞，在这个数据块真正被写入数据之前，ext2并不为其实际分配数据块，而是将i_block域的对应位（或间接寻址使用的索引数据块中的对应位）设置为0，表示这是一个文件洞。该文件的内容如下图所示：</p><p><img src="/images/linux_filehole_1_1.png" alt></p><h1 id="ls和du查看稀疏文件的异同"><a href="#ls和du查看稀疏文件的异同" class="headerlink" title="ls和du查看稀疏文件的异同"></a>ls和du查看稀疏文件的异同</h1><p>du查看的是被文件实际占据数据块的总大小，因为‘洞’是没有被分配data block的，所以不包含‘洞’的大小。ls查看的是文件实际占用文件系统的大小，包含了‘洞’的大小。</p><p>学习资料参考于：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-filesrc2/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-filesrc2/</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux运行时动态调整内核参数工具sysctl小结</title>
      <link href="/2019/03/14/Linux%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E5%B7%A5%E5%85%B7sysctl%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/14/Linux%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E5%B7%A5%E5%85%B7sysctl%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="sysctl工具简介"><a href="#sysctl工具简介" class="headerlink" title="sysctl工具简介"></a>sysctl工具简介</h1><p>sysctl命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录<code>/proc/sys</code>中。它包含一些TCP/IP堆栈和虚拟内存系统的高级选项， 这可以让有经验的管理员提高引人注目的系统性能。用sysctl可以读取设置超过五百个系统变量。</p><p>通过sysctl工具有两种方式修改内核参数：</p><p>（1）直接使用sysctl命令</p><p>直接执行<code>sysctl -w key=value</code>命令去修改内核参数。需要注意，这种方式只在内存中有效，机器重启后就失效了。</p><p>（2）修改/etc/sysctl.conf配置文件</p><p>sysctl命令的配置文件是<code>/etc/sysctl.conf</code>，我们可以直接修改<code>/etc/sysctl.conf</code>这个配置文件，然后执行<code>sysctl -p</code>命令将配置文件中的内容加载到内存。建议使用这种方式，机器重启后仍然有效。</p><h1 id="命令使用格式"><a href="#命令使用格式" class="headerlink" title="命令使用格式"></a>命令使用格式</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl [options] parameters</span><br></pre></td></tr></table></figure><p>常用的选项：</p><pre><code>-w #当改变sysctl设置时使用此项-p #加载指定的配置文件中的内核参数，默认是/etc/sysctl.conf-a #打印当前所有可用的内核参数变量和值-A #以表格方式打印当前所有可用的内核参数变量和值</code></pre><h1 id="常用操作举例"><a href="#常用操作举例" class="headerlink" title="常用操作举例"></a>常用操作举例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a                           <span class="comment">#查看所有可读变量</span></span><br><span class="line">sysctl kernel.hostname              <span class="comment">#查看指定变量的设置，输出为key=value形式</span></span><br><span class="line">sysctl -n kernel.hostname           <span class="comment">#查看指定变量的设置，只输出变量的值</span></span><br><span class="line">sysctl -w kernel.hostname=testhost  <span class="comment">#修改的是内存中的主机名</span></span><br><span class="line">sysctl -p                           <span class="comment">#将sysctl.conf中的内核参数配置信息加载并应用到系统上</span></span><br></pre></td></tr></table></figure><p>学习资料来源于：<br><a href="http://man.linuxde.net/sysctl" target="_blank" rel="noopener">http://man.linuxde.net/sysctl</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中级联删除|级联更新|级联查询</title>
      <link href="/2019/03/14/MySQL%E4%B8%AD%E7%BA%A7%E8%81%94%E5%88%A0%E9%99%A4-%E7%BA%A7%E8%81%94%E6%9B%B4%E6%96%B0-%E7%BA%A7%E8%81%94%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/03/14/MySQL%E4%B8%AD%E7%BA%A7%E8%81%94%E5%88%A0%E9%99%A4-%E7%BA%A7%E8%81%94%E6%9B%B4%E6%96%B0-%E7%BA%A7%E8%81%94%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="级联删除和级联更新"><a href="#级联删除和级联更新" class="headerlink" title="级联删除和级联更新"></a>级联删除和级联更新</h1><p>级联删除或级联更新是为了保证数据完整性。有两种方式：</p><p>（1）外键实现</p><p>在外键上设置<code>ON DELETE CASCADE</code>或<code>ON UPDATE CASCADE</code>，实现级联更新或级联查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="string">`student_ibfk1`</span></span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> <span class="string">`sid`</span>(<span class="string">`sid`</span>) <span class="keyword">REFERENCES</span> <span class="string">`students`</span> (<span class="string">`id`</span>)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure><p>即当某个学生从数据库中删除了，会自动删除score表中该学生的成绩。</p><p>（2）触发器实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="string">`deleteScore`</span> <span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="string">`students`</span></span><br><span class="line"> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> <span class="keyword">sid</span>=OLD.<span class="string">`id`</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h1 id="级联查询"><a href="#级联查询" class="headerlink" title="级联查询"></a>级联查询</h1><p>通过JOIN/LEFT JOIN/RIGHT JOIN等来实现多表的级联查询。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计中关系映射（一对一|多对一|一对多|多对多）</title>
      <link href="/2019/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%AD%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%EF%BC%88%E4%B8%80%E5%AF%B9%E4%B8%80-%E5%A4%9A%E5%AF%B9%E4%B8%80-%E4%B8%80%E5%AF%B9%E5%A4%9A-%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%89/"/>
      <url>/2019/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%AD%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%EF%BC%88%E4%B8%80%E5%AF%B9%E4%B8%80-%E5%A4%9A%E5%AF%B9%E4%B8%80-%E4%B8%80%E5%AF%B9%E5%A4%9A-%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="关系映射"><a href="#关系映射" class="headerlink" title="关系映射"></a>关系映射</h1><p>在关系型数据库RDBMS中，存在如下几种关系：</p><pre><code>一对一一对多多对一多对多</code></pre><p>需要注意的是，这些都是概念上的关系，在真实的关系数据库中，只有外键的概念，并没有这几种关系。</p><h1 id="一对多或多对一"><a href="#一对多或多对一" class="headerlink" title="一对多或多对一"></a>一对多或多对一</h1><p>一对多和多对一是同一个概念，是同一回事。一对多的概念是一个对象A会对应多个对象B，而从B的角度看，也是多个对象B对应一个对象A。比如说班级和学生就是一对多关系。一个班级对应多个学生，一个学生只会对应一个班级。</p><p>一对多的关系比较常见，也很简单，因为在RDBMS中的外键其实就是表示一对多关系。对于一对多关系，我们只需要在“多”的这个表中建立“一”的外键关联即可，而“一”这边的表不需要做任何修改。比如前面说到的班级学生关系。班级表不变，学生表增加班级ID作为外键。</p><p><img src="/images/mysql_map_1_1.png" alt></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`class`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`class`</span> (</span><br><span class="line">  <span class="string">`classid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`location`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`classid`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`classid_UNIQUE`</span> (<span class="string">`classid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'班级表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`student`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`studentid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`classid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`studentid`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`classid_idx`</span> (<span class="string">`classid`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`classid`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`classid`</span>) <span class="keyword">REFERENCES</span> <span class="string">`class`</span> (<span class="string">`classid`</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'学生表'</span>;</span><br></pre></td></tr></table></figure><h1 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h1><p>多对多的关系在数据库设计时比一对一要常见，所以这里先说说多对多。多对多是一个对象A对应多个对象B，从B角度看，一个对象B也会对应多个对象A。比如说学生和课程的关系就是多对多关系。一个学生会学习多门课程，一门课程会有多个学生来选修。</p><p>在RDBMS中，必须使用“中间表”来表示多对多的关系。中间表我们可以分成两种，一种是纯粹表示关系的中间表，一种是表示中间实体的中间表。</p><p>（1）纯粹表示关系的中间表</p><p>纯粹表示关系的中间表很简单，只需要两列：AID和BID，AID以外键关联到A表的主键，BID以外键关联到B表的主键，然后这两个列组成联合主键。这个中间表纯粹是表示多对多关系而存在，在业务上不会有对应的实体与之对应。比如前面提到的学生和课程的关系，如果我们只需要知道哪些学生上哪些课，哪些课有哪些学生选，不需要有更多的信息的情况下，我们就可以建立“学生课程”中间表，里面只有学生ID和课程ID两个字段。</p><p>（2）中间实体的中间表</p><p>中间实体是在纯粹的中间关系表的基础上，加上了更多的属性，从而形成了一个新的实体。比如前面提到的学生和课程的关系，如果我们需要记录学生选课的时间、学生选择这门课程后的考试成绩，那么我们就像建立一个“选课”实体，该实体具有如下属性：</p><pre><code>选课ID，主键学生ID，与学生表做外键关联课程ID，与课程表做外键关联选课时间，DateTime类型考试成绩，记录选修该课程后考试的最终成绩</code></pre><p>这就是一个中间实体，已经完全脱离了普通的多对多关系中间表，而变成一个实体的形式的存在，所以按照前面博客中讲到的主键设计的原则，我们可以单独建立一个选课ID的列作为数据库的主键，该主键本身并没有业务含义。</p><p><img src="/images/mysql_map_1_2.png" alt></p><h1 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h1><p>一对一概念上是说一个对象A最多对应一个对象B，从B角度看，也是一个对象B最多对应一个对象A。比如说班主任和班级的关系，一个班主任最多管理一个班级，一个班级也最多只有一个班主任。</p><p>一对一的关系在数据库设计中，是使用的最少的关系，因为一般来说，如果两个实体是一对多关系，那么我们也可以把这两个实体合并成一个实体。但是在设计中，我们仍然会遇到两个完全不同的实体，之间存在一对一关系。</p><p>一对一的RDBMS实现是在其中的一个表上建立外键指向另一个表，同时在该外键列上建立唯一约束。比如前面说到的班主任和班级关系，我们可以在班级表建立班主任字段，然后再在该字段建立唯一约束。因为每个班都会有班主任，所以班主任字段是不允许为空的。一个教师可以当某个班的班主任，也可以不当任和班的班主任，同时也不可能在班级表的班主任字段上出现两次，所以最多就当一个班的班主任，所以该设计满足需求。</p><p>那么我们可不可以反过来，在教师表中建立所管理的班级Id字段，指向班级表，并建立唯一约束呢？除了不满足“每个班必然有一个班主任”这个业务约束外，其他都没有问题。所以如果对于一对一的情况，如果那边必须要求持有另一边，则就在哪边增加外键字段；如果没有要求必须持有一个另一类实体的话，就哪边添加外键列都行。</p><p><img src="/images/mysql_map_1_3.png" alt></p><p>学习资料参考于：<br><a href="http://www.cnblogs.com/studyzy/p/3309782.html" target="_blank" rel="noopener">http://www.cnblogs.com/studyzy/p/3309782.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库中多表查询操作</title>
      <link href="/2019/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="简单多表查询"><a href="#简单多表查询" class="headerlink" title="简单多表查询"></a>简单多表查询</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TableA.name, TableA.sex, TableB.income, TableB.dscrept <span class="keyword">FROM</span> TableA a, TableB b <span class="keyword">where</span> a.name = b.name;</span><br></pre></td></tr></table></figure><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><h2 id="MySQL子查询简介"><a href="#MySQL子查询简介" class="headerlink" title="MySQL子查询简介"></a>MySQL子查询简介</h2><p>子查询是在MySQL中经常使用到的一个操作，不仅仅是用在DQL语句中，在DDL语句、DML语句中也都会常用到子查询。所谓子查询是将一个查询语句嵌套在另一个查询语句中。在特定情况下，一个查询语句的条件需要另一个查询语句来获取，内层查询（inner query）语句的查询结果，可以为外层查询（outer query）语句提供查询条件。</p><h2 id="MySQL子查询的分类"><a href="#MySQL子查询的分类" class="headerlink" title="MySQL子查询的分类"></a>MySQL子查询的分类</h2><p>按子查询（select语句）在外部查询（select语句）出现的位置的不同可以分为：</p><pre><code>from子查询，即子查询跟在from之后where子查询，即子查询出现在where条件中exists子查询，即子查询出现在exists里面in子查询，即子查询出现在in里面</code></pre><p>根据子查询得到的数据进行分类，可以分为：</p><pre><code>标量子查询，即子查询得到的结果是一行一列列子查询，即子查询得到的结构是一列多行行子查询，即子查询的得到的结果是一行多列(也可以是多行多列)表子查询，即子查询得到的结果是多行多列</code></pre><h2 id="MySQL子查询的举例"><a href="#MySQL子查询的举例" class="headerlink" title="MySQL子查询的举例"></a>MySQL子查询的举例</h2><p>（1）from子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> tb_student <span class="keyword">order</span> <span class="keyword">by</span> height <span class="keyword">desc</span>) <span class="keyword">as</span> t <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">class</span>;</span><br></pre></td></tr></table></figure><p>（2）where子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> s_user <span class="keyword">where</span> user_birthday = (<span class="keyword">select</span> <span class="keyword">MAX</span>(user_birthday) <span class="keyword">from</span> s_user ) <span class="keyword">and</span> user_salary = (<span class="keyword">select</span> <span class="keyword">MAX</span>(user_salary) <span class="keyword">from</span> s_user);</span><br></pre></td></tr></table></figure><p>（3）exists子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> d_name <span class="keyword">from</span> department <span class="keyword">where</span> d_id=<span class="number">1004</span>);  <span class="comment">--内层循环并没有查询到满足条件的结果，因此返回false，外层查询不执行</span></span><br></pre></td></tr></table></figure><p>（4）in子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> d_id <span class="keyword">in</span> (<span class="keyword">select</span> d_id <span class="keyword">from</span> department);</span><br></pre></td></tr></table></figure><h1 id="JOIN操作"><a href="#JOIN操作" class="headerlink" title="JOIN操作"></a>JOIN操作</h1><p>包括INNER JOIN/LEFT JOIN/RIGHT JOIN/FULL JOIN等，具体内容参见<a href="https://wangjianno1.github.io/2019/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%BF%9E%E6%8E%A5JOIN%E6%93%8D%E4%BD%9C/">《数据库表连接JOIN操作》</a></p><h1 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h1><h2 id="并集操作"><a href="#并集操作" class="headerlink" title="并集操作"></a>并集操作</h2><p><img src="/images/mysql_set_1_1.png" alt></p><p>在大多数开发中，使用一条select查询就会返回一个结果集。如果，我们想一次性查询多条SQL语句，并将每一条select查询的结果合并成一个结果集返回。就需要用到Union操作符，将多个select语句组合起来，这种查询被称为并（Union）。举例来说，假设现在两张表，分别是websites和apps，内容如下：</p><p><img src="/images/mysqlunion_1_1.png" alt></p><p>如下是使用union和union all来查询的效果图。union默认会将多个select结果中重复的记录只保留一条，而union all会保留重复的记录：</p><p><img src="/images/mysqlunion_1_2.png" alt></p><p>在使用union或union all时，每个select查询子句必须包含相同的列、表达式或者聚合函数 ，但列名称可以不一样。union查询在遇到不一致的字段名称时，会使用第一条select的查询字段名称，或者可以使用别名来改变查询字段名称，如下：</p><p><img src="/images/mysqlunion_1_3.png" alt></p><h2 id="交集操作"><a href="#交集操作" class="headerlink" title="交集操作"></a>交集操作</h2><p><img src="/images/mysql_set_1_2.png" alt></p><h2 id="差集操作"><a href="#差集操作" class="headerlink" title="差集操作"></a>差集操作</h2><p><img src="/images/mysql_set_1_3.png" alt></p><p>备注：在上面的“并集”、“交集”以及“差集”操作中，前后子查询的结果集中包含的字段是一样的，不过这种集合操作在实际项目中使用的并不多。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库表连接JOIN操作</title>
      <link href="/2019/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%BF%9E%E6%8E%A5JOIN%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%BF%9E%E6%8E%A5JOIN%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="表连接JOIN操作简介"><a href="#表连接JOIN操作简介" class="headerlink" title="表连接JOIN操作简介"></a>表连接JOIN操作简介</h1><p>在关系型数据库中，JOIN本质上是基于两个或者多个表进行结合重构成一种大表的过程。其创造的结果可以被保存为一个表（table）或是作为一个表来使用。这个结合的过程的基础，或者说联系点，是存在于两个表之间的共同的列。一般来说，ANSI标准的SQL定义了如下这些JOIN操作类型：</p><pre><code>INNER JOIN，指内连接LEFT OUTER JOIN，指左连接RIGHT OUTER JOIN，指右连接FULL OUTER JOIN，指全连接CROSS JOIN，指交叉连接</code></pre><p>备注：其中INNER JOIN属于内连接，LEFT OUTER JOIN、RIGHT OUTER JOIN以及FULL OUTER JOIN属于外连接。</p><h1 id="维恩图解释表连接JOIN"><a href="#维恩图解释表连接JOIN" class="headerlink" title="维恩图解释表连接JOIN"></a>维恩图解释表连接JOIN</h1><p>很多文章采用维恩图（两个圆的集合运算），解释不同数据库连接JOIN的差异。如下图：</p><p><img src="/images/mysql_join_1_1.png" alt></p><p>需要说明的是，用集合操作的方式并不能恰当的解释数据库JOIN操作，因为集合操作中，需要各个集合中的元素是同类型的。而执行数据库连接JOIN操作的不同数据表的结构并不是一样的哦，真正的集合操作见<a href="https://wangjianno1.github.io/2019/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/">《数据库中多表查询操作》</a>。因此下面还有更恰当的解释方法。</p><h1 id="笛卡尔乘积解释表连接JOIN"><a href="#笛卡尔乘积解释表连接JOIN" class="headerlink" title="笛卡尔乘积解释表连接JOIN"></a>笛卡尔乘积解释表连接JOIN</h1><h2 id="笛卡尔积的概念"><a href="#笛卡尔积的概念" class="headerlink" title="笛卡尔积的概念"></a>笛卡尔积的概念</h2><p><img src="/images/mysql_join_1_2.png" alt></p><h2 id="交叉连接CROSS-JOIN"><a href="#交叉连接CROSS-JOIN" class="headerlink" title="交叉连接CROSS JOIN"></a>交叉连接CROSS JOIN</h2><p>交叉连接CROSS JOIN是一种特殊的连接，指的是表A和表B不存在关联字段，这时表A（共有n条记录）与表B（共有m条记录）连接后，会产生一张包含<code>n x m</code>条记录的新表。</p><p><img src="/images/mysql_join_1_3.png" alt></p><p>需要说明的是，交叉连接是其他各种连接的基础，其他各种连接可以简单理解为<strong>“加上了筛选条件的交叉连接”</strong>。</p><h2 id="其他各种连接"><a href="#其他各种连接" class="headerlink" title="其他各种连接"></a>其他各种连接</h2><p><img src="/images/mysql_join_1_4.png" alt></p><h1 id="各种数据库JOIN操作语法举例"><a href="#各种数据库JOIN操作语法举例" class="headerlink" title="各种数据库JOIN操作语法举例"></a>各种数据库JOIN操作语法举例</h1><p>（1）内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TableA a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> TableB b <span class="keyword">ON</span> a.name = b.name;       <span class="comment">--INNER可以省略</span></span><br></pre></td></tr></table></figure><p>备注：TableA和TableB做完笛卡尔积之后，只有满足a.name = b.name的记录才是内连接的结果。</p><p>（2）左连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TableA a <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> TableB b <span class="keyword">ON</span> a.name = b.name;  <span class="comment">--OUTER可以省略</span></span><br></pre></td></tr></table></figure><p>备注：TableA和TableB做完笛卡尔积之后，除了满足a.name = b.name的记录是左连接的结果外，再加上TableA中没有被匹配上的记录（这块没有TableB的字段）。</p><p>（3）右连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TableA a <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> TableB b <span class="keyword">ON</span> a.name = b.name; <span class="comment">--OUTER可以省略</span></span><br></pre></td></tr></table></figure><p>备注：TableA和TableB做完笛卡尔积之后，除了满足a.name = b.name的记录是由连接的结果外，再加上TableB中没有被匹配上的记录（这块没有TableA的字段）。</p><p>（4）全连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TableA a <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> TableB b <span class="keyword">ON</span> a.name = b.name;  <span class="comment">--OUTER可以省略</span></span><br></pre></td></tr></table></figure><p>备注：TableA和TableB做完笛卡尔积之后，除了满足a.name = b.name的记录是全连接的结果外，再加上TableA中没有被匹配上的记录（这块没有TableB的字段），再加上TableB中没有被匹配上的记录（这块没有TableA的字段）。</p><p>另外，在JOIN操作的SQL语句后面还可以加上where从句，进一步过滤查询结果，举例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TableA a <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> TableB b <span class="keyword">ON</span> a.name = b.name <span class="keyword">WHERE</span> b.name <span class="keyword">IS</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://www.ruanyifeng.com/blog/2019/01/table-join.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/01/table-join.html</a><br><a href="https://coolshell.cn/articles/3463.html/comment-page-1" target="_blank" rel="noopener">https://coolshell.cn/articles/3463.html/comment-page-1</a><br><a href="https://blog.jooq.org/2016/07/05/say-no-to-venn-diagrams-when-explaining-joins/" target="_blank" rel="noopener">https://blog.jooq.org/2016/07/05/say-no-to-venn-diagrams-when-explaining-joins/</a><br><a href="https://www.jianshu.com/p/9e1d3793cba6" target="_blank" rel="noopener">https://www.jianshu.com/p/9e1d3793cba6</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见的虚拟化解决方案</title>
      <link href="/2019/03/10/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/03/10/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的操作系统虚拟化解决方案"><a href="#常见的操作系统虚拟化解决方案" class="headerlink" title="常见的操作系统虚拟化解决方案"></a>常见的操作系统虚拟化解决方案</h1><pre><code>Virtual Machine技术，例如Xen、VMware、KVM以及VirtualBox等DockerBorg/KubernetesMesos.....</code></pre><p>其实，像Borg、Mesos及Yarn等等这些东东，其实是一类东西，称为集群资源管理和调度的工具平台。而这些平台也各自包含了一些特有的功能。而Docker的侧重点则在于轻量级虚拟化的解决方案。</p><h1 id="VM技术与Docker类技术的差别"><a href="#VM技术与Docker类技术的差别" class="headerlink" title="VM技术与Docker类技术的差别"></a>VM技术与Docker类技术的差别</h1><p>综合来说，VM是比较重量级。而Docker是轻量级的操作系统虚拟化解决方案。</p><p>（1）Virtual Machine</p><p><img src="/images/virtualization_1_2.png" alt></p><p>（2）Docker类</p><p><img src="/images/virtualization_1_3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Virtualization </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机器监视器Hypervisor简介</title>
      <link href="/2019/03/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%99%A8%E7%9B%91%E8%A7%86%E5%99%A8Hypervisor%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/03/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%99%A8%E7%9B%91%E8%A7%86%E5%99%A8Hypervisor%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h1><p>Hypervisor，又称虚拟机器监视器，全称为Virtual Machine Monitor，缩写为VMM。虚拟化就是通过某种方式隐藏底层物理硬件的过程，从而让多个操作系统可以透明地使用和共享它。这种架构的另一个更常见的名称是平台虚拟化。在典型的分层架构中，提供平台虚拟化的层称为Hypervisor（有时称为虚拟机管理程序或VMM）。来宾操作系统称为虚拟机（VM），因为对这些VM而言，硬件是专门针对它们虚拟化的。</p><h1 id="Hypervisor的两种类型"><a href="#Hypervisor的两种类型" class="headerlink" title="Hypervisor的两种类型"></a>Hypervisor的两种类型</h1><h2 id="本地或裸机Hypervisor"><a href="#本地或裸机Hypervisor" class="headerlink" title="本地或裸机Hypervisor"></a>本地或裸机Hypervisor</h2><p>这些虚拟机管理程序直接运行在主机的硬件来控制硬件和管理客体操作系统上，如Xen、KVM等。</p><h2 id="Hosted-Hypervisor"><a href="#Hosted-Hypervisor" class="headerlink" title="Hosted Hypervisor"></a>Hosted Hypervisor</h2><p>这些虚拟机管理程序运行在传统的操作系统上，就像其他计算机程序那样运行。例如VMware Workstation、QEMU及WINE等。</p><p><img src="/images/virtualization_1_1.png" alt></p><p>学习资料来源于：<br><a href="http://www.ibm.com/developerworks/cn/linux/l-hypervisor/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/l-hypervisor/</a><br><a href="https://zh.wikipedia.org/wiki/Hypervisor" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Hypervisor</a></p>]]></content>
      
      
      <categories>
          
          <category> Virtualization </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux任务组物理资源限制机制cgroup</title>
      <link href="/2019/03/10/Linux%E4%BB%BB%E5%8A%A1%E7%BB%84%E7%89%A9%E7%90%86%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E6%9C%BA%E5%88%B6cgroup/"/>
      <url>/2019/03/10/Linux%E4%BB%BB%E5%8A%A1%E7%BB%84%E7%89%A9%E7%90%86%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E6%9C%BA%E5%88%B6cgroup/</url>
      
        <content type="html"><![CDATA[<h1 id="cgroup简介"><a href="#cgroup简介" class="headerlink" title="cgroup简介"></a>cgroup简介</h1><p>cgroup是control groups的缩写，是Linux内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如CPU、Memory及I/O等等）的机制。cgroups也是LXC为实现虚拟化所使用的资源管理手段。</p><p>cgroup提供了一个cgroup虚拟文件系统，作为进行分组管理和各子系统设置的用户接口。要使用cgroup，必须挂载cgroup文件系统。这时通过挂载选项指定使用哪个子系统。</p><p>Linux使用了多种数据结构在内核中实现了cgroups的配置，关联了进程和cgroups节点，那么Linux又是如何让用户态的进程使用到cgroups的功能呢？Linux内核有一个很强大的模块叫VFS（Virtual File System）。VFS能够把具体文件系统的细节隐藏起来，给用户态进程提供一个统一的文件系统API接口。cgroups也是通过VFS把功能暴露给用户态的，cgroups与VFS之间的衔接部分称之为cgroups文件系统。</p><h1 id="常见的cgroup子系统"><a href="#常见的cgroup子系统" class="headerlink" title="常见的cgroup子系统"></a>常见的cgroup子系统</h1><pre><code>blkio   #这个子系统为块设备设定输入/输出限制，比如物理设备（磁盘，固态硬盘，USB等等）cpu     #这个子系统使用调度程序提供对CPU的cgroup任务访问cpuacct #这个子系统自动生成cgroup中任务所使用的CPU报告cpuset  #这个子系统为cgroup中的任务分配独立CPU（在多核系统）和内存节点devices #这个子系统可允许或者拒绝cgroup中的任务访问设备freezer #这个子系统挂起或者恢复cgroup中的任务memory  #这个子系统设定cgroup中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告net_cls #这个子系统使用等级识别符（classid）标记网络数据包，可允许Linux流量控制程序（tc）识别从具体cgroup中生成的数据包ns      #名称空间子系统</code></pre><h1 id="cgroup层级图"><a href="#cgroup层级图" class="headerlink" title="cgroup层级图"></a>cgroup层级图</h1><p>假设我们将cpu子系统mount到了<code>/cgroup/cpu</code>上，memory子系统mount到了<code>/cgroup/memory</code>等等，那<code>/cgroup/cpu</code>和<code>/cgroup/memory</code>称为root-cgroup，该cgroup的资源限制策略对<code>/cgroup/cpu</code>和<code>/cgroup/memory</code>目录中tasks文件以及cgroup.procs文件中的进程ID和线程ID有效。我们还可以在<code>/cgroup/cpu</code>和<code>/cgroup/memory</code>下mkdir新的目录xx，以及xx的子目录，那么将形成新的子cgroup，子cgroup对相应的tasks文件以及cgroup.procs文件中的进程ID和线程ID有效。</p><p><img src="/images/linux_cgroups_1_1.png" alt></p><h1 id="其他闲杂知识"><a href="#其他闲杂知识" class="headerlink" title="其他闲杂知识"></a>其他闲杂知识</h1><p>（1）使用<code>cat /proc/cgroups</code>可以查看当前系统中开启了哪些子系统。</p><p>（2）使用<code>cat /proc/${pid}/cgroup</code>可以查看进程号为pid的进程处在哪个cgroup中。</p><p>学习资料参考于：<br><a href="http://xiezhenye.com/2013/10/linux-cgroups-%E6%A6%82%E8%BF%B0.html" target="_blank" rel="noopener">《linux cgroups概述》</a><br><a href="http://xiezhenye.com/2013/10/%e7%94%a8-cgroups-%e7%ae%a1%e7%90%86-cpu-%e8%b5%84%e6%ba%90.html" target="_blank" rel="noopener">《用cgroups管理CPU资源》</a><br><a href="http://xiezhenye.com/2013/10/%e7%94%a8-cgroups-%e7%ae%a1%e7%90%86%e8%bf%9b%e7%a8%8b%e7%a3%81%e7%9b%98-io.html" target="_blank" rel="noopener">《用cgroups管理进程磁盘IO》</a><br><a href="http://xiezhenye.com/2013/10/%e7%94%a8-cgruops-%e7%ae%a1%e7%90%86%e8%bf%9b%e7%a8%8b%e5%86%85%e5%ad%98%e5%8d%a0%e7%94%a8.html" target="_blank" rel="noopener">《用cgruops管理进程内存占用》</a><br><a href="http://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Virtualization </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中环境隔离机制NameSpace小结</title>
      <link href="/2019/03/10/Linux%E4%B8%AD%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6NameSpace%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/10/Linux%E4%B8%AD%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6NameSpace%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="NameSpace简介"><a href="#NameSpace简介" class="headerlink" title="NameSpace简介"></a>NameSpace简介</h1><p>Linux NameSpace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式，chroot内部的文件系统无法访问外部的内容。Linux NameSpace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。</p><pre><code>PID NameSpaceNET NameSpaceIPC NameSpaceMNT NameSpace，类似于chrootUTS NameSpaceuser NameSpace</code></pre><h1 id="NameSpace的具体实现"><a href="#NameSpace的具体实现" class="headerlink" title="NameSpace的具体实现"></a>NameSpace的具体实现</h1><p>当调用clone时，设定了CLONE_NEWPID，就会创建一个新的PID NameSpace，clone出来的新进程将成为NameSpace里的第一个进程。一个PID NameSpace为进程提供了一个独立的PID环境，PID NameSpace内的PID将从1开始，在NameSpace内调用fork，vfork或clone都将产生一个在该NameSpace内独立的PID。新创建的NameSpace里的第一个进程在该NameSpace内的PID将为1，就像一个独立的系统里的init进程一样。该NameSpace内的孤儿进程都将以该进程为父进程，当该进程被结束时，该NameSpace内所有的进程都会被结束。PID NameSpace是层次性，新创建的NameSpace将会是创建该NameSpace的进程属于的NameSpace的子NameSpace。子NameSpace中的进程对于父NameSpace是可见的，一个进程将拥有不止一个PID，而是在所在的NameSpace以及所有直系祖先NameSpace中都将有一个PID。系统启动时，内核将创建一个默认的PID NameSpace，该NameSpace是所有以后创建的NameSpace的祖先，因此系统所有的进程在该NameSpace都是可见的。</p><p>当调用clone时，设定了CLONE_NEWIPC，就会创建一个新的IPC NameSpace，clone出来的进程将成为NameSpace里的第一个进程。一个IPC NameSpace有一组System V IPC objects标识符构成，这标识符有IPC相关的系统调用创建。在一个IPC NameSpace里面创建的IPC object对该NameSpace内的所有进程可见，但是对其他NameSpace不可见，这样就使得不同NameSpace之间的进程不能直接通信，就像是在不同的系统里一样。当一个IPC NameSpace被销毁，该NameSpace内的所有IPC object会被内核自动销毁。</p><p>PID NameSpace和IPC NameSpace可以组合起来一起使用，只需在调用clone时，同时指定CLONE_NEWPID和CLONE_NEWIPC，这样新创建的NameSpace既是一个独立的PID空间又是一个独立的IPC空间。不同NameSpace的进程彼此不可见，也不能互相通信，这样就实现了进程间的隔离。</p><p>当调用clone时，设定了CLONE_NEWNS，就会创建一个新的mount NameSpace。每个进程都存在于一个mount NameSpace里面，mount NameSpace为进程提供了一个文件层次视图。如果不设定这个flag，子进程和父进程将共享一个mount NameSpace，其后子进程调用mount或umount将会影响到所有该NameSpace内的进程。如果子进程在一个独立的mount NameSpace里面，就可以调用mount或umount建立一份新的文件层次视图。该flag配合pivot_root系统调用，可以为进程创建一个独立的目录空间。</p><p>当调用clone时，设定了CLONE_NEWNET，就会创建一个新的Network NameSpace。一个Network NameSpace为进程提供了一个完全独立的网络协议栈的视图。包括网络设备接口，IPv4和IPv6协议栈，IP路由表，防火墙规则，sockets等等。一个Network NameSpace提供了一份独立的网络环境，就跟一个独立的系统一样。一个物理设备只能存在于一个Network NameSpace中，可以从一个NameSpace移动另一个NameSpace中。虚拟网络设备(virtual network device)提供了一种类似管道的抽象，可以在不同的NameSpace之间建立隧道。利用虚拟化网络设备，可以建立到其他NameSpace中的物理设备的桥接。当一个Network NameSpace被销毁时，物理设备会被自动移回init Network NameSpace，即系统最开始的NameSpace。</p><p>当调用clone时，设定了CLONE_NEWUTS，就会创建一个新的UTS NameSpace。一个UTS NameSpace就是一组被uname返回的标识符。新的UTS NameSpace中的标识符通过复制调用进程所属的NameSpace的标识符来初始化。Clone出来的进程可以通过相关系统调用改变这些标识符，比如调用sethostname来改变该NameSpace的hostname。这一改变对该NameSpace内的所有进程可见。CLONE_NEWUTS和CLONE_NEWNET一起使用，可以虚拟出一个有独立主机名和网络空间的环境，就跟网络上一台独立的主机一样。</p><p>以上所有clone flag都可以一起使用，为进程提供了一个独立的运行环境。LXC正是通过在clone时设定这些flag，为进程创建一个有独立PID，IPC，FS，Network，UTS空间的container。一个container就是一个虚拟的运行环境，对container里的进程是透明的，它会以为自己是直接在一个系统上运行的。</p><p>一个container就像传统虚拟化技术里面的一台安装了OS的虚拟机，但是开销更小，部署更为便捷。</p><p>参考资料来源于：<br><a href="http://www.cnblogs.com/lisperl/archive/2012/05/03/2480316.html" target="_blank" rel="noopener">http://www.cnblogs.com/lisperl/archive/2012/05/03/2480316.html</a><br><a href="http://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">http://coolshell.cn/articles/17010.html</a><br><a href="http://coolshell.cn/articles/17029.html" target="_blank" rel="noopener">http://coolshell.cn/articles/17029.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Virtualization </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell中控制逻辑语句小结</title>
      <link href="/2019/03/06/Shell%E4%B8%AD%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/06/Shell%E4%B8%AD%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><h2 id="if-then式"><a href="#if-then式" class="headerlink" title="if-then式"></a>if-then式</h2><p>if-then式的结构形式如下：                 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [条件表达式1]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment">#当条件表达式1成立时，可以进行的命令工作内容</span></span><br><span class="line"><span class="keyword">elif</span> [条件表达式2]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment">#当条件表达式2成立时，可以进行的命令工作内容</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">#当条件表达式1和2均不成立时，可以进行的命令工作内容</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>if-then式举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Please input (Y/N): "</span> yn</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ X<span class="string">"<span class="variable">$yn</span>"</span> == X<span class="string">"Y"</span> ] || [ X<span class="string">"<span class="variable">$yn</span>"</span> == X<span class="string">"y"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"OK, continue..."</span></span><br><span class="line"><span class="keyword">elif</span> [ X<span class="string">"<span class="variable">$yn</span>"</span> == X<span class="string">"N"</span> ] || [ X<span class="string">"<span class="variable">$yn</span>"</span> == X<span class="string">"n"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Oh, interrupt!"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"I don't know what your choice is"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="case-esac式"><a href="#case-esac式" class="headerlink" title="case-esac式"></a>case-esac式</h2><p>case-esac式的结构形式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> X<span class="variable">$variable</span> <span class="keyword">in</span></span><br><span class="line">   X<span class="string">"第一个变量内容"</span>)</span><br><span class="line">        <span class="comment">#程序段</span></span><br><span class="line">        ;;</span><br><span class="line">   X<span class="string">"第二个变量内容"</span>)</span><br><span class="line">        <span class="comment">#程序段</span></span><br><span class="line">        ;;</span><br><span class="line">   *)</span><br><span class="line">        <span class="comment">#程序段</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>case-esac式举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">case</span> X<span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    X<span class="string">"hello"</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Hello,how are you?"</span></span><br><span class="line">        ;;</span><br><span class="line">    X<span class="string">"world"</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"You must input parameter,ex&gt; &#123;<span class="variable">$0</span> someword&#125;"</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Usage <span class="variable">$0</span> &#123;hello&#125;"</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="while-do-done式"><a href="#while-do-done式" class="headerlink" title="while-do-done式"></a>while-do-done式</h2><p>while-do-done式的结构形式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ 条件表达式 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment">#程序段</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>while-do-done式举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ X<span class="string">"<span class="variable">$yn</span>"</span> != X<span class="string">"yes"</span> -a X<span class="string">"<span class="variable">$yn</span>"</span> != X<span class="string">"YES"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">"Please input yes/YES to stop this program: "</span> yn</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"OK! you input the correct answer."</span></span><br></pre></td></tr></table></figure><h2 id="until-do-done式"><a href="#until-do-done式" class="headerlink" title="until-do-done式"></a>until-do-done式</h2><p>until-do-done式的结构形式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [条件表达式]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment">#程序段</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>until-do-done式举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">until [ X<span class="string">"<span class="variable">$yn</span>"</span> == X<span class="string">"yes"</span> -a X<span class="string">"<span class="variable">$yn</span>"</span> == X<span class="string">"YES"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">"Please input yes/YES to stop this program: "</span> yn</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"OK! you input the correct answer."</span></span><br></pre></td></tr></table></figure><h2 id="for-do-done固定循环式"><a href="#for-do-done固定循环式" class="headerlink" title="for-do-done固定循环式"></a>for-do-done固定循环式</h2><p>for-do-done固定循环式的结构形式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> cond1 cond2 cond3 ...</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment">#程序段</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>for-do-done固定循环式举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> $(seq 1 14)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The number is: <span class="variable">$variable</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="for-do-done数值处理式"><a href="#for-do-done数值处理式" class="headerlink" title="for-do-done数值处理式"></a>for-do-done数值处理式</h2><p>for-do-done数值处理式的结构形式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>((初始值; 限制条件; 执行步长))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment">#程序段</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>for-do-done数值处理式举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line">sum=0;</span><br><span class="line"><span class="keyword">for</span>((i=1; i&lt;=100; i=i+1))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sum=$((sum+<span class="variable">$i</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The sum is: <span class="variable">$sum</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">for</span>((i=1; i&lt;=100; i=$((<span class="variable">$i</span>+1))))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sum=$((sum+<span class="variable">$i</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The sum is: <span class="variable">$sum</span>"</span></span><br></pre></td></tr></table></figure><p>其中，#1和#2经过验证都是正确的。可为什么在#1中执行步长可以写成<code>i=i+1</code>呢？严格来说是<code>i=$(($i+1))</code>的啊。难道说，这里的i相当于是<code>declare -i i</code>吗？待确认。</p><h1 id="循环遍历实践举例"><a href="#循环遍历实践举例" class="headerlink" title="循环遍历实践举例"></a>循环遍历实践举例</h1><p>（1）遍历目录下面有哪些文件或目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> ./*               <span class="comment">#遍历当前目录下有哪些文件或目录</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *                 <span class="comment">#同上</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls -1 pack_wzj`  <span class="comment">#遍历目录pack_wzj下有哪些文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $(ls -1 pack_wzj) <span class="comment">#同上</span></span><br></pre></td></tr></table></figure><p>（2）遍历文件中内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $(cat list)  <span class="comment">#逐行遍历文件list中的内容</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `cat list`   <span class="comment">#同上</span></span><br><span class="line"></span><br><span class="line">cat list | <span class="keyword">while</span> <span class="built_in">read</span> _line  <span class="comment">#同上</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$_line</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> _line <span class="comment">#同上，如果list文件中有多列，此处_line可以写成多个变量，例如while read name age;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$_line</span></span><br><span class="line"><span class="keyword">done</span> &lt; list</span><br></pre></td></tr></table></figure><p>（3）使用for快速批量处理命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> `cat hostlist`; <span class="keyword">do</span> ssh <span class="variable">$x</span> <span class="string">"cd /home/wahaha/ $$ ls -1 | tail -1"</span>; <span class="keyword">done</span>      <span class="comment">#串行</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> `cat hostlist`; <span class="keyword">do</span> ( ssh <span class="variable">$x</span> <span class="string">"cd /home/wahaha/ &amp;&amp; ls -l | tail -1"</span> )&amp; <span class="keyword">done</span>  <span class="comment">#并行</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> `cat hostlist`; <span class="keyword">do</span> &#123; ssh <span class="variable">$x</span> <span class="string">"cd /home/wahaha/ &amp;&amp; ls -l | tail -1"</span>; &#125;&amp; <span class="keyword">done</span> <span class="comment">#并行</span></span><br></pre></td></tr></table></figure><p>（4）使用while快速批量处理命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep -v grep | awk <span class="string">'&#123;print $2&#125;'</span> | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> <span class="built_in">kill</span> -9 <span class="variable">$line</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>备注：while read line这种形式，循环体内不能是ssh登录哦，否则只能登录一台，用上面的for循环就好了。</p><h1 id="关于条件表达式闲杂知识"><a href="#关于条件表达式闲杂知识" class="headerlink" title="关于条件表达式闲杂知识"></a>关于条件表达式闲杂知识</h1><p>if中的条件判断式用的就是<code>[ ]</code>判断符号，因为<code>[ ]</code>用户和test命令几乎一样，所以如果不知道<code>[ ]</code>中某个符号的含义，就是man test看看喽。</p><p>多个条件形成一个复合表达式的方式有两种：</p><p>（1）写在一个<code>[ ]</code>内，例如<code>[ exp1 -o exp2 ]</code></p><p>（2）通过逻辑操作符连接多个<code>[ ]</code>，例如<code>[ exp1 ] || [ exp2 ]</code>，<code>[ exp1 ] &amp;&amp; [ exp2 ]</code></p><p><code>[ &quot;$variable&quot; == &quot;Y&quot; -o &quot;$variable&quot; == &quot;y&quot;]</code>与<code>[ &quot;$variable&quot; == &quot;Y&quot; ] || [ &quot;$variable&quot; == &quot;y&quot; ]</code>的含义是一样的。</p><p><code>[ exp1 ] || [ exp2 ]</code>，<code>[ exp1 ] &amp;&amp; [ exp2 ]</code>中的<code>||</code>，<code>&amp;&amp;</code>与<code>cmd1 || cmd2</code>，<code>cmd1 &amp;&amp; cmd2</code>中的<code>||</code>，<code>&amp;&amp;</code> 意涵是不一样的。在<code>[ exp1 ] || [ exp2 ]</code>，<code>[ exp1 ] &amp;&amp; [ exp2 ]</code>中<code>||</code>，<code>&amp;&amp;</code>是逻辑操作符的含义。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx中四层负载均衡stream模块介绍</title>
      <link href="/2019/03/06/Nginx%E4%B8%AD%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1stream%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/03/06/Nginx%E4%B8%AD%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1stream%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>Nginx从1.9.0开始发布<code>ngx_stream_*_module</code>模块，该模块支持TCP代理及负载均衡。注意和HTTP七层代理和负载均衡区别开来，stream模块是在四层上做的负载均衡哦。举个使用stream模块的Nginx的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">worker_processes auto;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_log /var/log/nginx_error.log info;</span><br><span class="line"></span><br><span class="line">stream &#123;</span><br><span class="line">    upstream mysqld &#123;</span><br><span class="line">        hash $remote_addr consistent;</span><br><span class="line">        server 192.168.1.42:3306 weight=5 max_fails=1 fail_timeout=10s;</span><br><span class="line">        server 192.168.1.43:3306 weight=5 max_fails=1 fail_timeout=10s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 3306;</span><br><span class="line">        proxy_connect_timeout 1s;</span><br><span class="line">        proxy_timeout 3s;</span><br><span class="line">        proxy_pass mysqld;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：如上是用Nginx对后端的MySQL服务进行四层代理和负载均衡。</p><p>学习资料参考于：<br><a href="http://www.10tiao.com/html/357/201703/2247484964/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/357/201703/2247484964/1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx基本配置和最佳实践</title>
      <link href="/2019/03/05/Nginx%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/03/05/Nginx%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx配置文件结构"><a href="#Nginx配置文件结构" class="headerlink" title="Nginx配置文件结构"></a>Nginx配置文件结构</h1><p>Nginx的配置文件分为如下几个部分：</p><p>（1）全局配置</p><p>这是一些nginx的全局配置，例如user、worker_processes等配置。</p><p>（2）event配置</p><p>event主要用来定义Nginx的工作模块。</p><p>（3）http配置</p><p>http配置主要是提供一些web功能。例如http中包括了server配置，而server就是用来设置虚拟主机的，可以为Nginx配置多个server。</p><p>Nginx的主配置文件的大致结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#设置用户组</span><br><span class="line">user nobody;</span><br><span class="line">#启动子进程数</span><br><span class="line">worker_processes 2;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    #每个进程可以处理的连接数，受系统文件句柄的限制</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    #mine.types为文件类型定义文件</span><br><span class="line">    include mine.types;</span><br><span class="line">    #是否采取压缩功能，将页面压缩后传输更节省流量</span><br><span class="line">    gzip on;</span><br><span class="line">    #使用sever定义虚拟主机</span><br><span class="line">    server &#123;</span><br><span class="line">        #服务器监听的端口</span><br><span class="line">        listen 80;</span><br><span class="line">        #定义虚拟主机</span><br><span class="line">        server_name www.domain1.com;</span><br><span class="line">        #对URL进行匹配</span><br><span class="line">        location / &#123;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">        location /cde &#123;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #使用sever定义其他虚拟主机</span><br><span class="line">    server &#123;</span><br><span class="line">        #服务器监听的端口</span><br><span class="line">        listen 80;</span><br><span class="line">        #定义虚拟主机</span><br><span class="line">        server_name www.domain2.com;</span><br><span class="line">        #对URL进行匹配</span><br><span class="line">        location / &#123;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">        location /abc &#123;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Nginx常用配置指令"><a href="#Nginx常用配置指令" class="headerlink" title="Nginx常用配置指令"></a>Nginx常用配置指令</h1><p>Nginx的配置是由简单指令和块指令组成。简单指令如Listen、server_name等，块指令如events、http、stream等。</p><p>（1）access_log与error_log</p><p>access_log可以定义日志输出的格式，而error_log不可以定义日志的输出格式。</p><p>（2）include指令</p><p>可以把其他配置文件中的内容引入到Nginx的主配置文件nginx.conf中。</p><p>（3）keepalive_timeout 5  </p><p>表示nginx这边保持与客户端连接的时长。</p><p>（4）check interval=10000 rise=2 fall=3 timeout=3000 type=tcp default_down=false</p><p>upstream的健康检查，健康检查的周期为10000ms，健康检查超时时间为3000ms，即认为3000ms下游还未返回，那么任务本次健康检查是失败的。rise=2表示，如果两次健康检查都是正常的，那么对应的下游被标记为up，fall=3表示连续三次健康健康失败，对应的下游被标记为down，也就是会被剔除。</p><p>（5）proxy_pass URL</p><p>设置Nginx作为Proxy将请求转发到的目的地址。proxy_pass指令后可以是具体url，也可以是upstream哦。</p><p>（6）proxy_set_header  </p><p>Nginx作为Proxy将请求转发出去前，设置HTTP header。</p><p>（7）resolver address   </p><p>设置DNS服务器的地址，用来解析域名的IP地址。</p><p>（8）add_header name value </p><p>用来设置http response的响应头给浏览器。</p><p>（9）proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for  </p><p>将$proxy_add_x_forwarded_for的值，设置到X-Forwarded-For请求头中。</p><h1 id="Nginx中常见的内置变量"><a href="#Nginx中常见的内置变量" class="headerlink" title="Nginx中常见的内置变量"></a>Nginx中常见的内置变量</h1><p>Nginx中有一些内置的变量，可以在Nginx的配置文件中直接使用，如下列举出一些常用的内置变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$http_user_agent     #客户端代理信息</span><br><span class="line">$request_method      #请求的方法，比如get/post等;</span><br><span class="line">$scheme              #所用的协议，比如http/https等</span><br><span class="line">$server_protocol     #请求使用的协议，通常是HTTP/1.0或HTTP/1.1</span><br><span class="line">$host                #优先级如下：HTTP请求行的主机名&gt;请求头HOST字段&gt;符合请求的服务器名 server_name</span><br><span class="line">$remote_addr         #客户端的IP，如果用nginx做了多层代理了，那么remote_addr就是上一层代理的IP</span><br><span class="line">$remote_port         #客户端的端口</span><br><span class="line">$request             #原始请求url</span><br><span class="line">$http_cookie         #客户端cookie信息</span><br><span class="line">$args                #这个变量等于请求行中的参数，同$query_string</span><br><span class="line">$remote_user         #已经经过Auth Basic Module验证的用户名。</span><br><span class="line">$request_uri         #包含请求参数的原始URI，不包含主机名，如：&quot;/foo/bar.php?arg=baz&quot;</span><br><span class="line">$uri                 #不带请求参数的当前URI，$uri不包含主机名，如&quot;/foo/bar.html&quot;</span><br><span class="line">$document_uri        #与$uri相同</span><br><span class="line">$server_name         #就是虚机的server_name</span><br><span class="line">$proxy_add_x_forwarded_for   #该变量等于nginx收到的请求的X-Forwarded-For请求头内容，加上$remote_addr。也就是将请求来源的IP追加到X-Forwarded-For请求头的尾部，并用逗号分开</span><br></pre></td></tr></table></figure><p>备注：remote_addr代表客户端的IP，但它的值不是由客户端提供的，而是服务端根据客户端的IP来指定的，当你的浏览器访问某个网站时，假设中间没有任何代理，那么网站的WEB服务器（Nginx/Apache等）就会把remote_addr设为你的机器IP，如果你用了某个代理，那么你的浏览器会先访问这个代理，然后再由这个代理转发到网站，这样web服务器就会把remote_addr设为这台代理机器的IP。对于使用了多层代理时，服务端要想获取到真实用户的IP，是通过proxy_add_x_forwarded_for变量来获取的啦。</p><h1 id="Nginx的最佳配置实践"><a href="#Nginx的最佳配置实践" class="headerlink" title="Nginx的最佳配置实践"></a>Nginx的最佳配置实践</h1><p>（1）在实际安装部署Nginx时，要遵循按需安装模块的原则。需要某一个模块则安装，不需要则不要安装。因为每一个被安装的模块都可能会消耗资源，影响Nginx的性能。</p><p>（2）Nginx和Apache都是模块化的设计，但是二者的模块化管理有所有不用。Apache支持模块的“热插拔”，即Apache添加模块，只需要引入模块，然后重启Apache就行了。而Nginx添加模块需要重新编译。</p><p>（3）Nginx的worker进程数量最好要与CPU的核数保持一致，并设置CPU亲和力。</p><p>（4）在生产环境中，当我们修改完Nginx的配置后，可以使用<code>/sbin/nginx -t</code>来测试Nginx的配置文件格式是否正确。</p><p>（5）Nginx中server内location的推荐配置</p><p>在实际生成环境中，至少有三个匹配规则定义是不可少的，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</span><br><span class="line">#这里是直接转发给后端应用服务器了，也可以是一个静态首页</span><br><span class="line"># 第一个必选规则</span><br><span class="line">location = / &#123;</span><br><span class="line">    proxy_pass http://tomcat:8080/index</span><br><span class="line">&#125;</span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class="line">location ^~ /static/ &#123;</span><br><span class="line">    root /webroot/static/;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">    root /webroot/res/;</span><br><span class="line">&#125;</span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class="line">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://tomcat:8080/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Nginx配置中一些细节"><a href="#Nginx配置中一些细节" class="headerlink" title="Nginx配置中一些细节"></a>Nginx配置中一些细节</h1><p>（1）server_name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server_name www.example.com example.com news.example.com; #server_name指令可以配置多个server，中间用空格分开即可</span><br><span class="line">server_name *.example.com;                                #server_name也可以用通配符，用来匹配满足要求的请求，而不单单匹配某一个虚机Host</span><br></pre></td></tr></table></figure><p>（2）Nginx作为代理的配置</p><p>如果Nginx的虚机是用来做反向代理，那么一般就需要如下的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header Host $host;               #设置代理转发http request的Host header中</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;   #将上一层http请求的来源IP，设置到转发http request的X-Real-IP header中</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;   #将多层代理的IP，设置到转发http request的X-Forwarded-For header中，最终让服务端能够获取的多层代理的IP</span><br><span class="line">proxy_pass http://10.17.136.17:8080;</span><br></pre></td></tr></table></figure><p>X-Forwarded-For是一个HTTP扩展头部。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由Squid这个缓存代理软件引入，用来表示HTTP请求端真实IP。如今它已经成为事实上的标准，被各大HTTP代理、负载均衡等转发服务广泛使用，并被写入RFC 7239（Forwarded HTTP Extension）标准之中。说白了，对于有多层代理的架构来说，X-Forwarded-For能够将浏览器IP以及各层代理的IP记录到X-Forwarded-For请求头中，供WEB应用来获取。</p><p>X-Forwarded-For 请求头格式非常简单，如下：</p><pre><code>X-Forwarded-For: client, proxy1, proxy2</code></pre><p>X-Real-IP也是一个HTTP扩展头部字段。X-Real-IP通常被HTTP代理用来表示与它产生TCP连接的设备IP，这个设备可能是其他代理，也可能是真正的请求端。需要注意的是，X-Real-IP目前并不属于任何标准，代理和Web应用之间可以约定用任何自定义头来传递这个信息。</p><p>（3）expires指令的用法</p><p>expires指令用来控制HTTP响应头中是否增加或修改Expires和Cache-Control，expires指令仅仅对响应状态码为200，201，204，206，301，302，303，304及307的时候有效。</p><pre><code>当expire为负时，会在响应头增加`Cache-Control: no-cache`当expire为正或者0时，就表示Cache-Control: max-age=指定的时间(秒)，同时Expires被设置为当前时间加上time值所代表的时间点当expire为max时，会把Expires设置为“Thu, 31 Dec 2037 23:55:55 GMT”，Cache-Control设置到10年当expire为off时，表示不增加或修改Expires和Cache-Control</code></pre><p>expire指令的使用举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expires -1;</span><br><span class="line">expires 0;</span><br><span class="line">expires 1h;</span><br><span class="line">expires max;</span><br><span class="line">expires off;</span><br></pre></td></tr></table></figure><p>（4）Nginx关于proxy_set_header和add_header指令的一个坑</p><p>我们知道，Nginx的配置是有层级关系的，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xxxxx</span><br><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">    upstream xxxx &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        xxxxxx</span><br><span class="line">        location /path &#123;</span><br><span class="line">            xxxxx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以proxy_set_header为例来说，当某个级别中不包含proxy_set_header指令时，就会从上一级继承。举例来说，若location中配置了任何的proxy_set_header指令，那么即使sever中配置了再多的proxy_set_header，location中还是只生效其自己配置的proxy_set_header。当location中没有配置任何的proxy_set_header，那么它会从server中继承一些proxy_set_header配置。</p><p>在这个地方，我们一般有一定的误解，认为proxy_set_header和其他指令一样，会叠加上一层级的配置，事实上会覆盖上一级的配置。如下图中，<code>proxy_set_header X-**-Https &quot;https&quot;</code>所配置的位置和箭头所指向的位置带来的效果是不一样的哦。</p><p><img src="/images/nginx_conf_1_1.png" alt></p><p>同理add_header也有这样的问题。</p><p>学习资料参考于：<br><a href="https://www.4os.org/?p=1010" target="_blank" rel="noopener">https://www.4os.org/?p=1010</a></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx缓存原理及配置</title>
      <link href="/2019/03/05/Nginx%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/03/05/Nginx%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx缓存简介"><a href="#Nginx缓存简介" class="headerlink" title="Nginx缓存简介"></a>Nginx缓存简介</h1><p>Nginx的http_proxy模块，可以实现类似于Squid的缓存功能。Nginx对客户已经访问过的内容在Nginx服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过Nginx服务器再次向后端服务器发出请求，所以能够减少Nginx服务器与后端服务器之间的网络流量，减轻网络拥塞，同时还能减小数据传输延迟，提高用户访问速度。同时，当后端服务器宕机时，Nginx服务器上的副本资源还能够回应相关的用户请求，这样能够提高后端服务器的鲁棒性。</p><h1 id="Nginx-cache基本配置"><a href="#Nginx-cache基本配置" class="headerlink" title="Nginx cache基本配置"></a>Nginx cache基本配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path /path/to/cache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off;</span><br><span class="line">server &#123;</span><br><span class="line">    set $upstream http://ip:port</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_pass $upstream;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置项说明如下：</p><p>（1）/path/to/cache</p><p>本地路径，用来设置Nginx缓存资源的存放地址。</p><p>（2）levels</p><p>默认所有缓存文件都放在同一个/path/to/cache下，但是会影响缓存的性能，因此通常会在/path/to/cache下面建立子目录用来分别存放不同的文件。假设<code>levels=1:2</code>，Nginx为将要缓存的资源生成的key为f4cd0fbc769e94925ec5540b6a4136d0，那么key的最后一位0，以及倒数第2-3位6d作为两级的子目录，也就是该资源最终会被缓存到/path/to/cache/0/6d目录中。</p><p>（3）key_zone</p><p>在共享内存中设置一块存储区域来存放缓存的key和metadata（类似使用次数），这样Nginx可以快速判断一个request是否命中或者未命中缓存，1m可以存储8000个key，10m可以存储80000个key。</p><p>（4）max_size</p><p>最大cache空间，如果不指定，会使用掉所有disk space，当达到配额后，会删除最少使用的cache文件。</p><p>（5）inactive</p><p>未被访问文件在缓存中保留时间，本配置中如果60分钟未被访问则不论状态是否为expired，缓存控制程序会删掉文件。inactive默认是10分钟。需要注意的是，inactive和expired配置项的含义是不同的，expired只是缓存过期，但不会被删除，inactive是删除指定时间内未被访问的缓存文件。</p><p>（6）use_temp_path</p><p>如果为off，则Nginx会将缓存文件直接写入指定的cache文件中，而不是使用temp_path存储，official建议为off，避免文件在不同文件系统中不必要的拷贝。</p><p>（7）proxy_cache</p><p>启用proxy cache，并指定key_zone。另外，如果proxy_cache off表示关闭掉缓存。</p><h1 id="Nginx缓存机制"><a href="#Nginx缓存机制" class="headerlink" title="Nginx缓存机制"></a>Nginx缓存机制</h1><p><img src="/images/nginx_cache_1_1.png" alt></p><h1 id="一些其他Nginx缓存知识"><a href="#一些其他Nginx缓存知识" class="headerlink" title="一些其他Nginx缓存知识"></a>一些其他Nginx缓存知识</h1><p>（1）proxy_cache_use_stale增强站点容错能力</p><p>源站有问题时，Nginx可以通过proxy_cache_use_stale指令开启容错能力，即使用缓存内容来响应客户端的请求。举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    ...</span><br><span class="line">    proxy_cache_use_stale error timeout http_500 http_502 http_503 http_504;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上配置表示，当作为cache的Nginx收到源站返回error、timeout或者其他指定的5XX错误，并且在其缓存中有请求文件的陈旧版本，则会将这些陈旧版本的文件而不是错误信息发送给客户端。</p><p>（2）多磁盘分割缓存</p><p>使用Nginx，不需要建立一个RAID（磁盘阵列）。如果有多个硬盘，Nginx可以用来在多个硬盘之间分割缓存。举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path /path/to/hdd1 levels=1:2 keys_zone=my_cache_hdd1:10m max_size=10g inactive=60m use_temp_path=off;</span><br><span class="line">proxy_cache_path /path/to/hdd2 levels=1:2 keys_zone=my_cache_hdd2:10m max_size=10g inactive=60m use_temp_path=off;</span><br><span class="line"></span><br><span class="line">split_clients $request_uri $my_cache &#123;</span><br><span class="line">    50%   &quot;my_cache_hdd1&quot;;</span><br><span class="line">    50%   &quot;my_cache_hdd2&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_cache $my_cache;</span><br><span class="line">        proxy_pass http://my_upstream;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中的两个proxy_cache_path定义了两个缓存（my_cache_hdd1和my_cache_hdd2）分属两个不同的硬盘。split_clients配置部分指定了请求结果的一半在my_cache_hdd1中缓存，另一半在my_cache_hdd2中缓存。基于<code>$request_uri</code>（请求URI）变量的哈希值决定了每一个请求使用哪一个缓存，对于指定URI的请求结果通常会被缓存在同一个缓存中。</p><p>（3）缓存命中情况的Nginx变量$upstream_cache_status</p><p>$upstream_cache_status的可能值有：</p><pre><code>MISS        #响应在缓存中找不到，所以需要在服务器中取得。这个响应之后可能会被缓存起来BYPASS      #响应来自原始服务器而不是缓存，因为请求匹配了一个proxy_cache_bypass，这个响应之后可能会被缓存起来EXPIRED     #缓存中的某一项过期了，来自原始服务器的响应包含最新的内容STALE       #内容陈旧是因为原始服务器不能正确响应。需要配置proxy_cache_use_staleUPDATING    #内容过期了，因为相对于之前的请求，响应的入口（entry）已经更新，并且proxy_cache_use_stale的updating已被设置REVALIDATED #proxy_cache_revalidate命令被启用，Nginx检测得知当前的缓存内容依然有效（If-Modified-Since或者If-None-Match）HIT         #响应包含来自缓存的最新有效的内容</code></pre><p>（4）HTTP响应头Cache-Control</p><p>当在响应头部中Cache-Control被配置为Private，No-Cache，No-Store或者Set-Cookie，不允许代理对资源进行缓存。</p><p>（5）Nginx对缓存的资源会设置一个key，Nginx生成的键的默认格式是类似于下面的Nginx变量的MD5哈希值<code>$scheme$proxy_host$request_uri</code>，实际的算法有些复杂。 为了改变变量（或其他项）作为基础键，可以使用proxy_cache_key命令。例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_key $proxy_host$request_uri$cookie_jessionid;</span><br></pre></td></tr></table></figure><p>（6）缓存指令proxy_cache_valid</p><p>为不同的HTTP返回状态码的资源设置不同的缓存时长。</p><p>命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_valid [code ...] time;</span><br></pre></td></tr></table></figure><p>举例来说，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_valid 200 302 10m;    #为响应码是200和302的资源，设置缓存时长为10分钟</span><br><span class="line">proxy_cache_valid 404      1m;    #为响应码是404的资源，设置的缓存的时长为1分钟</span><br></pre></td></tr></table></figure><p>（7）缓存清理指令proxy_cache_purge</p><p>学习资料参考于：<br><a href="https://blog.51cto.com/benpaozhe/1763897" target="_blank" rel="noopener">https://blog.51cto.com/benpaozhe/1763897</a></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx的请求路由规则</title>
      <link href="/2019/03/05/Nginx%E7%9A%84%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99/"/>
      <url>/2019/03/05/Nginx%E7%9A%84%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>Nginx的请求处理过程大概有两个步骤，第一步是虚拟主机的确定，第二步是location路由的确定。</p><h1 id="虚拟主机的确定"><a href="#虚拟主机的确定" class="headerlink" title="虚拟主机的确定"></a>虚拟主机的确定</h1><p>Nginx首先决定由哪个虚拟主机来处理请求，就是由哪个server段来处理请求。在这个过程中又分几个步骤：</p><p>（1）判断listen指令</p><p>listen指令的格式是<code>listen ip:port</code>。如果port省略，则监听标准端口80；如果ip省略，表示监听所有ip，也就是监听来自所有网卡的请求；如果server段中没有listen指令，那就表示监听所有网卡ip的80的端口。</p><p>（2）判断server_name指令</p><p>server_name指令可以有精确配置、通配符配置以及正则配置三种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_name www.baidu.com;                 #精确配置</span><br><span class="line">server_name *.baidu.com;                   #以通配符开头的配置</span><br><span class="line">server_name baidu.*;                       #以通配符结尾的配置</span><br><span class="line">server_name ~^(?&lt;user&gt;.+)\.example\.net$;  #正则的配置，必须以波浪线为开头</span><br></pre></td></tr></table></figure><p>假设在Nginx中由多个虚拟主机监听同一个端口，相当于在步骤（1）中同时匹配到多个虚拟主机，这时就需要通过server_name指令决定使用哪个虚拟主机来响应请求。也就是通过HTTP请求中的Host请求头来和server_name进行匹配。如果通过server_name还是有多个虚拟主机能够匹配上，那么就会按照一定的优先级来决定，规则为：</p><pre><code>精确匹配 &gt;&gt; 以通配符开头匹配 &gt;&gt; 以通配符结尾的匹配 &gt;&gt; 正则匹配</code></pre><p>（3）例外</p><p>如果通过listen和server_name没有匹配上任何的虚拟主机，那么请求会交给default server来处理。default server默认为Nginx配置文件中第一个虚拟主机，当然我们在<code>listen ip:port default_server</code>来显式指定一个缺省的虚拟主机。</p><p>还有，如果用户的HTTP请求中，没有Host请求头，那么我们需要为其配置一个虚拟主机来处理，如下配置（在0.8.48以后的版本，下面的配置可以省略）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name &quot;&quot;;</span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="location路由处理"><a href="#location路由处理" class="headerlink" title="location路由处理"></a>location路由处理</h1><p>以<code>=</code>开头，表示精确匹配；</p><p>以<code>^~</code>开头，表示uri以某个常规字符串开头，不是正则匹配；</p><p>以<code>~</code>开头，表示区分大小写的正则匹配；</p><p>以<code>~*</code>开头，表示不区分大小写的正则匹配；</p><p>以<code>/</code>开头，表示通用匹配，如果没有其它匹配,任何请求都会匹配到；</p><p>如果多个location匹配均匹配，按照如下的优先级来确定：</p><pre><code>(location =) &gt;&gt; (location 完整路径) &gt;&gt; (location ^~ 路径) &gt;&gt; (location ~,~* 正则顺序) &gt;&gt; (location 部分起始路径) &gt;&gt; (/)</code></pre><h1 id="location-name实现内部跳转"><a href="#location-name实现内部跳转" class="headerlink" title="location @name实现内部跳转"></a>location @name实现内部跳转</h1><p>举例来说，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /img/ &#123;</span><br><span class="line">    error_page 404 @img_err;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">location @img_err &#123;</span><br><span class="line">    # 规则</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述规则表示，以<code>/img/</code>开头的请求，如果请求返回的状态为404，则会匹配到<code>@img_err</code>这条规则上。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx中URL重写rewrite模块</title>
      <link href="/2019/03/05/Nginx%E4%B8%ADURL%E9%87%8D%E5%86%99rewrite%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/03/05/Nginx%E4%B8%ADURL%E9%87%8D%E5%86%99rewrite%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx-rewrite模块简介"><a href="#Nginx-rewrite模块简介" class="headerlink" title="Nginx rewrite模块简介"></a>Nginx rewrite模块简介</h1><p>Nginx rewrite模块就是使用Nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现URL重写以及重定向。rewrite模块包含的指令有break、if、return、rewrite、rewrite_log、set以及uninitialized_variable_warn。</p><p>rewrite模块的指令一般在server及location块指令里面。在server或location中包含了rewrite指令后，请求在server中处理顺序为：</p><pre><code>a）执行server块中的rewrite模块指令b）选择locationc）location块中的rewrite模块的指令被执行d）如果在c）中请求uri被修改，那么会从b）继续往后执行，即重新选择location</code></pre><p>如上d）的循环不能超过10次，如果超过10次，就会返回浏览器500，内部服务器错误。</p><p>备注：理解rewrite模块一定要理解内部重定向和外部重定向。</p><h1 id="break指令"><a href="#break指令" class="headerlink" title="break指令"></a>break指令</h1><p>break跳过当前上下文中所有ngx_http_rewrite_module模块的指令（如rewrite/if/return等等），但是其他模块指令是不受影响的。break有如下几点注意事项：</p><p>（1）break只对ngx_http_rewrite_module模块的指令有影响，对其他模块的指令没有影响；</p><p>（2）break指令可以在server/location/if上下文中，break只影响所属上下文中的ngx_http_rewrite_module模块的指令，例如server中break，不会影响到location的中重写相关的指令。值得注意的是，if语句块中的break，会影响到if所在的server或location中重写模块相关的指令。</p><h1 id="rewrite指令"><a href="#rewrite指令" class="headerlink" title="rewrite指令"></a>rewrite指令</h1><p>rewrite指令只能放在<code>server{}</code>，<code>location{}</code>以及<code>if{}</code>中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如<code>http://seanlook.com/a/we/index.php?id=1&amp;u=str</code>，rewrite只对<code>/a/we/index.php</code>重写。</p><p>rewrite命令使用格式：</p><pre><code>rewrite regex replacement [flag];</code></pre><p>其中regex是正则，用来匹配request uri，replacement是将匹配的uri替换为新的uri。flag可以为last、break、redirect和permanent。</p><p>（1）last</p><p>表示终止后续的rewrite模块的指令，且立即开始重新选择location，即实现Nginx内部的重定向，对用户来说是无感的哦</p><p>（2）break</p><p>表示终止后续的rewrite模块的指令，但是还会执行后续的非rewrite模块的指令，然后再开始重新选择location，也是实现Nginx的内部重定向。</p><p>（3）redirect</p><p>返回302临时重定向，浏览器地址栏会显示跳转后的地址。也即是外部重定向。</p><p>（4）permanent</p><p>返回301永久重定向，地址栏会显示跳转后的地址。也是外部重定向。</p><h1 id="return指令"><a href="#return指令" class="headerlink" title="return指令"></a>return指令</h1><p>return指令停止处理并将指定的HTTP码返回给浏览器。return指令的格式有：</p><pre><code>return code [text];return code URL;return URL</code></pre><p>举例来说，<code>return 404</code>将返回给浏览器404错误页面。return也可以实现30X的重定向了。如果<code>return 444</code>，那么Nginx不会返回浏览器任何响应。</p><h1 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h1><p>if指令用来根据一定的条件，来执行一些指令，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (condition) </span><br><span class="line">&#123; </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="set指令"><a href="#set指令" class="headerlink" title="set指令"></a>set指令</h1><p>设置指定变量的值。变量的值可以包含文本，变量或者是它们的组合形式。</p><p>学习资料参考于：<br><a href="https://segmentfault.com/a/1190000008102599" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008102599</a></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SYNFlood攻击简介</title>
      <link href="/2019/03/05/SYNFlood%E6%94%BB%E5%87%BB%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/03/05/SYNFlood%E6%94%BB%E5%87%BB%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="SYNFlood简介"><a href="#SYNFlood简介" class="headerlink" title="SYNFlood简介"></a>SYNFlood简介</h1><p>SYNFlood是当前最流行的DoS（拒绝服务攻击）与DDoS（分布式拒绝服务攻击）的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。</p><h1 id="SYNFlood原理"><a href="#SYNFlood原理" class="headerlink" title="SYNFlood原理"></a>SYNFlood原理</h1><p>要明白SYNFlood攻击的基本原理，需要从TCP连接建立的过程开始说起，大家都知道，TCP与UDP不同，它是基于连接的，也就是说，为了在服务端和客户端之间传送TCP数据，必须先建立一个虚拟电路，也就是TCP连接，建立TCP连接的标准过程是这样的：</p><p>（1）请求端（客户端）发送一个包含SYN标志的TCP报文，SYN即同步（Synchronize），同步报文会指明客户端使用的端口以及TCP连接的初始序号。</p><p>（2）服务器在收到客户端的SYN报文后，将返回一个SYN+ACK的报文，表示客户端的请求被接受，同时TCP序号被加一，ACK即确认（Acknowledgment）。</p><p>（3）客户端也返回一个确认报文ACK给服务器端，同样TCP序列号被加一，到此一个TCP连接完成。</p><p>以上的连接过程在TCP协议中被称为三次握手（Three-Way Handshake）。</p><p>问题出在TCP连接的三次握手中，假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）。</p><p>一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源（数以万计的半连接），即使是简单的保存并遍历也会消耗非常多的CPU时间和内存，何况还要不断对这个列表中的IP进行SYN+ACK的重试。实际上如果服务器的TCP/IP栈不够强大，最后的结果往往是堆栈溢出崩溃。即使服务器端的系统足够强大，服务器端也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们就称作服务器端受到了SYNFlood攻击（SYN洪水攻击）。</p>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全领域的一些专业术语</title>
      <link href="/2019/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/"/>
      <url>/2019/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><p>POC，Proof Of Concept，中文意思是“观点证明”。这个短语会在漏洞报告中使用，漏洞报告中的POC则是一段说明或者一个攻击的样例，使得读者能够确认这个漏洞是真实存在的。</p><h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><p>EXP，Exploit，中文意思是“漏洞利用”。意思是一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码，可以使得读者完全了解漏洞的机理以及利用的方法。</p><h1 id="VUL"><a href="#VUL" class="headerlink" title="VUL"></a>VUL</h1><p>VUL，Vulnerability的缩写，泛指漏洞。</p><h1 id="CVE"><a href="#CVE" class="headerlink" title="CVE"></a>CVE</h1><p>CVE的英文全称是“Common Vulnerabilities &amp; Exposures”公共漏洞和暴露，例如CVE-2015-0057、CVE-1999-0001等等。CVE就好像是一个字典表，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。如果在一个漏洞报告中指明的一个漏洞，如果有CVE名称，你就可以快速地在任何其它CVE兼容的数据库中找到相应修补的信息，解决安全问题。</p><p>可以在<code>https://cve.mitre.org/</code>网站根据漏洞的CVE编号搜索该漏洞的介绍。也可以在中文社区<code>http://www.scap.org.cn/</code>上搜索关于漏洞的介绍。</p><h1 id="0DAY漏洞和0DAY攻击"><a href="#0DAY漏洞和0DAY攻击" class="headerlink" title="0DAY漏洞和0DAY攻击"></a>0DAY漏洞和0DAY攻击</h1><p>在计算机领域中，零日漏洞或零时差漏洞（Zero-Day Exploit）通常是指还没有补丁的安全漏洞，而零日攻击或零时差攻击（Zero-Day Exploit）则是指利用这种漏洞进行的攻击。提供该漏洞细节或者利用程序的人通常是该漏洞的发现者。零日漏洞的利用程序对网络安全具有巨大威胁，因此零日漏洞不但是黑客的最爱，掌握多少零日漏洞也成为评价黑客技术水平的一个重要参数。</p><p>零日漏洞及其利用代码不仅对犯罪黑客而言，具有极高的利用价值，一些国家间谍和网军部队，例如美国国家安全局和美国网战司令部也非常重视这些信息。据路透社报告称美国政府是零日漏洞黑市的最大买家。</p>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些重要的IT专业术语</title>
      <link href="/2019/03/05/%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84IT%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/"/>
      <url>/2019/03/05/%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84IT%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h1><p>QPS，Query Per Second，指的是每秒查询率。</p><h1 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h1><p>PV，Page View，即页面浏览量，通常是衡量一个网络新闻频道或网站甚至一条网络新闻的主要指标。网页浏览数是评价网站流量最常用的指标之一，简称为PV。监测网站PV的变化趋势和分析其变化原因是很多站长定期要做的工作。Page View中的Page一般是指普通的HTML网页，也包含php、jsp等动态产生的HTML内容，来自浏览器的一次HTML内容请求会被看作一个PV，逐渐累计成为PV总数。</p><h1 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h1><p>UV，Unique Visitor，网站独立访客，是指通过互联网访问、浏览这个网页的自然人。</p><h1 id="VV"><a href="#VV" class="headerlink" title="VV"></a>VV</h1><p>VV，Video View，是指在一个统计周期内，视频被打开的次数之和。</p><h1 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h1><p>CV，Content View，是指在一个统计周期内，视频被打开，且视频正片内容（除广告）被成功播放的次数之和。一般来说，CV小于VV。</p><h1 id="OTT"><a href="#OTT" class="headerlink" title="OTT"></a>OTT</h1><p>OTT是“Over The Top”的缩写，是通信行业非常流行的一个词汇，这个词汇来源于篮球等体育运动，是“过顶传球”之意，指的是球类运动员(player)在他们头之上来回传送而达到目的地。即互联网公司越过运营商，发展基于开放互联网的各种视频及数据服务业务，强调服务与物理网络的无关性。</p><p>在看明白了微信等OTT业务将“革掉自己的命”后，三大运营商终于开始醒悟过来，开始向微信等OTT业务讨个说法，直指OTT企业对传统电信运营商的挤压非常明显，并以网络电话来形容OTT业务利用电信运营商的网络开通免费语音和视频服务，造成短信、彩信、视频等业务的大量流失。</p><h1 id="BI"><a href="#BI" class="headerlink" title="BI"></a>BI</h1><p>BI，Business Intelligence，中文名为商业智能，它指为企业提供迅速分析数据的技术和方法，将数据转化为有价值信息。</p><h1 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h1><p>TPS，Transaction Per Second，指每秒事务处理量。每秒钟系统能够处理的交易或事务的数量。它是衡量系统处理能力的重要指标。</p><h1 id="MAU"><a href="#MAU" class="headerlink" title="MAU"></a>MAU</h1><p>Monthly Active Users，月活跃用户数，去除重复的用户。</p><h1 id="DAU"><a href="#DAU" class="headerlink" title="DAU"></a>DAU</h1><p>Daily Active Users，日活跃用户数，去除重复的用户。</p><h1 id="UGC-PCG-OGC"><a href="#UGC-PCG-OGC" class="headerlink" title="UGC/PCG/OGC"></a>UGC/PCG/OGC</h1><p>UGC，User Generated Content，也就是用户生成内容的意思。UGC的概念最早起源于互联网领域，即用户将自己原创的内容通过互联网平台进行展示或者提供给其他用户。UGC是伴随着以提倡个性化为主要特点的Web2.0概念兴起的。</p><p>PGC，Professionally Generated Content，其含义为专业生产内容。</p><p>OGC，Occupationally Generated Content，其含义为品牌生产内容。</p><h1 id="UX"><a href="#UX" class="headerlink" title="UX"></a>UX</h1><p>UX，User experience design，用户体验设计。</p><h1 id="PUE"><a href="#PUE" class="headerlink" title="PUE"></a>PUE</h1><p>PUE，Power Usage Effectiveness，是评价数据中心能源效率的指标，是数据中心消耗的所有能源与IT负载使用的能源之比。说白了，就是一个数据中心的总能耗与有价值的消耗的比值。PUE值越接近于1，表示一个数据中心的绿色化程度越高。当前，国外先进的数据中心机房PUE值通常小于2，而我国的大多数数据中心的PUE值在2-3之间。</p><h1 id="DCIE"><a href="#DCIE" class="headerlink" title="DCIE"></a>DCIE</h1><p>DCIE，Data Center Infrastructure Efficiency，与PUE成反比。</p><h1 id="SLA"><a href="#SLA" class="headerlink" title="SLA"></a>SLA</h1><p>SLA，Service-Level Agreement，中文名称为服务等级协议。SLA是关于网络服务供应商和客户间的一份合同，其中定义了服务类型、服务质量和客户付款等术语。说白了，就是我对客户提供的服务质量的承诺。</p><h1 id="UPS"><a href="#UPS" class="headerlink" title="UPS"></a>UPS</h1><p>UPS，Uninterruptible Power System，称为不间断电源。</p><p>UPS将蓄电池与主机相连接，通过主机逆变器等模块电路将直流电转换成市电的系统设备。当市电输入正常时，UPS将市电稳压后供应给负载使用，此时的UPS就是一台交流市电稳压器，同时它还向机内电池充电；当市电中断（事故停电）时，UPS立即将电池的直流电能，通过逆变零切换转换的方法向负载继续供应220V交流电，使负载维持正常工作并保护负载软、硬件不受损坏。UPS设备通常对电压过高或电压过低都能提供保护。</p><p><img src="/images/hardware_ups_1_1.png" alt></p><h1 id="sign-in-sign-out-sign-up"><a href="#sign-in-sign-out-sign-up" class="headerlink" title="sign-in/sign-out/sign-up"></a>sign-in/sign-out/sign-up</h1><p>sign-out，相当于exit，退出账户登录。</p><p>sign-in，相当于login，登录账户。</p><p>sign-up，注册账户。</p><h1 id="scale-up-scale-down"><a href="#scale-up-scale-down" class="headerlink" title="scale-up/scale-down"></a>scale-up/scale-down</h1><p>scale-up/scale-down表示纵向扩缩容，指调整机器资源的Quota，比如增大或减少CPU/MEM等的分配。</p><p>scale-up是纵向扩容，scale-down是纵向缩容。</p><h1 id="scale-in-scale-out"><a href="#scale-in-scale-out" class="headerlink" title="scale-in/scale-out"></a>scale-in/scale-out</h1><p>scale-in/scale-out表示横向扩缩容，指调整实例数，比如增大或减少机器数。</p><p>scale-in是横向缩容，scale-out是横向扩容。</p><h1 id="auto-scaling"><a href="#auto-scaling" class="headerlink" title="auto-scaling"></a>auto-scaling</h1><p>自动扩缩容。</p><h1 id="fan-in-fan-out"><a href="#fan-in-fan-out" class="headerlink" title="fan-in/fan-out"></a>fan-in/fan-out</h1><p>扇入和扇出原本是电子技术中电子元件及其输入端和输出端的结构。</p><p>（1）扇入</p><p>扇入表示一个模块被多个模块调用。如下：</p><p><img src="/images/fan_in_out_1_1.png" alt></p><p>（2）扇出</p><p>扇出表示一个模块调用多个模块。如下：</p><p><img src="/images/fan_in_out_1_2.png" alt></p><h1 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h1><p>RTT，全称为Round-Trip Time，表示往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</p><h1 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h1><p>ETL，是英文Extract-Transform-Load的缩写，用来描述将数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程。ETL一词较常用在数据仓库，但其对象并不限于数据仓库。</p>]]></content>
      
      
      <categories>
          
          <category> 杂货铺 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx技术简介</title>
      <link href="/2019/03/05/Nginx%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/03/05/Nginx%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h1><p>Nginx集web服务器、负载均衡、cache三种能力于一身。Nginx和Apache类似，采用的模块化设计，Nginx的模块分为内置模块和第三方模块。其中Nginx的内置模块有从功能上可以划分为：</p><p>（1）Nginx核心类模块</p><p>包括Nginx的内核模块和事件驱动events模块等。</p><p>（2）Nginx邮件类模块</p><p>包括Mail的内核模块和相关的额认证、代理，以及提供POP3、IMAP和SMTP的SSL模块。</p><p>（3）HTTP服务类模块</p><p>包括HTTP的内核模块http_core、代理模块http_proxy、负载均衡模块http_upstream等。</p><p>（4）4层代理stream类模块</p><p>包括stream的内核模块stream_core、代理模块stream_proxy、负载均衡模块stream_upstream等。</p><p>另外，Nginx plus是Nginx的商业版本，从2013年开始发布Nginx plus。Nginx plus对比开源版本重点增加了若干企业特性，包括更完善的七层、四层负载均衡、会话保持、健康检查以及实时监控和管理等。</p><h1 id="Nginx的进程模型"><a href="#Nginx的进程模型" class="headerlink" title="Nginx的进程模型"></a>Nginx的进程模型</h1><p>Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：</p><p>（1）单进程启动</p><p>此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。</p><p>（2）多进程启动</p><p>此时系统有且仅有一个Master进程，至少有一个Worker进程工作。Master进程主要进行一些全局性的初始化工作、绑定端口以及创建管理Worker进程等工作。Worker进程才是执行所有实际任务的进程，包括响应HTTP请求、处理网络连接、读取和写入内容到磁盘，与上游服务器通信等。</p><p><img src="/images/nginx_analy_1_1.png" alt></p><p>另外，需要注意的是，如果Nginx开启了cache功能，那么Nginx还将启动两个cache相关的进程：</p><p>（1）cache manager process</p><p>缓存管理进程（cache manager process）周期性运行，并削减磁盘缓存（prunes entries from the disk caches），以使其保持在配置范围内。</p><p>（2）cache loader process</p><p>缓存加载进程（cache loader process）在启动时运行，把基于磁盘的缓存（disk-based cache）加载到内存中，然后退出。对它的调度很谨慎，所以其资源需求很低。</p><p>对于Nginx来说，cache manager process和cache loader process是两个特殊的Worker进程。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见浏览器的并发请求量控制</title>
      <link href="/2019/03/05/%E5%B8%B8%E8%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/03/05/%E5%B8%B8%E8%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器对并发量的控制"><a href="#浏览器对并发量的控制" class="headerlink" title="浏览器对并发量的控制"></a>浏览器对并发量的控制</h1><p>浏览器的并发请求数目限制是针对同一域名的。也就是说，同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。</p><p>假设<code>www.sohu.com</code>页面中有很多的<code>images.sohu.com</code>的图片元素，当网民在浏览器中输入<code>www.sohu.com</code>时，浏览器会对<code>images.sohu.com</code>的并发请求有一定数据量的限制，所以当<code>www.sohu.com</code>页面中有很多<code>images.sohu.com</code>的图片元素时，就会显得有些图片加载的比较慢。</p><p>具体各个浏览器的限制不一样，一般来说，</p><p><img src="/images/browser_conc_1_1.png" alt></p><p>学习资料参考于：<br><a href="https://www.zhihu.com/question/20474326" target="_blank" rel="noopener">https://www.zhihu.com/question/20474326</a></p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UUID概念</title>
      <link href="/2019/03/05/UUID%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/03/05/UUID%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>UUID，全称为Universally Unique Identifier，中文为全局唯一标识符，是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。按照开放软件基金会（OSF）制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。但是UUID的唯一缺陷在于生成的结果串会比较长。</p><p>可以在<code>http://www.uuid.online/</code>网址上生产UUID。</p>]]></content>
      
      
      <categories>
          
          <category> 杂货铺 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP握手代理SYNProxy</title>
      <link href="/2019/03/05/TCP%E6%8F%A1%E6%89%8B%E4%BB%A3%E7%90%86SYNProxy/"/>
      <url>/2019/03/05/TCP%E6%8F%A1%E6%89%8B%E4%BB%A3%E7%90%86SYNProxy/</url>
      
        <content type="html"><![CDATA[<h1 id="SYNProxy"><a href="#SYNProxy" class="headerlink" title="SYNProxy"></a>SYNProxy</h1><p>SYNProxy，顾名思义就是一个TCP握手代理 ，该代理截获TCP连接创建的请求，它可以保证只有与自己完成整个TCP握手的连接才被认为是正常的连接，此时才会由代理真正发起与真实服务器的TCP连接。整个流程图如下：</p><p><img src="/images/network_tcpproxy_1_1.png" alt></p><p>上述流程分为四个阶段：</p><p>（1）T1</p><p>Client与SYNProxy三次握手建立TCP连接。</p><p>（2）T2</p><p>SYNProxy与Server三次握手建立TCP连接。</p><p>（3）T3</p><p>Client与Server之间传输数据。</p><p>（4）T4</p><p>SYNProxy清理资源，释放TCP连接。</p><p>备注：SYNProxy可以有效解决SYNFlood攻击问题。关于SYNFlood知识参见<a href="https://wangjianno1.github.io/2019/03/05/SYNFlood%E6%94%BB%E5%87%BB%E7%AE%80%E4%BB%8B/">《SYNFlood攻击简介》</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单播|组播(多播)|广播|任播的小结</title>
      <link href="/2019/03/05/%E5%8D%95%E6%92%AD-%E7%BB%84%E6%92%AD-%E5%A4%9A%E6%92%AD-%E5%B9%BF%E6%92%AD-%E4%BB%BB%E6%92%AD%E7%9A%84%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/05/%E5%8D%95%E6%92%AD-%E7%BB%84%E6%92%AD-%E5%A4%9A%E6%92%AD-%E5%B9%BF%E6%92%AD-%E4%BB%BB%E6%92%AD%E7%9A%84%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="单播（unicast）"><a href="#单播（unicast）" class="headerlink" title="单播（unicast）"></a>单播（unicast）</h1><p>单播是指封包在计算机网络的传输中，目的地址为单一目标的一种传输方式。它是现今网络应用最为广泛，通常所使用的网络协议或服务大多采用单播传输，例如一切基于TCP的协议。</p><p>在单播通信中，每次只有两个实体相互通信，发送端和接收端都是唯一确定的。在IPv4网络中，0.0.0.0到223.255.255.255属于单播地址。你对小月月喊“小月月”，那么只有小月月回过头来答应你。</p><p><img src="/images/network_unicast_1_1.png" alt></p><h1 id="组播（multicast）"><a href="#组播（multicast）" class="headerlink" title="组播（multicast）"></a>组播（multicast）</h1><p>组播（multicast）也叫多播， 多点广播或群播，指把信息同时传递给一组目的地址。它使用策略是最高效的，因为消息在每条网络链路上只需传递一次，而且只有在链路分叉的时候，消息才会被复制。</p><p>“组播”这个词通常用来指代IP组播。IP组播是一种通过使用一个组播地址将数据在同一时间以高效的方式发往处于TCP/IP网络上的多个接收者的协议。此外，它还常用来与RTP等音视频协议相结合。组播报文的目的地址使用D类IP地址， D类地址不能出现在IP报文的源IP地址字段。你在大街上大喊一声“美女”， 会有一群女性回头看你。</p><p><img src="/images/network_multicast_1_1.png" alt></p><h1 id="广播（broadcast）"><a href="#广播（broadcast）" class="headerlink" title="广播（broadcast）"></a>广播（broadcast）</h1><p>广播（broadcast）是指封包在计算机网络中传输时，目的地址为网络中所有设备的一种传输方式。实际上，这里所说的“所有设备”也是限定在一个范围之中，称为“广播域”。</p><p>并非所有的计算机网络都支持广播，例如X.25网络和帧中继都不支持广播，而且也没有在“整个互联网范围中”的广播。IPv6亦不支持广播，广播相应的功能由任播（anycast）代替。通常，广播都是限制在局域网中的，比如以太网或令牌环网络。因为广播在局域网中造成的影响远比在广域网中小得多。你在公司大喊一声“放假了”， 全部同事都会响应，大叫爽死了。</p><p><img src="/images/network_broadcast_1_1.png" alt></p><p>广播地址（Broadcast Address）是专门用于向网络中所有工作站发送消息的一个地址。在使用TCP/IP协议的网络中，主机标识段host ID为全1的IP地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0（255.255.255.0）网段，其广播地址为10.1.1.255（255 即为2进制的11111111），当发出一个目的地址为10.1.1.255的分组（封包）时，它将被分发给该网段上的所有计算机。</p><p>在Linux中是ifconfig可以查看一个网卡配置的广播地址，或者为某一块网卡配置广播地址。举例来说，</p><pre><code>ifconfig eth0 10.0.0.1 broadcast 10.0.0.255 netmask 255.255.255.0  #为10.0.0.1的网卡配置广播地址为10.0.0.255</code></pre><h1 id="任播（anycast）"><a href="#任播（anycast）" class="headerlink" title="任播（anycast）"></a>任播（anycast）</h1><p>任播（anycast）是一种网络寻址和路由的策略，使得资料可以根据路由拓朴来决定送到“最近”或“最好”的目的地。</p><p>在单播中，在发送者和接收者之间存在一一对应的关系。在广播和组播中，在发送者和接收者之间存在一对多的关系，发送者对应一群可以接收消息的节点。在任播中，在发送者和接收者之间存在一对多的关系，发送者对应一群接收节点，但在任何给定时间，只有其中之一可以接收到传送端发来的消息。</p><p>在互联网中，通常使用边界网关协议来实现任播。作为老板，你在公司大喊一声“开发组的过来一个人”， 总会有一个人灰溜溜去响应， 挨批还是发钱啊？</p><h1 id="一点闲杂"><a href="#一点闲杂" class="headerlink" title="一点闲杂"></a>一点闲杂</h1><p>（1） 广播域</p><p>广播域是网络中的一组设备的集合，即同一广播包能到达的所有设备成为一个广播域。二层网络上有广播域，广播帧的目标MAC地址是FF:FF:FF:FF:FF:FF。IP层网络也有广播域名，广播数据包的目标IP地址是255.255.255.255。</p><p>一个二层网络（以太网）内就是一个广播域。在二层网络继续划分出来的逻辑二层网络，逻辑二层网络也就是VLAN，每一个VLAN内也是一个隔离广播域。其实觉得VLAN这个缩写不太对，LAN是局域网，局域网/城域网/广域网是计算机网络范围的界定，局域网可能是一个区域的网络，可能有多个子网，也就是一个很大的网络，比如一个校园网也是一个局域网。VLAN应该算是虚拟二层网络或逻辑二层网络。</p><p>学习资料参考于：<br><a href="http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/" target="_blank" rel="noopener">http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SaltStack Python Client API小结</title>
      <link href="/2019/03/05/SaltStack-Python-Client-API%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/05/SaltStack-Python-Client-API%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="获取Salt-OPTS字典（salt-master端）"><a href="#获取Salt-OPTS字典（salt-master端）" class="headerlink" title="获取Salt OPTS字典（salt-master端）"></a>获取Salt OPTS字典（salt-master端）</h1><p>即获取salt-master的主配置文件/etc/salt/master的结构化数据，代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> salt.config</span><br><span class="line">master_opts = salt.config.client_config(<span class="string">'/etc/salt/master'</span>)</span><br><span class="line"><span class="keyword">print</span> master_opts</span><br></pre></td></tr></table></figure><p>备注：需要在salt-master所在机器上执行哦。</p><h1 id="获取Salt-OPTS字典（salt-minion端）"><a href="#获取Salt-OPTS字典（salt-minion端）" class="headerlink" title="获取Salt OPTS字典（salt-minion端）"></a>获取Salt OPTS字典（salt-minion端）</h1><p>即获取salt-minion的主配置文件/etc/salt/minion的结构化数据，代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> salt.config</span><br><span class="line">minion_opts = salt.config.minion_config(<span class="string">'/etc/salt/minion'</span>)</span><br><span class="line"><span class="keyword">print</span>  minion_opts</span><br></pre></td></tr></table></figure><p>备注： 需要在salt-minion所在机器上执行哦。</p><h1 id="salt-client-LocalClient"><a href="#salt-client-LocalClient" class="headerlink" title="salt.client.LocalClient"></a>salt.client.LocalClient</h1><p>代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> salt.client</span><br><span class="line">localClient = salt.client.LocalClient()</span><br><span class="line">localClient.cmd(<span class="string">'*'</span>, <span class="string">'cmd.run'</span>, [<span class="string">'whoami'</span>])</span><br></pre></td></tr></table></figure><p>备注：需要在salt-master所在机器上执行哦。</p><h1 id="salt-client-Caller"><a href="#salt-client-Caller" class="headerlink" title="salt.client.Caller"></a>salt.client.Caller</h1><p>该API类似于salt-minion上salt-call命令，用来在salt-minion端执行一些命令，代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> salt.client</span><br><span class="line">caller = salt.client.Caller()</span><br><span class="line">caller.cmd(<span class="string">'test.ping'</span>)</span><br></pre></td></tr></table></figure><p>备注：需要在salt-minion所在机器上执行哦。</p><h1 id="salt-runner-RunnerClient"><a href="#salt-runner-RunnerClient" class="headerlink" title="salt.runner.RunnerClient"></a>salt.runner.RunnerClient</h1><p>该API类似于salt-master上salt-run命令，用来在salt-master端执行一些命令，代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> salt.runner</span><br><span class="line">runnerClient = salt.runner.RunnerClient()</span><br><span class="line">runnerClient.cmd(<span class="string">'*'</span>, <span class="string">'cmd.run'</span>, [<span class="string">'whoami'</span>])</span><br></pre></td></tr></table></figure><h1 id="salt-wheel-WheelClient"><a href="#salt-wheel-WheelClient" class="headerlink" title="salt.wheel.WheelClient"></a>salt.wheel.WheelClient</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> salt.config</span><br><span class="line"><span class="keyword">import</span> salt.wheel</span><br><span class="line">opts = salt.config.master_config(<span class="string">'/etc/salt/master'</span>)</span><br><span class="line">wheel = salt.wheel.WheelClient(opts)</span><br><span class="line">wheel.cmd(<span class="string">'key.finger'</span>, [<span class="string">'jerry'</span>])</span><br></pre></td></tr></table></figure><h1 id="salt-cloud-CloudClient"><a href="#salt-cloud-CloudClient" class="headerlink" title="salt.cloud.CloudClient"></a>salt.cloud.CloudClient</h1><p>待补充</p><h1 id="ssh-client-SSHClient"><a href="#ssh-client-SSHClient" class="headerlink" title="ssh.client.SSHClient"></a>ssh.client.SSHClient</h1><p>利用ssh协议来执行一些操作。</p><h1 id="salt-api"><a href="#salt-api" class="headerlink" title="salt-api"></a>salt-api</h1><p>详细内容参见<a href="https://docs.saltstack.com/en/latest/ref/netapi/all/salt.netapi.rest_cherrypy.html" target="_blank" rel="noopener">《REST_CHERRYPY用户文档》</a></p><p>学习资料参考于：<br><a href="https://docs.saltstack.com/en/latest/ref/clients/index.html" target="_blank" rel="noopener">https://docs.saltstack.com/en/latest/ref/clients/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SaltStack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SaltStack事件驱动Event和Reactor小结</title>
      <link href="/2019/03/05/SaltStack%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8Event%E5%92%8CReactor%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/05/SaltStack%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8Event%E5%92%8CReactor%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Event和Reactor"><a href="#Event和Reactor" class="headerlink" title="Event和Reactor"></a>Event和Reactor</h1><p>SaltStack的内部组件之间的通信是通过发送和监听事件实现的。在SaltStack中，几乎所有的变动都会产生事件，如salt-minion连接salt-master、密钥被接受或拒绝、发送作业、从minion返回作业结果、心跳包发送，甚至是salt命令行接口使用事件系统都会产生事件。</p><p>Event对SaltStack里面的每一个事件进行了记录，比Job更加底层，Event可以记录Minion连接Master、Key认证、job等。Reactor是基于每个Event事件做相应的操作，Reactor监听Event，触发一些States操作。</p><p>在Salt-Master上执行命令<code>salt-run state.event pretty=True</code>，然后可以看到Salt-Master上产生的所有Event事件。例如我们重启某台salt-minion的进程，然后通过<code>salt-run state.event pretty=True</code>命令可以看到salt-master上产生了如下的一些Event：</p><p><img src="/images/saltstack_1_6.png" alt></p><p>其中每个Event包括tag和data两部分，如salt/auth表示事件Event的tag，花括号{}中的内容是事件Event的data。</p><h1 id="Event和Reactor的使用"><a href="#Event和Reactor的使用" class="headerlink" title="Event和Reactor的使用"></a>Event和Reactor的使用</h1><p>Reactor模块用来匹配指定规则的Salt Event，然后触发相应的动作。Reactor的具体使用如下：</p><p>（1）首先Reactor的主要配置文件在/etc/salt/master.d/reactor.conf中，举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reactor:</span><br><span class="line">  - &apos;salt/auth&apos;:</span><br><span class="line">    - /opt/salt/reactor/test1.sls</span><br><span class="line">  - &apos;salt/minion/*/start&apos;:</span><br><span class="line">    - /opt/salt/reactor/test2.sls</span><br></pre></td></tr></table></figure><p>上述表示，若匹配到salt/auth的Event，就执行/opt/salt/reactor/test1.sls中定义的动作。若匹配到salt-minion重启的Event（<code>salt/minion/*/start</code>），则执行<code>/opt/salt/reactor/test2.sls</code>中定义的动作。</p><p>（2）定义具体匹配Event后要执行的动作，也即上面的/opt/salt/reactor/test1.sls和/opt/salt/reactor/test1.sls。</p><h1 id="常见的SaltStack事件Event"><a href="#常见的SaltStack事件Event" class="headerlink" title="常见的SaltStack事件Event"></a>常见的SaltStack事件Event</h1><p>（1）<code>salt/auth</code></p><p>salt-minion向salt-master发送了公钥，并请求salt-master进行认证。</p><p>（2）<code>salt/minion/*/start</code></p><p>某台salt-minion启动了，如salt/minion/6000006049/start代表了minion id为6000006049的salt-minion启动了。</p><p>备注：我们可以定义自定义Event事件哦，这个非常有用。如在salt-minion执行命令<code>salt-call event.send /my/test/event &#39;{&quot;data&quot;: &quot;my event test&quot;}&#39;</code>，即发出了一个<code>/my/test/event</code>的自定义Event事件。</p>]]></content>
      
      
      <categories>
          
          <category> SaltStack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SaltStack Runners模块</title>
      <link href="/2019/03/04/SaltStack-Runners%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/03/04/SaltStack-Runners%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="SaltStack-Runners模块简介"><a href="#SaltStack-Runners模块简介" class="headerlink" title="SaltStack Runners模块简介"></a>SaltStack Runners模块简介</h1><p>SaltStack Runners的写法和SaltStack的Execution Module的差不多。但是需要注意的是，Execution Module是在salt-minion上执行命令或脚本。而SaltStack Runners模块是在salt-master本地执行命令或脚本。</p><h1 id="SaltStack-Runners模块的使用"><a href="#SaltStack-Runners模块的使用" class="headerlink" title="SaltStack Runners模块的使用"></a>SaltStack Runners模块的使用</h1><p>（1）首先配置Runners模块的脚本存放路径</p><p>修改/etc/salt/master中runner_dirs的配置，即表示修改了Runners模块的脚本存放路径。</p><p>（2）编写Runners模块的自定义脚本</p><p>在runner_dirs指定的目录中编写Python脚本，举例来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#root@salt-master:~# cat /srv/salt/_runners/lsdir.py</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> salt.client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lsdir</span><span class="params">(directory)</span>:</span></span><br><span class="line">    match = re.findall(<span class="string">r'^(/)'</span>,directory)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> match:</span><br><span class="line">        directory = <span class="string">"/%s"</span> % directory</span><br><span class="line">    client = salt.client.LocalClient(__opts__[<span class="string">'conf_file'</span>])</span><br><span class="line">    ret = client.cmd(<span class="string">'*'</span>, <span class="string">'cmd.run'</span>, [<span class="string">'/bin/ls /home'</span>], timeout=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> ret.items():</span><br><span class="line">        value_list = value.split(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"\033[31m%s\033[0m"</span> % key</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> value_list:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"\033[32m%s\033[0m"</span> % value</span><br></pre></td></tr></table></figure><p>（3）使用salt-run命令执行</p><p>执行命令<code>salt-run lsdir.lsdir home</code>即可。其中lsdir.lsdir是Python模块名和函数名的拼接。</p>]]></content>
      
      
      <categories>
          
          <category> SaltStack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SaltStack Pillar组件</title>
      <link href="/2019/03/04/SaltStack-Pillar%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/03/04/SaltStack-Pillar%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Pillar组件简介"><a href="#Pillar组件简介" class="headerlink" title="Pillar组件简介"></a>Pillar组件简介</h1><p>Pillar也是Key/Value，但是Pillar数据是动态的，和salt-minion启不启动没关系，它给特定的salt-minion指定特定的数据，只有指定的salt-minion才能看到自己的数据。</p><h1 id="SaltStack-Pillar的使用"><a href="#SaltStack-Pillar的使用" class="headerlink" title="SaltStack Pillar的使用"></a>SaltStack Pillar的使用</h1><p>（1）在salt-master上开启Pillar及配置pillar_roots</p><p>在/etc/salt/master中配置pillar_roots，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pillar_roots:</span><br><span class="line">  base:</span><br><span class="line">    - /srv/pillar</span><br><span class="line">pillar_opts: True</span><br></pre></td></tr></table></figure><p>（2）创建一个Pillar的sls，名称为/srv/pillar/web/apache.sls</p><p>文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if grains[&apos;os&apos;] == &apos;CentOS&apos; %&#125;</span><br><span class="line">apache: httpd</span><br><span class="line">&#123;% elif grains[&apos;os&apos;] == &apos;Debian&apos; %&#125;</span><br><span class="line">apache: apache2</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>（3）配置Pillar的top file，名称为/srv/pillar/top.sls</p><p>编辑top file（Pillar必须要写top file，不像SaltStack State不写top file也可以），文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base:</span><br><span class="line">  &apos;linux-node2*&apos;:</span><br><span class="line">    - web.apache</span><br></pre></td></tr></table></figure><p>（4）刷新Pillar并测试获取pillar item</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salt <span class="string">'*'</span> saltutil.refresh_pillar</span><br><span class="line">salt <span class="string">'*'</span> pillar.items apache</span><br></pre></td></tr></table></figure><p><img src="/images/saltstack_1_4.png" alt></p><h1 id="Grains-VS-Pillar"><a href="#Grains-VS-Pillar" class="headerlink" title="Grains VS. Pillar"></a>Grains VS. Pillar</h1><p><img src="/images/saltstack_1_5.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> SaltStack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SaltStack Grains组件</title>
      <link href="/2019/03/04/SaltStack-Grains%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/03/04/SaltStack-Grains%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Grains组件简介"><a href="#Grains组件简介" class="headerlink" title="Grains组件简介"></a>Grains组件简介</h1><p>Grains是SaltStack组件中非常重要的组件之一，因为我们在做配置部署的过程中会经常使用它，Grains是SaltStack记录salt-minion的一些静态信息的组件，我们可以简单地理解为Grains里面记录着每台salt-minion的一些常用属性，比如操作系统、主机名、CPU、内存、磁盘、网络信息等，我们可以通过grains.items查看某台salt-minion的所有Grains信息，salt-minion的Grains信息是salt-minion启动的时候采集汇报给salt-master的，在实际应用环境中我们需要根据自己的业务需求去自定义一些Grains。</p><p>简单来说，Grains就是在salt-minion端去配置一些元信息，然后在salt-master端可以读取及使用这些信息。</p><h1 id="Grains组件的使用"><a href="#Grains组件的使用" class="headerlink" title="Grains组件的使用"></a>Grains组件的使用</h1><p>Grains信息是需要在salt-minion端来配置，既可以在主配置文件/etc/salt/minion中配置，也可以在/etc/salt/grains中配置。下面分别举例来说明：</p><p>（1）在/etc/salt/minion中配置Grains信息</p><p>我们可以在salt-minion的配置文件/etc/salt/minion中去配置grains，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grains:</span><br><span class="line">  roles:</span><br><span class="line">    - webserver</span><br><span class="line">    - memcache</span><br><span class="line">  deployment: datacenter4</span><br><span class="line">  cabinet: 13</span><br><span class="line">  cab_u: 14-15</span><br></pre></td></tr></table></figure><p>（2）在/etc/salt/grains中配置Grains信息</p><p>如果想将Grains信息从/etc/salt/minion中独立出来，那么可以在/etc/salt/grains中配置即可。举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">username:</span><br><span class="line">  wahaha</span><br><span class="line">password:</span><br><span class="line">  abc1234</span><br></pre></td></tr></table></figure><p>需要注意的是，/etc/salt/grains不需要grains这个最上层的key。若/etc/salt/minion和/etc/salt/grains存在相同的Grains Key，则只会生效/etc/salt/minion中的信息。</p><p>通过上面的配置，就可以在salt-master端通过<code>salt &#39;minion_id&#39; grains.items</code>来查看指定salt-minion的Grains信息。另外，可以通过Grains定义的属性来识别满足条件的机器，如<code>salt -G roles:webserver cmd.run &#39;hostname&#39;</code>在所有的Grains role为webserver的机器上执行hostname命令。若salt-minion上Grains信息变更了，需要在salt-master执行<code>salt &#39;*&#39; saltutil.refresh_modules</code>使之生效。</p>]]></content>
      
      
      <categories>
          
          <category> SaltStack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SaltStack State组件</title>
      <link href="/2019/03/04/SaltStack-State%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/03/04/SaltStack-State%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="SaltStack-State机制简介"><a href="#SaltStack-State机制简介" class="headerlink" title="SaltStack State机制简介"></a>SaltStack State机制简介</h1><p>state，中文为状态，可以简单理解为，我们希望salt-minion要达到什么样的状态，比如说装什么软件、配置成什么样、服务是该运行还是该停止等等。我们定义了state，然后让所有的salt-minion去执行，则我们的salt-minion就会成为我们在state中定义的那个状态了。</p><p>简单来说，salt-master指导salt-minion干活，无外乎两种方式。一种是通过远程执行命令，另外一种方式就是saltstack state了。saltstack state可以理解为按照一定的逻辑把命令组织成脚本，就像Linux里面的shell脚本一样。显而易见，有组织有纪律的state干起活来肯定比远程执行一个命令要高效得多。</p><h1 id="sls文件"><a href="#sls文件" class="headerlink" title="*.sls文件"></a><code>*.sls</code>文件</h1><p><code>*.sls</code>是saltstack State的核心，我们将状态规则定义到sls文件中，然后让salt-minion去执行才能达到这个效果。举一个sls文件例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">install_network_packages:</span><br><span class="line">  pkg.installed:</span><br><span class="line">    - pkgs:</span><br><span class="line">      - rsync</span><br><span class="line">      - lftp</span><br><span class="line">      - curl</span><br></pre></td></tr></table></figure><p>上面的sls就表示，需要salt-minion去安装rsysc/lftp/curl这三个包。</p><p>Salt States文件（<code>*.sls</code>文件）的存放位置默认在salt-master的/srv/salt目录下，当然可以通过修改salt-master的主配置文件/etc/salt/master来修改这个位置，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_roots:</span><br><span class="line">  base:</span><br><span class="line">    - /opt/salt/sls</span><br></pre></td></tr></table></figure><p>当然saltstack State也支持多环境的配置，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file_roots:</span><br><span class="line">  base:</span><br><span class="line">    - /srv/salt/base</span><br><span class="line">  dev:</span><br><span class="line">    - /srv/salt/dev</span><br><span class="line">  test:</span><br><span class="line">    - /srv/salt/test</span><br><span class="line">  prod:</span><br><span class="line">    - /srv/salt/prod</span><br></pre></td></tr></table></figure><h1 id="SaltStack-State的使用"><a href="#SaltStack-State的使用" class="headerlink" title="SaltStack State的使用"></a>SaltStack State的使用</h1><p>SaltStack State有两种方式执行，一种是手动执行state方式；另一种是highstate的方式。详细如下：</p><p>（1）手动执行state的方式</p><p>例如我们编写一个/srv/salt/nettools.sls，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">install_network_packages:</span><br><span class="line">  pkg.installed:</span><br><span class="line">    - pkgs:</span><br><span class="line">      - rsync</span><br><span class="line">      - lftp</span><br><span class="line">      - curl</span><br></pre></td></tr></table></figure><p>然后执行<code>salt &#39;minion2&#39; state.apply nettools</code>或<code>salt &#39;minion2&#39; state.sls nettools</code>将上述nettools.sls生效到minion2这台机器上。</p><p>（2）highstate的方式</p><p>其实是使用top.sls作为SaltStack state的入口文件，top.sls文件是SaltState的默认sls文件。下面以一个例子来说明，新建top.sls文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base:</span><br><span class="line">  &apos;*&apos;:</span><br><span class="line">    - webserver</span><br></pre></td></tr></table></figure><p>然后编写top.sls中引用的webserver.sls文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">httpd:</span><br><span class="line">   pkg:</span><br><span class="line">     - installed</span><br><span class="line">   service:</span><br><span class="line">     - running</span><br><span class="line">     - require:</span><br><span class="line">       - pkg: httpd</span><br></pre></td></tr></table></figure><p>然后执行<code>salt &#39;*&#39; state.highstate</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> SaltStack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SaltStack技术简介</title>
      <link href="/2019/03/04/SaltStack%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/03/04/SaltStack%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="SaltStack简介"><a href="#SaltStack简介" class="headerlink" title="SaltStack简介"></a>SaltStack简介</h1><p>SaltStack是基于Python开发的一套C/S架构配置管理工具（功能不仅仅是配置管理，如使用salt-cloud配置AWS EC2实例），它的底层使用ZeroMQ消息队列Pub/Sub方式通信，使用SSL证书签发的方式进行认证管理。号称世界上最快的消息队列ZeroMQ使得SaltStack能快速在成千上万台机器上进行各种操作，而且采用RSA Key方式确认身份，传输采用AES加密，这使得它的安全性得到了保障。SaltStack具备配置管理、远程执行、监控等功能，一般可以理解为是简化版的Puppet和加强版的Func。SaltStack本身是基于Python语言开发实现，结合了轻量级的消息队列软件ZeroMQ与Python第三方模块（Pyzmq、PyCrypto、Pyjinjia2、python-msgpack和PyYAML等）构建。</p><p>puppet、chef、ansible以及saltstack都是同类性质的工具平台。</p><h1 id="SaltStack架构"><a href="#SaltStack架构" class="headerlink" title="SaltStack架构"></a>SaltStack架构</h1><p>在SaltsStack架构中服务端叫作Master，客户端叫作Minion，都是以守护进程的模式运行。salt-master一直监听配置文件中定义的ret_port（saltstack客户端与服务端通信的端口，负责接收客户端发送过来的结果，默认4506端口）和publish_port（saltstack的消息发布系统，默认4505端口）的端口。salt-minion在启动时，会自动生成一套密钥，包含私钥和公钥。之后将公钥发送给服务器端，服务器端验证并接受公钥，以此来建立可靠且加密的通信连接，同时通过消息队列ZeroMQ在客户端与服务端之间建立消息发布连接。</p><p><img src="/images/saltstack_1_1.png" alt></p><p>salt-minion是SaltStack需要管理的客户端安装组件，会主动去连接salt-master端，并从salt-master端得到资源状态信息，同步资源管理信息。salt-master作为控制中心运行在主机服务器上，负责salt命令运行和资源状态的管理。ZeroMQ是一款开源的消息队列软件，用于在salt-minion端与salt-master端建立系统通信桥梁。</p><p>需要注意的是，ZeroMQ并非RocketMQ这样的消息队列。ZeroMQ仅仅就是一个消息队列库，有点像socket一样的东西，但比socket要高级。</p><h1 id="salt-master和salt-minion的安装"><a href="#salt-master和salt-minion的安装" class="headerlink" title="salt-master和salt-minion的安装"></a>salt-master和salt-minion的安装</h1><p>下面以CentOS6为例来说明：</p><p>（1）安装EPEL YUM源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh https://mirrors.tuna.tsinghua.edu.cn/epel/epel-release-latest-6.noarch.rpm</span><br></pre></td></tr></table></figure><p>（2）安装并启动salt管理端salt-master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install salt-master</span><br><span class="line">service salt-master start</span><br></pre></td></tr></table></figure><p>备注：salt-master启动之后会监听两个端口，一个是ret_port，该端口负责接收来自salt-minion发送过来的结果，默认4506端口；另一个是publish_port，该端口是saltstack的消息发布系统，默认4505端口。</p><p>（3）安装并启动salt客户端salt-minion</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install salt-minion</span><br><span class="line">sed -i <span class="string">'s@#master:.*@master: master_ipaddress@'</span> /etc/salt/minion  <span class="comment">#master_ipaddress为管理端IP</span></span><br><span class="line"><span class="built_in">echo</span> 10.252.137.141 &gt; /etc/salt/minion_id   <span class="comment">#个人习惯使用IP，默认主机名</span></span><br><span class="line">service salt-minion start</span><br></pre></td></tr></table></figure><p>当salt-minion启动时会自动连接到配置文件中定义的master地址ret_port端口进行连接认证。</p><p>备注：salt-master和salt-minion最好是同一个YUM仓库源，不然会出现奇怪的问题啦。</p><h1 id="salt-master-salt-minion的配置文件"><a href="#salt-master-salt-minion的配置文件" class="headerlink" title="salt-master/salt-minion的配置文件"></a>salt-master/salt-minion的配置文件</h1><p>salt-master/salt-minion的配置文件都在/etc/salt/目录中。</p><p>（1）salt-master的主要配置</p><pre><code>/etc/salt/master               #salt-master的主配置文件/etc/salt/pki/master/minions/  #该目录中存放了所有salt-minion的公钥</code></pre><p>（2）salt-minion的主要配置</p><pre><code>/etc/salt/minion       #salt-minion的主配置文件/etc/salt/minion_id    #存放的是salt-minion的id/etc/salt/pki/minion/  #该目录存放的是该salt-minion的公私钥</code></pre><h1 id="salt-master和salt-minion间认证"><a href="#salt-master和salt-minion间认证" class="headerlink" title="salt-master和salt-minion间认证"></a>salt-master和salt-minion间认证</h1><p>salt-minion在第一次启动时，会在/etc/salt/pki/minion/（该路径在/etc/salt/minion里面设置）下自动生成minion.pem（private key）和 minion.pub（public key），然后将minion.pub发送给salt-master。salt-master在接收到salt-minion的public key后，通过salt-key命令accept salt-minion public key，这样在salt-master的/etc/salt/pki/master/minions下的将会存放以minion id命名的public key，然后salt-master就能对salt-minion发送指令了。即salt-master使用salt-minion的public key来加密指令发送给salt-minion来实现安全通信的。</p><p>在salt-master端关于认证相关的命令有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salt-key -L     <span class="comment">#查看salt-master当前公钥认证情况</span></span><br><span class="line">salt-key -A -y  <span class="comment">#同意接受所有没有接受的salt-minion公钥</span></span><br></pre></td></tr></table></figure><h1 id="salt-master执行命令"><a href="#salt-master执行命令" class="headerlink" title="salt-master执行命令"></a>salt-master执行命令</h1><p>通用的salt-master命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salt <span class="string">'&lt;target&gt;'</span> &lt;module.function&gt; [arguments]</span><br></pre></td></tr></table></figure><p>举例来说：</p><p><img src="/images/saltstack_1_2.png" alt></p><p>其中，target是执行salt命令的目标，即代表一批salt-minion，可以使用通配符、Grains、列表以及正则表达式等；function是方法，由module提供；arguments是function的参数。</p><p>常用的命令举例有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">salt <span class="string">'*'</span> test.ping           <span class="comment">#ping所有的salt-minion</span></span><br><span class="line">salt <span class="string">'*'</span> disk.usage          <span class="comment">#查看所有的salt-minion的磁盘使用率</span></span><br><span class="line">salt <span class="string">'*'</span> network.interfaces  <span class="comment">#查看机器的网络接口卡信息</span></span><br><span class="line">salt <span class="string">'*'</span> cmd.run <span class="string">'uname -r'</span>  <span class="comment">#*代表对所有的被管理客户端进行操作，cmd.run是命令调用模块</span></span><br><span class="line">salt <span class="string">'*'</span> pkg.install <span class="string">'lrzsz'</span> <span class="comment">#批量安装lrzsz软件</span></span><br></pre></td></tr></table></figure><p>另外，可以将module或function的名称作为参数传递给sys.doc，从而可以看到相应的一些帮助文档。命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salt <span class="string">'*'</span> sys.doc pkg</span><br><span class="line">salt <span class="string">'*'</span> sys.doc pkg.install</span><br><span class="line">salt <span class="string">'*'</span> cmd.script salt://hostname.sh   <span class="comment">#在salt-minion上执行salt-mater中file_roots中hostname.sh脚本文件，很重要哦</span></span><br></pre></td></tr></table></figure><h1 id="SaltStack的执行模块"><a href="#SaltStack的执行模块" class="headerlink" title="SaltStack的执行模块"></a>SaltStack的执行模块</h1><p>SaltStack有很多的执行模块，一部分的模块列表如下：</p><p><img src="/images/saltstack_1_3.png" alt></p><p>例如，我们常用的有cmdmod（执行shell命令）等。</p><h1 id="salt-master-salt-minion运行日志"><a href="#salt-master-salt-minion运行日志" class="headerlink" title="salt-master/salt-minion运行日志"></a>salt-master/salt-minion运行日志</h1><p>salt-master的运行日志在<code>/var/log/salt/master</code>；salt-minion的运行日志在<code>/var/log/salt/minion</code>。</p><h1 id="salt-master端的一些常用工具命令"><a href="#salt-master端的一些常用工具命令" class="headerlink" title="salt-master端的一些常用工具命令"></a>salt-master端的一些常用工具命令</h1><p>（1）salt</p><p>在远程系统上执行命令。</p><p>（2）salt-key</p><p>salt-minion每次启动时会连接到salt-master时，会将salt-minion的公钥发送给salt-master，然后salt-master会利用salt-key命令来查看或同意接收新的公钥。具体命令举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salt-key -L      <span class="comment">#查看salt-master当前公钥认证情况</span></span><br><span class="line">salt-key -A -y   <span class="comment">#同意接收所有没有接收的salt-minion公钥</span></span><br></pre></td></tr></table></figure><p>（3）salt-run</p><p>是SaltStack Runners模块的工具命令。</p><h1 id="salt-minion端的一些常用工具命令"><a href="#salt-minion端的一些常用工具命令" class="headerlink" title="salt-minion端的一些常用工具命令"></a>salt-minion端的一些常用工具命令</h1><p>（1）salt-call</p><p>用于在salt-minion上执行一个模块函数，如<code>salt-call event.send *</code>产生一个事件Event。</p><h1 id="SaltStack与Ansible的比较"><a href="#SaltStack与Ansible的比较" class="headerlink" title="SaltStack与Ansible的比较"></a>SaltStack与Ansible的比较</h1><p>Ansible、SaltStack都是基于Python开发的，Ansible基于SSH协议传输数据，SaltStack使用消息队列ZeroMQ传输数据。从网上数据来看，SaltStack比Ansible快大约40倍。对比Ansible，SaltStack缺点是需要安装客户端。为了速度建议选择SaltStack。</p><p>网络上有人测试过SaltStack与Ansible的性能数据。测试场景是对1000台服务器执行相同的操作所消耗的时间，基于SSH协议的Ansible耗时85s左右，基于ZeroMQ的SaltStack耗时2s左右。</p><p>学习资料参考于：<br><a href="https://www.ibm.com/developerworks/cn/opensource/os-devops-saltstack-in-cloud/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-devops-saltstack-in-cloud/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SaltStack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis技术小结</title>
      <link href="/2019/03/04/MyBatis%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/04/MyBatis%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h1><p>MyBatis本是Apache的一个开源项目iBatis，2010年这个项目由Apache Software Foundation迁移到了Google Code，并且改名为MyBatis。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）。MyBatis是iBatis的升级版，用法有很多的相似之处，但是MyBatis进行了重要的改进。</p><p>MyBatis是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或注解来配置和映射原生信息，将接口和Java的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。</p><p>备注：Hibernate比较重，Mybatis比较轻，简单易用。</p><h1 id="MyBatis的架构和原理"><a href="#MyBatis的架构和原理" class="headerlink" title="MyBatis的架构和原理"></a>MyBatis的架构和原理</h1><p>MyBatis的架构图如下：</p><p><img src="/images/java_mybatis_1_1.png" alt></p><p>MyBatis应用程序根据XML配置文件创建SqlSessionFactory，SqlSessionFactory在根据配置，配置来源于两个地方，一处是配置文件，一处是Java代码的注解，获取一个SqlSession。SqlSession包含了执行sql所需要的所有方法，可以通过SqlSession实例直接运行映射的SQL语句，完成对数据的增删改查和事务提交等，用完之后关闭SqlSession。</p><h1 id="MyBatis框架中的一些基础框架"><a href="#MyBatis框架中的一些基础框架" class="headerlink" title="MyBatis框架中的一些基础框架"></a>MyBatis框架中的一些基础框架</h1><pre><code>SqlSessionFactoryBuilderSqlSessionFactorySqlSession()Mapper</code></pre><h1 id="MyBatis使用"><a href="#MyBatis使用" class="headerlink" title="MyBatis使用"></a>MyBatis使用</h1><p>（1）引入Maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）编写mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/bat/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）编写SQL到实体类的映射文件</p><p>比如BlogMapper.xml文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.bat.BlogMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>备注：这里<code>id=&quot;selectBlog&quot;</code>是给这条SQL语句命个名字，然后就可以在代码中调用，从而执行这条SQL语句。</p><p>MyBatis也支持使用注解代替xml文件方法，如上可以用下面接口来达到同样效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Select</span>(<span class="string">"SELECT * FROM blog WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）生成SqlSessionFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"org/mybatis/mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure><p>（5）获取数据库SqlSession并进行CRUD操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MyBatis优势"><a href="#MyBatis优势" class="headerlink" title="MyBatis优势"></a>MyBatis优势</h1><p>相对于JPA/Hibernate来说，MyBatis主要优势有：</p><pre><code>SQL语句可以自由控制，更灵活，性能较高SQL与代码分离，易于阅读和维护提供XML标签，支持编写动态SQL语句</code></pre><p>相对于MyBatis来说，JPA/Hibernate主要优势有：</p><pre><code>JPA移植性比较好（JPQL），若换了底层数据库，不用修改代码，只需修改一些数据库的配置信息即可提供了更多的CRUD方法，开发效率高对象化程度更高</code></pre><p>学习资料参考于：<br><a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SSM/SSH </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate技术小结</title>
      <link href="/2019/03/04/Hibernate%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/04/Hibernate%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Hibernate简介"><a href="#Hibernate简介" class="headerlink" title="Hibernate简介"></a>Hibernate简介</h1><p>Hibernate是一个符合JPA规范的对象关系映射ORM框架。</p><h1 id="Hibernate的使用"><a href="#Hibernate的使用" class="headerlink" title="Hibernate的使用"></a>Hibernate的使用</h1><p>（1）编写实体类</p><p>如Person类。</p><p>（2）编写实体类和数据库表的映射文件</p><p>如Person.hbm.xml。</p><p>（3）编写Hibernate的主配置文件hibernate.cfg.xml</p><p>hibernate.cfg.xml中配置数据库的地址、用户名、密码等基本信息，同时将第（2）步中的定义的对象关系映射文件配置到hibernate.cfg.xml中。</p><p>（4）使用Hibernate提供工具加载hibernate.cfg.xml，并获取到SessionFactory对象，SessionFactory对象可以打开与数据库连接会话，通过会话我们就可以操作数据库了。伪代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration().configure();  <span class="comment">//Hibernate会在类路径的根路径下自动寻找名为hibernate.cfg.xml的配置文件并加载</span></span><br><span class="line">sessionFactory = cfg.buildSessionFactory();</span><br><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">Transaction ts = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ts = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询操作，对标Select语句</span></span><br><span class="line">    Query query = session.createQuery(<span class="string">"from Course"</span>);</span><br><span class="line">    <span class="comment">//session.find(".....");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加操作，对标Insert语句</span></span><br><span class="line">    <span class="comment">//User user = new User();</span></span><br><span class="line">    <span class="comment">//user.setLoginName("amigo");</span></span><br><span class="line">    <span class="comment">//session.save(employee);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改操作，对标Update语句</span></span><br><span class="line">    <span class="comment">//User user = session.get(User.class, "amigo");</span></span><br><span class="line">    <span class="comment">//user.setFullName("xxxx");</span></span><br><span class="line">    <span class="comment">//session.update(user);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除操作，对标Delete语句</span></span><br><span class="line">    <span class="comment">//User user = session.get(User.class, "amigo");</span></span><br><span class="line">    <span class="comment">//session.delete(user);</span></span><br><span class="line">    ts.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：这个是Hibernate的最传统的使用方式，Hibernate支持通过注解来提高开发效率哦。</p><h1 id="Hibernate与MyBatis的区别"><a href="#Hibernate与MyBatis的区别" class="headerlink" title="Hibernate与MyBatis的区别"></a>Hibernate与MyBatis的区别</h1><p>Hibernate和MyBatis同为实现了JPA规范的ORM框架，它们有很多的区别。</p><p>ORM框架的本质是简化编程中与数据库相关的交互，发展到现在基本上就剩两家了，一个是宣称可以不用写一句SQL的Hibernate，一个是可以灵活调试动态SQL的MyBatis，两者各有特点，在企业级系统开发中可以根据需求灵活使用。Hibernate特点就是所有的SQL都用Java代码来生成，不用跳出程序去写（看）SQL，有着编程的完整性，发展到最顶端就是Spring Data JPA这种模式了，基本上根据方法名就可以生成对应的SQL了。MyBatis初期使用比较麻烦，需要各种配置文件、实体类、dao层映射关联、还有一大推其它配置。当然MyBatis也发现了这种弊端，初期开发了generator可以根据表结果自动生产实体类、配置文件和dao层代码，可以减轻一部分开发量，后期也进行了大量的优化可以使用注解了，自动管理DAO层和配置文件等。目前MyBatis已经可以和SpringBoot进行整合集成，即在SpringBoot项目中使用mybatis-spring-boot-starter依赖，可以通过注解的方式将Mybatis和SpringBoot进行整合。</p><p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。属于全自动的ORM框架，着力点在于POJO和数据库表之间的映射，完成映射即可自动生成和执行SQL。</p><p>而MyBatis本是Apache的一个开源项目iBatis，2010年这个项目由Apache Software Foundation迁移到了Google Code，并且改名为MyBatis 。属于半自动的ORM框架，着力点在于POJO和SQL之间的映射，自己编写SQL语句，然后通过配置文件将所需的参数和返回的字段映射到POJO。</p><p>总之，Hibernate对数据库结构提供了较为完整的封装，Hibernate的O/R Mapping实现了POJO和数据库表之间的映射，以及SQL的自动生成和执行。程序员往往只需定义好了POJO到数据库表的映射关系，即可通过Hibernate提供的方法完成持久层操作。程序员甚至不需要对SQL的熟练掌握，Hibernate会根据制定的存储逻辑，自动生成对应的SQL 并调用JDBC接口加以执行。</p><p>MyBatis的着力点，则在于POJO与SQL之间的映射关系。然后通过映射配置文件，将SQL所需的参数，以及返回的结果字段映射到指定POJO。相对Hibernate的“O/R”而言，MyBatis是一种“SQL Mapping”的ORM实现。</p>]]></content>
      
      
      <categories>
          
          <category> SSM/SSH </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data与Spring Data JPA技术小结</title>
      <link href="/2019/03/04/Spring-Data%E4%B8%8ESpring-Data-JPA%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/04/Spring-Data%E4%B8%8ESpring-Data-JPA%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Data简介"><a href="#Spring-Data简介" class="headerlink" title="Spring Data简介"></a>Spring Data简介</h1><p>Spring Data是Spring平台中一个功能模块，主要用来和数据访问层相关的框架功能。其模块组织结构图如下：</p><p><img src="/images/java_springdata_1_1.png" alt></p><h1 id="Spring-Data-JPA简介"><a href="#Spring-Data-JPA简介" class="headerlink" title="Spring Data JPA简介"></a>Spring Data JPA简介</h1><p>Spring Data JPA是Spring Data的一个子模块，使用它可以非常简单地操作“关系型数据库”。Spring Data JPA是用来简化项目中数据访问层的逻辑。在以前的Spring应用项目中，我们需要编写DAO层接口和DAO层实现类，而这些接口或实现类有很多是重复类似的代码。若使用了Spring Data JPA子模块，那么我们只需要编写DAO层接口，Spring Data JPA会根据这些接口自动生成实现类，并由Spring容器管理以便再注入到service层。</p><p>如下为Spring Data JPA的周边技术关系图（可见使用Spring Data JPA时，具体使用哪种ORM框架是由用户自己决定的，<strong>默认的还是Hibernate哦</strong>）：</p><p><img src="/images/java_springdata_1_2.png" alt></p><h1 id="Spring-Data-JPA的使用"><a href="#Spring-Data-JPA的使用" class="headerlink" title="Spring Data JPA的使用"></a>Spring Data JPA的使用</h1><p>（1）引入Spring Data JPA的依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）定义实体类Entity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：@Entity和@Id都是JAVA JPA中定义的注解，即javax.persistence.Entity和javax.persistence.Id等</p><p>（3）定义Repository接口</p><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Foo</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountInfo <span class="title">save</span><span class="params">(Foo foo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：Repository就是Spring Data JPA中的一个概念哦。开发者只需要定义一个继承了Repository或其子接口的接口即可。然后Spring Data JPA会帮我们自动生成实现类，开发者就不需要自己去实现该接口了。另外，不需要使用注解将UserDao定义Bean，Spring会自动将其视为Bean并管理，在Service层直接注入即可使用。</p><p>（4）Spring容器将Repository bean对象注入service层，用户在service层直接调用Repository bean对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FooRepository fooRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">Foo <span class="title">getFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fooRepository.findOne(<span class="number">1L</span>); <span class="comment">//look, you didn't need to write a DAO!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：有一点一定需要了解哦，Spring Data JPA只是用来简化DAO层的开发，它并不是ORM框架哦，<strong>像上面的例子中的ORM映射默认使用的是Hibernate框架</strong>，因为我们引入的spring-data-jpa的依赖会默认引入Hibernate相关的依赖哦。</p><h1 id="Spring-Data-JPA中Repository接口及其子接口XXRepository的说明"><a href="#Spring-Data-JPA中Repository接口及其子接口XXRepository的说明" class="headerlink" title="Spring Data JPA中Repository接口及其子接口XXRepository的说明"></a>Spring Data JPA中Repository接口及其子接口XXRepository的说明</h1><p>（1）Repository</p><p>Repository接口是Spring Data的核心接口，该接口是一个空接口，没有声明任何的接口方法。其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span>  <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>（2）CrudRepository</p><p>CrudRepository继承了Repository接口，实现了CRUD相关的方法。</p><p>（3）PagingAndSortingRepository</p><p>PagingAndSortingRepository继承了CrudRepository接口，实现了分页排序相关的方法。</p><p>（4）JpaRepository</p><p>JpaRepository继承了PagingAndSortingRepository，实现了JPA规范相关的方法。</p><h1 id="Repository中方法名定义规则"><a href="#Repository中方法名定义规则" class="headerlink" title="Repository中方法名定义规则"></a>Repository中方法名定义规则</h1><p>在Repository中已经定了一些增删改查的方法，我们可以直接使用，不需要在Repository中定义或声明，如findOne、findAll以及delete等等。如果需要一些特殊的数据库操作需求，可以有两种方式，一种是Repository按照一定的规则声明一些方法名，Spring Data JPA会自动生成SQL语句，还有一种使用@query注解加上SQL语句来定制数据库操作需求。</p><p>（1）按一定规则来定义Repository中的方法名来满足定制化的数据库操作需求</p><p>在Repository中按照Spring Data JPA的规范来定义方法名，那么Spring Data JPA会根据方法名帮我们自动生成SQL语句。如下为具体的规则以及对应的SQL语句：</p><p><img src="/images/java_springdata_1_3.png" alt></p><p><img src="/images/java_springdata_1_4.png" alt></p><p>（2）使用@Query注解来实现复杂的数据库操作</p><p>使用@Query注解，就不需要按照上述的命名规则哦，方法名可以随意地定义，数据库的操作也可以根据需要来定义，是比较灵活的。使用@Query注解在工作中最常使用的方式。@Query annotation要注解到Repository的具体方法上即可。</p><p>（3）使用Query By Example技术</p><p>可以动态构造查询条件。</p><p>（4）使用Query By Specification技术</p><p>也是可以动态构造查询条件。</p><h1 id="JDBC-JPA-Spring-Data-JPA三者区别和联系"><a href="#JDBC-JPA-Spring-Data-JPA三者区别和联系" class="headerlink" title="JDBC/JPA/Spring-Data-JPA三者区别和联系"></a>JDBC/JPA/Spring-Data-JPA三者区别和联系</h1><p>（1）JDBC是JDK中定义的数据驱动接口java.sql.Driver，但并没有具体的实现，具体的实现都是由不同的数据库厂商来提供的。主要是用在关系型数据库的场景。</p><p>（2）JPA是Java定义的ORM框架的规范，实现是Hibernate等产品。</p><p>（3）Spring Data JPA是对JPA ORM框架的进一步封装，让用户程序的DAO层开发更简单高效，只需要按照Spring Data JPA的规范书定义一些接口，然后Spring Data JPA会帮我们生产一些实现接口的具体方法。</p><p>参考资料来源于：<br><a href="https://projects.spring.io/spring-data-jpa/" target="_blank" rel="noopener">https://projects.spring.io/spring-data-jpa/</a></p>]]></content>
      
      
      <categories>
          
          <category> SSM/SSH </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA访问数据库技术实战</title>
      <link href="/2019/03/04/JAVA%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/"/>
      <url>/2019/03/04/JAVA%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="使用JDBC来访问数据库"><a href="#使用JDBC来访问数据库" class="headerlink" title="使用JDBC来访问数据库"></a>使用JDBC来访问数据库</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bat.testmaven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//JDBC驱动名及数据库URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost:3306/hostnames"</span>;</span><br><span class="line">    <span class="comment">//数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"test123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注册JDBC驱动</span></span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            <span class="comment">//打开连接</span></span><br><span class="line">            conn = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line">            <span class="comment">//执行查询</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql = <span class="string">"SELECT * FROM record"</span>;</span><br><span class="line">            ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="comment">//展开结果集数据库</span></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">//通过字段检索</span></span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String host = rs.getString(<span class="string">"host"</span>);</span><br><span class="line">                String destination = rs.getString(<span class="string">"destination"</span>);</span><br><span class="line">                <span class="comment">//输出数据</span></span><br><span class="line">                System.out.println(<span class="string">"ID: "</span> + id);</span><br><span class="line">                System.out.println(<span class="string">"host: "</span> + host);</span><br><span class="line">                System.out.println(<span class="string">"destination: "</span> + destination);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//完成后关闭</span></span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">            <span class="comment">//处理JDBC错误</span></span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//处理Class.forName错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stmt != <span class="keyword">null</span>)</span><br><span class="line">                    stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException se2) &#123;</span><br><span class="line">            &#125; <span class="comment">// 什么都不做</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>)</span><br><span class="line">                    conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用Spring-Framework中的JDBC子模块来访问数据库（JdbcTemplate）"><a href="#使用Spring-Framework中的JDBC子模块来访问数据库（JdbcTemplate）" class="headerlink" title="使用Spring Framework中的JDBC子模块来访问数据库（JdbcTemplate）"></a>使用Spring Framework中的JDBC子模块来访问数据库（JdbcTemplate）</h1><p>（1）在pom.xml中添加Spring JDBC的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库驱动的jar包依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.45<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）在src/main/resources/application.properties中配置数据源</p><pre><code>spring.datasource.url=jdbc:mysql://127.0.0.1/hostnamesspring.datasource.username=rootspring.datasource.password=test123spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code></pre><p>（3）编写Dao层，让Spring容器注入jdbcTemplete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HostNameDaoImpl</span> <span class="keyword">implements</span> <span class="title">HostNameDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRecordCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String q_sql = <span class="string">"select count(*) from record"</span>;</span><br><span class="line">        <span class="keyword">int</span> count = jdbcTemplate.queryForObject(q_sql, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）在sevice层直接使用Dao层实现类即可</p><p>备注：使用JdbcTemplate模式是没有对象关系映射ORM的功能。</p><h1 id="使用Hibernate等符合JPA规范的ORM框架"><a href="#使用Hibernate等符合JPA规范的ORM框架" class="headerlink" title="使用Hibernate等符合JPA规范的ORM框架"></a>使用Hibernate等符合JPA规范的ORM框架</h1><p>参见<a href="https://wangjianno1.github.io/2019/03/04/Hibernate%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/">《Hibernate技术小结》</a></p><h1 id="使用Spring-Data-JPA"><a href="#使用Spring-Data-JPA" class="headerlink" title="使用Spring Data JPA"></a>使用Spring Data JPA</h1><p>参见<a href="https://wangjianno1.github.io/2019/03/04/Spring-Data%E4%B8%8ESpring-Data-JPA%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/">《Spring Data与Spring Data JPA技术小结》</a></p>]]></content>
      
      
      <categories>
          
          <category> SSM/SSH </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中JPA关联映射小结</title>
      <link href="/2019/03/04/JAVA%E4%B8%ADJPA%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/04/JAVA%E4%B8%ADJPA%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA中JPA关联映射简介"><a href="#JAVA中JPA关联映射简介" class="headerlink" title="JAVA中JPA关联映射简介"></a>JAVA中JPA关联映射简介</h1><p>数据库的关系映射的概念知识，参见<a href="https://wangjianno1.github.io/2019/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%AD%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%EF%BC%88%E4%B8%80%E5%AF%B9%E4%B8%80-%E5%A4%9A%E5%AF%B9%E4%B8%80-%E4%B8%80%E5%AF%B9%E5%A4%9A-%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%89/">《数据库设计中关系映射（一对一|多对一|一对多|多对多|单向|双向）》</a>部分。JAVA JPA规范也对关系映射有支持，JPA中的映射类型有：</p><pre><code>一对一（One To One）一对多（One To Many）多对一（Many To One）多对多（Many To Many）</code></pre><p>另外，关联映射是有方向的，即是单向或者双向的。如Student和ClassRoom两个实体类，从student来看，是多对一；而从ClassRoom来看，是一对多。具体来说如下：</p><p>（1）单向“多对一”</p><p>若Student实体类中定义了private ClassRoom classRoom属性，那么对于Student实体类来说是建立了单向的“ManyToOne”的映射，通过Student的classRoom属性可以得知该Student所属的ClassRoom；</p><p>（2）单向“一对多”</p><p>若ClassRoom实体类中定义了private List<student> studentList属性，那么对于ClassRoom实体类来说是建立了单向的“OneToMany”的映射，通过ClassRoom的studentList属性可以得知属于该ClassRoom的所有Student。</student></p><p>（3）双向“一对多”或双向“多对一”</p><p>若Student实体类中定义了private ClassRoom classRoom属性，且ClassRoom实体类中定义了<code>private List&lt;Student&gt; studentList</code>属性，那么对于Student和ClassRoom来说，它们就建立了双向“一对多”或双向“多对一”的关系。</p><h1 id="mappedBy-”xxxxxx”"><a href="#mappedBy-”xxxxxx”" class="headerlink" title="mappedBy=”xxxxxx”"></a>mappedBy=”xxxxxx”</h1><p>在四种关联关系OneToOne，OneToMany，ManyToOne和ManyToMany中，只有OneToOne、OneToMany和ManyToMany这三种关联关系有mappedBy属性，ManyToOne是不存在mappedBy属性的。</p><p>简单来说，实体类中使用了mappedBy设置，那么表示该实体类放弃维护关联关系，也就是不会去维护数据库层面的外键关系，而是将关联关系交给对方维护。假设ClassRoom中定义了private List<student> studentList属性，当在studentList上使用mappedBy，则我们新增一个ClassRoom时，会在数据库中插入ClassRoom记录以及Student记录，但是不会设置Student表中外键值，在这种情况下，只有新增Student实例时，才会设置Student表中的外键classid。</student></p><p>ClassRoom实体类<code>private List&lt;Student&gt; studentList</code>属性上的<code>mappedBy=&quot;xxxxxx&quot;</code>，xxxx要是Student实例中private ClassRoom classRoom的属性名，即classRoom，也就是<code>mappedBy=&quot;classRoom&quot;</code>。</p><h1 id="JoinColum-name-“xxxxx”"><a href="#JoinColum-name-“xxxxx”" class="headerlink" title="JoinColum(name = “xxxxx”)"></a>JoinColum(name = “xxxxx”)</h1><p>关于<code>@JoinColumn(name = &quot;address_id&quot;, referencedColumnName=&quot;ref_id&quot;)</code>，我们知道，无论使用OneToOne，OneToMany还是ManyToOne，最终都会落实到数据库表中的外键关系，这里的name表明外键在数据库中的字段名，referencedColumnName表示被外键关联到的表的哪个字段，如果不指定referencedColumnName，默认会外键指向的被关联表的主键哦。在实例类的关系映射处都加上JoinColumn注解。</p><p>需要注意是，当属性上标注了mappedBy，则该属性就不能再标注JoinColum或JoinTable啦。</p><h1 id="关联映射中的FetchType和CascadeType"><a href="#关联映射中的FetchType和CascadeType" class="headerlink" title="关联映射中的FetchType和CascadeType"></a>关联映射中的FetchType和CascadeType</h1><p>使用JPA标准或实现了JPA标准的框架时，会使用@OneToOne|@OneToMany|@ManyToOne|@ManyToMany等注解来实现实体类的关联映射。例如ClassRoom实体类中定义了<code>private List&lt;Student&gt; studentList</code>属性，那么当我们增删改查ClassRoom实体类对应的数据库记录时，就涉及到对Student实体类的级联操作。具体来说，查询ClassRoom时，属于该ClassRoom的所有学生的查询形式，这对应就是FetchType。当我们删除某个ClassRoom时，我们是否删除属于该ClassRoom下的所有学生实体类，这对应的就是CascadeType概念。</p><h1 id="FetchType类型"><a href="#FetchType类型" class="headerlink" title="FetchType类型"></a>FetchType类型</h1><p>（1）FetchType.LAZY</p><p>延迟加载，在查询实体A时，不查询出其关联实体B，只有再调用A的getB方法时，才会去数据库中查询A的关联实体B。我们在使用延迟加载特性时，可能会因为使用不当导致“LazyInitializationException no Session”问题，这是因为当我们查询A后，Hibernate连接数据库的Session已经关闭了，当我们再使用A的getB去查询关联对象B时，就没有session可以使用了。若我们想要getB()成功，需要在Service层的方法上使用事务@Transactional注解，这样在该事务中Hibernate连接数据库的Session会一直有效，这样在调用getB()时可以成功地从数据库中查询到关联数据。</p><p>（2）FetchType.EAGER</p><p>饥饿加载，在查询实体A时，就立即查询出其关联的实体B。所以使用饥饿加载时，会发起多次查询，不仅查询实体A对应的数据库表，还会去查询实体A的关联实体B对应的数据库表，所以在控制台日志中我们可以看到多条的查询语句。</p><h1 id="CascadeType类型"><a href="#CascadeType类型" class="headerlink" title="CascadeType类型"></a>CascadeType类型</h1><p>假设ClassRoom实体类中定义了<code>private List&lt;student&gt; studentlist</code>属性，下面分别说明CascadeType各种类型的作用：</p><p>（1）CascadeType.PERSIST</p><p>当我们增加一个ClassRoom记录时，会在ClassRoom对应的数据表中插入一条记录，同时将studentlist中的Student实例，插入到student实例对应的数据库表中。说白了，就是级联插入。当studentlist属性上没有标注CascadeType.PERSIST，那么数据库中只插入ClassRoom记录，并不会级联插入Student啦。</p><p>（2）CascadeType.MERGE</p><p>当我们修改ClassRoom实例类的某个属性，同时修改studentlist中Student实例类的属性时，ClassRoom和Student实体类对应的数据库表都会被更新Update，说白了，CascadeType.MERGE是级联更新。若在studentlist属性上没有标明CascadeType.MERGE，则只会更新ClassRoom对应的数据库表，并不会更新Student实例类对应的数据库表啦。</p><p>（3）CascadeType.REMOVE</p><p>当我们删除ClassRoom实例类时，会将ClassRoom实体类对应的数据库表中的记录删除，同时会将Student实例类对应的数据库表中的记录删除。说白了，CascadeType.REMOVE是级联删除的功能。若在studentlist属性上没有标明CascadeType.REMOVE，则ClassRoom和Student对应的数据库表中的记录都不会删除，ClassRoom不会被删除，是因为Student表中有外键关联到ClassRoom，数据库层面的一致性导致都删除失败啦。</p><p>（4）CascadeType.REFRESH</p><p>对于业务系统，往往会存在多个用户，如果用户A取得了ClassRoom和其对应的studentlist，并且对ClassRoom和studentlist进行了修改，同时用户B也做了如此操作，但是用户B先保存了，然后用户A保存时，需要先刷新ClassRoom关联的studentlist，然后再把用户A的变更更新到数据库。这中场景就对应了CascadeType.REFRESH的需求。</p><p>（5）CascadeType.ALL</p><p>包含了CascadeType.PERSIST、CascadeType.MERGE、CascadeType.REMOVE以及CascadeType.REFRESH的功能。</p><h1 id="FetchType和CascadeType的默认值"><a href="#FetchType和CascadeType的默认值" class="headerlink" title="FetchType和CascadeType的默认值"></a>FetchType和CascadeType的默认值</h1><p>（1）FetchType</p><p>当我们没有显式地指定FetchType时，则会有缺省值。在JPA2.0规范中，缺省值如下：</p><pre><code>OneToMany: LAZYManyToOne: EAGERManyToMany: LAZYOneToOne: EAGER</code></pre><p>而若使用的是Hibernate框架，默认值都是LAZY。</p><p>（2）CascadeType</p><p>CascadeType缺省值是空，也就是说没有任何级联的操作。</p><p>学习资料参考于：<br><a href="https://www.jianshu.com/p/9970495f76ab" target="_blank" rel="noopener">https://www.jianshu.com/p/9970495f76ab</a><br><a href="http://westerly-lzh.github.io/cn/2014/12/JPA-CascadeType-Explaining/" target="_blank" rel="noopener">http://westerly-lzh.github.io/cn/2014/12/JPA-CascadeType-Explaining/</a><br><a href="https://www.zhihu.com/question/64187262" target="_blank" rel="noopener">https://www.zhihu.com/question/64187262</a></p>]]></content>
      
      
      <categories>
          
          <category> SSM/SSH </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC技术小结</title>
      <link href="/2019/03/04/SpringMVC%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/04/SpringMVC%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h1><p>SpringMVC是Spring Framework的一个模块，它是一个WEB MVC框架，它和Struts/Struts2解决的问题是一致的，可以直接代替Struts/Struts2，不过Struts作为一个非常成熟的MVC，功能上感觉还是比Spring强一点，不过SpringMVC已经足够用了。SpringMVC解决的问题有URL路由、Session、模板引擎、静态Web资源等等。</p><p>SpringMVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成，其核心组件为DispatcherServlet。SpringMVC实现了MVC模式，包括怎样与Web容器环境集成，Web请求的拦截、分发、处理和ModelAndView数据的返回，以及如何集成各种UI视图展现和数据表示。</p><p>本质上来说，SpringMVC是基于Servlet规范的MVC框架的实现，那么SpringMVC在Tomcat/JSP来看，其实就是一个Servlet。SpringMVC是Servlet的实现，在SpringMVC就是DispatchServlet，所有的http请求都是映射到这个Servlet上，请求进入到这个Servlet中之后，就算进入到了框架之中了，由这个Servlet来统一的分配http请求到各个Controller。</p><h1 id="SpringMVC整体架构"><a href="#SpringMVC整体架构" class="headerlink" title="SpringMVC整体架构"></a>SpringMVC整体架构</h1><p><img src="/images/java_springmvc_1_1.png" alt></p><p>其请求详细过程如下：</p><p>（1）发起请求到前端控制器(DispatcherServlet)</p><p>（2）前端控制器请求HandlerMapping查找Handler，可以根据xml配置、注解进行查找</p><p>（3）处理器映射器HandlerMapping向前端控制器返回Handler</p><p>（4）前端控制器调用处理器适配器去执行Handler</p><p>（5）处理器适配器去执行Handler</p><p>（6）Handler执行完成给适配器返回ModelAndView</p><p>（7）处理器适配器向前端控制器返回ModelAndView(是springmvc框架的一个底层对象，包括Model和View)</p><p>（8）前端控制器请求视图解析器去进行视图解析，根据逻辑视图名称解析真正的视图(jsp…)</p><p>（9）视图解析器向前端控制器返回View</p><p>（10）前端控制器进行视图渲染，视图渲染就是将模型数据(在ModelAndView对象中)填充到request域中</p><p>（11）前端控制器向用户响应结果</p><h1 id="SpringMVC与Spring创建的Bean容器"><a href="#SpringMVC与Spring创建的Bean容器" class="headerlink" title="SpringMVC与Spring创建的Bean容器"></a>SpringMVC与Spring创建的Bean容器</h1><p><img src="/images/java_springmvc_1_2.png" alt></p><p>在SpringMVC+Spring的WEB应用中，SpringMVC DispatcherServlet会创建一个Bean容器，即Servlet WebapplicationContext。Spring也会创建一个Bean容器，即Root WebApplicationContext。且Servlet WebapplicationContext是Root WebApplicationContext的子容器，它们管理的Bean不同，Servlet WebapplicationContext管理和WEB相关的Bean，如Controller、ViewResolver等，Root WebApplicationContext则管理一些公共基础的Bean，如Services、Repositories以及DAO等等。</p><p>备注：在tomcat/jetty容器启动时，是先初始化Spring容器，再初始化SpringMVC容器哦。</p><h1 id="使用了SpringMVC框架的项目的web-xml"><a href="#使用了SpringMVC框架的项目的web-xml" class="headerlink" title="使用了SpringMVC框架的项目的web.xml"></a>使用了SpringMVC框架的项目的web.xml</h1><p>使用SpringMVC框架的项目，首先要做的将DispatcherServlet配置到WEB引用的web.xml，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置DispatchcerServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Spring mvc下的配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM/SSH </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Framework技术小结</title>
      <link href="/2019/03/04/Spring-Framework%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/04/Spring-Framework%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Framework简介"><a href="#Spring-Framework简介" class="headerlink" title="Spring Framework简介"></a>Spring Framework简介</h1><p>通常来说，我们说的Spring指的是Spring Framework，其实它只是Spring家族中一个产品。</p><p>Spring Framework是使用基本的JavaBean代替EJB，通过容器来管理JavaBean的配置和生命周期，在此基础上实现了AOP、IoC的Spring核心功能，其他WEB框架组件在AOP、IoC的基础上工作，将JavaBean交给Spring来管理。简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。<br>Spring功能模块框架图如下：</p><p><img src="/images/java_spring_1_1.png" alt></p><p>Spring Framework的主要子模块有IoC，AOP，Spring MVC，JMS，JMX等等。</p><h1 id="Spring-Framework的几个核心概念"><a href="#Spring-Framework的几个核心概念" class="headerlink" title="Spring Framework的几个核心概念"></a>Spring Framework的几个核心概念</h1><p>简单来说，Spring Framework是一个轻量级的控制反转IoC和面向切面AOP的容器框架。Spring Framework的核心模块有：</p><p>（1）Bean容器</p><p>Bean容器（Spring Framework的基础核心概念哦，Spring Bean容器存放的是一个个单例对象）。<strong>相比于JAVA官方的EJB，Spring Bean容器更轻量级及简单易用（Spring Bean容器可以对标到EJB容器哦）</strong>。也许正是因为这个核心功能，才让人们经常把Spring和EJB进行对标。</p><p>备注：Spring容器中的Bean默认都是单例的。</p><p>（2）IoC（和依赖注入DI是一个意思哦）</p><p>IoC，控制反转，即依赖对象的获得被反转了。控制反转有一个更容易理解的名字是“依赖注入（DI）”。许多复杂的应用都是由两个或多个类通过彼此的合作来实现业务逻辑的，这使得每个对象都获得与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程是靠自身实现，那么将导致代码高度耦合并且难以测试。在Spring中，有了IoC或DI，它可以在对象生成或初始化时直接将数据注入到对象中，也可以通过将对象引用注入到对象数据域中的方式来注入对方法调用的依赖。这种依赖注入是可以递归的，对象被逐层注入，这样就简化了对象依赖关系的管理，在很大程度上简化了面向对象系统的复杂性。</p><p>其实，IoC的思想在不同的语言中都有很多实现。Spring IoC是JAVA世界中最著名的一个。</p><p>（3）AOP</p><p>IOC容器和AOP是Spring平台的核心内容，它们是Spring系统中其他组件模块和应用开发的基础。</p><p><img src="/images/java_spring_1_2.png" alt></p><h1 id="Spring-Bean容器"><a href="#Spring-Bean容器" class="headerlink" title="Spring Bean容器"></a>Spring Bean容器</h1><p><img src="/images/java_spring_1_3.png" alt></p><p><img src="/images/java_spring_1_4.png" alt></p><p>备注：如上是Spring这个庞大的框架的基础设施，其他的Spring功能模块是基于Bean管理之上的哦</p><p><strong>Spring对Bean的管理有两种方式，一种是基于XML配置文件（手动装配），一种是基于注解的方式（自动装配）</strong>。</p><p>（1）基于XML配置文件</p><p>开发人员在spring-xxx.xml配置文件中，通过一些<code>&lt;bean&gt;...&lt;/bean&gt;</code>标签来定义各个bean对象以及它们之间的依赖关系。然后应用程序通过<code>BeanFactory</code>或<code>ApplicationContext</code>获取到bean对象。这是传统的管理方式哦。举例来说：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>;</span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>;</span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"</span>&gt;</span>;</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDAO"</span> <span class="attr">class</span>=<span class="string">"com.bjsxt.DAO.impl.UserDAOImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.bjsxt.service.UserService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDAO"</span> <span class="attr">ref</span>=<span class="string">"userDAO"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，可以通过Spring的Application Context来获取指定的bean对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] locations = &#123;<span class="string">"spring-xxx.xml"</span>&#125;;</span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(locations);</span><br><span class="line">UserService userService = (UserService)ctx.getBean(<span class="string">"userService"</span>);</span><br><span class="line">System.out.println(userService);</span><br></pre></td></tr></table></figure><p>备注：<strong>在Spring中XXXApplicationContext是一个很重要的东东哦，通过它可以拿到Spring管理的各种Bean对象哦</strong>。常用的XXXApplicationContext有：</p><pre><code>ClassPathXmlApplicationContextXmlWebApplicationContextAnnotationConfigApplicationContextAnnotationConfigWebApplicationContext......</code></pre><p>Spring主要提供了两种IOC容器，分别是BeanFactory和ApplicationContext。</p><p>BeanFacotry是Spring中比较原始的Factory，如XMLBeanFactory就是一种典型的BeanFactory。原始的BeanFactory无法支持Spring的许多插件，如AOP功能、WEB应用等。ApplicationContext接口，它由BeanFactory接口派生而来，因而提供BeanFactory所有的功能。ApplicationContext以一种更向面向框架的方式工作以及对上下文进行分层和实现继承，ApplicationContext包还提供了以下的功能：  </p><pre><code>MessageSource, 提供国际化的消息访问资源访问，如URL和文件事件传播载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 </code></pre><p>（2）基于注解的方式</p><p>通过JAVA的注解来定义bean，而不是XML配置文件，从而将Spring配置信息的载体由XML文件转移到了JAVA类中，最终简化了Spring配置的繁琐性哦。常用的Spring Bean注解是<code>org.springframework.stereotype.*</code>，举例来说：</p><pre><code>@Component是一个通用的bean注解，可用于任何bean@Repository通常用于注解DAO类，即持久层的bean@Service通常用于注解Service类，即服务层的bean@Controller通常用于注解Controller类，即控制层的bean</code></pre><p>即被@Component、@Repository，@Service以及@Controller等注解，注解过的对象，就会被Spring自动识别为Bean并予以管理哦。然后在需要用到Bean的地方使用注解@Autowired（<code>org.springframework.beans.factory.annotation.Autowired</code>）就可以自动装配指定的Bean了。</p><p>备注：其实Spring框架中的很多模块的使用，即可以使用XML配置文件，也可以使用注解的方式。</p><h1 id="AOP技术"><a href="#AOP技术" class="headerlink" title="AOP技术"></a>AOP技术</h1><p>（1）AOP简介</p><p>AOP，Aspect Oriented Programming，中文为面向切面的编程，通过预编译方式或运行期动态代理实现程序功能的统一维护的一种技术。AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性，主要的功能有日志记录、性能统计、安全控制、事务处理以及异常处理等等。举例来说：</p><p><img src="/images/java_spring_1_5.png" alt></p><p>（2）AOP技术的实现方式</p><p>AOP技术的实现方式有两种，一个是以AspectJ等为代表的预编译方式，一个是以Spring AOP，JbossAOP等为代表的运行期动态代理（JDK动态代理、CGLib动态代理）。</p><p><img src="/images/java_spring_1_8.png" alt></p><p>Spring AOP是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，这时候Spring AOP会使用Cglib，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="/images/java_spring_1_7.png" alt></p><p>（3）AOP技术中的一些基本概念</p><p><img src="/images/java_spring_1_6.png" alt></p><p>（4）Spring AOP的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span><span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Spring-Bean注入方式"><a href="#Spring-Bean注入方式" class="headerlink" title="Spring Bean注入方式"></a>Spring Bean注入方式</h1><p>Spring Bean注入方式有三种：</p><p>（1）属性注入</p><p>所谓基于属性注入，就是在Bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到属性。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是Spring团队所不推荐的方式。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Svc svc;</span><br></pre></td></tr></table></figure><p>（2）构造器注入</p><p>将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">privat Svc svc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HelpService</span><span class="params">(Svc svc)</span> </span>&#123;  <span class="comment">// HelpService是一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>.svc = svc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：在Spring 4.3及以后的版本中，如果这个类只有一个构造方法，那么这个构造方法上面也可以不写@Autowired注解。</p><p>（3）setter注入</p><p>通过对应变量的<code>setXXX()</code>方法以及在方法上面使用注解，来完成依赖注入。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Helper helper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelper</span><span class="params">(Helper helper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.helper = helper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：在Spring 4.3及以后的版本中，setter上面的@Autowired注解是可以不写的。</p><h1 id="Spring-HelloWorld程序"><a href="#Spring-HelloWorld程序" class="headerlink" title="Spring HelloWorld程序"></a>Spring HelloWorld程序</h1><p>（1）在Eclipse新建Maven Project，且在pom.xml中引入Spring框架的核心依赖，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）新建一个将要被Spring容器管理的Bean类</p><p>新建一个名称为HelloWorld的Bean类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Your Message : "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在XML中配置HelloWorld Bean</p><p>新建一个<code>src/main/resources/beans.xml</code>文件（文件的名称可任意），XML配置文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>;</span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>;</span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>;</span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"com.sohu.sysadmin.spring_learning.bean.HelloWorld"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Hi,Guys~~~"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）Spring依据beans.xml配置生成Spring ApplicationContext，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 普通方式</span></span><br><span class="line">        HelloWorld hw_1 = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">        hw_1.getMessage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring使用方式一__使用BeanFactory获取Bean对象</span></span><br><span class="line">        XmlBeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">"Beans.xml"</span>));</span><br><span class="line">        HelloWorld hw_2 = (HelloWorld) factory.getBean(<span class="string">"helloWorld"</span>);</span><br><span class="line">        hw_2.getMessage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring使用方式二__使用ApplicationContext获取bean对象</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"Beans.xml"</span>);</span><br><span class="line">        HelloWorld hw_3 = (HelloWorld) context.getBean(<span class="string">"helloWorld"</span>);</span><br><span class="line">        hw_3.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）直接运行测试</p><h1 id="Tomcat中Spring的初始化"><a href="#Tomcat中Spring的初始化" class="headerlink" title="Tomcat中Spring的初始化"></a>Tomcat中Spring的初始化</h1><p>使用了Spring框架的Java Web应用，必须需要在/WEB-INF/web.xml中配置如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml classpath:resources/services.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中contextConfigLocation配置了Spring的配置文件，ContextLoaderListener是Spring框架实现了javax.servlet.ServletContextListener接口的Listener，它会读取contextConfigLocation指定的Spring配置文件，并加载和初始化Spring管理的各种Bean对象啦。</p><h1 id="其他闲杂知识"><a href="#其他闲杂知识" class="headerlink" title="其他闲杂知识"></a>其他闲杂知识</h1><p>（1）Spring MVC对标Struts，Spring JDBC对标Hibernate。</p><p>学习资料参考于：<br><a href="http://mp.weixin.qq.com/s/uhDCppoDTvs_WdGTdyuVdg" target="_blank" rel="noopener">《Spring技术的前世今生》</a></p>]]></content>
      
      
      <categories>
          
          <category> SSM/SSH </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Servlet/JSP技术说明</title>
      <link href="/2019/03/04/Servlet-JSP%E6%8A%80%E6%9C%AF%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/03/04/Servlet-JSP%E6%8A%80%E6%9C%AF%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="Servlet简介"><a href="#Servlet简介" class="headerlink" title="Servlet简介"></a>Servlet简介</h1><p>Java Servlet是运行在Web服务器或应用服务器上的程序，它是作为来自Web浏览器或其他HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。</p><p>使用Servlet，可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。Java Servlet通常情况下与使用CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。</p><p>Servlet可以使用javax.servlet和 javax.servlet.http包创建，它是Java企业版的标准组成部分，Java企业版是支持大型开发项目的Java类库的扩展版本。</p><h1 id="Servlet架构"><a href="#Servlet架构" class="headerlink" title="Servlet架构"></a>Servlet架构</h1><p>Servlet的架构如下所示：</p><p><img src="/images/java_servlet_1_1.png" alt></p><p>备注：这里的HTTP Server可以是Tomcat/Jetty等。</p><h1 id="Java-Servlet-HelloWorld程序"><a href="#Java-Servlet-HelloWorld程序" class="headerlink" title="Java Servlet HelloWorld程序"></a>Java Servlet HelloWorld程序</h1><p>（1）编写HelloWorld Servlet程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        message = <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do nothing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在tomcat中配置做Servlet的映射</p><p>按如下内容修改tomcat web.xml配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/HelloWorld<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）启动tomcat并测试</p><p>在浏览器中输入<code>http://127.0.0.1/HelloWorld</code>即可访问。如下：</p><p><img src="/images/java_servlet_1_2.png" alt></p><h1 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h1><p><img src="/images/java_servlet_1_3.png" alt></p><h1 id="JAVA-Servlet-WEB应用程序部署规范"><a href="#JAVA-Servlet-WEB应用程序部署规范" class="headerlink" title="JAVA Servlet WEB应用程序部署规范"></a>JAVA Servlet WEB应用程序部署规范</h1><p>根据J2EE Servlet规范，WEB应用程序有特定的目录结构，将Servlet应用程序部署到Servlet容器（Tomcat/Jetty等）时必须按照这样的目录结构部署，具体结构如下：</p><p><img src="/images/java_servlet_1_4.png" alt></p><p>当我们使用Eclipse等IDE工具创建WEB工程时，IDE会自动在webapp目录下按照这样的目录结构给开发者组织WEB应用。</p><p>需要注意的是，JAVA Web应用部署到容器后，/WEB-INF/classes/和/WEB-INF/lib/目录都属于CLASSPATH中一部分，JAVA Web应用可以直接使用这些目录中jar包中的类。</p><h1 id="其他闲杂知识"><a href="#其他闲杂知识" class="headerlink" title="其他闲杂知识"></a>其他闲杂知识</h1><p>（1）Listener</p><p>监听器Listener，它是实现了javax.servlet.ServletContextListener接口的服务器端程序，它是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。主要作用是做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。在Servlet被Servlet容器初始化之前，可以向Servlet容器注册一些Listener来执行一些前置的工作逻辑，该Listener需要继承自javax.servlet.ServletContextListener。比如Spring 框架的监听器ContextLoaderListener会在服务器启动的时候实例化我们配置的bean对象、hibernate的session的监听器会监听session的活动和生命周期，负责创建，关闭session等活动。</p><p>（2）Filter</p><p>Filter是一个可以复用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，它不能产生一个接收请求或者响应请求，它只是修改对某一资源的请求，或者修改对某一资源的响应。Servlet/JSP规范中的过滤器Filter是实现了javax.servlet.Filter接口的服务器端程序，主要的用途是过滤字符编码、做一些业务逻辑判断等。</p><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>在使用Servlet时，若想给浏览器返回HTML页面，那我们在Servlet中代码中插入HTML页面的字符串，那一个简单的页面都很复杂（当然现在结合模版引擎也很方便啦）：</p><p><img src="/images/java_jsp_1_1.png" alt></p><p>JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以<code>&lt;%</code>开头，以<code>%&gt;</code>结束。实际上jsp页面的本质还是Servlet，只不过是为了方面画界面所单独拉出来的一部分而已，到最终的实现还是会回到Servlet当中。</p><p>Servlet容器通过解析其中Servlet的别名，再找到对应的Servlet并执行其中的service方法做出处理和响应，那么对于Servlet容器来说它只认识Servlet，那么我们编辑的Jsp到底是如何被服务器识别的？实际上Servlet容器还是将<code>*.jsp</code>当作Servlet的别名在你局部配置下的web.xml找有没有对应的Servlet，如果没有找到对应的Servlet就去Tomcat的公共配置下的web.xml（Tomcat安装目录conf下的web.xml）找对应的Servlet。会找到如下内容：</p><p><img src="/images/java_jsp_1_2.png" alt></p><p><img src="/images/java_jsp_1_3.png" alt></p><p>org.apache.jasper.servlet.JspServlet会将对应的jsp文件转为Servlet。假设一个test.jsp文件内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=ISO-8859-1"</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="number">666</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>被org.apache.jasper.servlet.JspServlet转换成Servlet后，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generated by the Jasper component of Apache Tomcat</span></span><br><span class="line"><span class="comment"> * Version: Apache Tomcat/8.5.46</span></span><br><span class="line"><span class="comment"> * Generated at: 2019-10-16 09:05:10 UTC</span></span><br><span class="line"><span class="comment"> * Note: The last modified time of this file was set to</span></span><br><span class="line"><span class="comment"> *       the last modified time of the source file after</span></span><br><span class="line"><span class="comment"> *       generation to assist with modification tracking.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> org.apache.jsp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.jsp.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">index_jsp</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">HttpJspBase</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">JspSourceDependent</span>,</span></span><br><span class="line"><span class="class">                 <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">JspSourceImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> javax.servlet.jsp.JspFactory _jspxFactory =</span><br><span class="line">          javax.servlet.jsp.JspFactory.getDefaultFactory();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.util.Map&lt;java.lang.String,java.lang.Long&gt; _jspx_dependants;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.util.Set&lt;java.lang.String&gt; _jspx_imports_packages;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.util.Set&lt;java.lang.String&gt; _jspx_imports_classes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    _jspx_imports_packages = <span class="keyword">new</span> java.util.HashSet&lt;&gt;();</span><br><span class="line">    _jspx_imports_packages.add(<span class="string">"javax.servlet"</span>);</span><br><span class="line">    _jspx_imports_packages.add(<span class="string">"javax.servlet.http"</span>);</span><br><span class="line">    _jspx_imports_packages.add(<span class="string">"javax.servlet.jsp"</span>);</span><br><span class="line">    _jspx_imports_classes = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> javax.el.ExpressionFactory _el_expressionfactory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> org.apache.tomcat.InstanceManager _jsp_instancemanager;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.Map&lt;java.lang.String,java.lang.Long&gt; getDependants() &#123;</span><br><span class="line">    <span class="keyword">return</span> _jspx_dependants;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.Set&lt;java.lang.String&gt; getPackageImports() &#123;</span><br><span class="line">    <span class="keyword">return</span> _jspx_imports_packages;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.Set&lt;java.lang.String&gt; getClassImports() &#123;</span><br><span class="line">    <span class="keyword">return</span> _jspx_imports_classes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> javax.el.<span class="function">ExpressionFactory <span class="title">_jsp_getExpressionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_el_expressionfactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_el_expressionfactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _el_expressionfactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> org.apache.tomcat.<span class="function">InstanceManager <span class="title">_jsp_getInstanceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_jsp_instancemanager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_jsp_instancemanager == <span class="keyword">null</span>) &#123;</span><br><span class="line">          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _jsp_instancemanager;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(<span class="keyword">final</span> javax.servlet.http.HttpServletRequest request, <span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> java.lang.String _jspx_method = request.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">"GET"</span>.equals(_jspx_method) &amp;&amp; !<span class="string">"POST"</span>.equals(_jspx_method) &amp;&amp; !<span class="string">"HEAD"</span>.equals(_jspx_method) &amp;&amp; !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123;</span><br><span class="line">      response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, <span class="string">"JSPs only permit GET POST or HEAD"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;</span><br><span class="line">    javax.servlet.http.HttpSession session = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> javax.servlet.ServletContext application;</span><br><span class="line">    <span class="keyword">final</span> javax.servlet.ServletConfig config;</span><br><span class="line">    javax.servlet.jsp.JspWriter out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> java.lang.Object page = <span class="keyword">this</span>;</span><br><span class="line">    javax.servlet.jsp.JspWriter _jspx_out = <span class="keyword">null</span>;</span><br><span class="line">    javax.servlet.jsp.PageContext _jspx_page_context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response.setContentType(<span class="string">"text/html; charset=ISO-8859-1"</span>);</span><br><span class="line">      pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,</span><br><span class="line">                  <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">      _jspx_page_context = pageContext;</span><br><span class="line">      application = pageContext.getServletContext();</span><br><span class="line">      config = pageContext.getServletConfig();</span><br><span class="line">      session = pageContext.getSession();</span><br><span class="line">      out = pageContext.getOut();</span><br><span class="line">      _jspx_out = out;</span><br><span class="line"></span><br><span class="line">      out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;html&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;head&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\"&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;title&gt;Insert title here&lt;/title&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;/head&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;body&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"666\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;/body&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.Throwable t) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(t <span class="keyword">instanceof</span> javax.servlet.jsp.SkipPageException))&#123;</span><br><span class="line">        out = _jspx_out;</span><br><span class="line">        <span class="keyword">if</span> (out != <span class="keyword">null</span> &amp;&amp; out.getBufferSize() != <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">              out.flush();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              out.clearBuffer();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (_jspx_page_context != <span class="keyword">null</span>) _jspx_page_context.handlePageException(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _jspxFactory.releasePageContext(_jspx_page_context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们发现这个类并没有继承HttpServlet而是继承了org.apache.jasper.runtime.HttpJspBase并且里面也没有service方法而是<code>_jspservice</code>方法。那么Tomcat就会到它的父类中找service方法并进行调用。实际上它的父类org.apache.jasper.runtime.HttpJspBase继承了HttpServlet。</p><p>jsp已经是一门比较落后的技术来，因为html、css、js是前端写的，而后端要在其中加入逻辑判断，那么首先你一定得认识前端语言的代码，否则你如何嵌套？这样很不利于前后端的分离。之所以学习是因为很多框架和项目中依然会用到它，但是最终还是会被时代所淘汰。</p>]]></content>
      
      
      <categories>
          
          <category> SSM/SSH </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring家族说明</title>
      <link href="/2019/03/04/Spring%E5%AE%B6%E6%97%8F%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/03/04/Spring%E5%AE%B6%E6%97%8F%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h1><p>通常来说，我们说的Spring指的是Spring Framework，其实它只是Spring家族中一个产品，Spring家族还有很多产品，开发者可以根据自己的需要，选择Spring家族中的某些产品来使用。Spring家族的产品主要有：</p><p>（1）Spring Framework</p><p>它是Spring家族中核心子项目。包括了IoC，AOP，DAO/JDBC，Spring MVC，i18n等。</p><p>（2）Spring Data</p><p>Spring Data是Spring平台中一个功能模块，主要用来和数据访问层相关的框架功能。如关系型数据库、Map-Reduce分布式存储以及云存储环境等。</p><p>（3）Spring Security</p><p>它是被广泛使用的基于Spring的认证和安全工具，其目标是为Spring应用提供一个安全服务，比如认证、授权等等。</p><p>（4）Spring Boot</p><p>（5）Spring Cloud</p><p>（6）Spring Cloud Data Flow</p><p>（7）Spring Batch</p><p>（8）Spring AMQP</p><p>（9）Spring Mobile</p><p>（10）Spring For Android</p><p>（11）Spring Web Services</p><p>（12）Spring Web Flow</p><p>（13）Spring Session</p><p>（14）Spring Shell</p><p>（15）Spring Kafka</p><p>（16）…..</p><p>备注：Spring家族提供了很多的模块，开发项目时，我们可以根据需要来选择部分的模块来使用。具体参见<code>https://spring.io/projects</code>页面各模块的说明。</p><h1 id="Spring全家桶的包结构"><a href="#Spring全家桶的包结构" class="headerlink" title="Spring全家桶的包结构"></a>Spring全家桶的包结构</h1><p>（1）Spring Framework</p><pre><code>org.springframework.coreorg.springframework.beansorg.springframework.aoporg.springframework.web  // Spring MVC/Spring Weborg.springframework.cacheorg.springframework.cgliborg.springframework.contextorg.springframework.jdbcorg.springframework.jmsorg.springframework.schedulingorg.springframework.messaging....</code></pre><p>（2）Sping Data</p><pre><code>org.springframework.data.jpaorg.springframework.data.mongodborg.springframework.data.jdbcorg.springframework.data.redis....</code></pre><p>（3）Spring Boot</p><pre><code>org.springframework.boot</code></pre><p>（4）Spring Security</p><pre><code>org.springframework.security</code></pre><p>（5）….</p>]]></content>
      
      
      <categories>
          
          <category> SSM/SSH </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中JavaBeans|PO|VO|BO|DTO|DAO|POJO|EJB|Entity的概念及联系</title>
      <link href="/2019/03/04/JAVA%E4%B8%ADJavaBeans-PO-VO-BO-DTO-DAO-POJO-EJB-Entity%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%81%94%E7%B3%BB/"/>
      <url>/2019/03/04/JAVA%E4%B8%ADJavaBeans-PO-VO-BO-DTO-DAO-POJO-EJB-Entity%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%81%94%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA中JavaBeans-PO-VO-BO-DTO-DAO-POJO-EJB-Entity简介"><a href="#JAVA中JavaBeans-PO-VO-BO-DTO-DAO-POJO-EJB-Entity简介" class="headerlink" title="JAVA中JavaBeans|PO|VO|BO|DTO|DAO|POJO|EJB|Entity简介"></a>JAVA中JavaBeans|PO|VO|BO|DTO|DAO|POJO|EJB|Entity简介</h1><p><img src="/images/java_obj_1_1.png" alt></p><p>备注：POJO是DO/DTO/BO/VO的统称。</p><h1 id="JavaBeans"><a href="#JavaBeans" class="headerlink" title="JavaBeans"></a>JavaBeans</h1><p>JavaBeans是Java中一种特殊的类，可以将多个对象封装到一个对象（bean）中。特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。名称中的“Bean”是用于Java的可重用软件组件的惯用叫法。</p><p>要成为JavaBean类，则必须遵循关于命名、构造器、方法的特定规范。有了这些规范，才能有可以使用、复用、替代和连接JavaBeans的工具。具体规范如下：</p><pre><code>有一个public的无参数建构子属性可以通过get、set、is（可以替代get，用在布尔型属性上）方法或遵循特定命名规范的其他方法访问可序列化</code></pre><h1 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h1><p>POJO，英文全称为Plain Ordinary Java Object，POJO代表的是一个简单的Java类，这个类没有实现/继承任何特殊的java接口或者类，不遵循任何主要Java模型，约定或者框架的java对象。而且，在理想情况下，POJO不应该有注解。使用POJO名称是为了避免和EJB混淆起来。</p><h1 id="EJB"><a href="#EJB" class="headerlink" title="EJB"></a>EJB</h1><p>EJB，全称为Enterprise JavaBean，中文为企业级JavaBean，是一个用来构筑企业级应用的服务器端可被管理组件。EJB就比较复杂，包含一定的业务逻辑。</p><p>相关学习资料：<br><a href="https://blog.csdn.net/qq_35246620/article/details/77247427" target="_blank" rel="noopener">https://blog.csdn.net/qq_35246620/article/details/77247427</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot项目中的一些常用注解</title>
      <link href="/2019/03/04/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/03/04/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Controller-Service-Repository-Component"><a href="#Controller-Service-Repository-Component" class="headerlink" title="@Controller|@Service|@Repository|@Component"></a>@Controller|@Service|@Repository|@Component</h1><p>事实上，@Controller|@Service|@Repository|@Component这几个注解并没有任何功能上的区别，可以把这些当做是分类标签，目的是为了让你的代码可读性更强。在Annotaion配置注解中用@Component来表示一个通用注解，用于说明一个类是一个被Spring容器管理的bean，即该类已经拉入到Spring的管理中了。而@Controller, @Service, @Repository是对@Component的细化，这三个注解比@Component带有更多的语义，它们分别对应了控制层、服务层、持久层的类。详细如下：</p><pre><code>@Repository：用于标注数据访问组件，即DAO组件@Service：用于标注业务层组件@Controller：用于标注控制层组件（如struts中的action）@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注</code></pre><h1 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h1><p>Spring4之后新加的注解，表示controller返回给浏览器json格式的结果。此前控制器返回json结果，需要@ResponseBody配合@Controller一起。如果单独使用@Controller，那么需要配合模板引擎给浏览器返回html页面。即<code>@RestController=@Controller+@ResponseBody</code>。</p><h1 id="设置路由映射及请求方法-RequestMapping-GetMapping-PostMapping-PutMapping-DeleteMapping"><a href="#设置路由映射及请求方法-RequestMapping-GetMapping-PostMapping-PutMapping-DeleteMapping" class="headerlink" title="设置路由映射及请求方法_@RequestMapping|@GetMapping|@PostMapping|@PutMapping|@DeleteMapping"></a>设置路由映射及请求方法_@RequestMapping|@GetMapping|@PostMapping|@PutMapping|@DeleteMapping</h1><p>都是用来配置url路由映射（即请求url映射到controller方法上）以及HTTP请求方法设定。@GetMapping、@PostMapping、@PutMapping以及@DeleteMapping除了配置url路由外，还指定了HTTP请求的Method，如@GetMapping代表的是Get请求。举例来说：</p><pre><code>@GetMapping(&quot;/hello&quot;)    #映射到http://xxx/hello请求路径上，HTTP请求方法是GET请求@RequestMapping(value=&quot;/hello&quot;, method = RequestMethod.POST)  #映射到http://xxx/hello请求路径上，HTTP请求方法是POST请求</code></pre><h1 id="获取HTTP请求参数-PathVariable-RequestParam-RequestBody"><a href="#获取HTTP请求参数-PathVariable-RequestParam-RequestBody" class="headerlink" title="获取HTTP请求参数_@PathVariable|@RequestParam|@RequestBody"></a>获取HTTP请求参数_@PathVariable|@RequestParam|@RequestBody</h1><p>（1）@PathVariable</p><p>获取url中的数据，如<code>@PathVariable(&quot;id&quot;) int id</code>，获取<code>@RequestMapping(value=&quot;/searchListById/{id}&quot;,method = RequestMethod.POST)</code>中的id</p><p>（2）@RequestParam</p><p>获取url问号后参数，如<code>@RequestParam(value=&quot;name&quot;,required = true)</code>，name表示问号参数的key，<code>?name=xxxx</code></p><p>（3）@RequestBody</p><p>将请求体中内容映射到Java中对象上，如<code>@RequestBody TbUserModel user</code>，获取POST请求中请求body中的json数据，<code>{&quot;id&quot;:1,&quot;userId&quot;:1,&quot;pwd&quot;:&quot;123&quot;,&quot;name&quot;:&quot;123&quot;,&quot;pwd&quot;:&quot;123&quot;,&quot;headPortait&quot;:&quot;123&quot;,&quot;isEnable&quot;:&quot;123&quot;,&quot;createDate&quot;:&quot;2015-05-12&quot;,&quot;lastLogin&quot;:&quot;2015-05-12&quot;}</code></p><h1 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h1><p>@EnableAutoConfiguration注解，用来告诉SpringBoot框架帮我们自动生成一些配置，也就是依据我们依赖的jar包（pom.xml）这个线索帮我们自动生成需要的配置。</p><h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><p>@Autowired自动装配。</p><p>当Spring容器启动时，AutowiredAnnotationBeanPostProcessor将扫描Spring容器中所有Bean。当发现Bean中拥有@Autowired注释时，就找到和其匹配（默认按类型匹配）的Bean，并注入到对应的地方中去。</p><p><strong>@Autowired可以注解到私有成员变量、构造方法、成员方法上</strong>。当@Autowired对方法或构造函数进行标注时，Spring会将构造函数或成员方法的参数所对应的对象以Spring Bean的形式注入进去。</p><h1 id="EnableScheduling-Scheduled"><a href="#EnableScheduling-Scheduled" class="headerlink" title="@EnableScheduling|@Scheduled"></a>@EnableScheduling|@Scheduled</h1><p>@EnableScheduling表示开启Spring的定时调度任务功能，在SpringBoot项目上要实现定时调度任务，必须在项目入口类上加上该注解。@Scheduled是用来设定具体的调度策略，如<code>@Scheduled(cron = &quot;0 0 8,20 * * ?&quot;)</code>表示每天的8点和20点执行一下该任务。</p><h1 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h1><p>@Resource和@Autowired的功能是类似的，也是用来自动装配的。只是@Resource这个注解是JDK自带的，Spring对@Resource也是支持的。而@Autowired是Spring自带的注解。</p><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h1><p>@Configuration注解标注一个类是配置类，Spring框架在扫到这个注解时自动加载这个类相关的功能。@Configuration标注在类上，相当于把该类作为Spring的XML配置文件中的<beans>，即其作用为配置Spring容器的应用上下文。例如：</beans></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.spring.support.configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestConfiguration</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"spring容器启动初始化。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就相当于如下的Spring XML配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>; <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>;</span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span>; <span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span>; <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/taskhttp://www.springframework.org/schema/task/spring-task-4.0.xsd"</span>; <span class="attr">default-lazy-init</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"com.test.Foo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>备注：其中@Bean相当于定义了一个Bean对象，具体见下面对@Bean注解的描述。</p><h1 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h1><p>@Bean标注在某个方法上（该方法需要返回某个实例对象），这就相当于在Spring的XML配置文件中添加了一个<code>&lt;bean&gt;</code>的配置。说白了，@Bean和@Component等一样，定义了一个被Spring管理的Bean对象，只是@Bean是将某个方法返回的实例对象作为Bean让Spring去管理。</p><p>备注：使用@Configuration和@Bean注解来代替传统的XML配置文件，这种方式称为Spring JavaConfig方式哦，记住这个名词。</p><h1 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h1><p>将自定义配置文件中内容映射到JAVA对象中，具体参见<a href="https://wangjianno1.github.io/2019/03/04/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/">《SpringBoot项目中配置定义和使用》</a>。</p><h1 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h1><p>将resources/application.properties中的配置内容注入到类的成员变量上，具体参见<a href="https://wangjianno1.github.io/2019/03/04/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/">《SpringBoot项目中配置定义和使用》</a>。</p><h1 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h1><p>很多SpringBoot开发者总是使用@Configuration，@EnableAutoConfiguration和@ComponentScan注解他们的main类。由于这些注解被如此频繁地一块使用，Spring Boot提供一个方便的@SpringBootApplication选择。该@SpringBootApplication注解等价于以默认属性使用@Configuration，@EnableAutoConfiguration和@ComponentScan。值得注意的是，使用了@SpringBootApplication注解后，在该启动Main类所在的package下的所有子package都会被Spring扫描，若使用了@Service、 @Repository或@Component等注解的类，都会被Spring容器纳入管理。一定要注意的是，使用@SpringBootApplication注解只会扫描启动所在package下及其子package的类，如果满足@Service、 @Repository或@Component等注解才会纳入Spring容器管理。因此，如果需要SpringBoot中Spring能管理第三方包中的Bean，则在@SpringBootApplication的基础上再加上@ComponentScan注解，指明要扫描的包名。</p><h1 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h1><p>该注解用于将Controller的方法返回的对象通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。因此，当我们Controller方法返回的数据不是html格式的页面，而是其他某种格式的数据时，如json、xml等，就需要使用到@ResponseBody注解。</p><h1 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h1><p>在和数据库做相关操作时，我们可以通过@Transactional注解来达到事务功能。@Transactional注解可以作用到类上，也可以作用到方法上。假设@Transactional作用到某个方法上，那么在一次客户端请求过程中，如果该方法中任何地方抛出异常（不管是数据库相关的异常，还是其他的异常），则回滚所有数据库相关的变更操作。如果@Transactional作用到类上，那么相当于该类中所有方法上都使用了@Transactional注解。需要注意的是，一般我们将@Transactional注解到Service层的类名或Service层的方法上，注解到Service的类上，则该类中所有方法都有事务性，注解到方法上则只有该方法有事务性。</p><p>备注：@Transactional注解的完整包路径是<code>org.springframework.transaction.annotation.Transactional</code>，是属于Spring Framework框架中的。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中控制器增强@ControllerAdvice及统一异常处理</title>
      <link href="/2019/03/04/SpringBoot%E4%B8%AD%E6%8E%A7%E5%88%B6%E5%99%A8%E5%A2%9E%E5%BC%BA-ControllerAdvice%E5%8F%8A%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/03/04/SpringBoot%E4%B8%AD%E6%8E%A7%E5%88%B6%E5%99%A8%E5%A2%9E%E5%BC%BA-ControllerAdvice%E5%8F%8A%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="ControllerAdvice简介"><a href="#ControllerAdvice简介" class="headerlink" title="@ControllerAdvice简介"></a>@ControllerAdvice简介</h1><p>@ControllerAdvice，是Spring3.2提供的新注解，从名字上可以看出大体意思是控制器增强。@ControllerAdvice的定义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value=TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(value=RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ControllerAdvice</span><br></pre></td></tr></table></figure><p>从@ControllerAdvice定义可以看出，被@ControllerAdvice注解的类会是一个Component，即会被Spring容器管理。</p><p>@ControllerAdvice是一个@Component，可以配合@ExceptionHandler，@InitBinder或@ModelAttribute注解，来实现增强控制器的功能，适用于所有使用@RequestMapping的控制器方法。</p><p>Spring4之前，@ControllerAdvice在同一调度的Servlet中的所有的控制器controller进行增强。但Spring4已经改变，@ControllerAdvice支持配置控制器controller的子集，若不配置子集，则会对所有控制器有效。在Spring4中，@ControllerAdvice通过annotations()，basePackageClasses()，basePackages()方法定制用于选择控制器子集。</p><h1 id="使用-ControllerAdvice-ExceptionHandler来实现统一异常处理"><a href="#使用-ControllerAdvice-ExceptionHandler来实现统一异常处理" class="headerlink" title="使用@ControllerAdvice+@ExceptionHandler来实现统一异常处理"></a>使用@ControllerAdvice+@ExceptionHandler来实现统一异常处理</h1><p>如下为使用@ControllerAdvice+@ExceptionHandler来实现SprintBoot项目的统一异常处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalProcessException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlobalProcessException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value=GlobalProcessException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResultBody</span>&lt;<span class="title">Object</span>&gt; <span class="title">handleProcessException</span>(<span class="title">Exception</span> <span class="title">ex</span>, <span class="title">HttpServletRequest</span> <span class="title">request</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.exception(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value=Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResultBody</span>&lt;<span class="title">Object</span>&gt; <span class="title">handleUnknownException</span>(<span class="title">Exception</span> <span class="title">ex</span>, <span class="title">HttpServletRequest</span> <span class="title">request</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：ExceptionHandler表示该增强Controller可以捕获什么类型的异常。在上面的例子中，当controller层抛出GlobalProcessException或Exception异常时，就会被增强Controller GlobalExceptionHandler所捕获，然后按照方法内容进行处理并将处理结果返回给浏览器。使用@ResponseBody可以返回json格式的数据内容到浏览器。</p><p>学习资料参考于：<br><a href="http://www.spring4all.com/article/1477" target="_blank" rel="noopener">http://www.spring4all.com/article/1477</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot项目中单元测试</title>
      <link href="/2019/03/04/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/03/04/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="引入Junit依赖"><a href="#引入Junit依赖" class="headerlink" title="引入Junit依赖"></a>引入Junit依赖</h1><p>在SpringBoot项目中引入org.Junit测试框架的JAR依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>备注：使用的单元测试框架是JUnit啦。</p><h1 id="测试service层方法"><a href="#测试service层方法" class="headerlink" title="测试service层方法"></a>测试service层方法</h1><p>（1）在src/test/java目录中新建service层package，如com.bat.sbdemo.service</p><p>（2）在com.bat.sbdemo.service包下新建service测试类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">StudentServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line">       </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllStudentTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; allStudent = studentService.getAllStudent();</span><br><span class="line">        Assert.assertNotNull(allStudent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用Junit运行测试</p><p>在测试方法名或测试类上右键选择<code>Run As &gt;&gt; JUnit Test</code>菜单项，然后在Junit窗体中查看单元测试结果：</p><p><img src="/images/springboot_test_1_1.png" alt></p><p>备注：绿条表示测试用例通过，红条表示测试用例失败。</p><h1 id="测试controller层方法"><a href="#测试controller层方法" class="headerlink" title="测试controller层方法"></a>测试controller层方法</h1><p>（1）在src/test/java目录中新建service层package，如com.bat.sbdemo.controller</p><p>（2）在com.bat.sbdemo.controller包下新建controller测试类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureMockMvc</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">StudentControllerTest</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllStudentTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/student/all"</span>)).andExpect(MockMvcResultMatchers.status().isOk());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用Junit运行测试</p><p>在测试方法名或测试类上右键选择<code>Run As &gt;&gt; JUnit Test</code>菜单项，然后在Junit窗体中查看单元测试结果。</p><h1 id="Junit中Assert断言的使用"><a href="#Junit中Assert断言的使用" class="headerlink" title="Junit中Assert断言的使用"></a>Junit中Assert断言的使用</h1><p>Junit框架包下的Assert提供了多个断言方法，主用于比较测试传递进去的两个参数。常用的断言方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(T expected, T actual)   <span class="comment">//比较expected和actual值是否相等，可以是各种基础数据类型，也可以是抽象数据类型</span></span><br><span class="line">Assert.assertNotEquals(T expected, T actual)</span><br><span class="line"></span><br><span class="line">Assert.assertSame(T expected, T actual)   <span class="comment">//比较expected和actual值在内存中是否是同一个对象， expected == actual</span></span><br><span class="line">Assert.assertNotSame(T expected, T actual)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Assert.assertTrue(<span class="keyword">boolean</span> condition)</span><br><span class="line">Assert.assertFalse(<span class="keyword">boolean</span> condition)</span><br><span class="line"></span><br><span class="line">Assert.assertNull(Object object)</span><br><span class="line">Assert.assertNotNull(Object object)</span><br><span class="line"></span><br><span class="line">Assert.assertArrayEquals(Object[] expected, Object[] actual) <span class="comment">// 比较数组，如果数组长度相同，且每个对应的元素相同，则两个数组相等，否则不相等</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h1 id="闲杂知识"><a href="#闲杂知识" class="headerlink" title="闲杂知识"></a>闲杂知识</h1><p>（1）src/test/java目录下的package结构要和src/main/java下的package结构一样。被测试类要和测试类保持一一对应。</p><p>（2）测试类的命名是被测试类类名加上Test，如被测试类为StudentService，则测试类为StudentServiceTest。测试方法名是被测试方法名加上Test，如被测试方法名为getAllStudent，则测试方法名为getAllStudentTest。</p><p>（3）在测试方法名上<code>Run As &gt;&gt; JUnit Test</code>，只会测试该测试用例。如果想运行整个SpringBoot项目的测试用例，可以在项目名或src/test/java上右键鼠标，选择<code>Run As &gt;&gt; JUnit Test</code>菜单项，那么就会运行整个项目的测试用例啦。</p><p>（4）在使用<code>maven package</code>打包等命令时，maven会自动运行整个项目的测试用例。若想在打包时，跳过单元测试，可以使用<code>maven package -Dmaven.test.skip=true</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot项目中日志管理</title>
      <link href="/2019/03/04/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"/>
      <url>/2019/03/04/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot日志简介"><a href="#SpringBoot日志简介" class="headerlink" title="SpringBoot日志简介"></a>SpringBoot日志简介</h1><p>默认情况下，SpringBoot会用Logback来记录日志，并用INFO级别输出到控制台。但是默认配置也提供了对常用日志的支持，如Java Util Logging，Log4J，Log4J2和Logback。每种Logger都可以通过配置使用控制台或者文件输出日志内容。默认输出日志的格式如下：</p><pre><code>2016-04-13 08:23:50.120 INFO 37397 --- [ main] org.hibernate.Version : HHH000412: Hibernate Core {4.3.11.Final}</code></pre><p>各个字段说明如下：</p><pre><code>时间日期 — 精确到毫秒日志级别 — ERROR, WARN, INFO, DEBUG or TRACE进程ID分隔符 — 标识实际日志的开始线程名 — 方括号括起来（可能会截断控制台输出）Logger名 — 通常使用源代码的类名日志内容</code></pre><h1 id="SpringBoot日志的输出位置"><a href="#SpringBoot日志的输出位置" class="headerlink" title="SpringBoot日志的输出位置"></a>SpringBoot日志的输出位置</h1><p>SpringBoot默认配置只会输出到控制台，并不会记录到文件中，但是我们通常生产环境使用时都需要以文件方式记录日志。若要增加文件输出，需要在application.properties中配置logging.file或logging.path属性。需要注意的是，二者不能同时使用，如若同时使用，则只有logging.file生效。默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为ERROR、WARN、INFO。</p><p>（1）logging.file，设置文件，可以是绝对路径，也可以是相对路径。如logging.file=sbdemo.log会在当前目录生成一个sbdemo.log的日志文件</p><p>（2）logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如logging.path=/var/log会在/var/log/下生成一个spring.log的日志文件</p><p>具体配置实例如下：</p><pre><code>#logging.path=D:\\apache-tomcat-9.0.8\\logslogging.file=D:\\apache-tomcat-9.0.8\\logs\\sbdemo.log</code></pre><h1 id="SpringBoot应用的日志级别控制"><a href="#SpringBoot应用的日志级别控制" class="headerlink" title="SpringBoot应用的日志级别控制"></a>SpringBoot应用的日志级别控制</h1><p>SpringBoot应用的日志级别控制有如下几种配置：</p><p>（1）配置SpringBoot框架自身输出日志的级别在SpringBoot中默认配置了ERROR、WARN和INFO级别的日志输出到控制台。我们可以通过如下两种方式切换不同的日志级别，如切换到DEBUG日志级别，可以有如下两种方法：</p><pre><code>A).在运行命令后加入--debug标志，如java -jar myapp.jar --debugB).在application.properties中配置debug=true，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别</code></pre><p>备注：上述配置的日志级别是针对SpringBoot框架自身的日志级别，开发者在代码中logger.xxx并不会依据该级别输出日志。</p><p>（2）配置开发者自己代码输出的日志</p><p>我们可以在controller、service以及repository层定义Logger，然后使用Logger输出不同级别的日志，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(StudentController<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//参数一定要是当前类的类对象，将会在日志中有体现</span></span><br><span class="line">logger.info(<span class="string">"info log print~~~"</span>);</span><br><span class="line">logger.debug(<span class="string">"debug log print~~~"</span>);</span><br></pre></td></tr></table></figure><p>如需要在静态工具类中打印日志，可以使用<code>private final static Logger logger = LoggerFactory.getLogger(ResultUtil.class)</code>即可。</p><p>在application.properties中做如下配置可以控制输出的日志级别：</p><pre><code>logging.level.com.bat=WARN #格式为logging.level.*=LEVEL，其中*表示包名，表示对该包下的所有类的日志输出定义一个日志级别</code></pre><p>（3）配置SpringBoot的root Logger的日志级别</p><p>配置SpringBoot的root Logger的日志级别，对框架自身以及开发者自己输出的日志都是有效的，配置如下：</p><pre><code>logging.level.root=DEBUG</code></pre><h1 id="定义日志的格式"><a href="#定义日志的格式" class="headerlink" title="定义日志的格式"></a>定义日志的格式</h1><p>在application.properties中通过如下配置可以定义日志的格式：</p><pre><code>logging.pattern.console=%d - %msg%nlogging.pattern.file=%d - %msg%n</code></pre><p>其中logging.pattern.console表示输出到控制台的日志格式，logging.pattern.file表示输出到文件的日志格式。</p><h1 id="开发者自定义日志输出"><a href="#开发者自定义日志输出" class="headerlink" title="开发者自定义日志输出"></a>开发者自定义日志输出</h1><p>（1）在src/main/resources下创建日志配置文件，如logback-spring.xml，log4j-spring.xml，log4j2-spring.xml或logging.properties等</p><p>（2）在application.properties中指定日志配置文件的位置logging.config=classpath:log4j-spring.xml</p><p>学习资料参考于：<br><a href="https://blog.csdn.net/Inke88/article/details/75007649" target="_blank" rel="noopener">https://blog.csdn.net/Inke88/article/details/75007649</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合MyBatis访问RDBMS</title>
      <link href="/2019/03/04/SpringBoot%E6%95%B4%E5%90%88MyBatis%E8%AE%BF%E9%97%AERDBMS/"/>
      <url>/2019/03/04/SpringBoot%E6%95%B4%E5%90%88MyBatis%E8%AE%BF%E9%97%AERDBMS/</url>
      
        <content type="html"><![CDATA[<h1 id="引入MyBatis依赖"><a href="#引入MyBatis依赖" class="headerlink" title="引入MyBatis依赖"></a>引入MyBatis依赖</h1><p>在SpringBoot中引入MyBatis的JAR包依赖，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该JAR包是MyBatis开发出来用来集成SpringBoot项目的MyBatis依赖JAR包，有了这个JAR包，在SpringBoot项目中使用MyBatis就好用多了。mybatis-spring-boot-starter在SpringBoot项目中主要有两种开发配置方案，一种是使用注解解决一切问题，一种是简化XML后的传统方式。两种方式各有特点，注解版适合简单快速的模式，非常适合现在流行的微服务架构模式。XML传统模式比适合大型项目，可以灵活的动态生成SQL，方便调整SQL，也有痛痛快快，洋洋洒洒的写SQL的感觉。</p><h1 id="使用注解的方式"><a href="#使用注解的方式" class="headerlink" title="使用注解的方式"></a>使用注解的方式</h1><p>（1）在application.properties中添加如下配置</p><pre><code>mybatis.type-aliases-package=com.bat.entityspring.datasource.driverClassName = com.mysql.jdbc.Driverspring.datasource.url = jdbc:mysql://127.0.0.1:3306/testtable?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = sbdemospring.datasource.password = sbdemo</code></pre><p>SpringBoot会自动加载<code>spring.datasource.*</code>相关配置，数据源就会自动注入到sqlSessionFactory中，sqlSessionFactory会自动注入到Mapper中。</p><p>（2）在启动类中添加对mapper包扫描@MapperScan</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.bat.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接在Mapper类上面添加注解@Mapper，建议使用第一种，不然每个Mapper类都需要加个@Mapper注解，也是比较麻烦的。</p><p>（3）开发Mapper类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Result;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Results;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM users"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">        <span class="meta">@Result</span>(property = <span class="string">"userSex"</span>,  column = <span class="string">"user_sex"</span>, javaType = UserSexEnum<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">        @<span class="title">Result</span>(<span class="title">property</span> </span>= <span class="string">"nickName"</span>, column = <span class="string">"nick_name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;UserEntity&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM users WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">        <span class="meta">@Result</span>(property = <span class="string">"userSex"</span>,  column = <span class="string">"user_sex"</span>, javaType = UserSexEnum<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">        @<span class="title">Result</span>(<span class="title">property</span> </span>= <span class="string">"nickName"</span>, column = <span class="string">"nick_name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">UserEntity <span class="title">getOne</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"INSERT INTO users(user_name,password,user_sex) VALUES(#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;userSex&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"UPDATE users SET user_name=#&#123;userName&#125;,nick_name=#&#123;nickName&#125; WHERE id =#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"DELETE FROM users WHERE id =#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><pre><code>@Select是查询类的注解，所有的查询均使用这个@Result修饰返回的结果集，关联实体类属性和数据库字段一一对应，如果实体类属性和数据库属性名保持一致，就不需要这个属性来修饰@Insert插入数据库使用，直接传入实体类会自动解析属性到对应的值@Update负责修改，也可以直接传入对象@Delete负责删除</code></pre><p>（4）在Service层直接注入Mapper类，然后是用Mapper类来对数据进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper UserMapper;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSomeUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    UserMapper.insert(<span class="keyword">new</span> UserEntity(<span class="string">"aa"</span>, <span class="string">"a123456"</span>, UserSexEnum.MAN));</span><br><span class="line">    UserMapper.insert(<span class="keyword">new</span> UserEntity(<span class="string">"bb"</span>, <span class="string">"b123456"</span>, UserSexEnum.WOMAN));</span><br><span class="line">    UserMapper.insert(<span class="keyword">new</span> UserEntity(<span class="string">"cc"</span>, <span class="string">"b123456"</span>, UserSexEnum.WOMAN));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用简化XML配置的方式"><a href="#使用简化XML配置的方式" class="headerlink" title="使用简化XML配置的方式"></a>使用简化XML配置的方式</h1><p>简化XML版本保持映射文件的老传统，优化主要体现在不需要实现DAO的是实现层，系统会自动根据方法名在映射文件中找对应的SQL。</p><p>（1）在application.properties中添加如下配置</p><pre><code>mybatis.type-aliases-package=com.bat.entityspring.datasource.driverClassName = com.mysql.jdbc.Driverspring.datasource.url = jdbc:mysql://127.0.0.1:3306/testtable?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = sbdemospring.datasource.password = sbdemomybatis.config-locations=classpath:mybatis/mybatis-config.xmlmybatis.mapper-locations=classpath:mybatis/mapper/*.xml</code></pre><p>（2）新增MyBatis配置文件mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Integer"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Long"</span> <span class="attr">type</span>=<span class="string">"java.lang.Long"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"HashMap"</span> <span class="attr">type</span>=<span class="string">"java.util.HashMap"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"LinkedHashMap"</span> <span class="attr">type</span>=<span class="string">"java.util.LinkedHashMap"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"ArrayList"</span> <span class="attr">type</span>=<span class="string">"java.util.ArrayList"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"LinkedList"</span> <span class="attr">type</span>=<span class="string">"java.util.LinkedList"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>备注：这里还可以添加一些MyBatis基础的配置。</p><p>（3）添加User的映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.bat.mapper.UserMapper"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.bat.entity.UserEntity"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_name"</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">property</span>=<span class="string">"passWord"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_sex"</span> <span class="attr">property</span>=<span class="string">"userSex"</span> <span class="attr">javaType</span>=<span class="string">"com.bat.enums.UserSexEnum"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"nick_name"</span> <span class="attr">property</span>=<span class="string">"nickName"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_Column_List"</span> &gt;</span></span><br><span class="line">        id, user_name, password, user_sex, nick_name</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAll"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>  &gt;</span></span><br><span class="line">       SELECT</span><br><span class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">       FROM users</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOne"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Long"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> &gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">       FROM users</span><br><span class="line">       WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"com.bat.entity.UserEntity"</span> &gt;</span></span><br><span class="line">       INSERT INTO</span><br><span class="line">            users</span><br><span class="line">            (user_name,password,user_sex)</span><br><span class="line">        VALUES</span><br><span class="line">            (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;userSex&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"com.bat.entity.UserEntity"</span> &gt;</span></span><br><span class="line">       UPDATE</span><br><span class="line">            users</span><br><span class="line">       SET</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span>user_name = #&#123;userName&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"passWord != null"</span>&gt;</span>password = #&#123;passWord&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        nick_name = #&#123;nickName&#125;</span><br><span class="line">       WHERE</span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Long"</span> &gt;</span></span><br><span class="line">       DELETE FROM</span><br><span class="line">             users</span><br><span class="line">       WHERE</span><br><span class="line">             id =#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）编写Dao层的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;UserEntity&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">UserEntity <span class="title">getOne</span><span class="params">(Long id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：UserMapper接口中的名字要和映射文件中的id对应起来。</p><p>（5）在Service层直接注入Mapper类，然后是用Mapper类来对数据进行操作</p><p>同第一种方式。</p><p>学习资料参考于：<br><a href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">MyBatis整合SpringBoot官网</a><br><a href="http://www.ityouknow.com/springboot/2016/11/06/spring-boo-mybatis.html" target="_blank" rel="noopener">http://www.ityouknow.com/springboot/2016/11/06/spring-boo-mybatis.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot项目中访问关系型数据库</title>
      <link href="/2019/03/04/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/03/04/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h1><p>（1）引入JdbcTemplate相关的jar包依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）定义数据源DataSource，在application.properties中添加如下配置</p><pre><code>spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/sbdemospring.datasource.username=sbdemospring.datasource.password=sbdemo</code></pre><p>（3）定义与数据库表对应的POJO实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(Integer score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）编写Dao层类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;  <span class="comment">//直接注入JdbcTemplate模板类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getAllStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from student"</span>;</span><br><span class="line">        List&lt;Student&gt; allStudents = jdbcTemplate.query(sql, <span class="keyword">new</span> RowMapper&lt;Student&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Student <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">                stu.setId(rs.getInt(<span class="string">"id"</span>));</span><br><span class="line">                stu.setName(rs.getString(<span class="string">"name"</span>));</span><br><span class="line">                stu.setAge(rs.getInt(<span class="string">"age"</span>));</span><br><span class="line">                stu.setSex(rs.getString(<span class="string">"sex"</span>));</span><br><span class="line">                stu.setScore(rs.getInt(<span class="string">"score"</span>));</span><br><span class="line">                <span class="keyword">return</span> stu;</span><br><span class="line">            &#125;</span><br><span class="line">                     </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> allStudents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）在service业务逻辑层直接注入Dao层类，并使用Dao层类的方法。</p><h1 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h1><p>使用Spring Data JPA子项目来访问关系型数据库，需要引入spring-boot-starter-data-jpa依赖，该依赖会引入如下核心JAR包：</p><pre><code>HibernateSpring Data JPASpring ORMs</code></pre><p>所以说，在SpringBoot项目中使用Spring Data JPA，使用到的JPA ORM框架默认是Hibernate。</p><p>（1）引入Spring Data JPA相关的jar包依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）定义数据源DataSource，在application.properties中添加如下配置</p><pre><code>spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/sbdemospring.datasource.username=sbdemospring.datasource.password=sbdemospring.jpa.hibernate.ddl-auto=updatespring.jpa.show_sql=true</code></pre><p>（3）依据JPA的规范定义Entity类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"t_student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"age"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"sex"</span>)</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"score"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(Integer score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）编写Repository层接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Student</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：Repository层只需要定义一个继承自Repository/JpaRepository/CrudRepository相关接口的接口即可，该接口中不需要声明任何方法，除非你有特殊的数据库操作，在默认的Repository/JpaRepository/CrudRepository接口中不支持。另外，如果有非常复杂的数据库操作，那么可以在Repository层接口类中声明一个方法，且在该方法上使用@Query注解，该@Query注解的参数就是需要操作的SQL语句。使用@Query注解的代码举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"FROM IpInfo i "</span> +</span><br><span class="line">       <span class="string">"LEFT JOIN FETCH i.machine im "</span> +</span><br><span class="line">       <span class="string">"WHERE i.ipNum =:ipNum"</span></span><br><span class="line">) </span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;IpInfo&gt; <span class="title">getIpInfoByIpNumOnlyMachine</span><span class="params">(@Param(<span class="string">"ipNum"</span>)</span> Long ipNum)</span>;</span><br></pre></td></tr></table></figure><p>（5）在service业务逻辑层直接注入Repository层接口作为Bean，并调用其中的方法来实现数据库的操作。</p><h1 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h1><p>参见文章<a href="https://wangjianno1.github.io/2019/03/04/SpringBoot%E6%95%B4%E5%90%88MyBatis%E8%AE%BF%E9%97%AERDBMS/">《SpringBoot整合MyBatis访问RDBMS》</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot项目中配置定义和使用</title>
      <link href="/2019/03/04/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/03/04/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="application-properties配置的定义和读取"><a href="#application-properties配置的定义和读取" class="headerlink" title="application.properties配置的定义和读取"></a>application.properties配置的定义和读取</h1><p>在SpringBoot项目中，<code>resources/application.properties</code>或<code>resources/application.yml</code>是项目核心的配置文件，这两个文件也是SpringBoot项目默认的配置文件。读取<code>application.properties/application.yml</code>有两种方法：</p><p>（1）Environment方式读取</p><p>框架中有一个org.springframework.core.env.Environment类，可以读取application.properties中配置的值。用法如下，我们可以看到直接将Environment注入进来，然后就可以使用getProperty方法来获取配置的值了， 参数是配置的名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config/&#123;key:.+&#125;"</span>)</span><br><span class="line">    <span class="function">Object <span class="title">getConfig</span><span class="params">(@PathVariable String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> env.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）<code>@Value</code>注解方式读取</p><p>通过注解的方式将要读取的值映射到这个字段上面，然后就可以直接使用了。代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.context-path&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String contextPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config/contextpath"</span>)</span><br><span class="line">    <span class="function">Object <span class="title">getConfigContextPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contextPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringBoot项目中自定义配置文件"><a href="#SpringBoot项目中自定义配置文件" class="headerlink" title="SpringBoot项目中自定义配置文件"></a>SpringBoot项目中自定义配置文件</h1><p><code>application.properties/application.yml</code>是SpringBoot项目缺省的核心配置，配置了一些框架相关的参数。当然，我们也可以将业务方面的配置写入到<code>application.properties/application.yml</code>中，但是一般来说我们不建议这么做，这个时候就需要自定义配置文件了。在没用SpringBoot开发框架之前，我们一般先创建一个独立的配置文件，然后在里面配置好值，用工具类去读取。当然也可以用Spring提供的PropertiesFactoryBean去读取。在SpringBoot项目中有了更方便的操作方式。具体方法如下：</p><p>（1）在<code>src/main/resources/config</code>中新建配置文件，如<code>src/main/resources/config/es.properties</code>，内容如下：</p><pre><code>es.index.url=http://10.16.20.97:9200/_cat/indices?h=index,docs.count,health,pri.store.size&amp;format=json</code></pre><p>（2）定义一个配置类，将配置文件中内容映射到JAVA对象中，如com.sohu.sysadmin.sgwlogsys.config.ElasticSearchConfig，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/config/es.properties"</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"es.index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：通过自测，将<code>@Component</code>修改成<code>@Configuration</code>也是可以的。另外，如果将自定义的属性配置放到application.properties中，那么上面的<code>@PropertySource(&quot;classpath:/config/es.properties&quot;)</code>注解是不需要的。</p><p>（3）在需要使用自定义配置的地方注入ElasticSearchConfig对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticSearchConfig esConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String url = esConfig.getUrl();</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringBoot项目中多环境配置"><a href="#SpringBoot项目中多环境配置" class="headerlink" title="SpringBoot项目中多环境配置"></a>SpringBoot项目中多环境配置</h1><h2 id="SpringBoot项目在不同环境中的配置派生"><a href="#SpringBoot项目在不同环境中的配置派生" class="headerlink" title="SpringBoot项目在不同环境中的配置派生"></a>SpringBoot项目在不同环境中的配置派生</h2><p>在SpringBoot项目中，项目的配置缺省是放到<code>${PROJ_NAME}/src/main/resources/application.properties</code>文件中。在实际开发项目中，可能会存在开发环境、测试环境以及生产环境。不同的部署环境，应用的配置是不一样的。我们可以在<code>${PROJ_NAME}/src/main/resources/</code>目录中分别创建application.properties，application-dev.properties，application-test.properties以及application-prod.properties，分别代表不同环境下的特殊配置。其中application.properties也要创建哦，所有环境的公共配置可以放到这里啦。</p><h2 id="多环境配置的生成方法"><a href="#多环境配置的生成方法" class="headerlink" title="多环境配置的生成方法"></a>多环境配置的生成方法</h2><p>多环境配置的生成有如下几种方法：</p><p>（1）在application.properties文件中通过<code>spring.profiles.active=xxx</code>来说明使用什么环境的配置。若<code>spring.profiles.active=test</code>，表示使用application-test.properties中配置来运行项目。</p><p>（2）在我们启动项目时，可以通过<code>java -jar xxxx.jar --spring.profiles.active=prod</code>来运行不同的环境。若直接运行<code>java -jar xxxx.jar</code>，则会根据application.properties中的<code>spring.profiles.active=xxx</code>来决定以什么环境来启动SpringBoot应用。</p><p>备注：在application.properties中配置的属性，会在所有环境中有效哦。另外，这需要与Maven pom.xml中多环境配置的区别要注意下哦。</p><p>学习资料参考于：<br><a href="https://surpass-wei.github.io/2017/02/24/spring-boot1.5%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC@ConfigurationProperties%E5%8F%96%E6%B6%88location%E6%B3%A8%E8%A7%A3%E5%90%8E%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">关于自定义配置</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot应用的实际部署</title>
      <link href="/2019/03/04/SpringBoot%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%9E%E9%99%85%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/03/04/SpringBoot%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%9E%E9%99%85%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="将SpringBoot应用直接打成jar包，直接运行"><a href="#将SpringBoot应用直接打成jar包，直接运行" class="headerlink" title="将SpringBoot应用直接打成jar包，直接运行"></a>将SpringBoot应用直接打成jar包，直接运行</h1><p>（1）在项目的pom.xml添加spring-boot-maven-plugin插件，该插件会将SpringBoot项目本身及其依赖打包成一个可以独立运行的jar包，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）在Eclipse工程右击，选择<code>Run As Maven build</code>，然后在Goals中输入<code>clean package</code>，并执行。执行后会在<code>${PROJ_NAEM}/target</code>目录下生成一个jar包文件。</p><p>（3）将jar拷贝到部署环境，直接执行<code>java -jar xxx-0.0.1.jar</code></p><p>（4）通过<code>http://ip:port/index</code>即可访问</p><h1 id="将SpringBoot应用部署到Jetty-Tomcat容器"><a href="#将SpringBoot应用部署到Jetty-Tomcat容器" class="headerlink" title="将SpringBoot应用部署到Jetty/Tomcat容器"></a>将SpringBoot应用部署到Jetty/Tomcat容器</h1><p>在pom.xml配置文件中，将packaging修改为war，然后右键Eclipse项目，选择<code>Run As Maven build...</code>，在Goals输入框中输入<code>clean package</code>并运行，即可生成war包。再将生成的war包部署到Jetty或Tomcat Servlet容器中即可（其实这里打包生成的war包，是可执行的war包，即通过<code>java -jar ***.war</code>启动即可，但是不能直接部署到独立的tomcat/jetty容器中）。</p><p>非常重要的一点的是，若要将war部署在单独的tomcat/jetty等Servlet容器时，一定要让SpringBoot的启动类继承SpringBootServletInitializer类，并实现configure方法，效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> application.sources(Application<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再打包成war包部署到tomcat/jetty容器中即可。如我们打完的war包名称为wahaha-0.0.1-SNAPSHOT.war，将war包拷贝到容器的webapps目录中并启动tomcat/jetty容器。然后在浏览器输入<code>http://127.0.0.1:8080/wahaha-0.0.1-SNAPSHOT/api/test</code>即可访问。若将wahaha-0.0.1-SNAPSHOT.war重命名为ROOT.war后，可以直接在浏览器中输入<code>http://127.0.0.1:8080/api/test</code>进行访问。</p><p>备注：<strong>这里之所以继承SpringBootServletInitializer并实现configure方法，相当于在web.xml中增加了Servlet的配置</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一个SpringBoot应用</title>
      <link href="/2019/03/04/%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E5%BA%94%E7%94%A8/"/>
      <url>/2019/03/04/%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot-HelloWorld工程"><a href="#SpringBoot-HelloWorld工程" class="headerlink" title="SpringBoot HelloWorld工程"></a>SpringBoot HelloWorld工程</h1><p>（1）在Eclipse新建Maven Project，选择“maven-archetype-quickstart”新建一个Maven初始化工程。</p><p>（2）在pom.xml中引入SpringBoot的依赖，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）在Eclipse工程上右击，选择<code>Maven | Update Maven...</code>来刷新工程并下载依赖的jar包</p><p>（4）在<code>${PROJ_NAME}/src/main/java/xxx-package-name</code>中新建一个controller的Class（<code>com/sohu/sysadmin/sgwlogsys/SampleController.java</code>），内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sohu.sysadmin.sgwlogsys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringApplication.run(SampleController<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）启动SpringBoot应用</p><p>在controller中，右键选择<code>Run AS Java Application</code>，该操作会在本地启动一个HTTP端口，默认为8080.  SpringBoot应用启动日志如下：</p><p><img src="/images/springboot_fristapp_1_1.png" alt></p><p>（6）访问测试</p><p>在浏览器中输入<code>http://127.0.0.1:8080/index</code>即可访问到页面。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot工程初始化搭建</title>
      <link href="/2019/03/04/SpringBoot%E5%B7%A5%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/03/04/SpringBoot%E5%B7%A5%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="官方初始化SpringBoot工程在线网站"><a href="#官方初始化SpringBoot工程在线网站" class="headerlink" title="官方初始化SpringBoot工程在线网站"></a>官方初始化SpringBoot工程在线网站</h1><p>使用SpringBoot在线配置网站初始化SpringBoot项目步骤如下：</p><p>（1）进入SpringBoot的在线配置网站<code>http://start.spring.io/</code>，定制自己的项目服务组件，然后下载Maven包到本地。</p><p>（2）在Eclipse中，通过<code>Import | Maven | Import Existing Maven Projects</code>，把Download的Maven包导入即可（如果导入的项目无法识别，请右键选择Maven Update）</p><h1 id="使用Eclipse-STS（Spring-Tool-Suite）插件来初始化SpringBoot工程项目"><a href="#使用Eclipse-STS（Spring-Tool-Suite）插件来初始化SpringBoot工程项目" class="headerlink" title="使用Eclipse STS（Spring Tool Suite）插件来初始化SpringBoot工程项目"></a>使用Eclipse STS（Spring Tool Suite）插件来初始化SpringBoot工程项目</h1><p>（1）安装Eclipse STS插件</p><p>通过菜单<code>Help | Eclipse Marketplace</code>，搜索Spring Tool Suite，如下：</p><p><img src="/images/springboot_init_1_1.png" alt></p><p>安装STS之后，就可以利用STS插件创建SpringBoot项目工程，如下：</p><p><img src="/images/springboot_init_1_2.png" alt></p><p>生成的SpringBoot项目的目录结构如下：</p><p><img src="/images/springboot_init_1_3.png" alt></p><p>进入SpringBootDemoApplication类文件，右键选择<code>Run As Spring Boot App</code>即可运行SpringBoot应用了。</p><h1 id="使用Eclipse创建Maven工程，再引入SpringBoot依赖"><a href="#使用Eclipse创建Maven工程，再引入SpringBoot依赖" class="headerlink" title="使用Eclipse创建Maven工程，再引入SpringBoot依赖"></a>使用Eclipse创建Maven工程，再引入SpringBoot依赖</h1><p>使用Eclipse直接创建Maven Project，然后在pom.xml中引入SpringBoot的核心jar包即可。具体参见<a href="https://wangjianno1.github.io/2019/03/04/%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E5%BA%94%E7%94%A8/">《第一个SpringBoot应用》</a></p><p>学习资料参考于：<br><a href="http://blog.csdn.net/qq_19260029/article/details/77966154" target="_blank" rel="noopener">http://blog.csdn.net/qq_19260029/article/details/77966154</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot介绍</title>
      <link href="/2019/03/04/SpringBoot%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/03/04/SpringBoot%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h1><p>SpringBoot是这几年微服务概念流行后，Pivotal团队开发的一套快速开发Spring应用的框架。它本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置（例如Jackson，JDBC,，Mongo，Redis及Mail等等），SpringBoot应用中这些第三方库几乎可以零配置的开箱即用（out-of-the-box），大部分的SpringBoot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。从概念上说，SpringBoot需要使用到Spring框架的各个部分，并且对它们进行了大量的默认约定配置。</p><p>简单来说，SpringBoot是Spring技术的全家桶哦。也就是说，SpringBoot是为了简化Spring开发而生，主要思想是降低Spring的入门，使得新手可以以最快的速度让程序在Spring框架下跑起来。</p><p>另外，SpringBoot与SpringMVC二者没有必然关系，SpringBoot在WEB MVC这块使用的还是SpringMVC框架。</p><h1 id="SpringBoot的特点"><a href="#SpringBoot的特点" class="headerlink" title="SpringBoot的特点"></a>SpringBoot的特点</h1><p>SpringBoot主要特点有化繁为简，简化配置；下一代框架，技术迭代趋势；构建微服务入门级框架。</p><p>核心思想是“<strong>约定大于配置</strong>”。</p><h1 id="学习SpringBoot的前置知识"><a href="#学习SpringBoot的前置知识" class="headerlink" title="学习SpringBoot的前置知识"></a>学习SpringBoot的前置知识</h1><pre><code>Maven构建工具的使用Spring注解RESTful API不需要学习SpringMVC</code></pre><h1 id="SpringBoot项目的目录结构"><a href="#SpringBoot项目的目录结构" class="headerlink" title="SpringBoot项目的目录结构"></a>SpringBoot项目的目录结构</h1><p>若使用Maven构建工具，SpringBoot项目的目录结构如下：</p><p><img src="/images/springboot_info_1_1.png" alt></p><p>备注：controller是控制层，用来接收并响应http请求。service是业务逻辑层。dao是数据访问层，主要用来访问数据库等。entity是数据库中ORM的实体层。</p><h1 id="SpringBoot项目的一些常见依赖库说明"><a href="#SpringBoot项目的一些常见依赖库说明" class="headerlink" title="SpringBoot项目的一些常见依赖库说明"></a>SpringBoot项目的一些常见依赖库说明</h1><p>（1）spring-boot-maven-plugin插件的使用</p><p>Maven项目的pom.xml中，添加了org.springframework.boot:spring-boot-maven-plugin插件后，当运行<code>mvn package</code>命令进行打包时，会将SpringBoot应用打包成一个可以直接运行的JAR文件，即使用<code>java -jar</code>命令就可以直接运行。</p><p>一般的Maven项目的打包命令，不会把依赖的jar包也打包进去的，只是会放在jar包的同目录下，能够引用就可以了，但是spring-boot-maven-plugin插件，会将依赖的jar包全部打包进去。比如下面这个jar包的<code>BOOT-INF/lib</code>目录下面就包含了所有依赖的jar包：</p><p><img src="/images/springboot_info_1_2.png" alt></p><p>（2）spring-boot-starter-web</p><p>SpringBoot WEB项目的主要框架，其中包括了SpringMVC且内置了tomcat作为了缺省的容器服务器。spring-boot-starter-web是SpringBoot项目的非常核心的依赖。</p><p>（3）<code>spring-boot-starter-*</code></p><p>SrpingBoot开发框架中，提供了很多以<code>spring-boot-starter-*</code>为开头的starter，我们可以在pom.xml中引入这些依赖。举例来说，若我们的SpringBoot应用需要与ElasticSearch交互，那么可以引入spring-boot-starter-data-elasticsearch，这样SpringBoot会帮我们管理相关的依赖库和配置。</p><h1 id="SpringBoot支持的模板引擎"><a href="#SpringBoot支持的模板引擎" class="headerlink" title="SpringBoot支持的模板引擎"></a>SpringBoot支持的模板引擎</h1><p>模板引擎，一种很好的解释是，将动态页面静态化。SpringBoot支持的模板引擎非常多，主要有如下几种：</p><pre><code>Thymeleaf（Spring官方的提供的模板引擎）freemmarkerVelocityGroovyMustache</code></pre><p>备注：SpringBoot项目避免使用JSP哦。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中多线程编程</title>
      <link href="/2019/03/03/JAVA%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/03/03/JAVA%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA多线程简介"><a href="#JAVA多线程简介" class="headerlink" title="JAVA多线程简介"></a>JAVA多线程简介</h1><p>Java给多线程编程提供了内置的支持，Java的多线程是内核线程，即是JVM调用系统API创建的线程，Java线程调度是由操作系统来调度。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>一点说明，Java是单进程多线程模型，这个单进程就是JVM进程，在操作系统层面看到就是java或java.exe进程，Java貌似不能搞多进程编程，如果也可以通过<code>Runtime.getRuntime().exec(&quot;java xxx&quot;)</code>来创建新的进程，创建出来的也是JVM进程。</p><h1 id="JAVA中线程的生命周期"><a href="#JAVA中线程的生命周期" class="headerlink" title="JAVA中线程的生命周期"></a>JAVA中线程的生命周期</h1><p><img src="/images/java_thread_1_1.png" alt></p><h1 id="JAVA创建多线程编程的方法"><a href="#JAVA创建多线程编程的方法" class="headerlink" title="JAVA创建多线程编程的方法"></a>JAVA创建多线程编程的方法</h1><p>Java提供了三种创建线程的方法。</p><h2 id="通过实现Runnable接口的多线程"><a href="#通过实现Runnable接口的多线程" class="headerlink" title="通过实现Runnable接口的多线程"></a>通过实现Runnable接口的多线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  <span class="comment">//需要实现接口中run()方法</span></span><br><span class="line">        System.out.println(<span class="string">"RunnableThread.run() method invoking....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableThread rt1 = newRunnableThread();</span><br><span class="line">        RunnableThread rt2 = newRunnableThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(rt1, <span class="string">"实现Runnable接口的线程1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(rt2, <span class="string">"实现Runnable接口的线程2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以有更飒的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Jimmy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda匿名函数</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Jimmy"</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>RunnableThread类通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程的执行体，多线程的业务代码在run方法里面。Thread类实际上也是实现了Runnable接口的类，但其实现的run()方法体，是直接调用构造函数传递进来的target对象的run()方法。在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target)构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p><p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p><h2 id="通过继承Thread类本身的多线程"><a href="#通过继承Thread类本身的多线程" class="headerlink" title="通过继承Thread类本身的多线程"></a>通过继承Thread类本身的多线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  <span class="comment">// 需要重新Thread类中的run()方法</span></span><br><span class="line">        System.out.println(<span class="string">"ThreadTest2.run() method invoking....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest tt1 = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        ThreadTest tt2 = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        tt1.start();</span><br><span class="line">        tt2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过Callable和Future创建多线程"><a href="#通过Callable和Future创建多线程" class="headerlink" title="通过Callable和Future创建多线程"></a>通过Callable和Future创建多线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableImpl</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CallableImpl.call() invoking....."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CallableImpl call = <span class="keyword">new</span> CallableImpl();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(call);</span><br><span class="line">        <span class="keyword">new</span> Thread(ft, <span class="string">"Callable &amp; Future Thread 1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ft, <span class="string">"Callable &amp; Future Thread 2"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer o = ft.get(); <span class="comment">// 通过FutureTask对象获取到线程执行的返回值</span></span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// to do sth.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable接口很像是Runnable接口的增强版，Callable接口提供了一个call()方法可以作为线程的执行体，但call()方法比run()方法功能更强大。强大的地方体现在：</p><pre><code>call()方法可以有返回值call()方法可以抛出异常</code></pre><p>Callable接口是Java 5新增的接口，而且它不是Runnable接口的子接口，所以Callable对象不能直接作为Thread的target。Java 5提供了Future接口来代表Callable接口里call()方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口，并实现了Runnable接口，所以使用FutureTask实现类的对象作为Thread类的target。</p><h2 id="使用Executor框架中线程池来构建"><a href="#使用Executor框架中线程池来构建" class="headerlink" title="使用Executor框架中线程池来构建"></a>使用Executor框架中线程池来构建</h2><p>参见《JAVA Executor框架》（待写）</p><h1 id="Thread类中start-run-join-区别"><a href="#Thread类中start-run-join-区别" class="headerlink" title="Thread类中start()/run()/join()区别"></a>Thread类中start()/run()/join()区别</h1><p>start()开启线程，start()是将线程从“新建状态”转换到“就绪状态”，就可以等待CPU来调度执行了。</p><p>run()方法会将线程体的代码当成普通函数调用啦，并不会创建线程并CPU调度哦。</p><p>join()方法，阻塞当前线程，一直等待直到该线程死亡，可以指定等待指定时间内线程死亡，否则，一直在循环判断线程是否结束。也就是，在线程B中调用了线程A的join()方法，则直到线程A执行完毕后，才会继续执行线程B。</p><h1 id="多线程中的异常处理"><a href="#多线程中的异常处理" class="headerlink" title="多线程中的异常处理"></a>多线程中的异常处理</h1><p>（1）在run()方法内处理异常</p><p>我们知道Runnable和Thread的run()方法是不可以声明抛异常的，也就是线程中的代码抛出异常，就只能抛到run()方法，然后线程退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ThreadTest tt = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">    tt.start();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;  <span class="comment">// 此处是没有意义的，不会捕获到任何异常</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们可以在run()里面通过try-catch-finally块来处理异常。</p><p>（2）Thread API来处理异常</p><p>在Thread API中提供了UncaughtExceptionHandle，它能检测出某个由于未捕获的异常而线程终结的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加入一些释放连接等善后的业务的业务代码</span></span><br><span class="line">        logger.error(<span class="string">"UnCaughtException"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>该方法可以捕获到多线程中的一些未捕获的异常，然后进行一些善后的处理。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UNIX网络编程及各种I/O模型</title>
      <link href="/2019/03/03/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%90%84%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/03/03/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%90%84%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="UNIX网络编程概述"><a href="#UNIX网络编程概述" class="headerlink" title="UNIX网络编程概述"></a>UNIX网络编程概述</h1><p>在UNIX网络编程中，同时有大量的客户端连接到同一个服务器上时，服务端一般对每一个客户端请求fork出一个进程来响应处理，或者对每一个客户端创建出一个线程来响应处理。</p><h1 id="最基础的TCP网络编程"><a href="#最基础的TCP网络编程" class="headerlink" title="最基础的TCP网络编程"></a>最基础的TCP网络编程</h1><p><img src="/images/unix_io_1_1.png" alt></p><p>（1）socket函数</p><p>socket()函数用于在客户端或服务端创建一个socket对象，sockect函数的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;  <span class="comment">//若成功则返回非负整数，即为socket的文件描述符fd。若失败则返回-1</span></span><br></pre></td></tr></table></figure><p>（2）connect函数</p><p>客户端使用connect函数来建立与服务端的连接，connect函数的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr * servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;  <span class="comment">//若成功则返回0，若失败则返回-1</span></span><br></pre></td></tr></table></figure><p>（3）bind函数</p><p>服务端使用bind函数绑定到ip地址和端口。</p><p>（4）listen函数</p><p>listen函数将套接字的状态从CLOSED转换到LISTEN状态。</p><p>（5）accept函数</p><p>阻塞函数。服务端调用，用于获取与客户端的连接，该函数会导致进程或线程阻塞，直至有客户端连接进来。accept函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr * cliaddr, <span class="keyword">socklen_t</span> * addrlen)</span></span>;  <span class="comment">//若accept成功，则返回一个全新的文件描述符，代表着与客户端的网络连接</span></span><br></pre></td></tr></table></figure><p>（6）read函数</p><p>阻塞函数，直到read函数结束返回，才执行下一条代码。</p><p>（7）write函数</p><p>阻塞函数，直到write函数结束返回，才执行下一条代码。</p><h1 id="UNIX的I-O模型"><a href="#UNIX的I-O模型" class="headerlink" title="UNIX的I/O模型"></a>UNIX的I/O模型</h1><p>UNIX下有5种I/O模型。</p><h2 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h2><p>最流行的I/O模型是阻塞式I/O（blocking I/O）模型。</p><p><img src="/images/unix_io_1_2.png" alt></p><p>在上图中，进程调用recvfrom，该系统调用直到数据报文到达且被复制到应用进程的缓冲区中或者发生错误才返回，因此，应用进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的，recvfrom成功返回后，应用进程才开始处理数据报。</p><h2 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h2><p>下图是非阻塞式I/O（non blocking I/O）模型的示意图：</p><p><img src="/images/unix_io_1_3.png" alt></p><p>前三次调用recvfrom时没有数据可返回，因此内核立即返回一个EWOULDBLOCK错误，第四次调用recvfrom时已有一个数据报准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回，应用进程接着处理数据。</p><p>当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，我们称之为轮询polling。应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间。</p><h2 id="I-O复用（select-poll-epoll）"><a href="#I-O复用（select-poll-epoll）" class="headerlink" title="I/O复用（select/poll/epoll）"></a>I/O复用（select/poll/epoll）</h2><p>有了I/O复用（I/O multiplexing），我们就可以调用select和poll，那么应用进程会阻塞在select或poll系统调用上，而不是阻塞在真正的I/O系统调用上。如下图：</p><p><img src="/images/unix_io_1_4.png" alt></p><p>应用进程阻塞在select系统调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据报复制到应用进程的缓冲区。</p><h2 id="信号驱动式I-O（SIGIO）"><a href="#信号驱动式I-O（SIGIO）" class="headerlink" title="信号驱动式I/O（SIGIO）"></a>信号驱动式I/O（SIGIO）</h2><p>应用进程可以让内核在描述符就绪时发送SIGIO信号给应用进程，我们称这种模型为信号驱动式I/O模型，即signal-driven I/O模型。如下图：</p><p><img src="/images/unix_io_1_5.png" alt></p><p>应用进程首先开启套接字的信号驱动式I/O功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，我们的进程继续工作，也就是说应用进程并没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号，应用进程虽后就可以在信号处理函数中调用recvfrom读取数据报。</p><h2 id="异步I-O（POSIX的aio-系列函数）"><a href="#异步I-O（POSIX的aio-系列函数）" class="headerlink" title="异步I/O（POSIX的aio_*系列函数）"></a>异步I/O（POSIX的<code>aio_*</code>系列函数）</h2><p>异步I/O模型，asynchronous I/O。如下图：</p><p><img src="/images/unix_io_1_6.png" alt></p><p>首先应用进程告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到应用进程的缓冲区）完成后通知应用进程。与信号驱动式I/O不同的是，信号驱动式I/O是由内核通知应用进程何时可以启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。</p><p>应用进程调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。aio_read系统调用立即返回，而且在等待I/O完成期间，我们的应用进程不被阻塞。</p><h1 id="UNIX中五种I-O模型的异同"><a href="#UNIX中五种I-O模型的异同" class="headerlink" title="UNIX中五种I/O模型的异同"></a>UNIX中五种I/O模型的异同</h1><p><img src="/images/unix_io_1_7.png" alt></p><p>前四种模型都会导致应用进程阻塞，我们称他们为“同步IO模型”，因为他们的真正I/O操作recvfrom会阻塞应用进程。只有第五种模型才是“异步IO模型”，因为自始至终都没有因为I/O操作导致应用进程被阻塞。</p><h1 id="一点概念理解"><a href="#一点概念理解" class="headerlink" title="一点概念理解"></a>一点概念理解</h1><p>同步，异步，阻塞以及非阻塞等概念相对难理解。</p><p>所谓同步/异步是客户端和服务端之间交互的一种行为状态。同步就是在发出一个调用时，在没有得到结果之前，该调用就不返回，但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态信号来通知调用者，或通过回调函数处理这个调用。</p><p>所谓阻塞/非阻塞是客户端一种调用发出后的一种状态。阻塞调用是指调用结果返回之前，调用者会被挂起，调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p>以一个例子来说明，同步就是烧开水，要自己来看开没开；异步就是水开了，然后水壶响了通知你水开了。阻塞是烧开水的过程中，你不能干其他事情（即你被阻塞住了）；非阻塞是烧开水的过程里可以干其他事情。同步与异步说的是你获得水开了的方式不同。阻塞与非阻塞说的是你得到结果之前能不能干其他事情。两组概念描述的是不同的内容。</p><h1 id="网络编程的线程-进程模型"><a href="#网络编程的线程-进程模型" class="headerlink" title="网络编程的线程/进程模型"></a>网络编程的线程/进程模型</h1><h2 id="传统的线程-进程模型"><a href="#传统的线程-进程模型" class="headerlink" title="传统的线程/进程模型"></a>传统的线程/进程模型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统模型1：单线程模式，无法并发，如果当前的请求没有处理完，那么后面的请求只能被阻塞，服务器的吞吐量太低。</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    socket = accept();</span><br><span class="line">    handle(socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统模型2：多线程模式，connection per thread，每一个连接用一个线程处理。</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    socket = accept();</span><br><span class="line">    <span class="keyword">new</span> Thread(socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统模型3：线程池模式，减少了线程的反复创建和销毁，但本质上一个线程还是要完整的处理连接、读取、写入</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    socket = accept();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> Thread(socket));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p>基于I/O多路复用和线程池，就是所谓的”Reactor模型”的基本设计思想。</p><p>以Java的NIO库来说，Java nio的select函数，可以同时监听多个套接字socket。每个socket都会关联连接event、读取event、回写event。然后把一个线程拆分成更小的粒度：建立连接的handler、读取数据的handler、回写数据的hander。handler处理完event就丢给下一个handler处理，自己又可以去服务socket，提高了复用率，提高了系统的吞吐量。</p><p>Reactor模型由分为单Reactor单线程、单Reactor多线程和多Reactor多线程三种模型。</p><p>（1）单Reactor单线程</p><p><img src="/images/unix_io_1_8.png" alt></p><p>（2）单Reactor多线程</p><p><img src="/images/unix_io_1_9.png" alt></p><p>（3）多Reactor多线程</p><p><img src="/images/unix_io_1_10.png" alt></p><h2 id="Proactor模型"><a href="#Proactor模型" class="headerlink" title="Proactor模型"></a>Proactor模型</h2><p>基于异步IO模型。</p><p>学习资料参考于：<br>《UNIX网络编程卷1：套接字联网API》<br><a href="https://blog.csdn.net/wangjianno2/article/details/45609863" target="_blank" rel="noopener">https://blog.csdn.net/wangjianno2/article/details/45609863</a><br><a href="https://blog.csdn.net/wangjianno2/article/details/38157057" target="_blank" rel="noopener">https://blog.csdn.net/wangjianno2/article/details/38157057</a></p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数调用与栈帧空间</title>
      <link href="/2019/03/02/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%8E%E6%A0%88%E5%B8%A7%E7%A9%BA%E9%97%B4/"/>
      <url>/2019/03/02/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%8E%E6%A0%88%E5%B8%A7%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="源代码与可执行代码"><a href="#源代码与可执行代码" class="headerlink" title="源代码与可执行代码"></a>源代码与可执行代码</h1><p><img src="/images/os_frame_1_1.png" alt></p><p>首先我们的源代码会被编译链接成机器指令，存放在内存的“代码区”。然后在代码执行过程中，会在另外开辟内存空间来协助程序的执行。如在函数调用时会在“栈内存”中开辟空间来存放局部变量等；在new对象或malloc空间时，会在“堆空间”中开辟空间来存放数据。</p><h1 id="函数调用与栈帧"><a href="#函数调用与栈帧" class="headerlink" title="函数调用与栈帧"></a>函数调用与栈帧</h1><p>在程序语言中，假设“函数A”调用“函数B”，“函数B”调用“函数C”，“函数C”调用“函数D”，那么在程序的栈内存中结构如下：</p><p><img src="/images/os_frame_1_2.png" alt></p><p>每个函数的栈帧存放的内容大概是一样的，主要有：</p><pre><code>调用该函数的函数栈帧的栈底地址ebp各种局部变量下一个被调用函数的参数变量调完被调函数后的返回地址</code></pre><p>在函数调用过程中，有两个寄存器非常重要，即esp和ebp。寄存器ebp中存放的是当前执行函数栈帧的栈底地址，寄存器esp中存放的是当前执行函数栈帧的栈顶地址。</p><p>学习资料参考于：<br><a href="https://mp.weixin.qq.com/s/EoZyMgjEml_2rWu1dA85dA" target="_blank" rel="noopener">《码农翻身—CPU阿甘：函数调用的秘密》</a><br><a href="https://blog.csdn.net/wangjianno2/article/details/79783646" target="_blank" rel="noopener">《c函数调用过程原理及函数栈帧分析》</a></p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中with-as语句使用</title>
      <link href="/2019/02/26/Python%E4%B8%ADwith-as%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/26/Python%E4%B8%ADwith-as%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="with-as语句"><a href="#with-as语句" class="headerlink" title="with-as语句"></a>with-as语句</h1><p>从Python 2.6开始，with就成为默认关键字了。with是一个控制流语句，跟if/for/while/try等类似，with可以用来简化try-finally代码，看起来比try-finally更清晰，所以说with用很优雅的方式处理上下文环境产生的异常。with关键字的用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> expression <span class="keyword">as</span> variable:</span><br><span class="line">    <span class="keyword">with</span> block</span><br></pre></td></tr></table></figure><p>该代码块的执行过程是： </p><p>（1）先执行expression，然后执行该表达式返回的对象实例的<code>__enter__</code>函数，然后将该函数的返回值赋给as后面的变量。（注意，是将<code>__enter__</code>函数的返回值赋给变量）。</p><p>（2）然后执行with block代码块，不论成功，错误，异常，在with block执行结束后，会执行第一步中的实例的<code>__exit__</code>函数。</p><h1 id="with-as语句使用举例"><a href="#with-as语句使用举例" class="headerlink" title="with-as语句使用举例"></a>with-as语句使用举例</h1><p>（1）打开文件的例子</p><p>with-as语句最常见的一个用法是打开文件的操作，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"decorator.py"</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">print</span> file.readlines()</span><br></pre></td></tr></table></figure><p>（2）自定义</p><p>with语句后面的对象必须要有<code>__enter__</code>和<code>__exit__</code>方法，如下是一个自定义的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithTest</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"This is enter function"</span></span><br><span class="line">        <span class="keyword">return</span> self </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self,e_t,e_v,t_b)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Now, you are exit"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">playNow</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Now, I am playing"</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">print</span> <span class="string">"**********"</span></span><br><span class="line"><span class="keyword">with</span> WithTest(<span class="string">"coolboy"</span>) <span class="keyword">as</span> test:</span><br><span class="line">    <span class="keyword">print</span> type(test)</span><br><span class="line">    test.playNow() </span><br><span class="line">    <span class="keyword">print</span> test.name</span><br><span class="line"><span class="keyword">print</span> <span class="string">"**********"</span></span><br></pre></td></tr></table></figure><p>上述代码运行的结果如下：</p><pre><code>**********This is enter function&lt;type &apos;instance&apos;&gt;Now, I am playingcoolboyNow, you are exit**********</code></pre><p>分析以上代码：  一二行，执行open函数，该函数返回一个文件对象的实例，然后执行了该实例的<code>__enter__</code>函数，该函数返回此实例本身，最后赋值给file变量。从456句可以印证。</p><p>自定义的类WithTest，重载了<code>__enter__</code>和<code>__exit__</code>函数，就可以实现with这样的语法了，注意在<code>__enter__</code>函数中，返回了self，在<code>__exit__</code>函数中，可以通过<code>__exit__</code>的返回值来指示with-block部分发生的异常是否需要reraise，如果返回false，则会reraise with block异常，如果返回ture，则就像什么也没发生。</p><h1 id="上下文管理器contextlib模块对with-as的支持"><a href="#上下文管理器contextlib模块对with-as的支持" class="headerlink" title="上下文管理器contextlib模块对with-as的支持"></a>上下文管理器contextlib模块对with-as的支持</h1><p>contextlib模块提供了3个对象：装饰器contextmanager、函数nested上下文管理器closing。使用这些对象，可以对已有的生成器函数或者对象进行包装，加入对上下文管理协议的支持，避免了专门编写上下文管理器来支持with语句。</p><p>以contextlib的closing来说，closing帮助实现了<code>__enter__</code>和<code>__exit__</code>方法，用户不需要自己再实现这两个方法，但是被closing分装的对象必须提供close方法。contextlib.closing类的实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">closing</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># help doc here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, thing)</span>:</span></span><br><span class="line">        self.thing = thing</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.thing</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *exc_info)</span>:</span></span><br><span class="line">        self.thing.close()</span><br></pre></td></tr></table></figure><p>下面是一个使用contextlib.closing的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line">request_url = (<span class="string">'http://www.sina.com.cn/'</span>)</span><br><span class="line"><span class="keyword">with</span> contextlib.closing(urlopen(request_url)) <span class="keyword">as</span> response:</span><br><span class="line">    <span class="keyword">return</span> response.read().decode(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://www.choudan.net/2013/08/25/Python-With%E5%AD%A6%E4%B9%A0.html" target="_blank" rel="noopener">http://www.choudan.net/2013/08/25/Python-With%E5%AD%A6%E4%B9%A0.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中一些重要函数（map|reduce|filter|sorted|range等）使用</title>
      <link href="/2019/02/26/Python%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%EF%BC%88map-reduce-filter-sorted-range%E7%AD%89%EF%BC%89%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/26/Python%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%EF%BC%88map-reduce-filter-sorted-range%E7%AD%89%EF%BC%89%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h1><p>range函数可创建一个有一定规则的整数列表，函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range(start, end, scan):</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure><p>形参含义如下：</p><pre><code>start，表示计数从start开始，默认是从0开始，如range(5)等价于range(0, 5)end，表示计数到end结束，但不包括end，如range(0, 5)是[0, 1, 2, 3, 4]没有5scan，表示每次跳跃的间距，默认为1，如range(0, 5)等价于range(0, 5, 1)</code></pre><p>举例来说：</p><pre><code>&gt;&gt;&gt; range(5)[0, 1, 2, 3, 4]&gt;&gt;&gt; range(0, 5)[0, 1, 2, 3, 4]&gt;&gt;&gt; range(5)[0, 1, 2, 3, 4]&gt;&gt;&gt; range(0, 5, 2)[0, 2, 4]&gt;&gt;&gt; range(0, -5, -2)[0, -2, -4]&gt;&gt;&gt; range(-5)[]</code></pre><h1 id="enumerate函数"><a href="#enumerate函数" class="headerlink" title="enumerate函数"></a>enumerate函数</h1><p>enumerate函数用于将一个可遍历的数据对象（如列表、元组或字符串）组合为一个enumerate枚举对象，同时列出数据和数据下标，一般用在for循环当中。举例来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seasons = [<span class="string">'Spring'</span>, <span class="string">'Summer'</span>, <span class="string">'Fall'</span>, <span class="string">'Winter'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> enumerate(seasons)        <span class="comment">#输出&lt;enumerate object at 0x7f83e4c45550&gt;</span></span><br><span class="line"><span class="keyword">print</span> list(enumerate(seasons))  <span class="comment">#输出[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, season <span class="keyword">in</span> enumerate(seasons):</span><br><span class="line">    <span class="keyword">print</span> index, season</span><br></pre></td></tr></table></figure><h1 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h1><p><code>map(function, sequence)</code>对sequence中的item依次执行function(item)，执行结果组成一个List返回。举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cube</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> map(cube, range(<span class="number">1</span>, <span class="number">11</span>))  <span class="comment">#输出结果为[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]</span></span><br></pre></td></tr></table></figure><h1 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h1><p><code>reduce(function, sequence, starting_value)</code>对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> reduce(add, range(<span class="number">1</span>, <span class="number">11</span>))     <span class="comment">#输出结果为55 #1+2+3+4+5+6+7+8+9+10</span></span><br><span class="line"><span class="keyword">print</span> reduce(add, range(<span class="number">1</span>, <span class="number">11</span>), <span class="number">20</span>) <span class="comment">#输出结果为75 #1+2+3+4+5+6+7+8+9+10+20</span></span><br></pre></td></tr></table></figure><h1 id="filter函数"><a href="#filter函数" class="headerlink" title="filter函数"></a>filter函数</h1><p><code>filter(function, sequence)</code>对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple（取决于sequence的类型）返回。例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">and</span> x % <span class="number">3</span> != <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> filter(f, range(<span class="number">2</span>, <span class="number">25</span>)) <span class="comment">#输出结果为[5, 7, 11, 13, 17, 19, 23]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x != <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> filter(f, <span class="string">"abcdef"</span>)     <span class="comment">#输出结果为bcdef</span></span><br></pre></td></tr></table></figure><h1 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h1><p><code>sorted(iterable[, cmp[, key[, reverse]]])</code>用来对一个可迭代的对象中包含的元素进行排序，返回一个新的List。</p><p>其中iterable是必须参数，为一个可迭代的对象。可选的参数有三个，分别是cmp、key和reverse。</p><p>（1）cmp参数指定一个定制化的比较函数，这个函数接收两个参数（iterable的元素），如果第一个参数小于第二个参数，返回一个负数；如果第一个参数等于第二个参数，返回零；如果第一个参数大于第二个参数，返回一个正数。默认值为None。</p><p>（2）key参数指定一个获取cmp函数参数的函数，这个函数用于从每个元素中提取一个用于比较的关键字。默认值为None。</p><p>（3）reverse是一个布尔值。如果设置为True，列表元素将被倒序排列。</p><p>备注：key指定的关键字，用来作为cmp所指定的比较函数中被比较的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare_reverse</span><span class="params">(x, y)</span>:</span>   <span class="comment">#自定义的比较函数</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; y:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> x == y:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"> </span><br><span class="line">d_old = &#123;<span class="string">'x'</span>: <span class="number">31</span>,<span class="string">'y'</span>: <span class="number">5</span>, <span class="string">'zzx'</span>: <span class="number">3</span>, <span class="string">'a'</span>: <span class="number">4</span>, <span class="string">'b'</span>: <span class="number">74</span>, <span class="string">'cc'</span>: <span class="number">0</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#使用字典的value进行排序，默认为升序</span></span><br><span class="line"><span class="comment">#输出为[('cc', 0), ('zzx', 3), ('a', 4), ('y', 5), ('x', 31), ('b', 74)]</span></span><br><span class="line">d_new_1 = sorted(d_old.items(), key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用字典的key长度来进行排序，默认为升序</span></span><br><span class="line"><span class="comment">#输出为[('a', 4), ('b', 74), ('y', 5), ('x', 31), ('cc', 0), ('zzx', 3)]</span></span><br><span class="line">d_new_2 = sorted(d_old.items(), key=<span class="keyword">lambda</span> x: len(x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用字典的key长度来进行排序，同时自定义了比较函数，比较的对象还是key函数的返回值</span></span><br><span class="line"><span class="comment">#输出为[('zzx', 3), ('cc', 0), ('a', 4), ('b', 74), ('y', 5), ('x', 31)]</span></span><br><span class="line">d_new_3 = sorted(d_old.items(), cmp = compare_reverse, key = <span class="keyword">lambda</span> x: len(x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用字典的key长度来进行排序，同时通过reverse参数来标注是否需要翻转</span></span><br><span class="line"><span class="comment">#输出为[('zzx', 3), ('cc', 0), ('a', 4), ('b', 74), ('y', 5), ('x', 31)]</span></span><br><span class="line">d_new_4 = sorted(d_old.items(), key = <span class="keyword">lambda</span> x: len(x[<span class="number">0</span>]), reverse = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中DEBUG调试模块PDB使用</title>
      <link href="/2019/02/26/Python%E4%B8%ADDEBUG%E8%B0%83%E8%AF%95%E6%A8%A1%E5%9D%97PDB%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/26/Python%E4%B8%ADDEBUG%E8%B0%83%E8%AF%95%E6%A8%A1%E5%9D%97PDB%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pdb简介"><a href="#pdb简介" class="headerlink" title="pdb简介"></a>pdb简介</h1><p>pdb是Python自带的一个包，为Python程序提供了一种交互的源代码调试功能，主要特性包括设置断点、单步调试、进入函数调试、查看当前代码、查看栈片段、动态改变变量的值等。</p><p>pdb提供了一些常用的调试命令，见下表：</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>break 或 b 设置断点</td><td>设置断点</td></tr><tr><td>continue 或 c</td><td>继续执行程序</td></tr><tr><td>list 或 l</td><td>查看当前行的代码段</td></tr><tr><td>step 或 s</td><td>进入函数</td></tr><tr><td>return 或 r</td><td>执行代码直到从当前函数返回</td></tr><tr><td>exit 或 q</td><td>中止并退出</td></tr><tr><td>next 或 n</td><td>执行下一行</td></tr><tr><td>pp</td><td>打印变量的值</td></tr><tr><td>help</td><td>帮助</td></tr></tbody></table><h1 id="pdb使用方法"><a href="#pdb使用方法" class="headerlink" title="pdb使用方法"></a>pdb使用方法</h1><p>使用pdb DEBUG模式启动Python程序有两种方法：</p><p>（1）在Python程序中加入<code>pdb.set_trace()</code>代码，然后直接执行Python程序就可以进入Python的DEBUG模式。举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">a = <span class="string">"aaa"</span></span><br><span class="line">pdb.set_trace()</span><br><span class="line"></span><br><span class="line">b = <span class="string">"bbb"</span></span><br><span class="line">c = <span class="string">"ccc"</span></span><br><span class="line">final = a + b + c</span><br><span class="line"><span class="keyword">print</span> final</span><br></pre></td></tr></table></figure><p>（2）使用<code>python -m pdb *.py</code>的方式执行Python程序，也可以进入Python的DEBUG模式。</p><p>学习资料参考于：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程、线程与协程原理及联系</title>
      <link href="/2019/02/26/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86%E5%8F%8A%E8%81%94%E7%B3%BB/"/>
      <url>/2019/02/26/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86%E5%8F%8A%E8%81%94%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p><strong>进程是操作系统分配资源（CPU、内存等）的基本单位</strong>，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><strong>线程是CPU调度的基本单位</strong>，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行，即实现并发处理操作，每个请求分配一个线程来处理。</p><p>需要注意的是，线程可以通过操作系统的系统调用来创建，这就是内核线程，由操作系统来调用。当然我们也可以在用户态自己来创建线程，自己编写调度算法，这种情况下，操作系统是不知道这些线程的存在哦，操作系统只会看到进程，而看不到进程里面用户自己创建的线程。</p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p><strong>协程是一种用户态的轻量级线程</strong>，又称微线程，英文名Coroutine，协程的调度完全由应用程序自己来控制，不需要操作系统的介入，操作系统也压根不知道协程的存在。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><h1 id="进程是拥有资源的基本单位，-线程是CPU调度的基本单位"><a href="#进程是拥有资源的基本单位，-线程是CPU调度的基本单位" class="headerlink" title="进程是拥有资源的基本单位， 线程是CPU调度的基本单位"></a>进程是拥有资源的基本单位， 线程是CPU调度的基本单位</h1><p>举个例子，有两个进程，一个是Word，一个是QQ音乐。Word进程打开了文件，这是它的资源，QQ音乐打开了Socket，这也是它的资源。假设Word有两个线程，T1负责接受用户的文字输入，T2负责自动保存。QQ音乐也有两个线程，T3负责从Socket中读取数据，T4负责对音乐数据进行解码。操作系统在做调度的时候，基本单位不是Word，QQ音乐这样的进程，而是T1，T2，T3以及T4这些线程。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。线程池是一种池化技术，其中最核心的思想就是把宝贵的资源放到一个池子中，每次使用都从池子中获取，用完之后又放回池子供其他人使用。简单来说使用线程池有以下几个目的：</p><p>（1）线程是稀缺资源，不能频繁的创建</p><p>（2）解耦作用，线程的创建与执行完全分开，方便维护</p><p>（3）线程池是众多线程的池子，可以给其他任务进行复用</p><h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><p>（1）运行中的程序至少有一个进程，每个进程至少有一个线程（主线程）。</p><p>（2）进程和线程是操作系统支持的；而协程是用户态下模拟多线程的并发执行，是由开发者来负责协程的调度。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中常用module用法总结</title>
      <link href="/2019/02/25/Python%E4%B8%AD%E5%B8%B8%E7%94%A8module%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/02/25/Python%E4%B8%AD%E5%B8%B8%E7%94%A8module%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h1><p><code>sys.argv</code>用来获取执行Python脚本时，脚本的名称以及脚本参数，它是一个列表。<code>sys.argv[0]</code>即表示的是脚本的名称。</p><p><code>sys.exit(arg)</code>表示退出当前的程序，arg可以指定一个返回码，或者是一个错误信息。</p><h1 id="sys-path"><a href="#sys-path" class="headerlink" title="sys.path"></a>sys.path</h1><p>sys.path模块用来动态地改变Python搜索路径。如果Python中导入的package或module不在环境变量PATH中，那么可以使用sys.path将要导入的package或module加入到PATH环境变量中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'引用模块的地址'</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">'引用模块的地址'</span>)</span><br></pre></td></tr></table></figure><p>sys.path是个列表，所以在末尾添加目录是很容易的，用sys.path.append就行了。当这个append执行完之后，新目录即时起效，以后的每次import操作都可能会检查这个目录。如同解决方案所示，可以选择用sys.path.insert(0, …)这样新添加的目录会优先于sys.path中的其他目录被import检查。</p><p>即使sys.path中存在重复，或者一个不存在的目录被不小心添加进来，也没什么大不了，Python的import语句非常聪明，它会自己应付这类问题。但是，如果每次import时都发生这种错误（比如，重复的不成功搜索，操作系统提示的需要进一步处理的错误），我们会被迫付出一点小小的性能代价。</p><p>程序向sys.path添加的目录只会在此程序的生命周期之内有效，其他所有的对sys.path的动态操作也是如此。</p><h1 id="os"><a href="#os" class="headerlink" title="os"></a>os</h1><p><code>os.getcwd()</code>用来获取当前的工作目录，返回的是执行命令时所在的目录，而不是脚本本身所在的目录。</p><h1 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">os.path.abspath(path)  <span class="comment">#返回绝对路径</span></span><br><span class="line">os.path.split(path     <span class="comment">#将path分割成目录和文件名二元组返回</span></span><br><span class="line">os.path.dirname(path)  <span class="comment">#返回path的目录。其实就是os.path.split(path)的第一个元素</span></span><br><span class="line">os.path.basename(path) <span class="comment">#返回path最后的文件名</span></span><br><span class="line">os.path.exists(path)   <span class="comment">#如果path存在，返回True；如果path不存在，返回False</span></span><br><span class="line">os.path.isabs(path)    <span class="comment">#如果path是绝对路径，返回True</span></span><br><span class="line">os.path.isfile(path)   <span class="comment">#如果path是一个存在的文件，返回True。否则返回False</span></span><br><span class="line">os.path.isdir(path)    <span class="comment">#如果path是一个存在的目录，则返回True。否则返回False</span></span><br><span class="line">os.path.getatime(path) <span class="comment">#返回path所指向的文件或者目录的最后存取时间</span></span><br><span class="line">os.path.getmtime(path) <span class="comment">#返回path所指向的文件或者目录的最后修改时间 </span></span><br><span class="line">s.path.join(path1[, path2[, ...]])  <span class="comment">#将多个路径组合后返回，第一个绝对路径之前的参数将被忽略。</span></span><br></pre></td></tr></table></figure><p>举例来说，</p><pre><code>&gt;&gt;&gt; os.path.join(&apos;c:\\&apos;, &apos;csv&apos;, &apos;test.csv&apos;)&apos;c:\\csv\\test.csv&apos;&gt;&gt;&gt; os.path.join(&apos;windows\temp&apos;, &apos;c:\\&apos;, &apos;csv&apos;, &apos;test.csv&apos;)&apos;c:\\csv\\test.csv&apos;&gt;&gt;&gt; os.path.join(&apos;/home/aa&apos;,&apos;/home/aa/bb&apos;,&apos;/home/aa/bb/c&apos;)&apos;/home/aa/bb/c&apos;</code></pre><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><p>re模块是正则表达式处理的模块。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中命令行参数解析sys.argv|optparse模块</title>
      <link href="/2019/02/25/Python%E4%B8%AD%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90sys-argv-optparse%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/02/25/Python%E4%B8%AD%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90sys-argv-optparse%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a>sys.argv</h1><p>在Python脚本中使用sys.argv可以获取到一个列表，其中</p><pre><code>sys.argv[0]是脚本的名称sys.argv[n]是执行脚本时，命令行传入的第n个参数</code></pre><p>代码举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> sys.argv[:]</span><br><span class="line">    <span class="keyword">print</span> sys.argv[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">print</span> sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> sys.argv[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h1 id="optparse模块"><a href="#optparse模块" class="headerlink" title="optparse模块"></a>optparse模块</h1><p>使用范例代码如下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> optparse <span class="keyword">import</span> OptionParser</span><br><span class="line"></span><br><span class="line">usage = <span class="string">"usage: %prog [options] arg1 arg2"</span>  </span><br><span class="line"></span><br><span class="line">parser = OptionParser(usage=usage)    <span class="comment">#创建OptionParser对象</span></span><br><span class="line"></span><br><span class="line">parser.add_option(<span class="string">"-v"</span>, <span class="string">"--verbose"</span>,  <span class="comment">#add_option增加选项</span></span><br><span class="line">                  action=<span class="string">"store_true"</span>, dest=<span class="string">"verbose"</span>, default=<span class="literal">True</span>,</span><br><span class="line">                  help=<span class="string">"make lots of noise [default]"</span>)</span><br><span class="line">parser.add_option(<span class="string">"-q"</span>, <span class="string">"--quiet"</span>, action=<span class="string">"store_false"</span>,</span><br><span class="line">                  help=<span class="string">"be vewwy quiet (I'm hunting wabbits)"</span>)</span><br><span class="line">parser.add_option(<span class="string">"-f"</span>, <span class="string">"--filename"</span>, dest=<span class="string">"filename"</span>,</span><br><span class="line">                  action=<span class="string">"store"</span>, help=<span class="string">"write output to FILE"</span>)</span><br><span class="line">parser.add_option(<span class="string">"-m"</span>, <span class="string">"--mode"</span>, dest=<span class="string">"mode"</span>,</span><br><span class="line">                  action=<span class="string">"store"</span>, help=<span class="string">"interaction mode"</span>)</span><br><span class="line"></span><br><span class="line">(options, args) = parser.parse_args()  <span class="comment">#解析选项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> options.filename   <span class="comment">#获取命令行中filename参数</span></span><br><span class="line"><span class="keyword">print</span> options.mode       <span class="comment">#获取命令行中mode参数</span></span><br></pre></td></tr></table></figure><p>其中options中选项存储了选项参数，args存储其他的位置参数</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python日常开发编码规范</title>
      <link href="/2019/02/25/Python%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2019/02/25/Python%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><p>（1）应该避免的名称</p><ul><li>单字符名称, 除了计数器和迭代器</li><li>包/模块名中的连字符（<code>-</code>）</li><li>双下划线开头并结尾的名称（Python保留，例如<code>__init__</code>）</li></ul><p>（2）命名约定</p><ul><li>所谓“内部（Internal）”表示仅模块内可用，或者在类内是保护或私有的</li><li>用单下划线（<code>_</code>）开头表示模块变量或函数是protected的（使用<code>import * from</code>时不会包含）</li><li>用双下划线（<code>__</code>）开头的实例变量或方法表示类内私有</li><li>将相关的类和顶级函数放在同一个模块里。不像Java，没必要限制一个类一个模块</li><li>对类名使用大写字母开头的单词（如CapWords, 即Pascal风格），但是模块名应该用小写加下划线的方式（如lower_with_under.py）。尽管已经有很多现存的模块使用类似于CapWords.py这样的命名，但现在已经不鼓励这样做，因为如果模块名碰巧和类名一致，这会让人困扰</li></ul><p>（3）Python之父Guido推荐的规范</p><p><img src="/images/python_spec_1_1.png" alt></p><h1 id="其他规范"><a href="#其他规范" class="headerlink" title="其他规范"></a>其他规范</h1><p>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python开发者打包发布工具Distutils|setuptools</title>
      <link href="/2019/02/24/Python%E5%BC%80%E5%8F%91%E8%80%85%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%E5%B7%A5%E5%85%B7Distutils-setuptools/"/>
      <url>/2019/02/24/Python%E5%BC%80%E5%8F%91%E8%80%85%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%E5%B7%A5%E5%85%B7Distutils-setuptools/</url>
      
        <content type="html"><![CDATA[<h1 id="Distutils"><a href="#Distutils" class="headerlink" title="Distutils"></a>Distutils</h1><p>Distutils是Python标准库的一部分，其初衷是为开发者提供一种方便的打包方式， 同时为使用者提供方便的安装方式。</p><p>例如你创建了一个名为foo的包，包含一个foo.py文件，你想把它打包以便其它人使用。 这时候你需要写一个setup.py文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line">setup(name=<span class="string">'foo'</span>,</span><br><span class="line">      version=<span class="string">'1.0'</span>,</span><br><span class="line">      py_modules=[<span class="string">'foo'</span>],</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>然后运行命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py sdist</span><br></pre></td></tr></table></figure><p>然后你发现当前目录下出现一个名为dist的文件夹，里面有一个foo-1.0.tar.gz的包。 这个包里有三个文件，foo.py, setup.py, PKG-INFO，前两个文件和我们之前提到的两个文件一样。 PKG-INFO是关于包的一些信息。然后你就可以把foo-1.0.tar.gz给别人安装了。</p><p>安装者要使用这个包时，只需要解压这个foo-1.0.tar.gz文件，再运行命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>这个包就会被自动安装到系统合适的位置。</p><p>其他的一些用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1 build</span></span><br><span class="line">python setup.py build</span><br><span class="line"><span class="comment">#2 安装</span></span><br><span class="line">python setup.py install</span><br><span class="line"><span class="comment">#3 将程序文件打包</span></span><br><span class="line">python setup.py sdist</span><br><span class="line"><span class="comment">#4 创建windows安装程序</span></span><br><span class="line">python setup.py bdist --formats=wininst</span><br></pre></td></tr></table></figure><p>将软件发布到PyPI上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 在http://pypi.python.org/pypi上注册一个账号</span></span><br><span class="line"><span class="comment">#2. 模块注册</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/my_modulue &amp;&amp; python setup.py register</span><br><span class="line"><span class="comment">#3. 上传模块</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/my_modulue &amp;&amp; python setup.py sdist upload</span><br></pre></td></tr></table></figure><h1 id="setuptools"><a href="#setuptools" class="headerlink" title="setuptools"></a>setuptools</h1><p>setuptools是对distutils的增强, 尤其是引入了包依赖管理。</p><p>setuptools可以为Python包创建egg文件，Python与egg文件的关系，相当于java与jar包的关系。</p><p>setuptools提供的easy_install脚本可以用来安装egg包。 另外，easy_install可以自动从PyPI上下载相关的包，并完成安装，升级。</p><p>easy_install提供了多种安装，升级Python包的方式，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">easy_install SQLObject</span><br><span class="line">easy_install -f http://pythonpaste.org/package_index.html SQLObject</span><br><span class="line">easy_install http://example.com/path/to/MyPackage-1.2.3.tgz</span><br><span class="line">easy_install /my_downloads/OtherPackage-3.2.1-py2.3.egg</span><br><span class="line">easy_install --upgrade PyProtocols</span><br></pre></td></tr></table></figure><p>后来开发者们觉得setuptools开发的太慢了，fork出了Distribute项目，然后2013年8月，Distribute又合并回setuptools 0.7。</p><h1 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h1><p>pip是安装，管理Python包的工具。它是对easy_install的一种增强。 同样可以从PyPI上自动下载，安装包。</p><p>在pip中，</p><p>（1）安装前所有需要的包都要先下载，所以不会出现安装了一部分，另一部分没安装的情况</p><p>（2）所有安装的包会被跟踪，所以你可以知道为什么他们被安装，同时可以卸载</p><p>（3）无需使用egg文件。但是pip有Wheel(<code>*.whl</code>)格式的包，<code>*.whl</code>文件有一点与<code>*.egg</code>文件相似，实际上它们都是“伪装”的<code>*.zip</code>文件。如果将<code>*.whl</code>和<code>*.egg</code>文件的扩展名修改为<code>*.zip</code>，你就可以使用zip应用程序打开它，并且可以查看它包含的文件和文件夹</p><p>使用方式简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pip install package_name     <span class="comment">#安装python包</span></span><br><span class="line">pip uninstall package_name   <span class="comment">#卸载python包</span></span><br><span class="line">pip search package_name      <span class="comment">#搜索python包</span></span><br><span class="line">pip download package_name        <span class="comment">#下载python包，并下载package_name依赖的python包</span></span><br><span class="line">pip freeze &gt; requirements.txt    <span class="comment">#将当前系统中所有通过pip安装的python包的名称及版本信息，到处到requirements.txt文件中</span></span><br><span class="line">pip install -r requirements.txt  <span class="comment">#pip根据文件requirements.txt列出的python包及版本，来安装python包</span></span><br><span class="line">pip list                         <span class="comment">#查看系统中安装的python包列表</span></span><br><span class="line">pip install -U pip               <span class="comment">#升级pip自身</span></span><br><span class="line">pip --proxy=http://10.16.20.12:3128 search django  <span class="comment">#为pip设置代理</span></span><br><span class="line">pip install package_name[extra]  <span class="comment">#安装名称为package_name的包，且带上extra相关的功能扩展，如pip install splinter[django]表示安装splinter包，并带上django相关的功能扩展，注意并不是安装了splinter和django两个包哦</span></span><br></pre></td></tr></table></figure><p>另外，可以使用-i选项从指定的PyPI源中下载并安装Python模块。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>（1）Distutils、setuptools以及Distribute都是Python中打包安装的模块，使用它们需要编写setup.py文件，通过<code>python setup.py ***</code>来完成打包、安装以及上传pypi等功能。easy_install以及pip都是一个脚本而已，他们可以从PyPI仓库中下载安装Python模块，它们与原始的<code>python setup.py install</code>相比，pip和easy_install将所有依赖的模块也一起安装了。</p><p>（2）一般我们在Python项目中，需要引入第三方模块，有两种方式（以yaml模块为例）：一种是使用<code>python setup.py install</code>或者<code>easy_install yaml</code>或者<code>pip install yaml</code>将yaml模块安装到Python缺省的第三方库安装路径lib/site-packages目录中。另一种是使用<code>python setup.py build</code>生成模块的构建文件，然后将build目录下生成的模块目录拷贝到项目目录中，这样将项目部署其他机器上时，就不用再去安装环境了。</p><p>参考学习资料：<br><a href="http://blog.yangyubo.com/2012/07/27/python-packaging/" target="_blank" rel="noopener">http://blog.yangyubo.com/2012/07/27/python-packaging/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中logging包使用</title>
      <link href="/2019/02/24/Python%E4%B8%ADlogging%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/24/Python%E4%B8%ADlogging%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="logging-简介"><a href="#logging-简介" class="headerlink" title="logging 简介"></a>logging 简介</h1><p>Python的logging package提供了通用的日志系统，可以方便第三方模块或应用使用。这个模块提供不同的日志级别，并可以采用不同的方式记录日志，比如文件，HTTP GET/POST，SMTP，Socket等，甚至可以自己实现具体的日志记录方式。</p><p>logging包中定义了Logger、Formatter、Handler和Filter等重要的类，除此之外还有config模块。</p><p>Logger是日志对象，直接提供日志记录操作的接口。</p><p>Formatter定义日志的记录格式及内容。</p><p>Handler定义日志写入的目的地，你可以把日志保存成本地文件，也可以每个小时写一个日志文件，还可以把日志通过socket传到别的机器上。Python提供了十几种实用handler，比较常用的有StreamHandler，BaseRotatingHandler，SocketHandler，DatagramHandler及SMTPHandler等。我们可以通过Logger对象的addHandler()方法，将log输出到多个目的地。</p><h1 id="logging包使用"><a href="#logging包使用" class="headerlink" title="logging包使用"></a>logging包使用</h1><p>在Python编程中，引入了logging package，那么可以存在一个名称为root的logging对象，以及很多其他名称的logging对象。不同的Logger对象的Handler，Formatter等是分开设置的。</p><p>（1）logging.getLogger()</p><p>如果getLogger()中不带参数，那么返回的是名称为root的Logger对象，如果带参数，那么就以该参数为名称的Logger对象。同名称的Logger对象是一样的。</p><p>（2）logging.basicConfig()</p><p>此方法是为名称为root的Logger对象进行配置。</p><p>（3）logging.info()/logging.debug()等</p><p>使用的root Logger对象进行信息输出。如果是用其他的Logging对象进行log输出，可以使用Logging.getLogger(name).info()来实现。</p><p>（4）日志的等级</p><pre><code>CRITICAL = 50ERROR = 40WARNING = 30INFO = 20DEBUG = 10NOTSET = 0</code></pre><p>在Python中有0，10，20，30，40，50这6个等级数值，这6个等级数值分别对应了一个字符串常量，作为等级名称，如上。但是可以通过<code>logging.addLevelName(20, &quot;NOTICE:&quot;)</code>这个方法来改变这个映射关系，来定制化日志等级名称。</p><p>通过Logger对象的setLevel()方法，可以配置Logging对象的默认日志等级，只有当一条日志的等级大于等于这个默认的等级，才会输出到log文件中。</p><p>当使用logging.info(msg)输出log时，内部封装会用数字20作为日志等级数值，默认情况下20对应的是INFO，但如果通过addLevelName()修改了20对应的等级名称，那么log中打印的就将是个性化的等级名称。</p><h1 id="logging包使用配置文件"><a href="#logging包使用配置文件" class="headerlink" title="logging包使用配置文件"></a>logging包使用配置文件</h1><p>在前面描述中，对一个Logger对象的Handler，Formatter等都是在程序中定义或绑定的。而实际上Logging的个性化的配置可以放到配置文件中。</p><p>logging的配置文件举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[loggers]</span><br><span class="line">keys=root,simpleExample</span><br><span class="line"></span><br><span class="line">[handlers]</span><br><span class="line">keys=consoleHandler</span><br><span class="line"></span><br><span class="line">[formatters]</span><br><span class="line">keys=simpleFormatter</span><br><span class="line"></span><br><span class="line">[logger_root]</span><br><span class="line">level=DEBUG</span><br><span class="line">handlers=consoleHandler</span><br><span class="line"></span><br><span class="line">[logger_simpleExample]</span><br><span class="line">level=DEBUG</span><br><span class="line">handlers=consoleHandler</span><br><span class="line">qualname=simpleExample</span><br><span class="line">propagate=0</span><br><span class="line"></span><br><span class="line">[handler_consoleHandler]</span><br><span class="line">class=StreamHandler</span><br><span class="line">level=DEBUG</span><br><span class="line">formatter=simpleFormatter</span><br><span class="line">args=(sys.stdout,)</span><br><span class="line"></span><br><span class="line">[formatter_simpleFormatter]</span><br><span class="line">format=%(asctime)s - %(name)s - %(levelname)s - %(message)s</span><br><span class="line">datefmt=</span><br></pre></td></tr></table></figure><p>对应程序为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line"><span class="keyword">import</span> logging.config  </span><br><span class="line">  </span><br><span class="line">logging.config.fileConfig(<span class="string">"logging.conf"</span>)   <span class="comment">#采用配置文件   </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># create logger   </span></span><br><span class="line">logger = logging.getLogger(<span class="string">"simpleExample"</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># "application" code   </span></span><br><span class="line">logger.debug(<span class="string">"debug message"</span>)  </span><br><span class="line">logger.info(<span class="string">"info message"</span>)  </span><br><span class="line">logger.warn(<span class="string">"warn message"</span>)  </span><br><span class="line">logger.error(<span class="string">"error message"</span>)  </span><br><span class="line">logger.critical(<span class="string">"critical message"</span>)</span><br></pre></td></tr></table></figure><h1 id="一个常用的Logging封装工具"><a href="#一个常用的Logging封装工具" class="headerlink" title="一个常用的Logging封装工具"></a>一个常用的Logging封装工具</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    封装好的Logger工具</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, logPath)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initial</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        log_path = logPath</span><br><span class="line">        logging.addLevelName(<span class="number">20</span>, <span class="string">"NOTICE:"</span>)</span><br><span class="line">        logging.addLevelName(<span class="number">30</span>, <span class="string">"WARNING:"</span>)</span><br><span class="line">        logging.addLevelName(<span class="number">40</span>, <span class="string">"FATAL:"</span>)</span><br><span class="line">        logging.addLevelName(<span class="number">50</span>, <span class="string">"FATAL:"</span>)</span><br><span class="line">        logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                format=<span class="string">"%(levelname)s %(asctime)s [pid:%(process)s] %(filename)s %(message)s"</span>,</span><br><span class="line">                datefmt=<span class="string">"%Y-%m-%d %H:%M:%S"</span>,</span><br><span class="line">                filename=log_path,</span><br><span class="line">                filemode=<span class="string">"a"</span>)</span><br><span class="line">        console = logging.StreamHandler()</span><br><span class="line">        console.setLevel(logging.DEBUG)</span><br><span class="line">        formatter = logging.Formatter(<span class="string">"%(levelname)s [pid:%(process)s] %(message)s"</span>)</span><br><span class="line">        console.setFormatter(formatter)</span><br><span class="line">        logging.getLogger(<span class="string">""</span>).addHandler(console)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(self, msg=<span class="string">""</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        output DEBUG level LOG</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        logging.debug(str(msg))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self, msg=<span class="string">""</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        output INFO level LOG</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        logging.info(str(msg))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warning</span><span class="params">(self, msg=<span class="string">""</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        output WARN level LOG</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        logging.warning(str(msg))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exception</span><span class="params">(self, msg=<span class="string">""</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        output Exception stack LOG</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        logging.exception(str(msg))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self, msg=<span class="string">""</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        output ERROR level LOG</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        logging.error(str(msg))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">critical</span><span class="params">(self, msg=<span class="string">""</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        output FATAL level LOG</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        logging.critical(str(msg))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    testlog = Logger(<span class="string">"oupput.log"</span>)</span><br><span class="line">    testlog.info(<span class="string">"info...."</span>)</span><br><span class="line">    testlog.warning(<span class="string">"warning...."</span>)</span><br><span class="line">    testlog.critical(<span class="string">"critical...."</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        lists = []</span><br><span class="line">        <span class="keyword">print</span> lists[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="string">"""logging.exception()输出格式：</span></span><br><span class="line"><span class="string">        FATAL: [pid:7776] execute task failed. the exception as follows:</span></span><br><span class="line"><span class="string">        Traceback (most recent call last):</span></span><br><span class="line"><span class="string">            File "logtool.py", line 86, in &lt;module&gt;</span></span><br><span class="line"><span class="string">                print lists[1]</span></span><br><span class="line"><span class="string">        IndexError: list index out of range</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        testlog.exception(<span class="string">"execute task failed. the exception as follows:"</span>)</span><br><span class="line">        testlog.info(<span class="string">"++++++++++++++++++++++++++++++++++++++++++++++"</span>)</span><br><span class="line">        <span class="string">"""logging.error()输出格式：</span></span><br><span class="line"><span class="string">        FATAL: [pid:7776] execute task failed. the exception as follows:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        testlog.error(<span class="string">"execute task failed. the exception as follows:"</span>)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>备注：exception()方法能够完整地打印异常的堆栈信息。error()方法只会打印参数传入的信息。按照官方文档的介绍，logging是线程安全的，也就是说，在一个进程内的多个线程同时往同一个文件写日志是安全的。但是多个进程往同一个文件写日志是不安全的。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python自省机制及dir|hasattr|getattr|setattr使用</title>
      <link href="/2019/02/24/Python%E8%87%AA%E7%9C%81%E6%9C%BA%E5%88%B6%E5%8F%8Adir-hasattr-getattr-setattr%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/24/Python%E8%87%AA%E7%9C%81%E6%9C%BA%E5%88%B6%E5%8F%8Adir-hasattr-getattr-setattr%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Python的自省机制"><a href="#Python的自省机制" class="headerlink" title="Python的自省机制"></a>Python的自省机制</h1><p>在计算机编程中，自省是指这种能力，检查某些事物以确定它是什么、它知道什么以及它能做什么。整个Python语言对自省提供了深入而广泛的支持。实际上，很难想象假如Python语言没有其自省特性是什么样子。像dir()、hasattr()、getattr()、setattr()都属于Python自省机制中的核心函数。</p><h1 id="dir-hasattr-getattr-setattr-的使用"><a href="#dir-hasattr-getattr-setattr-的使用" class="headerlink" title="dir()|hasattr()|getattr()|setattr()的使用"></a>dir()|hasattr()|getattr()|setattr()的使用</h1><p>（1）<code>dir([obj])</code></p><p>dir()函数是一个Python内置函数，可能是Python自省机制中最著名的部分了。它返回传递给它的任何对象的经过排序的属性名称列表（会有一些特殊的属性不包含在内）。如果不指定对象，则dir()返回当前作用域中的名称（obj的默认值是当前的模块对象）。</p><p>举例来说：</p><p><img src="/images/python_self_1_1.png" alt></p><p>（2）<code>hasattr(obj, attr)</code></p><p>这个方法用于检查obj是否有一个名称为attr的属性，返回一个布尔值。</p><p>（3）<code>getattr(obj, attr)</code></p><p>getattr是一个Python内置函数，也是自省机制里面的核心函数，可以返回一个对象的所有属性。调用这个方法将返回obj中名称为attr的属性值，例如如果attr为“bar”，则返回obj.bar。getattr的返回值是方法属性，则可以直接调用这个函数。举例如下：</p><p><img src="/images/python_self_1_2.png" alt></p><p>（4）<code>setattr(obj, attr, val)</code></p><p>调用这个方法将给obj的名称为attr的属性赋值为val。例如如果attr为“bar”，则相当于<code>obj.bar = val</code>。</p><p>参考学习资料来源于：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-pyint/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-pyint/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中单元测试框架doctest|unittest</title>
      <link href="/2019/02/24/Python%E4%B8%AD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6doctest-unittest/"/>
      <url>/2019/02/24/Python%E4%B8%AD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6doctest-unittest/</url>
      
        <content type="html"><![CDATA[<h1 id="doctest模块"><a href="#doctest模块" class="headerlink" title="doctest模块"></a>doctest模块</h1><p>通过在文件字符串中加入一些程序执行的例子，那么在执行Python脚本时，doctest测试框架会自动地去验证这些例子，如果有例子不通过，那么就会提示测试失败。具体使用例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#my_math.py文件</span></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">''' </span></span><br><span class="line"><span class="string">    square function</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; my_square(2)</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; my_square(4)</span></span><br><span class="line"><span class="string">    15</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test.py文件</span></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest, my_math</span><br><span class="line">    doctest.testmod(my_math)</span><br></pre></td></tr></table></figure><p>如果文档字符串中的例子通过，那么doctest测试通过。如果验证到文档字符串中有例子不通过，那么doctest测试框架会明显的提示失败的原因和位置。</p><h1 id="unittest模块"><a href="#unittest模块" class="headerlink" title="unittest模块"></a>unittest模块</h1><p>unitest是基于Java的测试框架Junit，它比doctest测试框架更灵活和强大。还以测试my_math模块中的my_square为例，看看使用unittest如何测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest, my_math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMathTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testSquare</span><span class="params">(self)</span>:</span></span><br><span class="line">        ret = my_math.my_square(<span class="number">2</span>)</span><br><span class="line">        self.failUnless(ret == <span class="number">4</span>, <span class="string">"test failed."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>备注：首先定义一个unittest.TestCase子类，其中定义一些以test开头的方法，方法名最好和要测试的方法名一样，比如<code>testSqrt()</code>，表示测试的是sqrt方法。</p><p>在上面的例子，执行<code>unittest.main()</code>方法时，unittest框架会实例化所有unittest.TestCase的子类，并且运行所有以test开头命名的方法。例子中使用的断言语句是failUnless，其实unittest框架中有很多的断言函数。</p><p>在测试类MyMathTestCase中，可以覆写父类中的<code>setUp()</code>和<code>tearDown()</code>函数，<code>setUp()</code>用于在测试用例执行前的初始化工作，与之相应的<code>tearDown()</code>用于测试用例执行后的善后工作。</p><h1 id="Python源代码检查工具"><a href="#Python源代码检查工具" class="headerlink" title="Python源代码检查工具"></a>Python源代码检查工具</h1><p>PyChecker和PyLint是两个可以检查Python源代码的工具。它们都需要单独的安装。且有两种方式来使用它们，一种是将它们作为命令行工具来使用；一种是将它们嵌入到代码中进行检查。</p><h1 id="Python程序性能检测工具"><a href="#Python程序性能检测工具" class="headerlink" title="Python程序性能检测工具"></a>Python程序性能检测工具</h1><p>Python标准库中有一个叫做profile的分析模块，可以在检查Python程序的执行性能。</p><p>备注：单元测试是让程序可以工作，源代码检查可以让程序更好，最后，分析工具可以让程序更快。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中文件对象操作</title>
      <link href="/2019/02/24/Python%E4%B8%AD%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/02/24/Python%E4%B8%AD%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中文件对象操作"><a href="#Python中文件对象操作" class="headerlink" title="Python中文件对象操作"></a>Python中文件对象操作</h1><p>Python中的文件对象提供了三种读取方法，即read/readline/readlines。</p><h1 id="直接迭代"><a href="#直接迭代" class="headerlink" title="直接迭代"></a>直接迭代</h1><p>因文件对象是一个实现了<code>__iter__()</code>和<code>next()</code>方法的迭代器，因此我们可以直接使用for循环来遍历文件内容，一次只读取文件内容的一行，并非将整个文件一次性加载到内存当中，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_obj = open(<span class="string">'./data.txt'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file_obj:</span><br><span class="line">    <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure><h1 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h1><p>read()方法不带参数时，一次将整个文件读取到内存中，返回值是字符串。当read()方法带参数时，一次只会读取参数指定的字节数。举例来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#read不带参数，表示一下读取文件中所有内容，返回字符串</span></span><br><span class="line">file_obj = open(<span class="string">'data1.txt'</span>)</span><br><span class="line">out = f.read()</span><br><span class="line"><span class="keyword">print</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment">#read(n)带参数，表示一次读取n个字符</span></span><br><span class="line">file_obj = open(<span class="string">'data2.txt'</span>)</span><br><span class="line">out_1 = file_obj.read(<span class="number">3</span>)  <span class="comment">#读取前3个字符</span></span><br><span class="line">out_2 = file_obj.read(<span class="number">2</span>)  <span class="comment">#读取紧接着的2个字符</span></span><br><span class="line"><span class="keyword">print</span> out_1</span><br><span class="line"><span class="keyword">print</span> out_2</span><br></pre></td></tr></table></figure><h1 id="readline函数"><a href="#readline函数" class="headerlink" title="readline函数"></a>readline函数</h1><p>readline()方法一次读取文件对象中的一行内容，返回值是字符串。可以配合for循环使用，每一次循环，读取一行内容。适用于文件比较大，内存比较小，不能一次将整个文件读入内存的情况，使用readline就比较好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file_obj = open(<span class="string">'data.txt'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = file_obj.readline()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line: <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">print</span> line</span><br><span class="line">file_obj.close()</span><br></pre></td></tr></table></figure><h1 id="readlines函数"><a href="#readlines函数" class="headerlink" title="readlines函数"></a>readlines函数</h1><p>readlines()方法一次将整个文件读取到内存中，返回值是列表list，文件中每一行对应列表list中的一个元素。因返回值是list，可以使用for循环遍历内容啦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file_obj = open(<span class="string">'data.txt'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file_obj.readlines():</span><br><span class="line">    <span class="keyword">print</span> line</span><br><span class="line">file_obj.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中多线程编程</title>
      <link href="/2019/02/24/Python%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/02/24/Python%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中多线程编程"><a href="#Python中多线程编程" class="headerlink" title="Python中多线程编程"></a>Python中多线程编程</h1><p>进程是由若干线程组成的，一个进程至少有一个线程。由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p><p>Python的标准库提供了两个模块，thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。如下为使用threading模块来实现多线程编程的例程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新线程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'thread %s &gt;&gt;&gt; %s'</span> % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">'LoopThread'</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><pre><code>thread MainThread is running...thread LoopThread is running...thread LoopThread &gt;&gt;&gt; 1thread LoopThread &gt;&gt;&gt; 2thread LoopThread &gt;&gt;&gt; 3thread LoopThread &gt;&gt;&gt; 4thread LoopThread &gt;&gt;&gt; 5thread LoopThread ended.thread MainThread ended.</code></pre><p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2……</p><p>start函数是启动线程，调用start方法后，线程将开始执行了。join是阻塞方法，它会阻塞调用join函数的线程，直到对应的线程执行完毕。</p><h1 id="多线程中锁的使用"><a href="#多线程中锁的使用" class="headerlink" title="多线程中锁的使用"></a>多线程中锁的使用</h1><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假定这是你的银行存款:</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_it</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># 先存后取，结果应该为0:</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment"># 先要获取锁:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 放心地改吧:</span></span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 改完了一定要释放锁:</span></span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(balance)</span><br></pre></td></tr></table></figure><p>程序运行结果为0。</p><p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p><h1 id="伪多线程与GIL"><a href="#伪多线程与GIL" class="headerlink" title="伪多线程与GIL"></a>伪多线程与GIL</h1><p>GIL，Global Interpreter Lock，中文为全局解释器锁。在Python语言的主流解释器实现CPython中，GIL是一个货真价实的全局线程锁，在解释器解释执行任何Python代码时，都需要先获得这把锁才行，在遇到I/O操作时会释放这把锁。如果是纯计算的程序，没有I/O操作，解释器会每隔100次操作就释放这把锁，让别的线程有机会执行（这个次数可以通过sys.setcheckinterval来调整）。所以虽然CPython的线程库是直接封装操作系统的原生线程，但CPython进程做为一个整体，同一时间只会有一个获得了GIL的线程在执行，其它的线程都处于等待状态等着GIL的释放。</p><p>因GIL的存在，我们说Python的多线程是伪多线程。GIL直接导致CPython不能利用物理多核的性能加速运算。那为什么会有这样的设计呢？我猜想应该还是历史遗留问题。多核CPU在1990年代还属于类科幻，Guido van Rossum在创造Python的时候，也想不到他的语言有一天会被用到很可能1000+个核的CPU上面，一个全局锁搞定多线程安全在那个时代应该是最简单经济的设计了。简单而又能满足需求，那就是合适的设计。</p><p>一般说来，<strong>Python多线程不适合CPU密集型操作的任务，适合IO操作密集型的任务</strong>。因为某个线程CPU计算比较多时，会导致其他线程获取到CPU时间会变少。而当线程是IO操作密集时，线程会定时释放CPU时间，让其他线程得以被调度执行。</p><p>学习资料参考于：<br><a href="https://blog.csdn.net/wangjianno2/article/details/51930215" target="_blank" rel="noopener">https://blog.csdn.net/wangjianno2/article/details/51930215</a><br><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143192823818768cd506abbc94eb5916192364506fa5d000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143192823818768cd506abbc94eb5916192364506fa5d000</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中多进程编程</title>
      <link href="/2019/02/24/Python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/02/24/Python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Pyhton中多进程编程方式"><a href="#Pyhton中多进程编程方式" class="headerlink" title="Pyhton中多进程编程方式"></a>Pyhton中多进程编程方式</h1><h2 id="os-fork"><a href="#os-fork" class="headerlink" title="os.fork()"></a>os.fork()</h2><p>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程，例程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Process (%s) start...'</span> % os.getpid())</span><br><span class="line"><span class="comment"># Only works on Unix/Linux/Mac:</span></span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'I am child process (%s) and my parent is %s.'</span> % (os.getpid(), os.getppid()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'I (%s) just created a child process (%s).'</span> % (os.getpid(), pid))</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><pre><code>Process (6221) start...I (6221) just created a child process (6222).I am child process (6222) and my parent is 6221.</code></pre><p>普通的函数调用，调用一次，返回一次，但是<code>fork()</code>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。<strong>子进程永远返回0，而父进程返回子进程的ID</strong>。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p><p>值得注意的是，由于Windows没有fork调用，上面的Python代码在Windows上无法运行。</p><h2 id="multiprocessing-Process"><a href="#multiprocessing-Process" class="headerlink" title="multiprocessing.Process"></a>multiprocessing.Process</h2><p>multiprocessing模块就是跨平台版本的多进程模块。multiprocessing模块提供了一个Process类来代表一个进程对象。例程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</span><br><span class="line">    print(<span class="string">'Child process will start.'</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'Child process end.'</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><pre><code>Parent process 26656.Child process will start.Run child process test (26657)...Child process end.</code></pre><p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。<code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p><h2 id="multiprocessing-Pool"><a href="#multiprocessing-Pool" class="headerlink" title="multiprocessing.Pool"></a>multiprocessing.Pool</h2><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程。例程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'All subprocesses done.'</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parent process 669.</span><br><span class="line">Waiting for all subprocesses done...</span><br><span class="line">Run task 0 (671)...</span><br><span class="line">Run task 1 (672)...</span><br><span class="line">Run task 2 (673)...</span><br><span class="line">Run task 3 (674)...</span><br><span class="line">Task 2 runs 0.14 seconds.</span><br><span class="line">Run task 4 (673)...</span><br><span class="line">Task 1 runs 0.27 seconds.</span><br><span class="line">Task 3 runs 0.86 seconds.</span><br><span class="line">Task 0 runs 1.41 seconds.</span><br><span class="line">Task 4 runs 1.91 seconds.</span><br><span class="line">All subprocesses done.</span><br></pre></td></tr></table></figure><p>对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。<br>请注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的的大小是4，因此，最多同时执行4个进程。如果Pool(5)那么就可以同时执行5个子进程。</p><h2 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a>subprocess</h2><p>subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。下面的例子演示了如何在Python代码中运行命令<code>nslookup www.python.org</code>，这和命令行直接运行的效果是一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">print(<span class="string">'$ nslookup www.python.org'</span>)</span><br><span class="line">r = subprocess.call([<span class="string">'nslookup'</span>, <span class="string">'www.python.org'</span>])</span><br><span class="line">print(<span class="string">'Exit code:'</span>, r)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup www.python.org</span><br><span class="line">Server:         10.91.0.231</span><br><span class="line">Address:        10.91.0.231#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.python.org  canonical name = python.map.fastly.net.</span><br><span class="line">Name:   python.map.fastly.net</span><br><span class="line">Address: 103.245.222.223</span><br><span class="line"></span><br><span class="line">(&apos;Exit code:&apos;, 0)</span><br></pre></td></tr></table></figure><p>如果子进程还需要输入，则可以通过<code>communicate()</code>方法输入，可以做如下修改调整：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">print(<span class="string">'$ nslookup'</span>)</span><br><span class="line">p = subprocess.Popen([<span class="string">'nslookup'</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">output, err = p.communicate(<span class="string">b'set q=mx\npython.org\nexit\n'</span>)</span><br><span class="line">print(output.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(<span class="string">'Exit code:'</span>, p.returncode)</span><br></pre></td></tr></table></figure><p>上面的代码相当于在命令行执行命令nslookup，然后手动输入：</p><pre><code>set q=mxpython.orgexit</code></pre><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。</p><p>我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'Process to write: %s'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</span><br><span class="line">        print(<span class="string">'Put %s to queue...'</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'Process to read: %s'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = q.get(<span class="literal">True</span>)</span><br><span class="line">        print(<span class="string">'Get %s from queue.'</span> % value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    <span class="comment"># 启动子进程pw，写入:</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment"># 启动子进程pr，读取:</span></span><br><span class="line">    pr.start()</span><br><span class="line">    <span class="comment"># 等待pw结束:</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure><p>运行的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Process to write: 50563</span><br><span class="line">Put A to queue...</span><br><span class="line">Process to read: 50564</span><br><span class="line">Get A from queue.</span><br><span class="line">Put B to queue...</span><br><span class="line">Get B from queue.</span><br><span class="line">Put C to queue...</span><br><span class="line">Get C from queue.</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在Unix/Linux下，可以使用fork()调用实现多进程。要实现跨平台的多进程，可以使用multiprocessing模块。进程间通信是通过Queue、Pipes等实现的。</p><p>参考资料来源于：<br><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中网络编程总结</title>
      <link href="/2019/02/24/Python%E4%B8%AD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2019/02/24/Python%E4%B8%AD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="使用socket模块网络编程"><a href="#使用socket模块网络编程" class="headerlink" title="使用socket模块网络编程"></a>使用socket模块网络编程</h1><p>使用Python socktet模块来进行网络编程，范例如下：</p><p>（1）服务端demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket()      <span class="comment">#创建socket对象</span></span><br><span class="line">host = socket.gethostname()</span><br><span class="line">port = <span class="number">1234</span></span><br><span class="line">s.bind((host, port))     <span class="comment">#socket绑定host和port</span></span><br><span class="line">s.listen(<span class="number">5</span>)              <span class="comment">#配置监听</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c, addr = s.accept() <span class="comment">#接收client端的连接，是阻塞方法</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Got connection from"</span>, addr</span><br><span class="line">    c.send(<span class="string">"Thank you for connecting, aha!"</span>) <span class="comment">#向socket发送信息</span></span><br><span class="line">    c.close()</span><br></pre></td></tr></table></figure><p>（2）客户端demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket()     <span class="comment">#创建socket对象</span></span><br><span class="line">host = <span class="string">"test-host-01"</span>   <span class="comment">#假设server端程序是运行在test-host-1主机上</span></span><br><span class="line">port = <span class="number">1234</span></span><br><span class="line">s.connect((host, port)) <span class="comment">#连接server端</span></span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">1024</span>)      <span class="comment">#从网络套接字中接收内容</span></span><br></pre></td></tr></table></figure><h1 id="使用urllib和urllib2模块来抓取远程web上内容到本地"><a href="#使用urllib和urllib2模块来抓取远程web上内容到本地" class="headerlink" title="使用urllib和urllib2模块来抓取远程web上内容到本地"></a>使用urllib和urllib2模块来抓取远程web上内容到本地</h1><h1 id="使用SocketServer模块来编写网络程序"><a href="#使用SocketServer模块来编写网络程序" class="headerlink" title="使用SocketServer模块来编写网络程序"></a>使用SocketServer模块来编写网络程序</h1><h1 id="使用Twisted网络编程框架来进行网络编程"><a href="#使用Twisted网络编程框架来进行网络编程" class="headerlink" title="使用Twisted网络编程框架来进行网络编程"></a>使用Twisted网络编程框架来进行网络编程</h1><h1 id="其他很多模块也可以进行网络编程"><a href="#其他很多模块也可以进行网络编程" class="headerlink" title="其他很多模块也可以进行网络编程"></a>其他很多模块也可以进行网络编程</h1><pre><code>asynchatasyncorecgiCookieemailftplibtelnetlib......</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中装饰器Decorator用法</title>
      <link href="/2019/02/24/Python%E4%B8%AD%E8%A3%85%E9%A5%B0%E5%99%A8Decorator%E7%94%A8%E6%B3%95/"/>
      <url>/2019/02/24/Python%E4%B8%AD%E8%A3%85%E9%A5%B0%E5%99%A8Decorator%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="不带参数的装饰器"><a href="#不带参数的装饰器" class="headerlink" title="不带参数的装饰器"></a>不带参数的装饰器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func = decorator(func)</span><br></pre></td></tr></table></figure><h1 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator_one</span></span><br><span class="line"><span class="meta">@decorator_two</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func = decorator_one(decorator_two(func))</span><br></pre></td></tr></table></figure><h1 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator(arg1, arg2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func = decorator(arg1, arg2)(func)  <span class="comment">#这意味着decorator(arg1, arg2)这个函数需要返回一个“真正的decorator”</span></span><br></pre></td></tr></table></figure><h1 id="不带参数的类装饰器"><a href="#不带参数的类装饰器" class="headerlink" title="不带参数的类装饰器"></a>不带参数的类装饰器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDecorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"inside myDecorator.__init__()"</span></span><br><span class="line">        self.fn = fn</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fn()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"inside myDecorator.__call__()"</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@myDecorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aFunction</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"inside aFunction()"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Finished decorating aFunction()"</span></span><br><span class="line"> </span><br><span class="line">aFunction()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># inside myDecorator.__init__()</span></span><br><span class="line"><span class="comment"># Finished decorating aFunction()</span></span><br><span class="line"><span class="comment"># inside aFunction()</span></span><br><span class="line"><span class="comment"># inside myDecorator.__call__()</span></span><br></pre></td></tr></table></figure><p>装饰器的地方相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aFunction = myDocorator(aFunction).__call__</span><br></pre></td></tr></table></figure><h1 id="带参数的类装饰器"><a href="#带参数的类装饰器" class="headerlink" title="带参数的类装饰器"></a>带参数的类装饰器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDecorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"inside myDecorator.__init__()"</span></span><br><span class="line">        self.str = str </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"inside myDecorator.__call__()"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"start"</span>, self.str</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"end"</span>, self.str</span><br><span class="line">        <span class="keyword">return</span> fn</span><br><span class="line"> </span><br><span class="line"><span class="meta">@myDecorator('aha')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aFunction</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"inside aFunction()"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Finished decorating aFunction()"</span></span><br><span class="line"> </span><br><span class="line">aFunction()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># inside myDecorator.__init__()</span></span><br><span class="line"><span class="comment"># inside myDecorator.__call__()</span></span><br><span class="line"><span class="comment"># start aha</span></span><br><span class="line"><span class="comment"># end aha</span></span><br><span class="line"><span class="comment"># Finished decorating aFunction()</span></span><br><span class="line"><span class="comment"># inside aFunction()</span></span><br></pre></td></tr></table></figure><p>装饰器的地方相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aFunction = myDecorator(<span class="string">'aha'</span>).__call__(aFunction)</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://coolshell.cn/articles/11265.html" target="_blank" rel="noopener">http://coolshell.cn/articles/11265.html</a><br><a href="http://blog.jkey.lu/2013/03/15/python-decorator-and-functools-module/" target="_blank" rel="noopener">http://blog.jkey.lu/2013/03/15/python-decorator-and-functools-module/</a><br><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819879946007bbf6ad052463ab18034f0254bf355000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819879946007bbf6ad052463ab18034f0254bf355000</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中协程总结</title>
      <link href="/2019/02/24/Python%E4%B8%AD%E5%8D%8F%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2019/02/24/Python%E4%B8%AD%E5%8D%8F%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="协程coroutine的简介"><a href="#协程coroutine的简介" class="headerlink" title="协程coroutine的简介"></a>协程coroutine的简介</h1><p>协程的原理很简单，打个比方就能讲明白了。假设说有十个人去食堂打饭，这个食堂比较穷，只有一个打饭的窗口，并且也只有一个打饭阿姨，那么打饭就只能一个一个排队来打咯。这十个人胃口很大，每个人都要点5个菜，但这十个人又有个毛病就是做事情都犹豫不决，所以点菜的时候就会站在那里，每点一个菜后都会想下一个菜点啥，因此后面的人等的很着急呀。这样一直站着也不是个事情吧，所以打菜的阿姨看到某个人犹豫5秒后就开始吼一声，会让他排到队伍最后去，先让别人打菜，等轮到他的时候他也差不多想好吃啥了。这确实是个不错的方法，但也有一个缺点，那就是打菜的阿姨得等每个人5秒钟，如果那个人在5秒内没有做出决定吃啥，其实这5秒就是浪费了。一个人点一个菜就是浪费5秒，十个人每个人点5个菜可就浪费的多啦（菜都凉了要）。那咋办呢？这个时候阿姨发话了：大家都是学生，学生就要自觉，我以后也不主动让你们排到最后去了，如果你们觉得自己会犹豫不决，就自己主动点直接点一个菜就站后面去，等下次排到的时候也差不多想好吃啥了。这个方法果然有效，大家点了菜后想的第一件事情不是下一个菜吃啥，而是自己会不会犹豫，如果会犹豫那直接排到队伍后面去，如果不会的话就直接接着点菜就行了。这样一来整个队伍没有任何时间是浪费的，效率自然就高了。</p><p>这个例子里的排队阿姨的那声吼就是我们的CPU中断，用于切换上下文。每个打饭的学生就是一个task。而每个人自己决定自己要不要让出窗口的这种行为，其实就是我们协程的核心思想。</p><p>在用线程的时候，其实虽然CPU把时间给了你，你也不一定有活干，比如你要等IO、等信号啥的，这些时间CPU给了你你也没用呀。</p><p>在用协程的时候，CPU就不来分配时间了，时间由你们自己决定，你觉得干这件事情很耗时，要等IO啥的，你就干一会歇一会，等到等IO的时候就主动让出CPU，让别人上去干活，别人也是讲道理的，干一会也会把时间让给你。协程就是使用了这种思想，让编程者控制各个任务的运行顺序，从而最大可能的发挥CPU的性能。</p><h1 id="Python中的协程是用关键字yield来实现的"><a href="#Python中的协程是用关键字yield来实现的" class="headerlink" title="Python中的协程是用关键字yield来实现的"></a>Python中的协程是用关键字yield来实现的</h1><p>在Python中，包含yield表达式的函数是特殊的函数，叫做生成器函数(generator function)，被调用时将返回一个迭代器（iterator），调用时可以使用next或send(msg)。它的用法与return相似，<strong>区别在于它会记住上次迭代的状态，继续执行</strong>。关于生成器可以参见<a href="https://wangjianno1.github.io/2019/02/24/Python%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%E6%80%BB%E7%BB%93/">《Python中迭代器和生成器总结》</a>。如下用来说明生成器函数和普通的函数的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(type(func))   <span class="comment">#&lt;class 'function'&gt;</span></span><br><span class="line">print(type(gen))    <span class="comment">#&lt;class 'function'&gt;</span></span><br><span class="line"></span><br><span class="line">print(type(func())) <span class="comment">#&lt;class 'int'&gt;</span></span><br><span class="line">print(type(gen()))  <span class="comment">#&lt;class 'generator'&gt;</span></span><br></pre></td></tr></table></figure><p>下面是使用协程的一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">'[CONSUMER] Consuming %s...'</span> % n)</span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">c.send(<span class="literal">None</span>)</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    print(<span class="string">'[PRODUCER] Producing %s...'</span> % n)</span><br><span class="line">    r = c.send(n)</span><br><span class="line">    print(<span class="string">'[PRODUCER] Consumer return: %s'</span> % r)</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure><p>上面程序的输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br></pre></td></tr></table></figure><p>在上面中执行<code>c = consumer()</code>时，consumer函数并没用直接执行，而是直接返回一个迭代器并赋给变量c。当调用<code>c.send(None)</code>（或<code>c.next()</code>），就会触发consumer函数执行，执行到<code>yield r</code>后释放CPU控制权，返回调用处，并将<code>r</code>作为返回值传递给调用处。然后后面再执行<code>c.send(n)</code>时，就会再次进入到<code>yield r</code>代码处，此时不会执行<code>yield r</code>表达式，而是将send函数的参数值直接作为<code>yield r</code>表达式的计算结果赋给了变量n。</p><p>在consumer函数中<code>yield r</code>是一个表达式，当在consumer中执行到这个函数时，会将yield后面紧跟的值返回给调用者，并等待<code>send(msg)</code>中的msg值，将msg作为yield表达式的返回值。</p><p>备注：</p><p>如果一个函数中有yield表达式，那么这个函数就不是一个普通的函数，就是一个generator函数，即生成器函数。</p><p>生成器约等于迭代器。</p><p>执行到yield语句时，就是释放执行权。等下次调度时，再继续执行下去。</p><p>学习资料参考于：<br><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432090171191d05dae6e129940518d1d6cf6eeaaa969000#0" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432090171191d05dae6e129940518d1d6cf6eeaaa969000#0</a><br><a href="http://www.cnblogs.com/huxi/archive/2011/07/14/2106863.html" target="_blank" rel="noopener">http://www.cnblogs.com/huxi/archive/2011/07/14/2106863.html</a><br><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138681965108490cb4c13182e472f8d87830f13be6e88000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138681965108490cb4c13182e472f8d87830f13be6e88000</a><br><a href="http://blog.csdn.net/gzlaiyonghao/article/details/5397038" target="_blank" rel="noopener">http://blog.csdn.net/gzlaiyonghao/article/details/5397038</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中迭代器和生成器总结</title>
      <link href="/2019/02/24/Python%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2019/02/24/Python%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h1><p>实现了迭代器协议的对象，我们称之为迭代器对象。</p><p>所谓迭代器协议，要求对象实现了<code>__iter__()</code>和<code>next()</code>方法，调用<code>__iter__()</code>方法会返回一个对象自身，调用<code>next()</code>方法会返回下一个元素值。如果已经迭代完成，对象没有值可以返回，就会引发一个名称为<code>StopIteration</code>的异常。</p><p>迭代器的使用举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line">city = [<span class="string">'beijing'</span>, <span class="string">'shanghai'</span>, <span class="string">'tianjin'</span>, <span class="string">'chongqing'</span>]</span><br><span class="line">it = iter(city)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> type(it)</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法一：使用for循环来使用迭代器</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="keyword">print</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二：使用next方法来使用迭代器</span></span><br><span class="line"><span class="keyword">print</span> it.next()</span><br><span class="line"><span class="keyword">print</span> it.next()</span><br><span class="line"><span class="keyword">print</span> it.next()</span><br><span class="line"><span class="keyword">print</span> it.next()</span><br></pre></td></tr></table></figure><p>其中<code>iter()</code>方法获取了list的迭代器对象。</p><p>自定义迭代器的举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRange</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.idx = <span class="number">0</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.idx &lt; self.n:</span><br><span class="line">            val = self.idx</span><br><span class="line">            self.idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line"></span><br><span class="line">myRange = MyRange(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> myRange:</span><br><span class="line">    <span class="keyword">print</span> elem</span><br></pre></td></tr></table></figure><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器是一种特殊的“迭代器”。生成器在Python中的类型是<code>&lt;type &#39;generator&#39;&gt;</code>。</p><p><strong>一个包含了yield关键字的函数就是一个生成器，该函数也叫生成器函数</strong>。当生成器函数被调用时，在函数体中的代码不会被执行，而会返回一个迭代器。每次请求一个值，就会执行生成器中代码，直到遇到一个yield表达式或return语句。yield表达式表示要生成一个值，return语句表示要停止生成器。</p><p>换句话说，<strong>生成器是由两部分组成，生成器的函数和生成器的迭代器。生成器的函数是用def语句定义的，包含yield部分。生成器的迭代器是这个函数返回的部分。二者合起来叫做生成器</strong>。</p><p>几个需要注意的的点：</p><p>（1）调用生成器函数时，不会执行生成器函数的代码，而是直接返回一个迭代器iterator对象</p><p>（2）生成迭代器对象后，可以使用<code>iterator_obj.next()</code>或者<code>iterator_obj.send(None)</code>来执行，切记使用send函数第一次调用生成器时，参数必须是None，不然会抛出异常。</p><p>（3）<code>yield xxx</code>是表达式，不是Python语句。<code>yield xxx</code>会将xxx值返回给send或者next函数，即调用处。同时<code>yield xxx</code>表达式也有计算结果，计算结果即为send函数中的参数值。</p><p>生成器使用举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeater</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        new = <span class="keyword">yield</span> value</span><br><span class="line">        <span class="keyword">if</span> new <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: value = new</span><br><span class="line"></span><br><span class="line">it = repeater(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> type(it)</span><br><span class="line"><span class="keyword">print</span> it.next()  <span class="comment">#亦可以使用print it.send(None)</span></span><br><span class="line"><span class="keyword">print</span> it.send(<span class="string">'Hello, Guys!!!'</span>)</span><br></pre></td></tr></table></figure><p>返回结果如下：</p><pre><code>&lt;type &apos;generator&apos;&gt;42Hello, Guys!!!</code></pre><p>另外，除了上面使用生成器函数来构造生成器外，还可以使用生成器表达式来构造生成器，代码举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">squares = (x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)) <span class="comment">#形如列表推导式，但是将中括号换成了小括号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> square <span class="keyword">in</span> squares:</span><br><span class="line">    <span class="keyword">print</span> square</span><br></pre></td></tr></table></figure><p>备注：Python中可以使用生成器来实现Python协程编程。当然，还可以使用第三方的库来实现Python协程编程。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中yaml模块的使用</title>
      <link href="/2019/02/24/Python%E4%B8%ADyaml%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/24/Python%E4%B8%ADyaml%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中yaml的模块的使用"><a href="#Python中yaml的模块的使用" class="headerlink" title="Python中yaml的模块的使用"></a>Python中yaml的模块的使用</h1><p>（1）安装yaml模块到机器环境中</p><p>（2）编写yaml配置文件test.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Tom</span> <span class="string">Smith</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">37</span></span><br><span class="line"><span class="attr">spouse:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Jane</span> <span class="string">Smith</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">25</span></span><br><span class="line"><span class="attr">children:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Jimmy</span> <span class="string">Smith</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">15</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Jenny</span> <span class="string">Smith</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p>（3）编写解析yaml文件的Python程序test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">'/home/wahaha/coding/python'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line">f = open(<span class="string">'test.yaml'</span>)</span><br><span class="line">x = yaml.load(f)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> type(x)</span><br><span class="line"><span class="keyword">print</span> x</span><br></pre></td></tr></table></figure><p>程序输出的结果为（yaml.load产出的是dict哦）：</p><pre><code>&lt;type &apos;dict&apos;&gt;{&apos;age&apos;: 37, &apos;spouse&apos;: {&apos;age&apos;: 25, &apos;name&apos;: &apos;Jane Smith&apos;}, &apos;name&apos;: &apos;Tom Smith&apos;, &apos;children&apos;: [{&apos;age&apos;: 15, &apos;name&apos;: &apos;Jimmy Smith&apos;}, {&apos;age1&apos;: 12, &apos;name1&apos;: &apos;Jenny Smith&apos;}]}</code></pre><p>参考资料来源于：<br><a href="http://www.mutouxiaogui.cn/blog/?p=357" target="_blank" rel="noopener">yaml文档编写格式</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中json模块的使用</title>
      <link href="/2019/02/24/Python%E4%B8%ADjson%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/24/Python%E4%B8%ADjson%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中json的使用"><a href="#Python中json的使用" class="headerlink" title="Python中json的使用"></a>Python中json的使用</h1><p>（1）将Python数据类型转换json对象-encode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json.dump()</span><br><span class="line">json.dumps()</span><br><span class="line">json.JSONEncoder()</span><br></pre></td></tr></table></figure><p>其中，Python的数据类型转成json数据类型的映射表为：</p><p><img src="/images/python_json_1_1.png" alt></p><p>（2）将json对象转换成Python数据类型-decode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json.load()</span><br><span class="line">json.loads()</span><br><span class="line">json.JSONDecoder()</span><br></pre></td></tr></table></figure><p>其中，json的数据类型转成Python的数据类型的映射表为：</p><p><img src="/images/python_json_1_2.png" alt></p><h1 id="dump-load与dumps-loads"><a href="#dump-load与dumps-loads" class="headerlink" title="dump/load与dumps/loads"></a>dump/load与dumps/loads</h1><p>json模块提供了一种很简单的方式来编码和解码JSON数据，其中两个主要的函数是<code>json.dumps()</code>和<code>json.loads()</code>，这也是我们经常使用的json模块中的函数。举例来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'ACME'</span>,</span><br><span class="line">    <span class="string">'shares'</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">'price'</span>: <span class="number">542.23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">json_str = json.dumps(data)  <span class="comment">#将python对象转换成json对象</span></span><br><span class="line">data = json.loads(json_str)  <span class="comment">#将json对象转换成python对象</span></span><br></pre></td></tr></table></figure><p>如果你要处理的是文件而不是字符串，你可以使用<code>json.dump()</code>和<code>json.load()</code>来编码和解码JSON数据。举例来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Writing JSON data</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(data, f)   <span class="comment">#将Python对象转换成json对象并持久化到文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reading data back</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.load(f)  <span class="comment">#将文件中的json对象转换成Python对象</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中异常处理机制</title>
      <link href="/2019/02/24/Python%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/02/24/Python%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="异常代码范例"><a href="#异常代码范例" class="headerlink" title="异常代码范例"></a>异常代码范例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=gbk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> NameError:              <span class="comment">#捕获NameError异常</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"NameError"</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:      <span class="comment">#捕获ZeroDivisionError异常</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"ZeroDivisionError"</span></span><br><span class="line"><span class="keyword">else</span>:                          <span class="comment">#如果except捕获不到异常，就执行这个分支</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"That went well"</span></span><br><span class="line"><span class="keyword">finally</span>:                       <span class="comment">#不管是否有异常，finally语句一定执行</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Cleaning up."</span></span><br></pre></td></tr></table></figure><p>备注：</p><p>（1）在try-except结构中except语句可以写多个</p><p>（2）except语句的写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> (ZeroDivisionError, TypeError, NameError): <span class="comment">#一个except语句可以捕获多种类型的异常</span></span><br><span class="line"><span class="keyword">except</span> (ZeroDivisionError, TypeError) <span class="keyword">as</span> ex:      <span class="comment">#推荐此种写法</span></span><br><span class="line"><span class="keyword">except</span> Exception, ex:</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br></pre></td></tr></table></figure><h1 id="raise抛出异常"><a href="#raise抛出异常" class="headerlink" title="raise抛出异常"></a>raise抛出异常</h1><p>（1）<code>raise Exception</code></p><p>（2）<code>raise Exception(&quot;User&#39;s Error Message&quot;)</code></p><h1 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h1><p>用户可以自定义异常类，自定义异常类要继承Exception或其子类。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中的module|package概念以及包路径查找机制</title>
      <link href="/2019/02/24/Python%E4%B8%AD%E7%9A%84module-package%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%8C%85%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/02/24/Python%E4%B8%AD%E7%9A%84module-package%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%8C%85%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中的module和package"><a href="#Python中的module和package" class="headerlink" title="Python中的module和package"></a>Python中的module和package</h1><p>Python的程序由包（package）、模块（module）、类以及函数组成。包是由一系列模块组成的集合。模块是处理某一类问题的函数和类的集合。如下图所示：</p><p><img src="/images/python_pkg_1_1.png" alt></p><p>Python中的module和package是Python模块编程的体现，以及实现命名空间的隔离。</p><p>（1）Python中一个module就是一个<code>*.py</code>文件，模块名称就是文件的名称。</p><p>（2）Python中的package在文件系统中表现出来的就是一个目录，这个目录中可以包含众多的module以及其他的子package。而且这个目录中一定要有一个<code>__init__.py</code>文件，这个文件的存在才意味着该目录是Python中的一个package。</p><p>备注：<code>__init__.py</code>可以是空文件，也可以有一些初始化的代码。</p><h1 id="import导入package或module的过程"><a href="#import导入package或module的过程" class="headerlink" title="import导入package或module的过程"></a>import导入package或module的过程</h1><p>当执行<code>import package_name.module_name</code>时，会执行package_name目录下的<code>__init__.py</code>以及module_name文件。</p><h1 id="import导入函数-类-module-package"><a href="#import导入函数-类-module-package" class="headerlink" title="import导入函数|类|module|package"></a>import导入函数|类|module|package</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module_name     <span class="comment">#module_name.foo()表示调用module_name中foo函数</span></span><br><span class="line"><span class="keyword">import</span> package_name    <span class="comment">#如果package_name中__init__.py文件中导入了具体模块module_name,那么可以用package_name.module_name来使用module_name中的功能，否则是不行的</span></span><br><span class="line"><span class="keyword">import</span> package_name.module_name          <span class="comment">#package_name.module_name.foo()表示使用module_name中的foo函数</span></span><br><span class="line"><span class="keyword">from</span> package_name <span class="keyword">import</span> module_name     <span class="comment">#module_name.foo()表示使用module_name的foo函数</span></span><br><span class="line"><span class="keyword">from</span> package_name.module_name <span class="keyword">import</span> foo <span class="comment">#直接使用foo()就可以啦</span></span><br></pre></td></tr></table></figure><p>备注：<code>import module_name.foo</code>是非法的。</p><h1 id="module和package中的一些特殊的变量"><a href="#module和package中的一些特殊的变量" class="headerlink" title="module和package中的一些特殊的变量"></a>module和package中的一些特殊的变量</h1><p>（1）module中的<code>__name__</code>变量</p><p>当使用import导入module时，该<code>__name__</code>变量就是模块名或文件名（不带后缀哦）；当直接执行module的.py文件时，<code>__name__</code>变量就是<code>__main__</code>。</p><p>（2）package中的<code>__init__</code>变量</p><p><code>__init__</code>变量是一个元组，我们可以给这个变量赋值，如<code>__all__ = [&#39;Module1&#39;, &#39;Module2&#39;, &#39;Package2&#39;]</code>，当我们使用<code>from package_name import *</code>会执行<code>__init__.py</code>，这时就会导入<code>__all__</code>元组中定义的module或子package啦</p><h1 id="Python中包的查找机制"><a href="#Python中包的查找机制" class="headerlink" title="Python中包的查找机制"></a>Python中包的查找机制</h1><p>（1）绝对路径引入</p><p>当我们在Python代码中使用<code>from package_name import module</code>等形式来以绝对路径的方式来导入其他模块或包时，Python的查找顺序为：</p><pre><code>查看python的内置模块或包中是否存在根据sys.path这个列表中的路径按顺序依次查找</code></pre><p>备注：当我们使用<code>python /home/work/test.py</code>或<code>cd home &amp;&amp; python work/test.py</code>，都会将test.py文件所在的路径/home/work加入到sys.path列表中，且该路径在列表的最前面。所以在Python中，查找当前目录是早于Python中其他默认的第三方包路径。</p><p><img src="/images/python_pkg_1_2.png" alt></p><p>（2）相对路径引入</p><p>所谓相对路径的引入，是针对一个包内部模块间相互依赖的导入方法。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sound/                #Top-level package</span><br><span class="line">    __init__.py       #Initialize the sound package</span><br><span class="line">    formats/          #Subpackage for file format conversions</span><br><span class="line">        __init__.py</span><br><span class="line">        wavread.py</span><br><span class="line">        wavwrite.py</span><br><span class="line">        aiffread.py</span><br><span class="line">        aiffwrite.py</span><br><span class="line">        auread.py</span><br><span class="line">        auwrite.py</span><br><span class="line">        ...</span><br><span class="line">    effects/          #Subpackage for sound effects</span><br><span class="line">        __init__.py</span><br><span class="line">        echo.py</span><br><span class="line">        surround.py</span><br><span class="line">        reverse.py</span><br><span class="line">        ...</span><br><span class="line">    filters/          #Subpackage for filters</span><br><span class="line">        __init__.py</span><br><span class="line">        equalizer.py</span><br><span class="line">        vocoder.py</span><br><span class="line">        karaoke.py</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>在surround.py中通过<code>from . import echo</code>来引入echo模块；</p><p>在surround.py中通过<code>from .. import formats</code>来引入formats子包；</p><p>在surround.py中通过<code>from ..filters import equalizer</code>来引入filters包的equalizer模块；</p><p>像如上通过<code>./../...</code>等以相对路径的方式引入包内的其他模块或子包，是直接在包里面去查找模块或包的，就不是按照绝对路径的那种方式去查找。</p><p><a href="https://docs.python.org/2/tutorial/modules.html#intra-package-references" target="_blank" rel="noopener">相对地址引入包参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中的类编程</title>
      <link href="/2019/02/24/Python%E4%B8%AD%E7%9A%84%E7%B1%BB%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/02/24/Python%E4%B8%AD%E7%9A%84%E7%B1%BB%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中类定义和使用"><a href="#Python中类定义和使用" class="headerlink" title="Python中类定义和使用"></a>Python中类定义和使用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>:</span>      <span class="comment">#定义类Shape</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"draw a shape"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setName</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(Shape)</span>:</span> <span class="comment">#定义类Rectangle，并继承父类Shape</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span>     <span class="comment">#覆写|重写draw方法</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"darw a rectangle"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    shape = Shape()</span><br><span class="line">    shape.setName(<span class="string">"shape"</span>)</span><br><span class="line">    shape.getName()</span><br><span class="line">    shape.draw()</span><br><span class="line">        </span><br><span class="line">    rect = Rectangle()</span><br><span class="line">    rect.setName(<span class="string">"Rectangle"</span>)</span><br><span class="line">    rect.getName()</span><br><span class="line">    rect.draw()</span><br></pre></td></tr></table></figure><p>备注：</p><p>（1）成员方法的第一个参数必须是<code>self</code>，表示对象自身。<strong>当在一个成员方法调用该类的成员变量或其他成员方法时，必须带上<code>self</code>关键字，这和JAVA中的this是有区别的，在JAVA中是可以带上this，也可以不带上this</strong>。</p><p>（2）Python支持多继承，书写形式为<code>class Rectangle(Shape, Color)</code>，表示Rectangle有两个父类（Shape和Color）。如果在Shape和Color有一个相同的成员，按照继承书写的先后顺序，前面的父类覆写后面的父类，即Shape类中的方法覆写Color类。</p><h1 id="在Python的class声明中，几个需要注意的地方"><a href="#在Python的class声明中，几个需要注意的地方" class="headerlink" title="在Python的class声明中，几个需要注意的地方"></a>在Python的class声明中，几个需要注意的地方</h1><p>（1）变量分为实例变量和类变量；方法分为实例方法、类方法和静态方法。</p><p>实例变量就是在方法被<code>self.xxx = xxoo</code>定义的变量；类变量是直接在类中声明的变量。实例方法就是普通方法；类方法是被<code>@classmethod</code>装饰的方法；静态方法是被<code>@staticmethod</code>装饰的方法。举例来说，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    var = <span class="number">12</span>                <span class="comment">#类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo_1</span><span class="params">(self)</span>:</span>        <span class="comment">#实例方法</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"draw a shape"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo_2</span><span class="params">(self, name)</span>:</span>  <span class="comment">#静态方法</span></span><br><span class="line">        self.kaka = name    <span class="comment">#定义了一个实例变量kaka</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo_3</span><span class="params">(self)</span>:</span>        <span class="comment">#类方法</span></span><br><span class="line">        <span class="keyword">print</span> self.name</span><br></pre></td></tr></table></figure><p>（2）对于实例变量，只能通过实例来访问变量。而对于类变量，既可以通过实例来访问变量，也可以直接类来访问变量。</p><p>（3）对于实例方法，只能通过实例来访问。对于类方法，既可以通过实例，也可以直接通过类来访问。对于静态方法，既可以通过实例，也可以直接通过类来访问。</p><p>（4）在变量和方法的命名前加上双下划线，表示的是私有变量或私有方法。对外是不可以见的。</p><p>（5）在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量。</p><h1 id="Python类中的几个特殊函数"><a href="#Python类中的几个特殊函数" class="headerlink" title="Python类中的几个特殊函数"></a>Python类中的几个特殊函数</h1><p>（1）<code>__new__</code>函数是创建类的对象的函数，相当于C++中构造函数。</p><p>（2）<code>__init__</code>函数会在<code>__new__</code>之后被调用，用来初始化对象的。</p><p>（3）<code>__del__</code>函数是对象将要被销毁的时候被调用，用来将对象所占用的内存资源释放给操作系统，相当于C++中的析构函数。</p><h1 id="Python中私有成员的定义"><a href="#Python中私有成员的定义" class="headerlink" title="Python中私有成员的定义"></a>Python中私有成员的定义</h1><p>在Python中如果将一个成员前面加上双下划线<code>__</code>，就表示该成员是私有成员，不能通过对象直接访问，需要通过对象的public接口间接地访问。</p><p>Python中私有成员和其他语言中的私有成员不太一样，Python中的私有成员通过一定的特殊方式还是可以访问的。这就和Python语言底层实现私有成员的方案有关。在Python中私有成员的其实是使用了“名称变化术”。具体说来，就是Python将类的内部定义的以双下划线<code>__</code>的成员“翻译”成前面加上单下划线和类型的形式。</p><p>例如在类Bird中有<code>def __talk(self):</code>成员方法，我们可以通过<code>obj._Bird__talk()</code>来访问。</p><h1 id="新式类与旧式类"><a href="#新式类与旧式类" class="headerlink" title="新式类与旧式类"></a>新式类与旧式类</h1><p>由于Python的版本变化，形成了新式类和老式类，有一些特性在老式类中是不支持的，因此在使用老式类已经没有必要了。因为在定义一个类的时候，需要注明使用新式类。标注类为新式类有两种方法：</p><p>法一（在模块文件的开头添加如下语句）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__metaclass__ = type   <span class="comment">#使用新式类</span></span><br></pre></td></tr></table></figure><p>法二（定义新类时，显式地继承object类）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span> <span class="comment">#继承类object</span></span><br></pre></td></tr></table></figure><h1 id="Python类中的装饰器-staticmethod和-classmethod"><a href="#Python类中的装饰器-staticmethod和-classmethod" class="headerlink" title="Python类中的装饰器@staticmethod和@classmethod"></a>Python类中的装饰器<code>@staticmethod</code>和<code>@classmethod</code></h1><p>代码范例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'static_foo'</span></span><br><span class="line">        <span class="keyword">print</span> A.bar</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'class_foo'</span></span><br><span class="line">        <span class="keyword">print</span> cls.bar</span><br><span class="line">        cls().foo()</span><br><span class="line"></span><br><span class="line">A.static_foo()</span><br><span class="line">A.class_foo()</span><br></pre></td></tr></table></figure><p>程序输出结果为：</p><pre><code>static_foo1class_foo1foo</code></pre><p><code>@staticmethod</code>和<code>@classmethod</code>都可以直接<code>类名.方法名()</code>或者<code>实例名.方法名()</code>来调用。</p><p><img src="/images/python_class_1_1.png" alt></p><p>（1）<code>@staticmethod</code></p><p>不需要表示自身对象的<code>self</code>和自身类的<code>cls</code>参数，就跟使用函数一样。</p><p>（2）<code>@classmethod</code></p><p>也不需要<code>self</code>参数，但第一个参数需要是表示自身类的<code>cls</code>参数。</p><p>如果在<code>@staticmethod</code>中要调用到这个类的一些属性方法，只能直接<code>类名.属性名</code>或<code>类名.方法名</code>。</p><p>而<code>@classmethod</code>因为持有<code>cls</code>参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中的break|continue|pass|return语句</title>
      <link href="/2019/02/24/Python%E4%B8%AD%E7%9A%84break-continue-pass-return%E8%AF%AD%E5%8F%A5/"/>
      <url>/2019/02/24/Python%E4%B8%AD%E7%9A%84break-continue-pass-return%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中的break-continue-pass-return"><a href="#Python中的break-continue-pass-return" class="headerlink" title="Python中的break|continue|pass|return"></a>Python中的break|continue|pass|return</h1><p>break和continue和在其他程序语言中的用法是一样的。</p><p>pass是一个空操作，表示什么也不做的意思。</p><p>return是终结函数，并返回一个值给调用程序。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中函数定义及形参实参使用</title>
      <link href="/2019/02/23/Python%E4%B8%AD%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%BD%A2%E5%8F%82%E5%AE%9E%E5%8F%82%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/23/Python%E4%B8%AD%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%BD%A2%E5%8F%82%E5%AE%9E%E5%8F%82%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中函数定义"><a href="#Python中函数定义" class="headerlink" title="Python中函数定义"></a>Python中函数定义</h1><p>Python中函数的定义形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_name</span><span class="params">(parameter1, parameter2, ...)</span>:</span></span><br><span class="line">    语句段</span><br><span class="line">    <span class="keyword">return</span>语句</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello</span><span class="params">(personname)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello,"</span> + personname + <span class="string">"!"</span></span><br></pre></td></tr></table></figure><h1 id="Python中位置参数与关键字参数"><a href="#Python中位置参数与关键字参数" class="headerlink" title="Python中位置参数与关键字参数"></a>Python中位置参数与关键字参数</h1><p>我的理解是，<strong>位置参数与关键字参数都是指实参的传递形式，并非函数定义中的形参的形式哦</strong>。</p><p>假设函数定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(familyname, givenname)</span>:</span>   <span class="comment">#调用foo函数时，参数的顺序是由严格顺序的</span></span><br><span class="line">    <span class="keyword">return</span> familyname + givenname</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'wang'</span>, <span class="string">'hao'</span>)   <span class="comment">#是正确的，位置参数</span></span><br><span class="line">foo(<span class="string">'hao'</span>, <span class="string">'wang'</span>)   <span class="comment">#是错误的，位置参数</span></span><br><span class="line"></span><br><span class="line">foo(familyname=<span class="string">'wang'</span>, givenname=<span class="string">'hao'</span>)   <span class="comment">#是正确的，关键字参数</span></span><br><span class="line">foo(givenname=<span class="string">'hao'</span>, familyname=<span class="string">'wang'</span>)   <span class="comment">#是正确的，关键字参数</span></span><br></pre></td></tr></table></figure><h1 id="Python中默认参数"><a href="#Python中默认参数" class="headerlink" title="Python中默认参数"></a>Python中默认参数</h1><p>定义函数时可以定义默认参数，形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(familyname=<span class="string">'wang'</span>, givenname=<span class="string">'hao'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> familyname + givenname</span><br></pre></td></tr></table></figure><p>备注：对于默认形参，在调用函数时，可以不传递实参。</p><h1 id="Python中可变参数"><a href="#Python中可变参数" class="headerlink" title="Python中可变参数"></a>Python中可变参数</h1><p>（1）函数定义可变参数</p><p>形式1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*params)</span>:</span>   <span class="comment">#params在函数体内的类型是元组</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">4</span>, <span class="number">56</span>)       <span class="comment">#调用方式</span></span><br></pre></td></tr></table></figure><p>形式2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(**params)</span>:</span>  <span class="comment">#params在函数体内的形式是字典</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">foo(x=<span class="number">1</span>, y=<span class="number">4</span>, z=<span class="number">56</span>) <span class="comment">#调用方式</span></span><br></pre></td></tr></table></figure><p>举一个普通参数，形式1（位置参数）和形式2（关键字参数）联合一起的复杂的例子，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_params</span><span class="params">(x, y, z=<span class="number">3</span>, *pospar, **keypar)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> x, y, z</span><br><span class="line">    <span class="keyword">print</span> pospar</span><br><span class="line">    <span class="keyword">print</span> keypar</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print_params(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, foo=<span class="number">1</span>, bar=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>上述程序输出结果为：</p><pre><code>1 2 3(5, 6, 7){&apos;foo&apos;: 1, &apos;bar&apos;: 2}</code></pre><p>我们通常用这两种可变参数来使函数收集参数，所有我们经常会见到一种函数的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(fargs, *args, **kwargs)</span>  #其中<span class="title">fargs</span>是普通参数，*<span class="title">args</span>和**<span class="title">kwargs</span>用来收集不定量的形参</span></span><br><span class="line"><span class="function">    <span class="title">pass</span></span></span><br></pre></td></tr></table></figure><h1 id="实参两种特殊传递形式"><a href="#实参两种特殊传递形式" class="headerlink" title="实参两种特殊传递形式"></a>实参两种特殊传递形式</h1><p>（1）以元组作为实参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(familyname, givenname)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'my familyname is '</span> + familyname</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'my givenname is '</span> + givenname</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    username = (<span class="string">'wang'</span>, <span class="string">'hao'</span>)</span><br><span class="line">    foo(*username)</span><br></pre></td></tr></table></figure><p>（2）以字典作为实参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(familyname, givenname)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'my familyname is '</span> + familyname</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'my givenname is '</span> + givenname</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    username = &#123;<span class="string">'givenname'</span>: <span class="string">'hao'</span>, <span class="string">'familyname'</span>: <span class="string">'wang'</span>&#125;</span><br><span class="line">    foo(**username)</span><br></pre></td></tr></table></figure><h1 id="在函数体内修改参数内容会影响到函数外的对象的问题"><a href="#在函数体内修改参数内容会影响到函数外的对象的问题" class="headerlink" title="在函数体内修改参数内容会影响到函数外的对象的问题"></a>在函数体内修改参数内容会影响到函数外的对象的问题</h1><p>如果数字、字符串或元组，本身就是不可变的，自然也不会影响到函数体外的对象</p><p>如果是列表或字典，那么函数内修改参数内容，就会影响到函数体外的对象。</p><p>备注：<strong>这里的修改参数是修改参数对象内部的值，不是赋值哦</strong>。即<code>var[1] = &#39;hello&#39;</code>和<code>var = [&#39;hello&#39;, &#39;world&#39;]</code>区别。即使是列表，在函数体内对参数重新赋值了，不会影响到函数体外的对象哦。注意和c++的比较。</p><h1 id="Python函数的嵌套"><a href="#Python函数的嵌套" class="headerlink" title="Python函数的嵌套"></a>Python函数的嵌套</h1><p>Python语言允许在定义函数的时候，其函数体内又包含另外一个函数的完整定义，这就是我们通常所说的嵌套定义。</p><p>实例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span>         <span class="comment">#定义函数foo()，</span></span><br><span class="line">    m=<span class="number">3</span>            <span class="comment">#定义变量m=3;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span>     <span class="comment">#在foo内定义函数bar()</span></span><br><span class="line">        n=<span class="number">4</span>        <span class="comment">#定义局部变量n=4</span></span><br><span class="line">        <span class="keyword">print</span> m+n  <span class="comment">#m相当于函数bar()的全局变量</span></span><br><span class="line"></span><br><span class="line">    bar()          <span class="comment">#foo()函数内调用函数bar()</span></span><br></pre></td></tr></table></figure><p>实例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(m)</span>:</span></span><br><span class="line">    n=<span class="number">4</span></span><br><span class="line">    <span class="keyword">print</span> m+n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    m=4</span><br><span class="line">    bar(m)</span><br></pre></td></tr></table></figure><p>实例2首先定义函数<code>bar()</code>，然后再次定义<code>foo()</code>函数，此时<code>bar()</code>和<code>foo()</code>完全独立的两个函数，再次<code>foo()</code>函数内调用<code>bar()</code>；<br>其实实例1和实例2中的嵌套作用是一样只是两种不同的表现形式。</p><h1 id="Python匿名函数"><a href="#Python匿名函数" class="headerlink" title="Python匿名函数"></a>Python匿名函数</h1><p>在Python中，关键字lambda是用来创建匿名函数的，其语法格式为：</p><pre><code>lambda [arg1[, arg2, ... argN]]: expression</code></pre><p>使用举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#法一</span></span><br><span class="line">fun = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line"><span class="keyword">print</span> fun(<span class="number">1</span>,<span class="number">2</span>)              <span class="comment">#输出结果为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#法二</span></span><br><span class="line"><span class="keyword">print</span> (<span class="keyword">lambda</span> x,y:x+y)(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#输出结果为3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#上面法一和法二相当于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_1</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="keyword">print</span> func_1(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中引用传递与（不）可变对象</title>
      <link href="/2019/02/23/Python%E4%B8%AD%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E4%B8%8E%EF%BC%88%E4%B8%8D%EF%BC%89%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/02/23/Python%E4%B8%AD%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E4%B8%8E%EF%BC%88%E4%B8%8D%EF%BC%89%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中只有引用传递"><a href="#Python中只有引用传递" class="headerlink" title="Python中只有引用传递"></a>Python中只有引用传递</h1><p>在Python中，万物皆对象。Python中不存在所谓的值传递，一切传递的都是对象的引用，也可以认为是传址。</p><p>举例来说，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment">#将名字a与内存中值为1的内存绑定在一起</span></span><br><span class="line">a = <span class="number">2</span> <span class="comment">#将名字a与内存中值为2的内存绑定在一起，而不是修改原来a绑定的内存中的值，这时，内存中值为1的内存地址引用计数-1，当引用计数为0时，内存地址被回收</span></span><br><span class="line">b = a <span class="comment">#变量b执行与a绑定的内存</span></span><br><span class="line">b = <span class="number">3</span> <span class="comment">#创建一个内存值为3的内存地址与变量名字b进行绑定。这时a还是指向值为2的内存地址</span></span><br></pre></td></tr></table></figure><h1 id="Python中可变对象与不可变对象"><a href="#Python中可变对象与不可变对象" class="headerlink" title="Python中可变对象与不可变对象"></a>Python中可变对象与不可变对象</h1><p>在Python中，对象分为可变（mutable）和不可变（immutable）两种类型，元组（tuple）、数值型（number）、字符串（string）均为不可变对象，而字典型（dictionary）、列表型（list）、集合（set）的对象是可变对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>]</span><br><span class="line">a.append(<span class="number">78</span>)     <span class="comment">#这里是修改了变量a所指向的list对象内部状态</span></span><br><span class="line">a = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>] <span class="comment">#这里是修改了变量a的引用，并没有修改[12, 34, 56]对象的内部状态哦</span></span><br></pre></td></tr></table></figure><h1 id="闲杂"><a href="#闲杂" class="headerlink" title="闲杂"></a>闲杂</h1><p>在Python中<code>a = b</code>是一次对象的引用传递，也就是此时a和b其实指向的是同一块内存地址（不管a，b是可变对象，还是不可变对象）。若a，b是可变对象的话，那么修改对象的值，例如增加一个元素，这是a和b所引用的对象都会变化。而不管a，b是不是可变对象，执行完<code>a = b</code>后，然后对其中的一个变量进行了重新绑定（和修改对象的内容不一样哦），也就是说修改了变量的引用，那a和b的引用就不同了哦。</p><p>备注：感觉其实Java中的参数传递和Python是一样的，待验证。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中的and|or表达式</title>
      <link href="/2019/02/23/Python%E4%B8%AD%E7%9A%84and-or%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/02/23/Python%E4%B8%AD%E7%9A%84and-or%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中的and-or布尔逻辑演算说明"><a href="#Python中的and-or布尔逻辑演算说明" class="headerlink" title="Python中的and|or布尔逻辑演算说明"></a>Python中的and|or布尔逻辑演算说明</h1><p>在Python中<code>0</code>、<code>&#39;&#39;</code>、<code>[]</code>、<code>()</code>、<code>{}</code>、<code>None</code>在布尔上下文中为假，其它任何东西都为真。默认情况下，布尔上下文中的类实例为真，但是你可以在类中定义特定的方法使得类实例的演算值为假。</p><p><code>and|or</code>的布尔逻辑演算的格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx <span class="keyword">and</span> yyy <span class="keyword">and</span> ccc</span><br><span class="line">xxx <span class="keyword">or</span> yyy <span class="keyword">or</span> ccc</span><br></pre></td></tr></table></figure><p>使用and时，在布尔上下文中从左到右演算表达式的值。如果布尔上下文中的所有值都为真，那么and返回最后一个值。如果布尔上下文中的某个值为假，则and返回第一个假值。</p><p>使用or时，在布尔上下文中从左到右演算值，就像and一样。如果有一个值为真，or立刻返回该值。如果所有的值都为假，or返回最后一个假值。</p><p>举例如下：</p><pre><code>&gt;&gt;&gt; &apos;a&apos; and &apos;b&apos;&apos;b&apos;&gt;&gt;&gt; &apos;&apos; and &apos;b&apos;&apos;&apos;&gt;&gt;&gt; &apos;a&apos; and &apos;b&apos; and &apos;c&apos;&apos;c&apos;&gt;&gt;&gt; &apos;a&apos; or &apos;b&apos;&apos;a&apos;&gt;&gt;&gt; &apos;&apos; or &apos;b&apos;&apos;b&apos;&gt;&gt;&gt; &apos;&apos; or [] or {}{}</code></pre><h1 id="Python中的and-or布尔逻辑演算的使用方式"><a href="#Python中的and-or布尔逻辑演算的使用方式" class="headerlink" title="Python中的and|or布尔逻辑演算的使用方式"></a>Python中的and|or布尔逻辑演算的使用方式</h1><p>Python中的and|or布尔逻辑演算有两种使用方式：</p><p>（1）作为表达式来为变量赋值</p><p>举例说明如下，</p><pre><code>&gt;&gt;&gt; var = &apos;a&apos; and &apos;b&apos; and &apos;c&apos;&gt;&gt;&gt; print varc</code></pre><p>（2）作为if/while的表达式</p><pre><code>&gt;&gt;&gt; if &apos;a&apos; and &apos;b&apos; and &apos;&apos;:...     print &apos;haha&apos;... else:...     print &apos;xixi&apos;       ... xixi</code></pre><p>备注：其实and|or语句在Python中就是一个表达式，这个表达式会计算出来一个值。这个值可以直接用，也可以转换成布尔类型的值。</p><p>学习资料参考于：<br><a href="http://blog.sina.com.cn/s/blog_3fe961ae0100nuzg.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_3fe961ae0100nuzg.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中字符串的使用</title>
      <link href="/2019/02/22/Python%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/22/Python%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串的定义"><a href="#字符串的定义" class="headerlink" title="字符串的定义"></a>字符串的定义</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    var1 = <span class="string">'this world is beautiful!!'</span></span><br><span class="line">    var2 = <span class="string">"this world is beautiful!!"</span></span><br><span class="line">    var3 = <span class="string">'this "world" is beautiful!!'</span></span><br><span class="line">    var4 = <span class="string">"this 'world' is beautiful!!"</span></span><br><span class="line">    var5 = <span class="string">'''this </span></span><br><span class="line"><span class="string">world </span></span><br><span class="line"><span class="string">is </span></span><br><span class="line"><span class="string">beautiful!!'''</span></span><br><span class="line">    var6 = <span class="string">"""this </span></span><br><span class="line"><span class="string">world </span></span><br><span class="line"><span class="string">is </span></span><br><span class="line"><span class="string">beautiful!!"""</span></span><br><span class="line">    var7 = <span class="string">'''this </span></span><br><span class="line"><span class="string">"world" </span></span><br><span class="line"><span class="string">is </span></span><br><span class="line"><span class="string">beautiful!!'''</span></span><br><span class="line">    var8 = <span class="string">"""this </span></span><br><span class="line"><span class="string">'world' </span></span><br><span class="line"><span class="string">is </span></span><br><span class="line"><span class="string">beautiful!!"""</span></span><br><span class="line">    var9 = <span class="string">'this \"world\" is beautiful!!'</span></span><br><span class="line">    var10 = <span class="string">"this \'world\' is beautiful!!"</span></span><br><span class="line">    var11 = <span class="string">"this \"world\" is beautiful!!"</span></span><br><span class="line">    var12 = <span class="string">'this \'world\' is beautiful!!'</span></span><br><span class="line">    var13 = <span class="string">"this world "</span> <span class="string">"is beautiful!!"</span></span><br><span class="line">    var14 = <span class="string">'this world '</span> <span class="string">'is beautiful!!'</span></span><br><span class="line">    var15 = (<span class="string">"this world "</span> </span><br><span class="line">             <span class="string">"is beautiful!!"</span>)</span><br><span class="line">    var16 = <span class="string">'this world '</span>\</span><br><span class="line">            <span class="string">'is beautiful!!'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var1 : "</span> + var1</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var2 : "</span> + var2</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var3 : "</span> + var3</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var4 : "</span> + var4</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var5 : "</span> + var5</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var6 : "</span> + var6</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var7 : "</span> + var7</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var8 : "</span> + var8</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var9 : "</span> + var9</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var10 : "</span> + var10</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var11 : "</span> + var11</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var12 : "</span> + var12</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var13 : "</span> + var13</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var14 : "</span> + var14</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var15 : "</span> + var15</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"var16 : "</span> + var16</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span>*<span class="number">40</span></span><br></pre></td></tr></table></figure><p>输出内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">var1 : this world is beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var2 : this world is beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var3 : this &quot;world&quot; is beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var4 : this &apos;world&apos; is beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var5 : this </span><br><span class="line">world </span><br><span class="line">is </span><br><span class="line">beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var6 : this </span><br><span class="line">world </span><br><span class="line">is </span><br><span class="line">beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var7 : this </span><br><span class="line">&quot;world&quot; </span><br><span class="line">is </span><br><span class="line">beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var8 : this </span><br><span class="line">&apos;world&apos; </span><br><span class="line">is </span><br><span class="line">beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var9 : this &quot;world&quot; is beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var10 : this &apos;world&apos; is beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var11 : this &quot;world&quot; is beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var12 : this &apos;world&apos; is beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var13 : this world is beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var14 : this world is beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var15 : this world is beautiful!!</span><br><span class="line">****************************************</span><br><span class="line">var16 : this world is beautiful!!</span><br><span class="line">****************************************</span><br></pre></td></tr></table></figure><p>备注：</p><p>（1）单双引号都可以用来定义字符串</p><p>（2）当字符串串中包括单引号时，则使用双引号来定义。反之亦成立。当然这种情况可以使用转义字符</p><p>（3）对于多行的字符串，可以使用三重单引号或者三重双引号来定义。</p><h1 id="Python字符串定义中的u和r"><a href="#Python字符串定义中的u和r" class="headerlink" title="Python字符串定义中的u和r"></a>Python字符串定义中的u和r</h1><p>（1）指定中文编码为unicode</p><p>举例来说，<code>text = u&quot;你好&quot;</code>，这对解决Python中中文乱码问题很有用哦。</p><p>（2）指定字符串为raw string</p><p>举例来说，<code>text = r&quot;\tHello World!!!&quot;</code>，r指明该字符串为raw string，即字符串中有特殊字符，也当做普通字符来看。在本例中\t就是一个转义字符，但是加上r后，它就是两个普通字符。</p><h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><p>（1）用%格式化字符串</p><p>其中%前面为字符串模板，%后面为元组，用于替换前面的格式占位符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"%saaaaaaaaaaa%s"</span> % (<span class="string">"start"</span>, <span class="string">"end"</span>)</span><br><span class="line"><span class="keyword">print</span> str1</span><br></pre></td></tr></table></figure><p>（2）使用str.format()格式化字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">madlib1 = <span class="string">"I &#123;verb&#125; the &#123;object&#125; off the &#123;place&#125;"</span>.format(verb=<span class="string">"took"</span>, object=<span class="string">"cheese"</span>, place=<span class="string">"table"</span>)</span><br><span class="line">madlib2 = <span class="string">"I &#123;&#125; the &#123;&#125; off the &#123;&#125;"</span>.format(<span class="string">"took"</span>, <span class="string">"cheese"</span>, <span class="string">"table"</span>)</span><br></pre></td></tr></table></figure><h1 id="其他一些字符串操作"><a href="#其他一些字符串操作" class="headerlink" title="其他一些字符串操作"></a>其他一些字符串操作</h1><p>（1）序列的通用操作</p><p>参见<a href="https://wangjianno1.github.io/2019/02/22/Python%E4%B8%AD%E5%BA%8F%E5%88%97%E7%9A%84%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C/">《Python中序列的通用操作》</a></p><p>（2）字符串切割</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">'ab,cde,fgh,ijk'</span></span><br><span class="line">print(str1.split(<span class="string">','</span>))  <span class="comment">#输出结果为['ab', 'cde', 'fgh', 'ijk']</span></span><br></pre></td></tr></table></figure><p>（3）字符串大小写转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">'Hello World'</span></span><br><span class="line"><span class="keyword">print</span> str.upper()       <span class="comment">#输出HELLO WORLD</span></span><br><span class="line"><span class="keyword">print</span> str.lower()       <span class="comment">#输出hello world</span></span><br></pre></td></tr></table></figure><p>（4）字符串去空格</p><p>rstrip()删除字符串末尾的空格，lstrip()删除字符串开头的空格，strip()在字符串上执行lstrip()和rstrip()。</p><p>学习资料参考于：<br><a href="http://blog.xiayf.cn/2013/01/26/python-string-format/" target="_blank" rel="noopener">http://blog.xiayf.cn/2013/01/26/python-string-format/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中控制逻辑语句</title>
      <link href="/2019/02/22/Python%E4%B8%AD%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/"/>
      <url>/2019/02/22/Python%E4%B8%AD%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expr_1:</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">elif</span> expr_2:</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>备注，if语句也可以组成Python的三元表达式，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = x <span class="keyword">if</span> expr <span class="keyword">else</span> y</span><br></pre></td></tr></table></figure><p>如上语句表示如果expr为True，三元表达式返回x，否则返回y。有点类似C/C++语言中<code>bool?a:b</code>表达式，但Python中并没有问号表达式。</p><h1 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> expr:</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><h1 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><h1 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h1><p>（1）遍历列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">citys = [<span class="string">'beijing'</span>, <span class="string">'shanghai'</span>, <span class="string">'chongqin'</span>, <span class="string">'tianjin'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> citys:</span><br><span class="line">    <span class="keyword">print</span> city</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(citys)):</span><br><span class="line">    <span class="keyword">print</span> citys[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">    <span class="keyword">print</span> i, num</span><br></pre></td></tr></table></figure><p>（2）遍历字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict_citys = &#123;<span class="string">'beijing'</span>: <span class="number">1</span>, <span class="string">'tianjin'</span>: <span class="number">2</span>, <span class="string">'chongqin'</span>: <span class="number">3</span>, <span class="string">'shanghai'</span>: <span class="number">4</span>&#125; </span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict_citys: </span><br><span class="line">    <span class="keyword">print</span> key, <span class="string">'corresponds to'</span>, dict_citys[key] </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dict_citys.items(): </span><br><span class="line">    <span class="keyword">print</span> key, <span class="string">'corresponds to'</span>, dict_citys[key]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中的列表生成式|字典生成式</title>
      <link href="/2019/02/22/Python%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%BC%8F/"/>
      <url>/2019/02/22/Python%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h1><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><p>举个例子，要生成列表<code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>，可以用<code>list(range(1, 11))</code>：</p><pre><code>&gt;&gt;&gt; list(range(1, 11))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code></pre><p>但如果要生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code>怎么做？方法一是循环：</p><pre><code>&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):...    L.append(x * x)...&gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></pre><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p><pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></pre><p>写列表生成式时，把要生成的元素<code>x * x</code>放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p><p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p><pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100]</code></pre><p>还可以使用两层循环，可以生成全排列：</p><pre><code>&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;][&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</code></pre><p>三层和三层以上的循环就很少用到了。</p><p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p><pre><code>&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到&gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录[&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;]</code></pre><p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：</p><pre><code>&gt;&gt;&gt; d = {&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; }&gt;&gt;&gt; for k, v in d.items():...     print(k, &apos;=&apos;, v)...y = Bx = Az = C</code></pre><p>因此，列表生成式也可以使用两个变量来生成list：</p><pre><code>&gt;&gt;&gt; d = {&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; }&gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()][&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;]</code></pre><p>最后把一个list中所有的字符串变成小写：</p><pre><code>&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;]&gt;&gt;&gt; [s.lower() for s in L][&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;]</code></pre><h1 id="字典生成式"><a href="#字典生成式" class="headerlink" title="字典生成式"></a>字典生成式</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key: value <span class="keyword">for</span> (key, value) <span class="keyword">in</span> iterable&#125;</span><br></pre></td></tr></table></figure><p>其中iterable是一个可迭代的对象，比如list，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org_dict = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">3</span>&#125;</span><br><span class="line">new_dict = &#123;v: k <span class="keyword">for</span> k,v <span class="keyword">in</span> some_dict.items()&#125;</span><br></pre></td></tr></table></figure><p>参考资料来源于：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431779637539089fd627094a43a8a7c77e6102e3a811000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431779637539089fd627094a43a8a7c77e6102e3a811000</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中字典的操作</title>
      <link href="/2019/02/22/Python%E4%B8%AD%E5%AD%97%E5%85%B8%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/02/22/Python%E4%B8%AD%E5%AD%97%E5%85%B8%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="字典对象的定义"><a href="#字典对象的定义" class="headerlink" title="字典对象的定义"></a>字典对象的定义</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接定义</span></span><br><span class="line">d = &#123;<span class="string">'zhangsan'</span>: <span class="string">'82781443'</span>, <span class="string">'lisi'</span>: <span class="string">'827866123'</span>, <span class="string">'wangwu'</span>: <span class="string">'82781203'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#用列表初始化</span></span><br><span class="line">items = [(<span class="string">'zhangsan'</span>, <span class="string">'82781443'</span>), (<span class="string">'lisi'</span>, <span class="string">'827866123'</span>), (<span class="string">'wangwu'</span>, <span class="string">'82781203'</span>)]</span><br><span class="line">d = dict(items)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用dict函数初始化</span></span><br><span class="line">d = dict(zhangsan=<span class="string">'82781443'</span>, lisi=<span class="string">'827866123'</span>, wangwu=<span class="string">'82781203'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用dict函数初始化</span></span><br><span class="line">d1 = &#123;<span class="string">'zhangsan'</span>: <span class="string">'82781443'</span>, <span class="string">'lisi'</span>: <span class="string">'827866123'</span>&#125;</span><br><span class="line">d2 = &#123;<span class="string">'wangwu'</span>: <span class="string">'82781203'</span>&#125;</span><br><span class="line">d = dict(d1, **d2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用列表，然后通过zip/dict来构造</span></span><br><span class="line">names = [<span class="string">'zhangsan'</span>, <span class="string">'lisi'</span>, <span class="string">'wangwu'</span>]</span><br><span class="line">contacts = [<span class="string">'82781443'</span>, <span class="string">'827866123'</span>, <span class="string">'82781203'</span>]</span><br><span class="line">d = dict(zip(names, contacts))</span><br></pre></td></tr></table></figure><h1 id="字典的操作"><a href="#字典的操作" class="headerlink" title="字典的操作"></a>字典的操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">len(d)   <span class="comment">#返回字典的key-value对的数量</span></span><br><span class="line">d[k]     <span class="comment">#取出字典d中key为k的值</span></span><br><span class="line">d[k]=v   <span class="comment">#给字典中指定的key赋值，若key在字典中不存在，则增加key-value键值对</span></span><br><span class="line"><span class="keyword">del</span> d[k] <span class="comment">#删除键为k的项</span></span><br><span class="line">k <span class="keyword">in</span> d   <span class="comment">#检查d中是否有含有键为k的项</span></span><br></pre></td></tr></table></figure><h2 id="字典对象方法"><a href="#字典对象方法" class="headerlink" title="字典对象方法"></a>字典对象方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">d.clear()            <span class="comment">#清除字典中所有的项</span></span><br><span class="line">d.copy()             <span class="comment">#浅拷贝</span></span><br><span class="line">d1 = deepcopy(d)     <span class="comment">#深拷贝</span></span><br><span class="line">d.get(<span class="string">'keyname'</span>)     <span class="comment">#获取key为keyname的元素值，如果不存在返回None</span></span><br><span class="line">d.has_key(<span class="string">'keyname'</span>) <span class="comment">#判断字典对象是否有key为keyname的元素</span></span><br><span class="line">d.pop(<span class="string">'keyname'</span>)     <span class="comment">#获取key为keyname的值，并将该key-value对从dict中移除</span></span><br><span class="line">d.popitem()          <span class="comment">#从字典对象中随机弹出弹出一个key-value对，并在dict中移除</span></span><br><span class="line">d.setdefault(<span class="string">'keyname'</span>, <span class="string">'valuename'</span>)  <span class="comment">#返回字典对象中key为keyname所对应的值。如果keyname在字典中不存在，那么会在字典中添加keyname:valuename键值对；如果keyname在字典中存在，那么直接过去该keyname对应的值</span></span><br><span class="line">d.update(x)                  <span class="comment">#使用字典x去更新字典d，若x的key在d中不存在就添加到d中；若x的key在d中存在，那么就会覆盖d中的value</span></span><br><span class="line">d.items()和d.iteritems()     <span class="comment">#items返回字典key-value的列表，iteritems返回所有key-value的迭代器</span></span><br><span class="line">d.keys()和d.iterkeys()       <span class="comment">#keys返回字典key的列表，iterkeys返回字典key的迭代器</span></span><br><span class="line">d.values()和d.itervalues()   <span class="comment">#values返回字典中所有value的列表，itervalues()返回字典中所有的value的迭代器</span></span><br><span class="line">&#123;&#125;.fromkeys([<span class="string">'keyname_1'</span>, <span class="string">'keyname_2'</span>])    <span class="comment">#生成一个&#123;'key1': None, 'key2': None&#125;的字典</span></span><br><span class="line">dict.fromkeys([<span class="string">'keyname_1'</span>, <span class="string">'keyname_2'</span>])  <span class="comment">#同上</span></span><br></pre></td></tr></table></figure><h1 id="字典实现原理"><a href="#字典实现原理" class="headerlink" title="字典实现原理"></a>字典实现原理</h1><p>Python dict的底层数据结构还是数组，但是元素添加以及获取，需要定位到在数组中的问题，使用的是哈希表的原理。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中集合的操作</title>
      <link href="/2019/02/22/Python%E4%B8%AD%E9%9B%86%E5%90%88%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/02/22/Python%E4%B8%AD%E9%9B%86%E5%90%88%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="set简介"><a href="#set简介" class="headerlink" title="set简介"></a>set简介</h1><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p><h1 id="set的创建"><a href="#set的创建" class="headerlink" title="set的创建"></a>set的创建</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = set(str)        <span class="comment">#使用字符串来构造集合</span></span><br><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment">#使用set函数，以list作为实参，即可构建一个集合对象。若list中有重复对象，会自动过滤掉</span></span><br></pre></td></tr></table></figure><h1 id="set的操作"><a href="#set的操作" class="headerlink" title="set的操作"></a>set的操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s.add(key)    <span class="comment">#往集合对象s中添加元素</span></span><br><span class="line">s.remove(key) <span class="comment">#删除集合对象s中某个元素</span></span><br><span class="line">s1 &amp; s2       <span class="comment">#集合对象s1和s2做交集</span></span><br><span class="line">s1 | s2       <span class="comment">#集合对象s1和s2做并集</span></span><br><span class="line">s1 - s2       <span class="comment">#集合对象s1和s2做差集，也就是s1有，s2无的元素</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中元组tuple的操作</title>
      <link href="/2019/02/22/Python%E4%B8%AD%E5%85%83%E7%BB%84tuple%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/02/22/Python%E4%B8%AD%E5%85%83%E7%BB%84tuple%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="python元组对象的定义"><a href="#python元组对象的定义" class="headerlink" title="python元组对象的定义"></a>python元组对象的定义</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">elements = <span class="string">'heilongjiang'</span>, <span class="string">'jilin'</span>, <span class="string">'liaoning'</span>    <span class="comment">#直接使用逗号分隔一些值，即可创建元组</span></span><br><span class="line">elements = (<span class="string">'heilongjiang'</span>, <span class="string">'jilin'</span>, <span class="string">'liaoning'</span>)  <span class="comment">#使用小括号</span></span><br><span class="line">elements = <span class="number">3</span>,       <span class="comment">#创建包含一个元素的元组，元素后面需要加上一个逗号</span></span><br><span class="line">elements = (<span class="number">4</span>,)     <span class="comment">#创建包含一个元素的元组，后面必须有一个逗号哦，如果没有的话，elements就是一个普通的值变量</span></span><br><span class="line">tuple([<span class="number">2</span>, <span class="number">5</span>,<span class="number">8</span>])     <span class="comment">#使用一个list来构造元组</span></span><br><span class="line">tuple(<span class="string">'wahaha'</span>)     <span class="comment">#使用一个字符串来构造元组</span></span><br><span class="line">tuple((<span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>))    <span class="comment">#使用一个元组来构造元组</span></span><br></pre></td></tr></table></figure><h1 id="python-tuple的操作"><a href="#python-tuple的操作" class="headerlink" title="python tuple的操作"></a>python tuple的操作</h1><p>就是序列的一些通用操作，例如索引、分片等。tuple是不可修改的序列。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中列表的操作</title>
      <link href="/2019/02/22/Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/02/22/Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Python列表对象的定义"><a href="#Python列表对象的定义" class="headerlink" title="Python列表对象的定义"></a>Python列表对象的定义</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elements = [<span class="string">'heilongjiang'</span>, <span class="string">'jilin'</span>, <span class="string">'liaoning'</span>]</span><br><span class="line">list(<span class="string">'wahaha'</span>)  <span class="comment">#输出['w', 'a', 'h', 'a', 'h', 'a']</span></span><br></pre></td></tr></table></figure><h1 id="Python列表list的操作"><a href="#Python列表list的操作" class="headerlink" title="Python列表list的操作"></a>Python列表list的操作</h1><p>（1）序列的通用操作</p><p>（2）特殊操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst[index] = value  <span class="comment">#对指定元素赋值</span></span><br><span class="line"><span class="keyword">del</span> lst[index]      <span class="comment">#删除index位置处的元素</span></span><br></pre></td></tr></table></figure><p>（3）列表对象的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lst.append(value)        <span class="comment">#在列表尾部新增一个元素</span></span><br><span class="line">lst.count(value)         <span class="comment">#统计列表中value元素出现的次数</span></span><br><span class="line">lst_a.extend(lst_b)      <span class="comment">#将lst_b中的所有元素追加到lst_a列表对象中。注意与lst_a + lst_b的区别，extend不会新增一个新的list出来</span></span><br><span class="line">lst.index(value)         <span class="comment">#列表lst中value第一次出现的索引位置</span></span><br><span class="line">lst.insert(index, value) <span class="comment">#将value元素插入到列表的index位置</span></span><br><span class="line">lst.pop()                <span class="comment">#返回列表最后一个元素，并从列表中移除该元素</span></span><br><span class="line">lst.pop(index)           <span class="comment">#返回列表中index位置处的元素，并从列表中移除</span></span><br><span class="line">lst.remove(value)        <span class="comment">#移除列表中第一个值为value的元素，remove没有返回值，注意与pop的区别</span></span><br><span class="line">lst.reverse()            <span class="comment">#对列表中元素倒置，是直接对列表进行修改</span></span><br><span class="line">lst.sort()               <span class="comment">#对列表在原位置进行排序，注意sort函数有三个关键字参数cmp，key，reverse，其中cmp和key都是一个函数，cmp函数有两个参数，函数内容用来自定义比较的规则。key函数有一个参数，函数内容用来返回cmp函数要比较的key。这个用法同内置的sorted函数是一样的</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中序列的通用操作</title>
      <link href="/2019/02/22/Python%E4%B8%AD%E5%BA%8F%E5%88%97%E7%9A%84%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/02/22/Python%E4%B8%AD%E5%BA%8F%E5%88%97%E7%9A%84%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="序列通用操作"><a href="#序列通用操作" class="headerlink" title="序列通用操作"></a>序列通用操作</h1><p>Python中序列包括列表list、元组tuple、字符串、Unicode字符串、buffer对象以及xrange对象六种。对于Python中的序列，有一些通用的操作，如索引、分片、加、乘、成员资格判断以及内建函数等等。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>序列中的元素都是有编号的，从0开始递增。我们可以使用<code>sequence[index]</code>的方式访问序列中第index位置处的元素。注意index可以是正数，也可以是负数。-1表示的最后一个元素，-2表示倒数第二个元素，依次类推。举例来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">'beijing'</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">2</span>]         <span class="comment">#输出为i</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'shanghai'</span>[<span class="number">3</span>]  <span class="comment">#输出为n</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'wuhan'</span>[<span class="number">-2</span>]    <span class="comment">#输出a</span></span><br></pre></td></tr></table></figure><h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><p>与使用索引来访问单个元素类似，可以使用分片操作来访问一定范围内的元素，即使用<code>sequence[start:end]</code>来访问序列中若干元素。关于分片有几个需要注意的点：</p><p>（1）使用<code>sequence[start:end]</code>可以获取到序列中大于等于start，小于end范围内的元素。注意不包括end所在位置处的元素</p><p>（2）<code>sequence[start:end]</code>中start和end可以是正数，也可以是负数。-1表示是最后一个元素所对应的索引</p><p>（3）<code>sequence[start:end]</code>中start所指的元素要出现在end所指的元素的前面。否则分片的结果是一个空list</p><p>（4）<code>sequence[start:end]</code>中，若start省略掉，表示从第一个元素开始。若end省略掉，表示分片直到最后一个元素结束。注意end省略，和-1的效果是不一样的哦，若为-1的话，分片的结果是不包括最后一个元素的。而end省略，是包括最后一个元素的。</p><p>（5）<code>sequence[start:end:step]</code>可以使用指定的步长step来分片，步长step可以是正数，也可以是负数。如果step是正数，那么分片会从序列的头部开始向右提取元素。如果step是负数，那么分片会从序列的尾部开始向左提取元素。举例来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">elements = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">print</span> elements[<span class="number">2</span>:<span class="number">4</span>]     <span class="comment">#输出[3, 4]</span></span><br><span class="line"><span class="keyword">print</span> elements[<span class="number">-3</span>:<span class="number">-1</span>]   <span class="comment">#输出[8, 9]</span></span><br><span class="line"><span class="keyword">print</span> elements[<span class="number">-3</span>:<span class="number">0</span>]    <span class="comment">#输出[],因为-3所指的元素在0所指的元素的后面</span></span><br><span class="line"><span class="keyword">print</span> elements[:<span class="number">3</span>]      <span class="comment">#输出[1, 2, 3]</span></span><br><span class="line"><span class="keyword">print</span> elements[<span class="number">-3</span>:]     <span class="comment">#输出[8, 9, 10]</span></span><br><span class="line"><span class="keyword">print</span> elements[:]       <span class="comment">#copy出一个新的elements列表</span></span><br><span class="line"><span class="keyword">print</span> elements[<span class="number">-3</span>:<span class="number">-1</span>]   <span class="comment">#输出[8, 9]</span></span><br><span class="line"><span class="keyword">print</span> elements[<span class="number">0</span>:<span class="number">10</span>:<span class="number">2</span>]  <span class="comment">#输出[1, 3, 5, 7, 9]</span></span><br><span class="line"><span class="keyword">print</span> elements[<span class="number">10</span>:<span class="number">0</span>:<span class="number">-2</span>] <span class="comment">#输出[10, 8, 6, 4, 2]</span></span><br><span class="line"><span class="keyword">print</span> elements[::<span class="number">-1</span>]    <span class="comment">#输出[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]，相当于翻转了列表</span></span><br></pre></td></tr></table></figure><h1 id="加"><a href="#加" class="headerlink" title="加"></a>加</h1><p>通过使用加号+可以进行序列的连接操作，举例来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]  <span class="comment">#输出[1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'hello'</span> + <span class="string">'world'</span>      <span class="comment">#输出helloworld</span></span><br></pre></td></tr></table></figure><h1 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h1><p>用序列乘以一个数字n会生成一个新的序列，而在新的序列中，原来的序列将被重复n次。举例来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">'python'</span> * <span class="number">2</span>  <span class="comment">#输出pythonpython</span></span><br><span class="line"><span class="keyword">print</span> [<span class="number">2</span>, <span class="number">3</span>] * <span class="number">3</span>    <span class="comment">#输出[2, 3, 2, 3, 2, 3]</span></span><br><span class="line"><span class="keyword">print</span> [<span class="literal">None</span>] * <span class="number">2</span>    <span class="comment">#输出[None, None]</span></span><br></pre></td></tr></table></figure><h1 id="成员资格判断"><a href="#成员资格判断" class="headerlink" title="成员资格判断"></a>成员资格判断</h1><p>可以使用<code>in</code>操作符，来检查一个值是否在序列中。举例来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">'helloworld'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'w'</span> <span class="keyword">in</span> str   <span class="comment">#输出为True</span></span><br></pre></td></tr></table></figure><h1 id="通用的内建函数"><a href="#通用的内建函数" class="headerlink" title="通用的内建函数"></a>通用的内建函数</h1><p>一些Python内建函数，可以作用于序列。比如<code>len</code>、<code>min</code>以及<code>max</code>等。举例来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">elements = [<span class="number">34</span>, <span class="number">56</span>, <span class="number">13</span>]</span><br><span class="line"><span class="keyword">print</span> max(elements)</span><br><span class="line"><span class="keyword">print</span> min(elements)</span><br><span class="line"><span class="keyword">print</span> len(elements)</span><br><span class="line"><span class="keyword">print</span> max(<span class="number">3</span>, <span class="number">5</span>)     <span class="comment">#这里并没有使用序列，注意</span></span><br><span class="line"><span class="keyword">print</span> min(<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>)  <span class="comment">#这里并没有使用序列，注意</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中各种数据类型</title>
      <link href="/2019/02/22/Python%E4%B8%AD%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/02/22/Python%E4%B8%AD%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中基本数据类型"><a href="#Python中基本数据类型" class="headerlink" title="Python中基本数据类型"></a>Python中基本数据类型</h1><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>例如整型、长整型（字面值后面带有L，如100L）、浮点型、布尔型等。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器，包括序列、映射、集合等。</p><p>（1）序列</p><p>Python内置的序列有六种，</p><pre><code>列表list，如[12, 34, 45]元组tuple，称为不可变的序列，如(12, 34, 45) 字符串Unicode字符串buffer对象xrange对象</code></pre><p>备注：元组的定义可以有左右括号，也可以没有，比如上面的例子可以直接用<code>12, 34, 45</code>的效果是一样的。</p><p>（2）映射</p><p>映射类型有，</p><pre><code>字典dict，如{&apos;Beth&apos;: &apos;9102&apos;, &apos;Alice&apos;: &apos;2341&apos;, &apos;Cecil&apos;: &apos;3258&apos;}还有其他的，待补充</code></pre><p>（3）集合</p><p>待补充</p><h1 id="Python中抽象数据类型"><a href="#Python中抽象数据类型" class="headerlink" title="Python中抽象数据类型"></a>Python中抽象数据类型</h1><p>类</p><h1 id="Python中各种数据类型的转换"><a href="#Python中各种数据类型的转换" class="headerlink" title="Python中各种数据类型的转换"></a>Python中各种数据类型的转换</h1><p>参见<a href="http://www.cnblogs.com/linjiqin/p/3674356.html" target="_blank" rel="noopener">《python字符串/元组/列表/字典互转》</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>API设计中的流控|服务降级|服务熔断机制</title>
      <link href="/2019/02/22/API%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%B5%81%E6%8E%A7-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7-%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/02/22/API%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%B5%81%E6%8E%A7-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7-%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="限流或流控"><a href="#限流或流控" class="headerlink" title="限流或流控"></a>限流或流控</h1><p>限流或流控指得是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理。</p><p>流控中主要涉及到几种算法，即固定时间窗口限流算法、滑动时间窗口限流算法、漏桶算法和令牌桶算法。目前使用较多的还是漏桶算法和令牌桶算法，尤其是令牌桶算法。</p><p>（1）漏桶算法</p><p>漏桶算法（Leaky Bucket）是网络世界中流量整形（Traffic Shaping）或速率限制（Rate Limiting）时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。</p><p><img src="/images/ms_flowctrl_1_1.png" alt></p><p>如上图所示，把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。漏桶算法能强行限制水流的速度。</p><p>简单来说，用户单位时间内请求量可以无限大，但是系统的处理请求的速度是固定的。当单位时间内的请求量到达一定量时，就会被拒绝。</p><p>（2）令牌桶算法</p><p>令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。</p><p>令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。</p><p><img src="/images/ms_flowctrl_1_2.png" alt></p><p>需要注意的是，令牌桶算法比漏桶算法更加灵活，令牌桶算法在一定条件下，能够支持突发流量的处理。</p><p>在令牌桶算法的一些具体实现库中，如Golang的time.rate库，就是基于令牌桶算法实现的限流器，在构造令牌桶时，会有两个参数，一个是limit，一个是burst，limit表示每秒往令牌桶的放入多少个Token，burst表示令牌桶的容量，也就是能应对的最大突发流量。</p><h1 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h1><p>简单来说，当服务A调用服务B，当服务B出现异常且达到一定的异常条件时，服务A干脆就调用一个类似于本地方法（也即备用方案）来代替服务B。</p><h1 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h1><p>熔断就跟保险丝一样，当一个服务请求并发特别大，服务已经招架不住了，调用错误率飙升，当错误率达到一定阈值后，就将这个服务熔断了。熔断之后，后续的请求就不会再请求这个服务了。</p><h1 id="Hystrix组件"><a href="#Hystrix组件" class="headerlink" title="Hystrix组件"></a>Hystrix组件</h1><p>目前Netflix公司的开源组件Hystrix就已经对服务降级和服务熔断有了很好的支持。</p><p>学习资料参考于：<br><a href="https://www.infoq.cn/article/qg2tx8fyw5vt-f3hh673" target="_blank" rel="noopener">https://www.infoq.cn/article/qg2tx8fyw5vt-f3hh673</a><br><a href="https://www.jianshu.com/p/a59c13e70582" target="_blank" rel="noopener">https://www.jianshu.com/p/a59c13e70582</a><br><a href="http://www.voidcn.com/article/p-nrrhpwdv-bob.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-nrrhpwdv-bob.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生成环境中DPVS集群部署</title>
      <link href="/2019/02/21/%E7%94%9F%E6%88%90%E7%8E%AF%E5%A2%83%E4%B8%ADDPVS%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/02/21/%E7%94%9F%E6%88%90%E7%8E%AF%E5%A2%83%E4%B8%ADDPVS%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="DPVS集群部署网络结构"><a href="#DPVS集群部署网络结构" class="headerlink" title="DPVS集群部署网络结构"></a>DPVS集群部署网络结构</h1><p>在DPVS架构中有三个部分，分别是客户端、LB（即DPVS）以及RS。所谓one-arm指的是客户端和RS在同一个逻辑网络中，也就是DPVS上只有一个网卡，该网卡即连接客户端网络，也连接RS所在的网络。所有two-arm指的是用户和RS不在同一个逻辑网络中，也就是DPVS上需要有两块网卡，一块网卡连接客户端网络，一块网卡连接RS所在的网络。</p><p>one-arm的架构图如下：</p><p><img src="/images/dpvs_deploy_1_1.png" alt></p><p>two-arm的架构图如下：</p><p><img src="/images/dpvs_deploy_1_2.png" alt></p><h1 id="搭建单DPVS实例步骤"><a href="#搭建单DPVS实例步骤" class="headerlink" title="搭建单DPVS实例步骤"></a>搭建单DPVS实例步骤</h1><p>以搭建two-arm结构的DPVS FULLNAT集群为例来说明，拓扑结构如下：</p><p><img src="/images/dpvs_deploy_1_2.png" alt></p><p>（1）准备操作系统、内核、GCC等编译环境</p><p>（2）下载dpvs、dpdk代码，并编译安装</p><p>（3）修改配置文件，如需要被DPVS接管网卡的名称、绑核、大页内存等配置，并启动dpvs</p><p>此时执行<code>./dpip link show</code>命令，就可以看到dpdk已经托管了网卡，命令输出结果类似如下：</p><pre><code>1: dpdk0: socket 0 mtu 1500 rx-queue 8 tx-queue 8    UP 10000 Mbps full-duplex fixed-nego promisc-off    addr A0:36:9F:9D:61:F4 OF_RX_IP_CSUM OF_TX_IP_CSUM OF_TX_TCP_CSUM OF_TX_UDP_CSUM</code></pre><p>（4）配置DPVS的工作模式</p><p>包括dpdk网卡ip配置，路由配置，添加vip服务，添加rs服务，添加localip等等，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为dpdk1网卡配置ip，该ip将作为vip</span></span><br><span class="line">./dpip addr add 10.0.0.100/32 dev dpdk1</span><br><span class="line"></span><br><span class="line"><span class="comment">#为dpdk1和dpdk0配置同网段路由</span></span><br><span class="line">./dpip route add 10.0.0.0/16 dev dpdk1</span><br><span class="line">./dpip route add 192.168.100.0/24 dev dpdk0</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加vip服务</span></span><br><span class="line">./ipvsadm -A -t 10.0.0.100:80 -s rr</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加rs ip，-b表示是FULLNAT模式</span></span><br><span class="line">./ipvsadm -a -t 10.0.0.100:80 -r 192.168.100.2 -b</span><br><span class="line">./ipvsadm -a -t 10.0.0.100:80 -r 192.168.100.3 -b</span><br><span class="line"></span><br><span class="line"><span class="comment">#在dpdk0网卡上配置local ip</span></span><br><span class="line">./ipvsadm --add-laddr -z 192.168.100.200 -t 10.0.0.100:80 -F dpdk0</span><br></pre></td></tr></table></figure><p>（5）测试</p><p>执行命令<code>./dpip addr show</code>测试，命令输出结果如下：</p><pre><code>inet 10.0.0.100/32 scope global dpdk1     valid_lft forever preferred_lft foreverinet 192.168.100.200/32 scope global dpdk0     valid_lft forever preferred_lft forever sa_used 0 sa_free 1032176 sa_miss 0</code></pre><p>执行命令<code>./dpip route show</code>测试，命令输出结果如下：</p><pre><code>inet 10.0.0.100/32 via 0.0.0.0 src 0.0.0.0 dev dpdk1 mtu 1500 tos 0 scope host metric 0 proto autoinet 192.168.100.200/32 via 0.0.0.0 src 0.0.0.0 dev dpdk0 mtu 1500 tos 0 scope host metric 0 proto autoinet 192.168.100.0/24 via 0.0.0.0 src 0.0.0.0 dev dpdk0 mtu 1500 tos 0 scope link metric 0 proto autoinet 10.0.0.0/16 via 0.0.0.0 src 0.0.0.0 dev dpdk1 mtu 1500 tos 0 scope link metric 0 proto auto</code></pre><p>执行命令<code>./ipvsadm -ln</code>测试，命令输出结果如下：</p><pre><code>IP Virtual Server version 0.0.0 (size=0)Prot LocalAddress:Port Scheduler Flags  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  10.0.0.100:80 rr  -&gt; 192.168.100.2:80             FullNat 1      0          0  -&gt; 192.168.100.3:80             FullNat 1      0          0</code></pre><p>执行命令<code>curl http://10.0.0.100</code>进行测试验证。</p><h1 id="DPVS的高可用部署方案"><a href="#DPVS的高可用部署方案" class="headerlink" title="DPVS的高可用部署方案"></a>DPVS的高可用部署方案</h1><p>目前有两种模式构建高可用DPVS集群，一种是OSPF/ECMP，另一种是Master/Backup。OSPF/ECMP模式需要路由器模拟软件Quagga的支持，Master/Backup主备模式需要用到keepalived。</p><p>（1）OSPF/ECMP + DPVS FULLNAT架构的部署</p><p>首先在每台机器上按FULLNAT模式部署单DPVS实例，然后需要配置路由器模拟软件，需要使用Quagga软件，在每台DPVS上需要配置<code>/etc/quagga/ospfd.conf</code>，具体如下：</p><pre><code>network 210.34.183.21/32 area 0.0.0.20network 210.34.183.22/32 area 0.0.0.20network 210.34.183.23/32 area 0.0.0.20network 210.34.183.24/32 area 0.0.0.20network 210.34.183.25/32 area 0.0.0.20network 210.34.183.26/32 area 0.0.0.20</code></pre><p>然后DPVS上联的路由器就会分别形成到目的地址210.34.183.21-26的多条等价路由，然后又ECMP的HASH规则将数据包转发到不同的RS上。以目的地址210.34.183.21/32为例，在路由器上会形成如下的路由：</p><pre><code>210.34.183.21/32 via 172.10.0.0.2 dev eth0210.34.183.21/32 via 172.10.0.0.3 dev eth0210.34.183.21/32 via 172.10.0.0.4 dev eth0</code></pre><p>这里172.10.0.0.2-4是我们的三个DPVS实例。</p><p>（2）OSPF/ECMP + DPVS SNAT架构的部署</p><p>首先在每台机器上按SNAT模式部署单DPVS实例，然后需要配置路由器模拟软件，需要使用Quagga软件，在每台DPVS上需要配置<code>/etc/quagga/ospfd.conf</code>，具体如下：</p><pre><code>network 172.10.0.0/30 area 0.0.0.10  #通告ospf内敛地址network 172.10.0.100/32 area 0.0.0.10  #通告一个vip地址</code></pre><p>备注：这里每台DPVS实例上都需要一条<code>network 172.10.0.100/32 area 0.0.0.10</code>，然后上联路由器会认为172.10.0.100/32是一个vip，上联路由器将缺省路由指向172.10.0.100/32，然后就可以是各个dpvs均摊流量了，这里有些不理解，待推敲。</p><p>（3）Keepalived + DPVS SNAT架构的部署</p><p>利用dpvs包中的keepalived配置一个漂移IP即可，然后上联交换机指向这个漂移IP即可。</p><p>学习资料参考于：<br><a href="https://github.com/iqiyi/dpvs/blob/master/doc/tutorial.md" target="_blank" rel="noopener">https://github.com/iqiyi/dpvs/blob/master/doc/tutorial.md</a></p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DPVS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等价多路由ECMP技术</title>
      <link href="/2019/02/21/%E7%AD%89%E4%BB%B7%E5%A4%9A%E8%B7%AF%E7%94%B1ECMP%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/02/21/%E7%AD%89%E4%BB%B7%E5%A4%9A%E8%B7%AF%E7%94%B1ECMP%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="等价多路由ECMP简介"><a href="#等价多路由ECMP简介" class="headerlink" title="等价多路由ECMP简介"></a>等价多路由ECMP简介</h1><p>ECMP，Equal-Cost Multipath Routing，中文为等价多路径，表示存在多条不同链路路由到达同一目的地址的网络环境中。如果使用传统的路由技术，发往该目的地址的数据包只能利用其中的一条链路，其它链路处于备份状态或无效状态，并且在动态路由环境下相互的切换需要一定时间，而等值多路径路由协议可以在该网络环境下同时使用多条链路，不仅增加了传输带宽，并且可以无时延无丢包地备份失效链路的数据传输。</p><p>ECMP最大的特点是实现了等值情况下，多路径负载均衡和链路备份的目的，在静态路由和OSPF中基本上都支持ECMP功能。但是实际情况是，各路径的带宽、时延和可靠性等不一样，把Cost认可成一样，不能很好地利用带宽，尤其在路径间差异大时，效果会非常不理想。例如，路由器两个出口，两路径，一个带宽是100M，一个是2M，如果部署是ECMP，则网络总带宽只能达到4M的利用率。</p><p>为了实现负载分担，安全设备可以提供ECMP功能，对于每个接口去往同一目的的流量，支持最大3条等价路径。通过<strong>一个计算源和目的IP地址散列值的算法，安全设备可以在特定网关之间实现流量的负载分担</strong>。要注意的是，这并不能确保在这些网关中的流量分配是完全均等的。在下面的例子中，去往目的网络10.1.1.0/24有3条等价路径，它们会把流量发送给外部接口的3个不同的网关：</p><p><img src="/images/network_ecmp_1_1.png" alt></p><p>同样，每台设备也可以定义最多不超过3条的等价默认路由。在下面的例子中，3条等价默认路由会把流量发送给外部接口的3个不同的网关：</p><p><img src="/images/network_ecmp_1_2.png" alt></p><p>需要注意的是，<strong>ECMP可以将一个报文，按照一定的HASH策略，HASH到一条指定的路由上，这样可以保证某一个网络会话能总是被HASH到一条路由上，也就是发送到同一个目的地址上</strong>。这个在采用ECMP+OSPF的大型DPVS集群中有很大的作用哦。</p><p>学习资料参考于：<br><a href="http://blog.sina.com.cn/s/blog_40952fbf01018jy3.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_40952fbf01018jy3.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开源路由器模拟软件Quagga</title>
      <link href="/2019/02/20/%E5%BC%80%E6%BA%90%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A8%A1%E6%8B%9F%E8%BD%AF%E4%BB%B6Quagga/"/>
      <url>/2019/02/20/%E5%BC%80%E6%BA%90%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A8%A1%E6%8B%9F%E8%BD%AF%E4%BB%B6Quagga/</url>
      
        <content type="html"><![CDATA[<h1 id="Quagga简介"><a href="#Quagga简介" class="headerlink" title="Quagga简介"></a>Quagga简介</h1><p>Quagga是一个开源路由软件套件，可以将Linux变成支持如RIP、OSPF、BGP和IS-IS等主要路由协议的路由器。它具有对IPv4和IPv6的完整支持，并支持路由/前缀过滤。Quagga可以是你生命中的救星，以防你的生产路由器一旦宕机，而你没有备用的设备而只能等待更换。通过适当的配置，Quagga甚至可以作为生产路由器。</p><p>Quagga可以模拟很多的路由协议，如BGP、OSPF、OSPFv6、RIP以及RIPng等等。</p><h1 id="Quagga的安装和使用"><a href="#Quagga的安装和使用" class="headerlink" title="Quagga的安装和使用"></a>Quagga的安装和使用</h1><p>我们执行命令<code>yum install quagga</code>即可安装Quagga路由软件，命令结束后会在系统上安装如下的工具服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/zebra</span><br><span class="line">/usr/sbin/bgpd</span><br><span class="line">/usr/sbin/ospf6d</span><br><span class="line">/usr/sbin/ospfd</span><br><span class="line">/usr/sbin/isisd</span><br><span class="line">/usr/sbin/ripd</span><br><span class="line">/usr/sbin/ripngd</span><br><span class="line">/usr/sbin/babeld</span><br></pre></td></tr></table></figure><p>其中zebra是Quagga的核心守护进程，负责内核接口和静态路由。bgpd、ospfd以及ospf6d等守护进程就是用来模拟具体路由协议算法的。当bgpd、ospfd以及ospf6d等守护进程学习到了新的路由规则，就会调用zebra来更新系统的路由表。我们可以通过<code>service start xxxd</code>来启动其中的任一个守护进程。</p><h1 id="使用Quagga配置支持OSPF协议的路由器"><a href="#使用Quagga配置支持OSPF协议的路由器" class="headerlink" title="使用Quagga配置支持OSPF协议的路由器"></a>使用Quagga配置支持OSPF协议的路由器</h1><p><img src="/images/network_ospf_1_1.png" alt></p><p>在上面的例子中，有两个网络环境，一个是192.168.1.0/24，一个是172.16.1.0/24。现在我们想使用site-A-PTR和site-B-PTR两台普通的Linux服务器来搭建两台路由器。两个路由器之间的连接使用的是对等网络10.10.10.0/30。</p><p>（1）配置zebra</p><p>在site-A-PTR上配置<code>/etc/quagga/zebra.conf</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log file /var/log/quagga/quagga.log</span><br><span class="line">interface eth0</span><br><span class="line">ip address 10.10.10.1/30</span><br><span class="line">description to-site-B</span><br><span class="line">interface eth1</span><br><span class="line">ip address 192.168.1.1/24</span><br><span class="line">description to-site-A-LAN</span><br></pre></td></tr></table></figure><p>然后再site-B-PTR上配置<code>/etc/quagga/zebra.conf</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log file /var/log/quagga/quagga.log</span><br><span class="line">interface eth0</span><br><span class="line">ip address 10.10.10.1/30</span><br><span class="line">description to-site-B</span><br><span class="line">interface eth1</span><br><span class="line">ip address 172.17.1.1/24</span><br><span class="line">description to-site-B-LAN</span><br></pre></td></tr></table></figure><p>（2）配置OSPF</p><p>在site-A-PTR上配置<code>/etc/quagga/ospfd.conf</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router ospf</span><br><span class="line">router-id site-a-ptr</span><br><span class="line">network 10.10.10.0/30 area 0</span><br><span class="line">network 192.168.1.0/24 area 0</span><br></pre></td></tr></table></figure><p>在site-B-PTR上配置<code>/etc/quagga/ospfd.conf</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router ospf</span><br><span class="line">router-id site-b-ptr</span><br><span class="line">network 10.10.10.0/30 area 0</span><br><span class="line">network 172.16.1.0/24 area 0</span><br></pre></td></tr></table></figure><p>备注：如上<code>network 10.10.10.0/30 area 0</code>，表示ospf对周边的路由器公布，凡是目的地址是10.10.10.0/30这个段的数据包，发送给我就好啦。</p><p>学习资料参考于：<br><a href="https://linux.cn/article-4232-1.html" target="_blank" rel="noopener">https://linux.cn/article-4232-1.html</a><br><a href="https://linux.cn/article-4232-2.html" target="_blank" rel="noopener">https://linux.cn/article-4232-2.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NAT原理及NAT技术实现</title>
      <link href="/2019/02/20/NAT%E5%8E%9F%E7%90%86%E5%8F%8ANAT%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/02/20/NAT%E5%8E%9F%E7%90%86%E5%8F%8ANAT%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="NAT简介"><a href="#NAT简介" class="headerlink" title="NAT简介"></a>NAT简介</h1><p>NAT，Network Address Translation，中文为网络地址转换。NAT是一个IETF（Internet Engineering Task Force，Internet工程任务组）标准，允许一个整体机构以一个公用IP（Internet Protocol）地址出现在Internet上。顾名思义，它是一种把内部私有网络地址（IP地址）翻译成公网网络IP地址的技术。因此我们可以认为，NAT在一定程度上，能够有效的解决公网IPv4地址不足的问题。</p><p>NAT功能通常被集成到路由器、防火墙、ISDN路由器或者单独的NAT设备中。比如Cisco路由器中已经加入这一功能，网络管理员只需在路由器的IOS中设置NAT功能，就可以实现对内部网络的屏蔽。再比如防火墙将WEB Server的内部地址192.168.1.1映射为外部地址202.96.23.11，外部访问202.96.23.11地址实际上就是访问访问192.168.1.1。</p><h1 id="NAT的分类"><a href="#NAT的分类" class="headerlink" title="NAT的分类"></a>NAT的分类</h1><p>NAT有三种类型，如下：</p><p><img src="/images/network_nat_1_1.png" alt></p><p>（1）静态NAT（Static NAT）</p><p>静态NAT是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。因此，静态NAT并不能解决IP地址短缺的问题。 </p><p>（2）动态NAT（Pooled NAT）</p><p>动态NAT是指将内部网络的私有IP地址转换为公用IP地址时，IP地址对是不确定的，而是随机的，所有被授权访问上Internet的私有IP地址可随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行动态转换。动态转换可以使用多个合法外部地址集。当ISP提供的合法IP地址略少于网络内部的计算机数量时，可以采用动态转换的方式。 </p><p>（3）网络地址端口转换NAPT（Port-Level NAT）</p><p>网络地址端口转换NAPT（Network Address Port Translation）则是把内部地址映射到外部网络的一个IP地址的不同端口上。<strong>它可以将中小型的网络隐藏在一个合法的IP地址后面</strong>。NAPT与动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，<strong>同时在该地址上加上一个由NAT设备选定的端口号</strong>。</p><p>NAPT是使用最普遍的一种转换方式，它又包含三种转换方式，即SNAT，DNAT和FULL-NAT(SNAT+DNAT)。简单来说，若NAT网关在处理数据包时，只修改数据包的SRC IP，称为SNAT；若NAT网关在处理数据包时，只修改数据包的DEST IP，称为DNAT；若NAT网关在处理数据包时，即修改了SRC IP也修改了DEST IP，则称为FULL-NAT。</p><p>如下NAT网关，在收到局域网的数据包，做SNAT转换，即将源地址修改为公网地址。与此同时，连接跟踪模块ip_conntrack/nf_conntrack将本次的网络通信连接记录到连接跟踪表Track Table中。当公网服务器的响应数据包到达NAT网关时，NAT网关根据连接跟踪表Trace Table来查出响应数据包的实际归属客户机的私网地址，并做DNAT转换，即将目的地址修改为客户机的私网地址。值得注意的是，这个过程中包括了SNAT和DNAT，但这不称为是FULL-NAT，因为FULL-NAT是在数据包达到NAT网关后就做SNAT和DNAT，然后等响应数据包转发到NAT网关时，还做SNAT和DNAT。</p><p><img src="/images/network_nat_1_2.png" alt></p><p>备注：注意这里的Track Table，非常重要哦，它记录了每一个连接，并将不同的连接绑定到NAT公网IP的不同端口号上。</p><p>3.NAT的技术实现</p><p>（1）iptables</p><p>（2）LVS SNAT模式，需要打阿里的SNAT patch包</p><p>（3）DPDK-LVS SNAT模式</p><p>学习资料参考于：<br><a href="https://blog.csdn.net/hzhsan/article/details/45038265" target="_blank" rel="noopener">https://blog.csdn.net/hzhsan/article/details/45038265</a><br><a href="http://www.forz.site/2017/06/25/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">http://www.forz.site/2017/06/25/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</a><br><a href="http://blog.51cto.com/lustlost/943110" target="_blank" rel="noopener">http://blog.51cto.com/lustlost/943110</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPU与IO设备数据交互方式</title>
      <link href="/2019/02/20/CPU%E4%B8%8EIO%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/02/20/CPU%E4%B8%8EIO%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU与IO设备交互"><a href="#CPU与IO设备交互" class="headerlink" title="CPU与IO设备交互"></a>CPU与IO设备交互</h1><p>CPU与IO设备的数据交换方式主要有程序查询方式、程序中断方式以及DMA方式三种。</p><h1 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h1><p>CPU按照IO设备的优先级按序查询IO设备是否已有数据准备就绪。</p><p><img src="/images/cpu_io_1_1.png" alt></p><h1 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h1><p>当IO设置有数据准备就绪时，就向操作系统发起中断信号，然后又操作系统启动中断处理程序，来响应IO设备。</p><h1 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h1><p>DMA，全称为Direct Memory Access，直接内存存取。DMA传输将数据从一个地址空间复制到另外一个地址空间。当CPU初始化这个传输动作，传输动作本身是由DMA 控制器来实行和完成。在实现DMA传输时，是由DMA控制器直接掌管总线，因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器，而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。</p><p>简单来说，有了DMA控制器，在使用DMA控制器将IO设备的数据复制到内存时，就不需要CPU去执行任何指令啦，CPU继续做其他的工作，完全交由DMA控制器来处理（相当于DMA控制器在执行指令进行数据的复制操作）。下图是程序中断方式和DMA方式的区别示意图：</p><p><img src="/images/cpu_io_1_2.png" alt></p><p>学习资料参考于：<br>唐朔飞版《计算机组成原理》</p>]]></content>
      
      
      <categories>
          
          <category> HardWare </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之内存管理</title>
      <link href="/2019/02/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2019/02/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的内存管理方式"><a href="#操作系统的内存管理方式" class="headerlink" title="操作系统的内存管理方式"></a>操作系统的内存管理方式</h1><p>操作系统的内存管理方式主要有连续分配方式、分页存储管理方式、分段存储管理方式以及段页式存储管理方式四种。</p><p>（1）连续分配方式</p><p>连续分配方式，是指操作系统为一个用户程序分配一个连续的内存空间。这种分配方式曾被广泛应用于20世纪60～70年代的OS中，它至今仍在内存分配方式中占有一席之地。又可把连续分配方式进一步分为单一连续分配、固定分区分配、动态分区分配以及动态重定位分区分配四种方式。</p><p>连续分配方式会形成许多“碎片”，虽然可通过“紧凑”方法将许多碎片拼接成可用的大块空间，但须为之付出很大开销。如果允许将一个进程直接分散地装入到许多不相邻接的分区中，则无须再进行“紧凑”。基于这一思想而产生了离散分配方式。如果离散分配的基本单位是页，则称为分页存储管理方式；如果离散分配的基本单位是段，则称为分段存储管理方式。</p><p>（2）分页存储管理方式</p><ul><li>页面和物理块</li></ul><p>分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，从0开始，如第0页、第1页等。相应地，也把内存空间分成与页面相同大小的若干个存储块，称为（物理）块或页框（frame），也同样为它们加以编号，如 0#块、1#块等等。在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。</p><ul><li>页面大小的选择</li></ul><p>在分页系统中的页面其大小应适中。页面若太小，一方面虽然可使内存碎片减小，从而减少了内存碎片的总空间，有利于提高内存利用率，但另一方面也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存；此外，还会降低页面换进换出的效率。然而，如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。因此，页面的大小应选择适中，且页面大小应是2的幂，通常为512B～8KB。</p><ul><li>页表</li></ul><p>在分页系统中，允许将进程的各个页离散地存储在内存不同的物理块中，但系统应能保证进程的正确运行，即能在内存中找到每个页面所对应的物理块。为此，系统又为每个进程建立了一张页面映像表，简称页表。在进程地址空间内的所有页（0～n），依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。</p><p><img src="/images/os_mem_1_1.png" alt></p><p>（3）分段存储管理方式</p><p>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等。每个段都有自己的名字。为了实现简单起见，通常可用一个段号来代替段名，每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间由于是分成多个段，因而是二维的，亦即，其逻辑地址由段号（段名）和段内地址所组成。</p><p>在分段式存储管理系统中，则是为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中不同的分区中。为使程序能正常运行，亦即，能从物理内存中找出每个逻辑段所对应的位置，应像分页系统那样，在系统中为每个进程建立一张段映射表，简称“段表”。每个段在表中占有一个表项，其中记录了该段在内存中的起始地址（又称为“基址”）和段的长度。段表可以存放在一组寄存器中，这样有利于提高地址转换速度，但更常见的是将段表放在内存中。</p><p>在配置了段表后，执行中的进程可通过查找段表找到每个段所对应的内存区。可见，段表是用于实现从逻辑段到物理内存区的映射。</p><p><img src="/images/os_mem_1_2.png" alt></p><p>（4）段页式存储管理方式</p><p>段页式系统的基本原理，是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成。</p><h1 id="虚拟存储器与页面置换算法"><a href="#虚拟存储器与页面置换算法" class="headerlink" title="虚拟存储器与页面置换算法"></a>虚拟存储器与页面置换算法</h1><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>前面部分介绍的各种存储器管理方式有一个共同的特点，即它们都要求将一个作业全部装入内存后方能运行，于是，出现了下面这样两种情况：</p><p>（1）有的作业很大，其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业无法运行。</p><p>（2）有大量作业要求运行，但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让它们先运行，而将其它大量的作业留在外存上等待。</p><p>出现上述两种情况的原因，都是由于内存容量不够大。一个显而易见的解决方法，是从物理上增加内存容量，但这往往会受到机器自身的限制，而且无疑要增加系统成本，因此这种方法是受到一定限制的。另一种方法是从逻辑上扩充内存容量，这正是虚拟存储技术所要解决的主要问题。</p><p>程序在执行时将呈现出局部性规律，即在一较短的时间内，程序的执行仅局限于某个部分。相应地，它所访问的存储空间也局限于某个区域。这个规律称为“局部性原理”。</p><p>基于局部性原理，应用程序在运行之前，没有必要全部装入内存，仅须将那些当前要运行的少数页面或段先装入内存便可运行，其余部分暂留在盘上。程序在运行时，如果它所要访问的页（段）已调入内存，便可继续执行下去；但如果程序所要访问的页（段）尚未调入内存（称为缺页或缺段），此时程序应利用OS所提供的请求调页（段）功能（也即缺页中断），将它们调入内存，以使进程能继续执行下去。如果此时内存已满，无法再装入新的页（段），则还须再利用页（段）的置换功能，将内存中暂时不用的页（段）调至磁盘上，腾出足够的内存空间后，再将要访问的页（段）调入内存，使程序继续执行下去。这样，便可使一个大的用户程序能在较小的内存空间中运行；也可在内存中同时装入更多的进程使它们并发执行。从用户角度看，该系统所具有的内存容量，将比实际内存容量大得多。但须说明，用户所看到的大容量只是一种感觉，是虚的，故人们把这样的存储器称为虚拟存储器。</p><p>由上所述可以得知，所谓虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、中、小型机器和微型机中。</p><p>备注：这里说的虚拟存储器，指的是虚拟内存VIRT空间，并非SWAP啦，不要搞混淆了哇。</p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>在进程运行过程中，若其所要访问的页面不在内存而需把它们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，系统必须从内存中调出一页程序或数据送磁盘的对换区中。但应将哪个页面调出，须根据一定的算法来确定。通常，把选择换出页面的算法称为页面置换算法（Page-Replacement Algorithms）。置换算法的好坏，将直接影响到系统的性能。</p><p>常用的页面置换算法有：</p><pre><code>最佳（Optimal）置换算法先进先出（FIFO）页面置换算法最近最久未使用（LRU）置换算法Clock置换算法最少使用（LFU）置换算法页面缓冲（PBA）算法</code></pre><h1 id="大页内存"><a href="#大页内存" class="headerlink" title="大页内存"></a>大页内存</h1><p>随着计算需求规模的不断增大，应用程序对内存的需求也越来越大。为了实现虚拟内存管理机制，操作系统对内存实行分页管理。自内存“分页机制”提出之始，内存页面的默认大小便被设置为4096字节（4KB），虽然原则上内存页面大小是可配置的，但绝大多数的操作系统实现中仍然采用默认的4KB页面。4KB大小的页面在“分页机制”提出的时候是合理的，因为当时的内存大小不过几十兆字节，然而当物理内存容量增长到几G甚至几十G的时候，操作系统仍然以4KB大小为页面的基本单位，就不见得是最合理的。</p><p>页面大小太小时，为造成应用程序在执行时，会产生过多的缺页中断，从而大大影响到应用程序的性能。当把页面大小调大时，就可以缓解这样的问题。</p><p>学习资料参考于：<br>汤子瀛版《计算机操作系统》</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>系统调用与zero copy技术</title>
      <link href="/2019/02/19/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8Ezero-copy%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/02/19/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8Ezero-copy%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>操作系统提供了底层各种硬件资源的抽象层，应用程序必须通过这个抽象层来访问硬件资源。在抽象层之下就是操作系统的内核。</p><p><img src="/images/os_zc_1_1.jpg" alt></p><p>当应用程序调用“系统调用”接口（如read、write、sendfile、fork以及exec等等）时，就会让应用程序从用户态切换到内核态，也就是执行内核的代码和数据。</p><h1 id="read和write系统调用"><a href="#read和write系统调用" class="headerlink" title="read和write系统调用"></a>read和write系统调用</h1><p>read是从磁盘读取数据的系统调用，write是向本地磁盘或socket写数据的系统调用。如下是应用程序从磁盘中读取数据，然后通过socket发送到网络中的一个系统调用过程：</p><p><img src="/images/os_zc_1_2.jpg" alt></p><p>我们可以看到，通过read系统调用，操作系统使用DMA（Direct Memory Access）的方式把磁盘文件的数据从硬盘复制到了内核的缓冲区（也就是一段分配给内核的内存区域）， 然后又复制到了用户的缓冲区（也就是一段分配给上层应用程序的内存区域），这样read系统调用完成，返回到用户态 ，应用程序可以继续工作了。接下来，应用程序要通过socket发送数据，于是有向内核发起了write调用，再次进入内核态，内核又把用户缓冲区的数据复制到socket缓冲区（也是内核的内存区域）， write调用返回，返回用户态。网卡驱动会在一定的队列策略下，最终将数据发送到网络中去。</p><p>在这个例子中，我们发现一共发生了三次数据的复制，代价还是挺大的。</p><h1 id="sendfile系统调用及零拷贝zero-copy技术"><a href="#sendfile系统调用及零拷贝zero-copy技术" class="headerlink" title="sendfile系统调用及零拷贝zero copy技术"></a>sendfile系统调用及零拷贝zero copy技术</h1><p>在上面read和write系统调用的例子中，我们发现内核空间和用户空间的数据发生了多次复制，系统开销大。其实我们可以使用<code>sendfile(socket, file, len)</code>系统调用，内核把数据从硬盘复制到内核缓冲区，同时会把数据在内核缓冲区的位置和数据长度等信息复制到socket缓冲区。在这个过程中其实只产生了一次复制，第二次复制只是将一些数据元信息复制到socket缓冲区，网卡驱动在发送数据时，其实还是使用的第一次的内核缓冲区中的数据啦。</p><p>在这个例子中，并没有发生数据从内核态空间和用户态空间的复制动作，我们称之为zero copy技术，即“零拷贝”技术啦。</p><p><img src="/images/os_zc_1_3.jpg" alt></p><p>学习资料参考于：<br>码农翻身《操作系统和Web服务器那点事儿》——<a href="https://mp.weixin.qq.com/s?src=11×tamp=1544206393&amp;ver=1283&amp;signature=dpbbA0HjabqXDEWNjY0kO-wejYHf7pUNgpTuZCgYMc*giESDgjpG0rhX1qZnTYuhF0PQLkCmZz-hHlld1X71mcphRoeczn1hnbEiJaLvs4itVRCfl8bVV0isHxtiNhOA&amp;new=1" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?src=11×tamp=1544206393&amp;ver=1283&amp;signature=dpbbA0HjabqXDEWNjY0kO-wejYHf7pUNgpTuZCgYMc*giESDgjpG0rhX1qZnTYuhF0PQLkCmZz-hHlld1X71mcphRoeczn1hnbEiJaLvs4itVRCfl8bVV0isHxtiNhOA&amp;new=1</a></p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DPDK与DPVS技术原理与应用</title>
      <link href="/2019/02/18/DPDK%E4%B8%8EDPVS%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2019/02/18/DPDK%E4%B8%8EDPVS%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="DPDK技术简介"><a href="#DPDK技术简介" class="headerlink" title="DPDK技术简介"></a>DPDK技术简介</h1><p>Intel® DPDK全称Intel Data Plane Development Kit，是Intel提供的数据平面开发工具集，为Intel Architecture（IA）处理器架构下用户空间高效的数据包处理提供库函数和驱动的支持，<strong>它不同于Linux系统以通用性设计为目的，而是专注于网络应用中数据包的高性能处理</strong>。目前已经验证可以运行在大多数Linux操作系统上，包括FreeBSD 9.2、Fedora release 18、Ubuntu 12.04 LTS、RedHat Enterprise Linux 6.3和SUSE Enterprise Linux 11 SP2等。DPDK使用了BSD License，极大的方便了企业在其基础上来实现自己的协议栈或者应用。</p><p>需要强调的是，DPDK应用程序是运行在<strong>用户空间</strong>上利用自身提供的数据平面库来收发数据包，<strong>绕过了Linux内核协议栈对数据包处理过程</strong>。Linux内核将DPDK应用程序看作是一个普通的用户态进程，包括它的编译、连接和加载方式和普通程序没有什么两样。DPDK程序启动后只能有一个主线程，然后创建一些子线程并绑定到指定CPU核心上运行。</p><p>DPDK核心组件由一系列库函数和驱动组成，为高性能数据包处理提供基础操作。<strong>内核态模块主要实现轮询模式的网卡驱动和接口，并提供PCI设备的初始化工作</strong>；<strong>用户态模块则提供大量给用户直接调用的函数</strong>。DPDK本身是一些库函数和驱动，使用了DPDK库函数的应用程序则称为“DPDK应用程序”。</p><p><img src="/images/sre_dpvs_1_1.png" alt></p><p>直白地说，DPDK绕过了Linux内核协议栈，处在用户空间下的DPDK应用程序直接使用硬件驱动的接口来收发报文。类似于DPDK，PF_RING和Netmap等工具也实现了类似的功能。有了DPDK，就可以让服务器的数据包转发或数据包处理能力大大地提升了。</p><p>在dpdk中有一个igb_uio模块，是关于网卡的驱动模块。</p><h1 id="DPVS技术简介"><a href="#DPVS技术简介" class="headerlink" title="DPVS技术简介"></a>DPVS技术简介</h1><p>DPVS全称为“DPDK-LVS”，来源iqiyi的开源项目。DPVS是基于DPDK的高性能第4层负载均衡器，且基于alibaba/LVS修改而来。简单来说，DPDK+LVS=DPVS。从目前的测试数据来看，DPVS的性能优于LVS。架构图如下：</p><p><img src="/images/sre_dpvs_1_2.png" alt></p><p>我的理解是，<strong>DPVS使用DPDK的高性能转发技术，直接从硬件驱动的接口中读取数据，绕过了Linux协议栈，然后在操作系统的用户空间中把内核LVS的功能重新实现了一遍</strong>。</p><p>如下是DPVS项目的所有模块：</p><p><img src="/images/sre_dpvs_1_3.png" alt></p><p>其中实现了一个用户空间的轻型IP协议栈（功能类似于系统空间的内核IP协议栈）。</p><h1 id="dpdk和linux内核协议栈处理数据的关系"><a href="#dpdk和linux内核协议栈处理数据的关系" class="headerlink" title="dpdk和linux内核协议栈处理数据的关系"></a>dpdk和linux内核协议栈处理数据的关系</h1><p><img src="/images/sre_dpvs_1_4.png" alt></p><p>dpdk接管了linux部分网卡，直接接收和发送数据包。dpdk会在操作系统内核层面设置KNI网卡，dpdk将不想处理的数据包，如vrrp、ospf或sshd，通过DPDK rte_kni模块转发给系统协议栈的KNI网卡，从而走Linux系统的协议栈来处理数据包。需要注意的是，dpdk0和dpdk0.kni网卡对应，dpdk1和dpdk1.kni网卡对应。即dpdk0将不想处理的数据包转发给dpdk0.kni，dpdk1将不想处理的数据包转发给dpdk1.kni。</p><p>我们使用<code>ip addr show</code>命令查看到的是linux系统层面的网卡NICs，使用<code>dpip addr show</code>看到的DPDK内部的网卡NICs。</p><h1 id="DPDK与Linux内核处理数据包的对比"><a href="#DPDK与Linux内核处理数据包的对比" class="headerlink" title="DPDK与Linux内核处理数据包的对比"></a>DPDK与Linux内核处理数据包的对比</h1><p><img src="/images/sre_dpvs_1_5.png" alt></p><p>DPDK拦截中断，不触发后续中断流程，并绕过协议栈，通过UIO技术将网卡收到的报文拷贝到应用层处理，报文不再经过内核协议栈。减少了中断，DPDK的包全部在用户控件使用内存池管理，内核控件与用户空间的内存交互不用进行拷贝，只做控制权转移，减少报文拷贝过程，提高报文的转发效率。<br>DPDK核心技术如下：</p><pre><code>kernel bypass，通过UIO技术将报文拷贝到应用空间处理通过大页内存，降低cache miss，提高命中率，进而cpu访问速度通过cpu亲和性，绑定网卡和线程到固定的core，减少cpu任务切换通过无锁队列，减少资源竞争</code></pre><h1 id="DPDK-LVS的部署实践"><a href="#DPDK-LVS的部署实践" class="headerlink" title="DPDK-LVS的部署实践"></a>DPDK-LVS的部署实践</h1><p>目前DPVS支持NAT、Tunnel、DR、FULLNAT以及SNAT的模式。其中NAT、Tunnel、DR、FULLNAT可以用来部署LVS集群，即作为4层负载均衡设备，其中SNAT模式用来搭建NAT集群。</p><p>对于LVS集群部署上来说，目前业界比较多采用的是<code>FULLNAT + OSPF/ECMP（一致性hash）</code>模式部署，这种模式适合大规模的集群化部署，也能够实现单机LVS故障时的平滑迁移。</p><h1 id="DPDK-LVS的性能对比数据"><a href="#DPDK-LVS的性能对比数据" class="headerlink" title="DPDK-LVS的性能对比数据"></a>DPDK-LVS的性能对比数据</h1><p>（1）普通LVS的DR模式的性能数据</p><pre><code>10Gbps+的HTTP流量1000w+ pps的转发量</code></pre><p>（2）dpvs/lvs/maglev性能对比</p><p>从“数据包转发速率”这一项核心指标上来说：</p><p><img src="/images/sre_dpvs_1_6.png" alt></p><p>简单概括下，<strong>基于DPDK的DPVS相比于内核LVS要高5倍左右的性能</strong>。</p><p>（3）附上一张百度BGW性能数据图</p><p><img src="/images/sre_dpvs_1_7.png" alt></p><h1 id="DPDK-LVS性能高效的主要因素"><a href="#DPDK-LVS性能高效的主要因素" class="headerlink" title="DPDK-LVS性能高效的主要因素"></a>DPDK-LVS性能高效的主要因素</h1><p>（1）Kernel ByPass，内核旁路，也就是绕过内核，直接在用户态获取网卡数据，读取网卡数据采用轮询机制，而不是传统的依靠中断。当前Linux操作系统都是通过中断方式通知CPU来收发数据包，我们假定网卡每收到10个据包触发一次软中断，一个CPU核心每秒最多处理2w次中断，那么当一个核每秒收到20w个包时就占用了100%，此刻它没做其它任何操作。DPDK针对Intel网卡实现了基于轮询方式的PMD（Poll Mode Drivers）驱动，该驱动由API、用户空间运行的驱动程序构成，该驱动使用无中断方式直接操作网卡的接收和发送队列（除了链路状态通知仍必须采用中断方式以外）。目前PMD驱动支持Intel的大部分1G、10G和40G的网卡。PMD驱动从网卡上接收到数据包后，会直接通过DMA方式传输到预分配的内存中，同时更新无锁环形队列中的数据包指针，不断轮询的应用程序很快就能感知收到数据包，并在预分配的内存地址上直接处理数据包，这个过程非常简洁。如果要是让Linux来处理收包过程，首先网卡通过中断方式通知协议栈对数据包进行处理，协议栈先会对数据包进行合法性进行必要的校验，然后判断数据包目标是否本机的socket，满足条件则会将数据包拷贝一份向上递交给用户socket来处理，不仅处理路径冗长，还需要从内核到应用层的一次拷贝过程。总之，内核旁路的好处是绕过中断，绕过复杂的内核协议栈，DMA直接读取内存数据等。</p><p>（2）可以利用网卡多队列以及CPU亲和性设置，即可以绑核。</p><p>（3）内核是一个通用平台，为了安全性设计，会有很多锁的竞争机制，而DPVS做到lockless，即无锁竞争。</p><p>（4）使用大页内存，这个需要看看计算机组成原理。</p><h1 id="LVS-DPVS-FULLNAT模式下用户真实IP获取与TOA-UOA模块"><a href="#LVS-DPVS-FULLNAT模式下用户真实IP获取与TOA-UOA模块" class="headerlink" title="LVS/DPVS FULLNAT模式下用户真实IP获取与TOA/UOA模块"></a>LVS/DPVS FULLNAT模式下用户真实IP获取与TOA/UOA模块</h1><p>（1）LVS/DPVS FULLNAT模式下获取用户真实IP困难</p><p><img src="/images/sre_dpvs_1_8.png" alt></p><p>从上图可以发现FULLNAT模式一个问题，RS无法获得用户IP。</p><p>（2）阿里开发的TOA内核模块以及百度开发的TTM内核模块</p><p>阿里巴巴是通过开发一个叫TOA的内核模块来解决这个问题的。TOA主要原理是将用户真实IP地址放到了TCP Option字段里面，并带给后端RS，RS收到后保存在socket的结构体里并通过TOA内核模块Hook了getname函数，这样当应用程序调用getname获取远端地址时，返回的是保存在socket的TCP Option的IP。百度的BVS是通过一个叫TTM的内核模块来实现的，其实现方式跟TOA基本一样，只是没有开源。</p><p>TOA的原理图如下：</p><p><img src="/images/sre_dpvs_1_9.png" alt></p><h1 id="其他闲杂知识"><a href="#其他闲杂知识" class="headerlink" title="其他闲杂知识"></a>其他闲杂知识</h1><p>（1）DPDK启动后，会接管linux的上某些网卡，如eth0，eth1等。</p><p>（2）DPVS支持高可用性架构，目前有两种HA架构，一种是OSPF/ECMP，一种是主备模式。OSPF/ECMP模式需要quagga路由器模拟软件。主备模式需要用到keepalived。</p><p>（3）DPVS采用Master/Worker的工作模型，其中每个Worker绑定到一个CPU核心上。</p><p>学习资料参考于：<br><a href="https://dpdk.org/" target="_blank" rel="noopener">https://dpdk.org/</a><br><a href="https://github.com/iqiyi/dpvs" target="_blank" rel="noopener">https://github.com/iqiyi/dpvs</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA3ODgyNzcwMw==&amp;mid=202113096&amp;idx=1&amp;sn=7ce616f596c529890dfd475ce8d31858&amp;scene=4##" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA3ODgyNzcwMw==&amp;mid=202113096&amp;idx=1&amp;sn=7ce616f596c529890dfd475ce8d31858&amp;scene=4##</a><br><a href="http://www.infoq.com/cn/presentations/implementation-of-high-performance-load-equalizer-based-on-dpdk#downloadPdf" target="_blank" rel="noopener">http://www.infoq.com/cn/presentations/implementation-of-high-performance-load-equalizer-based-on-dpdk#downloadPdf</a><br><a href="https://tech.meituan.com/MGW.html" target="_blank" rel="noopener">https://tech.meituan.com/MGW.html</a><br><a href="https://blog.csdn.net/mumumuwudi/article/details/47064281" target="_blank" rel="noopener">https://blog.csdn.net/mumumuwudi/article/details/47064281</a></p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DPVS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVS技术原理及集群配置搭建</title>
      <link href="/2019/02/18/LVS%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/02/18/LVS%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="LVS项目背景"><a href="#LVS项目背景" class="headerlink" title="LVS项目背景"></a>LVS项目背景</h1><p>1998年5月，由章文嵩组织成立了Linux Virtual Server的自由软件项目，进行Linux服务器集群的开发工作。同时，Linux Virtual Server项目是国内最早出现的自由软件项目之一。</p><p>项目的成立目的就是，使用集群技术和Linux操作系统实现一个高性能、高可用的服务器，它具有很好的可伸缩性（Scalability）、可靠性（Reliability）和可管理性（Manageability）。</p><h1 id="LVS的体系架构"><a href="#LVS的体系架构" class="headerlink" title="LVS的体系架构"></a>LVS的体系架构</h1><p>一般来说，LVS集群采用三层结构，其通用的体系结构如下：</p><p><img src="/images/linux_lvs_1_1.png" alt></p><p><img src="/images/linux_lvs_1_2.png" alt></p><p>LVS集群主要有三层结构：</p><p>（1）负载调度器</p><p>负载调度器（Load Balancer），也称Director Server，简称DS。它是整个集群对外面的前端机，负责将客户的请求发送到一组服务器上执行，而客户认为服务是来自一个IP地址（我们可称之为虚拟IP地址）上的。调度器是服务器集群系统的唯一入口点（Single Entry Point），它可以采用IP负载均衡技术、基于内容请求分发技术或者两者相结合。在IP负载均衡技术中，需要服务器池拥有相同的内容提供相同的服务。当客户请求到达时，调度器只根据服务器负载情况和设定的调度算法从服务器池中选出一个服务器，将该请求转发到选出的服务器，并<strong>记录这个调度</strong>；<strong>当这个请求的其他报文到达，也会被转发到前面选出的服务器</strong>。在基于内容请求分发技术中，服务器可以提供不同的服务，<strong>当客户请求到达时，调度器可根据请求的内容选择服务器执行请求</strong>。因为所有的操作都是在Linux操作系统核心空间中将完成的，它的调度开销很小，所以它具有很高的吞吐率。</p><p>（2）服务器池</p><p>服务器池（server pool），也称Real Server，简称RS。它是一组真正执行客户请求的服务器，执行的服务有WEB、MAIL、FTP和DNS等。</p><p>（3）共享存储<br>共享存储（shared storage），它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务。</p><p>从整个LVS结构可以看出，Director Server是整个LVS的核心，目前，用于Director Server的操作系统只能是Linux和FreeBSD，linux2.6内核不用任何设置就可以支持LVS功能，而FreeBSD作为Director Server的应用还不是很多，性能也不是很好。对于Real Server，几乎可以是所有的系统平台，Linux、windows、Solaris、AIX、BSD系列都能很好的支持。</p><h1 id="LVS的技术实现"><a href="#LVS的技术实现" class="headerlink" title="LVS的技术实现"></a>LVS的技术实现</h1><p>可以利用LVS框架实现高可伸缩的、高可用的Web、Cache、Mail和Media等网络服务。在LVS框架包含三个部分：</p><p>（1）包含了三种IP负载均衡技术的IP虚拟服务器软件IPVS，即四层负载均衡</p><p>（2）基于内容请求分发的内核Layer-7交换机KTCPVS，即七层负载均衡，也即应用层的转发，目前这个组件在实际中使用的并不多，还不够成熟</p><p>（3）集群管理软件，即ipvsadm</p><p><img src="/images/linux_lvs_1_3.png" alt></p><p>KTCPVS是七层交互交换技术，也就是基于应用层来进行调度的目的，比如HTTP，FTP等。这个和IPVS在IP层的调度有很大的区别。<br>所以说，<strong>LVS的调度器有两种调度实现技术，一种是基于IP负载均衡技术的IPVS，一种是基于内容请求分发技术的KTCPVS</strong>。</p><h1 id="LVS的IPVS模块的三种负载均衡工作模式"><a href="#LVS的IPVS模块的三种负载均衡工作模式" class="headerlink" title="LVS的IPVS模块的三种负载均衡工作模式"></a>LVS的IPVS模块的三种负载均衡工作模式</h1><p>IPVS调度器的三种IP负载均衡技术如下：</p><p>（1）VS/NAT工作模式</p><p>VS/NAT，全称为Virtual Server via Network Address Translation。VS/NAT通过网络地址转换（Network Address Translation）将一组服务器构成一个高性能的、高可用的虚拟服务器。NAT用法本来是因为网络IP地址不足而把内部保留IP地址通过映射转换成公网地址的一种上网方式（原地址NAT）。如果把NAT的过程稍微变化，就可以成为负载均衡的一种方式。原理其实就是把从客户端发来的IP包的IP头目的地址在DR上换成其中一台RS的IP地址并发至此RS，而RS则在处理完成后把数据经过DR主机发回给客户端，DR在这个时候再把数据包的原IP地址改为DR接口上的IP地址即可。期间，无论是进来的流量，还是出去的流量，都必须经过DR。</p><p>简单来说，通过网络地址转换，调度器重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器；真实服务器的响应报文通过调度器时，报文的源地址被重写，再返回给客户，完成整个负载调度过程。</p><p>VS/NAT技术实施关键点，<strong>DS和RS要在同一个VLAN，且RS的缺省网关一定要配置成DS的VIP，RS响应包经过DS，RS不需要连接外网</strong>。</p><p>（2）VS/TUN工作模式</p><p>VS/TUN, 全称为Virtual Server via IP Tunneling。VS/TUN模式类似于VPN的方式，使用网络分层的原理，在从客户端发来的数据包的基础上，封装一个新的IP头标记（不完整的IP头，只有目的IP部）发给RS，RS收到后，先把DR发过来的数据包的头给解开，还原其数据包原样，处理后，直接返回给客户端，而不需要再经过DR。需要注意的是，由于RealServer需要对DR发过来的数据包进行还原，也就是说必须支持IPTUNNEL协议。所以，在RS的内核中，必须编译支持IPTUNNEL这个选项。IPTUNNEL也在Networking Options里面。</p><p>简单来说，采用NAT技术时，由于请求和响应报文都必须经过调度器地址重写，<strong>当客户请求越来越多时，调度器的处理能力将成为瓶颈</strong>。为了解决这个问题，调度器把请求报文通过IP隧道转发至真实服务器，而真实服务器将响应直接返回给客户，所以调度器只处理请求报文。由于一般网络服务应答比请求报文大许多，采用VS/TUN技术后，集群系统的最大吞吐量可以提高10倍。</p><p>VS/TUN技术实施关键点，<strong>DS和RS不需要在同一个VLAN下，且RS上需要配置VIP，RS响应包不经过DS，RS需要连接外网，RS需要安装ipip模块支持ip隧道技术</strong>。</p><p>（3）VS/DR工作模式</p><p>VS/DR，全称为Virtual Server via Direct Routing。VS/DR通过直接路由实现虚拟服务器。直接路由模式比较特别，很难说和什么方面相似，前2种模式基本上都是工作在网络层上（三层），而直接路由模式则应该是工作在数据链路层上（二层）。其原理为，DR和RS都使用同一个IP对外服务。但只有DR对ARP请求进行响应，所有RS对本身这个IP的ARP请求保持静默。也就是说，网关会把对这个服务IP的请求全部定向给DR，而DR收到数据包后根据调度算法，找出对应的RS，把目的MAC地址改为RS的MAC并发给这台RS。这时RS收到这个数据包，则等于直接从客户端收到这个数据包无异，处理后直接返回给客户端｡由于DR要对二层包头进行改换，所以DR和RS之间必须在一个广播域，也可以简单的理解为在同一台交换机上。</p><p>简单来说，VS/DR通过改写请求报文的MAC地址，将请求发送到真实服务器，而真实服务器将响应直接返回给客户。同VS/TUN技术一样，VS/DR技术可极大地提高集群系统的伸缩性。这种方法<strong>没有IP隧道的开销，对集群中的真实服务器也没有必须支持IP隧道协议的要求，但是要求调度器与真实服务器都有一块网卡连在同一物理网段上</strong>。</p><p>VS/DR技术实施关键点，<strong>DS和RS要在同一个VLAN，且RS上lo网口上要配置VIP，RS响应包不经过DS，RS需要连接外网</strong>。</p><p>备注：VS/DR模式下，各RS服务器均需要配置上VIP。这是因为经DR转发过来的IP包要被RS接受，则目的IP地址必须是RS的IP地址，所以需要RS在网卡上配置上VIP。但由于VIP已经配置在DS上，所以RS只能将VIP配置在<strong>Non-ARP</strong>网络设备上，它对外不可见（即不会响应外部的ARP地址解析请求，所以不会与DS IP冲突），只是用于欺骗RS去处理目标地址为VIP的网络数据包。一般来说，RS是将VIP绑定到本地回环接口设备lo上的。另外，VS/TUN模式应该也需要RS绑定VIP，而VS/NAT模式则不需要。</p><p>还有一点需要注意的是，<strong>DS上有一个连接Hash表中记录每一个连接，当某一个连接的下一个报文到达时，从连接Hash表中可以Hash算出原来的RS机器啦</strong>。</p><p>另外，alibaba/lvs项目增加了FULLNAT模式，不同于VS/NAT模式，DS和RS可以跨VLAN，且RS不需要连接外网，更灵活一些，但是RS响应包需要经过DS。</p><h1 id="LVS的IPVS模块的八种负载调度算法"><a href="#LVS的IPVS模块的八种负载调度算法" class="headerlink" title="LVS的IPVS模块的八种负载调度算法"></a>LVS的IPVS模块的八种负载调度算法</h1><p>IPVS调度器的八种负载调度算法如下：</p><p>（1）轮叫（Round Robin）</p><p>调度器通过“轮叫”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上实际的连接数和系统负载。</p><p>（2）加权轮叫（Weighted Round Robin）</p><p>调度器通过“加权轮叫”调度算法根据真实服务器的不同处理能力来调度访问请求。这样可以保证处理能力强的服务器处理更多的访问流量。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p><p>（3）最少链接（Least Connections）</p><p>调度器通过“最少连接”调度算法动态地将网络请求调度到已建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用“最小连接”调度算法可以较好地均衡负载。</p><p>（4）加权最少链接（Weighted Least Connections）</p><p>在集群系统中的服务器性能差异较大的情况下，调度器采用“加权最少链接”调度算法优化负载均衡性能，具有较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p><p>（5）基于局部性的最少链接（Locality-Based Least Connections）</p><p>“基于局部性的最少链接”调度算法是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。该算法根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器 是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用”最少链接”的原则选出一个可用的服务 器，将请求发送到该服务器。</p><p>（6）带复制的基于局部性最少链接（Locality-Based Least Connections with Replication）</p><p>“带复制的基于局部性最少链接”调度算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。它与LBLC算法的不同之处是它要维护从一个 目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。该算法根据请求的目标IP地址找出该目标IP地址对应的服务 器组，按”最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器，若服务器超载；则按”最小连接”原则从这个集群中选出一 台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p><p>（7）目标地址散列（Destination Hashing）</p><p>“目标地址散列”调度算法根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p><p>（8）源地址散列（Source Hashing）</p><p>“源地址散列”调度算法根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p><h1 id="LVS集群的配置和搭建"><a href="#LVS集群的配置和搭建" class="headerlink" title="LVS集群的配置和搭建"></a>LVS集群的配置和搭建</h1><p>ipvsadm是lvs的ipvs模块的配置工具，通过ipvsadm工具可以进行lvs的配置工作。ipvsadm命令的一些常用选项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-A, --add-service      #在内核的虚拟服务器列表中添加一条新的虚拟IP记录，也就是增加一台新的虚拟服务器，虚拟IP也就是虚拟服务器的IP地址</span><br><span class="line">-E, --edit-service     #编辑内核虚拟服务器列表中的一条虚拟服务器记录</span><br><span class="line">-D, --delete-service   #删除内核虚拟服务器列表中的一条虚拟服务器记录</span><br><span class="line">-C, --clear            #清除内核虚拟服务器列表中的所有记录</span><br><span class="line">-t                     #说明虚拟服务器提供的是TCP服务</span><br><span class="line">-u                     #说明虚拟服务器提供的是UDP服务</span><br><span class="line">-a, --add-server       #在内核虚拟服务器列表的一条记录里添加一条新的RS记录，也就是在一个虚拟服务器中增加一台新的RS</span><br><span class="line">-e, --edit-server      #编辑一条虚拟服务器记录中的某条RS记录</span><br><span class="line">-d, --delete-server    #删除一条虚拟服务器记录中的某条RS记录</span><br><span class="line">-L,-l,–list            #显示内核中虚拟服务器列表</span><br><span class="line">-s xxxx                #此选项后面跟LVS使用的调度算法</span><br><span class="line">-r real-server-ip:port #指定RS的IP地址</span><br><span class="line">-g, --gatewaying       #指定LVS 的工作模式为直接路由模式（此模式是LVS默认工作模式）</span><br><span class="line">-i, -ipip              #指定LVS的工作模式为隧道模式</span><br><span class="line">-m, --masquerading     #指定LVS的工作模式为NAT模式</span><br></pre></td></tr></table></figure><p>ipvsadm的一些常用命令操作范例如下：</p><p>（1）<code>ipvsadm -A -t 192.168.60.200:80 -s rr -p 600</code></p><p>在内核的虚拟服务器列表中添加一条192.168.60.200的虚拟服务器记录，并且指定此虚拟服务器的服务端口为80，然后指定此虚拟服务器的调度策略为轮询调度，并且在每个RS上的持续服务时间为600秒，即10分钟。</p><p>（2）<code>ipvsadm -A -t 192.168.60.188:21 -s wlc</code></p><p>在内核的虚拟服务器列表中又添加了一条192.168.60.188的虚拟服务器，此虚拟服务器的服务端口为21，即FTP服务。使用的调度策略为wlc，即加权最少链接算法。</p><p>（3）<code>ipvsadm -a -t 192.168.60.200:80 -r 192.168.60.132:80 –g</code>和<code>ipvsadm -a -t 192.168.60.200:80 -r 192.168.60.144:80 –g</code><br>以上两条设置表示在虚拟服务器192.168.60.200中添加两条新的RS记录，两个RS的IP分别为192.168.60.132和192.168.60.144，参数“-g”指定了虚拟服务器的工作模式为直接路由模式，即DR模式。 这样设置完毕后，当用户访问192.168.60.200的80服务时，LVS会根据设置的调度策略和路由模式将请求分配到192.168.60.132以及192.168.60.144的80端口。</p><p>（4）<code>ipvsadm -Ln</code></p><p>查询一台机器上的所有虚拟服务器。显示结果如下：</p><p><img src="/images/linux_lvs_1_4.png" alt></p><p>备注：Scheduler=rr是对RS的调度算法为Round Robin轮叫算法。Forward=Route表示使用的是直接路由Direct Routing工作模式。ActiveConn是处于ESTABLISHED状态的TCP连接数。InActConn是指除了ESTABLISHED以外的，所有的其它状态的TCP连接。有一点需要注意的是，从LVS里看的ActiveConn会比在真实机上通过netstat看到的ESTABLISHED一般会多一些。这是因为LVS自身有一个默认超时时间。可以用<code>ipvsadm -L --timeout</code>查看，默认是<code>900 120 300</code>（分别是TCP/TCPFIN/UDP的超时时间）。也就是说一条TCP的连接经过LVS后，LVS会把这条记录保存15分钟，而不管这条连接是不是已经失效。</p><p>（5）<code>ipvsadm -Ln --rate</code></p><p>查看LVS转发速率相关指标。命令执行效果如下：</p><p><img src="/images/linux_lvs_1_5.png" alt></p><p>其中，CPS表示每秒连接数，InPPS表示每秒入包个数，OutPPS表示每秒出包个数，InBPS表示每秒入流量（单位字节），OutBPS表示每秒出流量（单位字节）。</p><h1 id="LVS集群的高可用性"><a href="#LVS集群的高可用性" class="headerlink" title="LVS集群的高可用性"></a>LVS集群的高可用性</h1><p>LVS集群的高可用性体现在两个方面：</p><p>（1）Server Cluster/Server Array中的单台RS故障自动容灾</p><p>在调度器上有资源监测进程来时刻监视各个服务器结点的健康状况。当服务器对ICMP ping不可达时或者探测她的网络服务在指定的时间没有响应时，资源监测进程通知操作系统内核将该服务器从调度列表中删除或者失效。这样，新的服务请求就不会被调度到坏的结点。资源监测进程能通过电子邮件或传呼机向管理员报告故障。一旦监测进程到服务器恢复工作，通知调度器将其加入调度列表进行调度。另外，通过系统提供的管理程序，管理员可发命令随时可以将新机器加入服务来提高系统的处理性能，也可以将已有的服务器切出服务，以便对服务器进行系统维护。</p><p>（2）调度器的主备容灾</p><p>前端的调度器有可能成为系统的单一失效点（Single Point of Failure）。一般来说，调度器的可靠性较高，因为调度器上运行的程序较少而且大部分程序早已经遍历过，但我们不能排除硬件老化、网络线路或者人为误操作等主要故障。为了避免调度器失效而导致整个系统不能工作，我们需要设立一个从调度器作为主调度器的备份。两个心跳（Heartbeat）进程分别在主、从调度器上运行，它们通过串口线和UDP等心跳线来相互定时地汇报各自的健康状况。当从调度器不能听得主调度器的心跳时，从调度器通过ARP欺骗（Gratuitous ARP）来接管集群对外的Virtual IP Address，同时接管主调度器的工作来提供负载调度服务。当主调度器恢复时，这里有两种方法，一是主调度器自动变成从调度器，二是从调度器释放Virtual IP Address，主调度器收回Virtual IP Address并提供负载调度服务。</p><p>当主调度器失效时，主调度器上所有已建立连接的状态信息将丢失，已有的连接会中断。客户需要向重新连接，从调度器才会将新连接调度到各个服务器上，这对客户会造成一定的不便。为此，IPVS调度器在Linux内核中实现一种高效状态同步机制，将主调度器的状态信息及时地同步到从调度器。当从调度器接管时，绝大部分已建立的连接会持续下去。</p><p>目前，keepalived，heartbeat都支持IP漂移，来实现LVS调度器的高可用性。</p><p>学习资料来源于：<br><a href="http://www.linuxvirtualserver.org/zh/" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/zh/</a><br><a href="http://ixdba.blog.51cto.com/2895551/552947" target="_blank" rel="noopener">http://ixdba.blog.51cto.com/2895551/552947</a><br><a href="http://ixdba.blog.51cto.com/2895551/554029" target="_blank" rel="noopener">http://ixdba.blog.51cto.com/2895551/554029</a><br><a href="http://ixdba.blog.51cto.com/2895551/554799" target="_blank" rel="noopener">http://ixdba.blog.51cto.com/2895551/554799</a><br><a href="http://ixdba.blog.51cto.com/2895551/555738" target="_blank" rel="noopener">http://ixdba.blog.51cto.com/2895551/555738</a><br><a href="http://blog.51cto.com/blief/1745134" target="_blank" rel="noopener">http://blog.51cto.com/blief/1745134</a><br><a href="http://www.cnblogs.com/oldjiang/archive/2013/02/01/LVS-Nat-Tun-Dr.html" target="_blank" rel="noopener">http://www.cnblogs.com/oldjiang/archive/2013/02/01/LVS-Nat-Tun-Dr.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VRRP协议及Keepalived原理与应用</title>
      <link href="/2019/02/18/VRRP%E5%8D%8F%E8%AE%AE%E5%8F%8AKeepalived%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2019/02/18/VRRP%E5%8D%8F%E8%AE%AE%E5%8F%8AKeepalived%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="VRRP简介"><a href="#VRRP简介" class="headerlink" title="VRRP简介"></a>VRRP简介</h1><p>VRRP，Virtual Router Redundancy Protocol，虚拟路由器冗余协议。VRRP由IETF提出，目的是为了解决局域网中配置默认网关的单点失效问题，1998年已推出正式的RFC2338协议标准。VRRP广泛应用在边缘网络中，它的设计目标是支持特定情况下IP数据流量失败转移不会引起混乱，允许主机使用单路由器，以及及时在实际第一跳路由器使用失败的情形下仍能够维护路由器间的连通性。</p><p>VRRP将局域网的一组路由器（包括一个Master即活动路由器和若干个Backup即备份路由器）组织成一个虚拟路由器，称之为一个备份组。这个虚拟的路由器拥有自己的IP地址10.100.10.1（这个IP地址可以和备份组内的某个路由器的接口地址相同，相同的则称为ip拥有者），备份组内的路由器也有自己的IP 地址（如Master的IP地址为10.100.10.2，Backup 的IP地址为10.100.10.3）。局域网内的主机仅仅知道这个虚拟路由器的IP地址10.100.10.1，而并不知道具体的Master路由器的IP地址10.100.10.2以及Backup路由器的IP地址10.100.10.3。它们将自己的缺省路由下一跳地址设置为该虚拟路由器的IP地址10.100.10.1。于是，网络内的主机就通过这个虚拟的路由器来与其它网络进行通信。如果备份组内的Master路由器坏掉，Backup路由器将会通过选举策略选出一个新的Master路由器，继续向网络内的主机提供路由服务，从而实现网络内的主机不间断地与外部网络进行通信。</p><p>VRRP说白了就是实现IP地址漂移的，是一种容错协议。在下图中，Router A、Router B和Router C组成一个虚拟路由器。各虚拟路由器都有自己的IP地址。局域网内的主机将虚拟路由器设置为缺省网关。Router A、Router B和Router C中优先级最高的路由器作为Master路由器，承担网关的功能。其余两台路由器作为Backup路由器。当master路由器出故障后，backup路由器会根据优先级重新选举出新的master路由器承担网关功能。Master路由器周期性地发送VRRP报文，在虚拟路由器中公布其配置信息（优先级等）和工作状况。Backup路由器通过接收到VRRP报文的情况来判断Master路由器是否工作工常。</p><p><img src="/images/sre_keepalived_1_1.png" alt></p><p>配置VRRP时，需要路由器支持VRRP功能。同时VRRP管理的机器，需要在同一个二层网络下，或同一个VLAN下。</p><h1 id="Keepalived简介"><a href="#Keepalived简介" class="headerlink" title="Keepalived简介"></a>Keepalived简介</h1><p>Keepalived使用的是VRRP协议方式。简单的说就是，Keepalived的目的是模拟路由器的高可用，Keepalived是模块化设计，不同模块负责不同的功能，下面是keepalived的组件：</p><p>（1）core<br>core组件是keepalived的核心，负责主进程的启动和维护，全局配置文件的加载解析等。</p><p>（2）check</p><p>check组件负责healthchecker（健康检查），包括了各种健康检查方式，以及对应的配置的解析包括LVS的配置解析。</p><p>（3）vrrp</p><p>VRRPD子进程，VRRPD子进程就是来实现VRRP协议的。</p><p>（4）libipfwc</p><p>iptables（ipchains）库，配置LVS会用到。</p><p>（5）libipvs*</p><p>配置LVS会用到。</p><p>备注：Keepalived和LVS完全是两码事，只不过他们各负其责相互配合而已。</p><h1 id="Keepalived安装和配置"><a href="#Keepalived安装和配置" class="headerlink" title="Keepalived安装和配置"></a>Keepalived安装和配置</h1><p>编译Keepalived时，如果不加参数可以编译，那么将只包含VRRP相关的功能，用来搭建HA集群，实现IP漂移。当加上–with-kernel-dir=可以将IPVS相关的特性编译进去，用于配置LVS。直白地说，我们将LVS相关的配置（例如realserver、调度算法、工作模式等）写入到keepalived配置中，由Keepalived帮配置LVS，其他这部分配置工作和使用ipvsadm是差不多的。</p><p>Keepalived的配置主要有全局配置段和VRRP配置段两部分，如果需要配置lvs，还需要有lvs相关的配置。</p><h2 id="全局配置段"><a href="#全局配置段" class="headerlink" title="全局配置段"></a>全局配置段</h2><p>包括邮件报警、SMTP服务器的配置等等，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">global_defs  &#123; </span><br><span class="line">    notification_email &#123; </span><br><span class="line">        admin@example.com </span><br><span class="line">    &#125; </span><br><span class="line">    notification_email_from admin@example.com </span><br><span class="line">    smtp_server 127.0.0.1 </span><br><span class="line">    stmp_connect_timeout 30 </span><br><span class="line">    lvs_id my_hostname </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VRRP配置段"><a href="#VRRP配置段" class="headerlink" title="VRRP配置段"></a>VRRP配置段</h2><p>VRRP配置时Keepalived核心，就是IP漂移相关的配置。举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123; </span><br><span class="line">    state BACKUP  #为BACKUP节点</span><br><span class="line">    interface eth0 </span><br><span class="line">    virtual_router_id 51 </span><br><span class="line">    priority 100 </span><br><span class="line">    nopreempt </span><br><span class="line">    advert_int 1 </span><br><span class="line">    authentication &#123; </span><br><span class="line">        auth_type PASS </span><br><span class="line">        auth_pass 123456 </span><br><span class="line">    &#125; </span><br><span class="line">    virtual_ipaddress &#123; </span><br><span class="line">        192.168.1.199/24  #VIP为192.168.1.199</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：如上是一个VRRP的配置，该实例是BACKUP节点，还需要再另外台机器上配置MASTER节点，这样才能达到IP漂移的效果。作为Master/Slave架构的keepalived，主备都正常时，是由priority来决定的，谁的priority值大，就由谁来做主节点。当vrrp_instance中包含了自定义的健康检查脚本并包含了weight，那么主备的角色是由priority加weight的和值来决定的，谁大就由谁来做主。需要注意的是，主备角色与state设置没有任何关系。</p><h2 id="LVS配置段"><a href="#LVS配置段" class="headerlink" title="LVS配置段"></a>LVS配置段</h2><p>LVS配置只在要使用Keepalived来配置和管理LVS时使用，如果仅仅使用Keepalived做HA的话就可以完全不用配置LVS。Keepalived关于LVS的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">virtual_server 192.168.1.199 80 &#123;  #LVS的VIP</span><br><span class="line">    delay_loop 6 </span><br><span class="line">    lb_algo rr </span><br><span class="line">    lb_kind NAT </span><br><span class="line">    nat_mask 255.255.255.0 </span><br><span class="line">    persistence_timeout 10 </span><br><span class="line">    protocol TCP </span><br><span class="line"></span><br><span class="line">    real_server 192.168.1.13 80 &#123;   #RealServer的机器</span><br><span class="line">        weight 1 </span><br><span class="line">        TCP_CHECK &#123;  #健康检查</span><br><span class="line">            connect_timeout 3 </span><br><span class="line">            nb_get_retry 3 </span><br><span class="line">            delay_before_retry 3 </span><br><span class="line">            connect_port 80 </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    real_server 192.168.1.14 80 &#123;   #RealServer的机器</span><br><span class="line">        weight 1 </span><br><span class="line">        TCP_CHECK &#123;    #健康检查</span><br><span class="line">            connect_timeout 3 </span><br><span class="line">            nb_get_retry 3 </span><br><span class="line">            delay_before_retry 3 </span><br><span class="line">            connect_port 80 </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：如果我们是需要IP漂移的HA集群，LVS相关的配置可以没有哦。</p><h1 id="其他相关点"><a href="#其他相关点" class="headerlink" title="其他相关点"></a>其他相关点</h1><h2 id="LVS-Keepalived-ipvsadm三者的关系"><a href="#LVS-Keepalived-ipvsadm三者的关系" class="headerlink" title="LVS/Keepalived/ipvsadm三者的关系"></a>LVS/Keepalived/ipvsadm三者的关系</h2><p>LVS，在功能层面，已经被集成进了当前流行的Linux kernel，随时可用。keepalived和ipvsadm都是lvs的管理工具，功能层面作用相同，二选一即可。keepalived是第三方的，支持lvs node本身的HA以及real server故障检测等功能，而ipvsadm是lvs作者原创的, 只支持lvs自身的功能管理。通常情况下，我们安装了lvs的内核模块后，需要再安装ipvsadm工具来配置LVS。而使用keepalived时，可以将lvs的配置写入keepalived的配置文件keepalived.conf中，然后由keepalived加载即可，不需要再使用ipvsadm来配置了。</p><p>keepalived和lvs结合使用，keepalived可以完成两项工作，一是对Real Server中的机器进行健康检查，如果有问题，从服务器池中剔除；二是在LoadBalance间进行容灾切换。</p><p>keepalived编译的时候，可以将lvs的管理接口编译到keepalived中，这样keepalived就可以和LVS模块交互，就不只有IP漂移功能了。 </p><h2 id="keepalived的容灾切换原理"><a href="#keepalived的容灾切换原理" class="headerlink" title="keepalived的容灾切换原理"></a>keepalived的容灾切换原理</h2><p>keepalived中优先级高的节点为MASTER。MASTER其中一个职责就是响应VIP的ARP包，将VIP和MAC地址映射关系告诉局域网内其他主机，同时，它还会以多播的形式向局域网中发送VRRP通告，告知自己的优先级。网络中的所有BACKUP节点只负责处理MASTER发出的多播包，当发现MASTER的优先级没自己高，或者没收到MASTER的VRRP通告时，BACKUP将自己切换到MASTER状态，然后做MASTER该做的事（1.响应ARP包；2.发送VRRP通告）。</p><p>备注：响应ARP包，告诉本机的MAC地址，也意味着告诉发送方，本机才是虚拟IP的拥有者。这个IP漂移的关键哦。</p><h2 id="keepalived进程的说明"><a href="#keepalived进程的说明" class="headerlink" title="keepalived进程的说明"></a>keepalived进程的说明</h2><p>keepalived启动后会有三个进程，如下：</p><pre><code>父进程用来内存管理，子进程管理等VRRP子进程healthchecker子进程</code></pre><h2 id="keepalived集群组脑裂问题"><a href="#keepalived集群组脑裂问题" class="headerlink" title="keepalived集群组脑裂问题"></a>keepalived集群组脑裂问题</h2><p>在HA架构中，如果出现两个节点同时认为自已是唯一处于活动状态的服务器从而出现争用资源的情况，这种争用资源的场景即是所谓的”脑裂”（split-brain）或”partitioned cluster”。在两个节点共享同一个物理设备资源的情况下，脑裂会产生相当可怕的后果。</p><h2 id="keepalived-heartbeat-HAProxy的比较"><a href="#keepalived-heartbeat-HAProxy的比较" class="headerlink" title="keepalived/heartbeat/HAProxy的比较"></a>keepalived/heartbeat/HAProxy的比较</h2><p>keepalived主要是控制IP的漂移，其配置、应用简单，而heartbeat则不但可以控制IP漂移，更擅长对资源服务的控制，其配置、应用比较复杂。</p><p>一般Keepalived是实现前端高可用，常用的前端高可用的组合有，就是我们常见的LVS+Keepalived、Nginx+Keepalived、HAproxy+Keepalived。而Heartbeat或Corosync是实现服务的高可用，常见的组合有Heartbeat v3(Corosync)+Pacemaker+NFS+Httpd实现Web服务器的高可用，Heartbeat v3(Corosync)+Pacemaker+NFS+MySQL实现MySQL服务器的高可用。</p><h2 id="virtual-router-id冲突问题"><a href="#virtual-router-id冲突问题" class="headerlink" title="virtual_router_id冲突问题"></a>virtual_router_id冲突问题</h2><p>virtual_router_id，一般简称为VRID，全称为虚拟路由器的标识，有相同VRID的一组路由器构成一个虚拟路由器。</p><p>keepalived的主、备机的virtual_router_id必须相同，取值范围为0-255。但是同一局域网或同一交换机中不应有相同virtual_router_id的其他keepalived集群，这样会导致keepalived冲突。</p><h2 id="keepalived日志中一些关键字段"><a href="#keepalived日志中一些关键字段" class="headerlink" title="keepalived日志中一些关键字段"></a>keepalived日志中一些关键字段</h2><pre><code>Transition to MASTER STATE    #VIP漂移到该机器上Entering BACKUP STATE         #VIP漂移到其他机器上</code></pre><h2 id="VRRP通告报文"><a href="#VRRP通告报文" class="headerlink" title="VRRP通告报文"></a>VRRP通告报文</h2><p>在一套部署了Keepalived组成的高可用中，正常来说，只有Master节点才会发送VRRP通告，各个Slave是不会发送VRRP通告。但是当Master故障或Slave收到的VRRP通告的优先级没有自己高的时候，Slave在遇到这种状况下，就会向外广播VRRP通告。如下为在Slave节点通过<code>tcpdump -nni any vrrp | grep &#39;vrid 123&#39;</code>命令获取到的VRRP通告报文：</p><pre><code>14:30:37.034353 IP 10.13.100.16 &gt; 224.0.0.18: VRRPv2, Advertisement, vrid 123, prio 130, authtype simple, intvl 2s, length 20</code></pre><h2 id="VRRP协议栈结构"><a href="#VRRP协议栈结构" class="headerlink" title="VRRP协议栈结构"></a>VRRP协议栈结构</h2><p><img src="/images/sre_keepalived_1_2.png" alt></p><p>可见VRRP协议是工作在IP层协议之上的，也就是VRRP报文需要IP地址传递。</p><p>学习资料参考于：<br><a href="http://zhaoyuqiang.blog.51cto.com/6328846/1166840" target="_blank" rel="noopener">http://zhaoyuqiang.blog.51cto.com/6328846/1166840</a><br><a href="http://hugnew.com/?p=745" target="_blank" rel="noopener">http://hugnew.com/?p=745</a><br><a href="http://www.361way.com/keepalived-framework/5208.html" target="_blank" rel="noopener">http://www.361way.com/keepalived-framework/5208.html</a><br><a href="http://freeloda.blog.51cto.com/2033581/1280962" target="_blank" rel="noopener">http://freeloda.blog.51cto.com/2033581/1280962</a><br><a href="http://asram.blog.51cto.com/1442164/359093/" target="_blank" rel="noopener">http://asram.blog.51cto.com/1442164/359093/</a></p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中SPI机制总结</title>
      <link href="/2019/02/14/JAVA%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2019/02/14/JAVA%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="API与SPI"><a href="#API与SPI" class="headerlink" title="API与SPI"></a>API与SPI</h1><p>面向对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。</p><p><img src="/images/java_spi_1_1.png" alt></p><p>当接口属于实现方时，实现方提供了接口和具体实现类，然后调用方通过引用接口来达到调用该实现类的功能。这中模式就是我们经常所说的API。</p><p>当接口属于调用方时，我们就将其称为SPI（全称为Service Provider Interface）。</p><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><p>SPI全称为(Service Provider Interface)，是JDK内置的一种服务提供发现机制。许多开发框架都使用了Java的SPI机制，如数据库驱动java.sql.Driver的SPI实现（mysql驱动、oracle驱动等）、common-logging的日志接口实现、dubbo的扩展实现等等。下面我们以数据库驱动为例来解释SPI的机制原理。</p><h2 id="JDBC驱动接口的定义"><a href="#JDBC驱动接口的定义" class="headerlink" title="JDBC驱动接口的定义"></a>JDBC驱动接口的定义</h2><p>首先在JDK中定义了接口<code>java.sql.Driver</code>，但并没有具体的实现，具体的实现都是由不同的数据库厂商来提供的。</p><h2 id="java-sql-Driver的MySQL厂商实现"><a href="#java-sql-Driver的MySQL厂商实现" class="headerlink" title="java.sql.Driver的MySQL厂商实现"></a>java.sql.Driver的MySQL厂商实现</h2><p>在MySQL的jar包<code>mysql-connector-java-6.0.6.jar</code>中，可以找到<code>META-INF/services</code>目录，该目录下会有一个名字为<code>java.sql.Driver</code>的文件，文件内容是<code>com.mysql.cj.jdbc.Driver</code>，这个就是针对JDK中定义的Driver接口的MySQL实现类的完整包路径。</p><h2 id="java-sql-Driver的Postgresql厂商实现"><a href="#java-sql-Driver的Postgresql厂商实现" class="headerlink" title="java.sql.Driver的Postgresql厂商实现"></a>java.sql.Driver的Postgresql厂商实现</h2><p>同样在PostgreSQL的jar包postgresql-42.0.0.jar中，也可以找到同样的配置文件<code>META-INF/services/java.sql.Driver</code>，文件内容是<code>org.postgresql.Driver</code>，这是postgresql对JDK的Driver接口的实现类的完整包路径。</p><h2 id="通过SPI机制来加载具体的驱动实现"><a href="#通过SPI机制来加载具体的驱动实现" class="headerlink" title="通过SPI机制来加载具体的驱动实现"></a>通过SPI机制来加载具体的驱动实现</h2><p>我们在项目开发中，可以通过如下代码来获取数据库连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"jdbc:xxxx://xxxx:xxxx/xxxx"</span>;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, username, password);</span><br></pre></td></tr></table></figure><p>这里就涉及到使用Java的SPI扩展机制来查找相关具体驱动实例类了，但从直观上来看，并不能看到有关SPI机制相关的代码，其实被封装在了DriverManager中。DriverManager是JDK中的实现，用来获取数据库连接，在DriverManager中有一个静态代码块如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是加载实例化驱动的，接着看loadInitialDrivers方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> System.getProperty(<span class="string">"jdbc.drivers"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        drivers = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//使用SPI的ServiceLoader来加载接口的实现</span></span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"DriverManager.initialize: jdbc.drivers = "</span> + drivers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drivers == <span class="keyword">null</span> || drivers.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList = drivers.split(<span class="string">":"</span>);</span><br><span class="line">    println(<span class="string">"number of Drivers:"</span> + driversList.length);</span><br><span class="line">    <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">"DriverManager.Initialize: loading "</span> + aDriver);</span><br><span class="line">            Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            println(<span class="string">"DriverManager.Initialize: load failed: "</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，关于SPI的代码部分如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//获取迭代器</span></span><br><span class="line">Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"><span class="comment">//遍历所有的驱动实现</span></span><br><span class="line"><span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">    driversIterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在遍历的时候，首先调用<code>driversIterator.hasNext()</code>方法，这里会搜索classpath下以及jar包中所有的<code>META-INF/services</code>目录下的<code>java.sql.Driver</code>文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类。然后是调用<code>driversIterator.next()</code>方法，此时就会根据驱动名字具体实例化各个实现类了。现在驱动就被找到并实例化了。</p><p>当我们在测试项目中添加了两个jar包，<code>mysql-connector-java-6.0.6.jar</code>和<code>postgresql-42.0.0.0.jar</code>，跟踪到<code>DriverManager</code>中之后，可以看到此时迭代器中有两个驱动，mysql和postgresql的都被加载了。有关两个驱动都加载了，JDBC会有一定的方法来判断使用哪一个驱动。</p><p><img src="/images/java_spi_1_2.png" alt></p><h1 id="SPI的具体实现者需要遵循的SPI规则"><a href="#SPI的具体实现者需要遵循的SPI规则" class="headerlink" title="SPI的具体实现者需要遵循的SPI规则"></a>SPI的具体实现者需要遵循的SPI规则</h1><p>以<code>java.sql.Driver</code>的MySQL厂商实现<code>mysql-connector-java-5.1.44.jar</code>为例来说，需要在META-INF/services目录下创建一个名字为接口全限定名的文件，即<code>java.sql.Driver</code>文件，文件内容是具体的实现名字，如下：</p><pre><code>com.mysql.jdbc.Drivercom.mysql.fabric.jdbc.FabricMySQLDriver</code></pre><p><code>com.mysql.jdbc.Driver</code>和<code>com.mysql.fabric.jdbc.FabricMySQLDriver</code>即是MySQL公司实现了JAVA JDK的<code>java.sql.Driver</code>接口的实现类。</p><p>学习资料参考于：<br><a href="https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>悲观锁与乐观锁在MySQL中的应用</title>
      <link href="/2019/02/14/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81%E5%9C%A8MySQL%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/02/14/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81%E5%9C%A8MySQL%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库中的悲观锁与乐观锁"><a href="#数据库中的悲观锁与乐观锁" class="headerlink" title="数据库中的悲观锁与乐观锁"></a>数据库中的悲观锁与乐观锁</h1><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像Memcache、Hibernate、Tair等都有类似的概念。</p><p>针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据库中提供的锁机制（<strong>行锁、表锁、排他锁、共享锁</strong>）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。</p><p>备注：乐观锁/悲观锁是基于互斥锁/排他锁/共享锁等具体锁机制之上的一种思想。</p><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><h2 id="乐观锁简介"><a href="#乐观锁简介" class="headerlink" title="乐观锁简介"></a>乐观锁简介</h2><p>在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。</p><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般实现乐观锁的方式就是记录数据版本。</p><p>数据版本为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</p><p>实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。</p><h2 id="使用版本号实现乐观锁"><a href="#使用版本号实现乐观锁" class="headerlink" title="使用版本号实现乐观锁"></a>使用版本号实现乐观锁</h2><p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.查询出商品信息*/</span></span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">status</span>,<span class="keyword">status</span>,<span class="keyword">version</span>) <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125;</span></span><br><span class="line"><span class="comment">/*2.根据商品信息生成订单*/</span></span><br><span class="line"><span class="comment">/*3.修改商品status为2*/</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125; and version=#&#123;version&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="乐观锁的优缺点"><a href="#乐观锁的优缺点" class="headerlink" title="乐观锁的优缺点"></a>乐观锁的优缺点</h2><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p><h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><h2 id="悲观锁简介"><a href="#悲观锁简介" class="headerlink" title="悲观锁简介"></a>悲观锁简介</h2><p>在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</p><p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>MySQL InnoDB存储引擎中，共享锁和排它锁是两种悲观锁。</p><h2 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h2><p>排他锁，exclusive lock（也叫writer lock）又称写锁。排它锁是悲观锁的一种。若事务1对数据对象A加上排它锁，事务1可以读A也可以修改A，其他事务不能再对A加任何锁，直到事务1释放A上的锁。这保证了其他事务在事务1释放A上的锁之前不能再读取和修改A。</p><p>要使用悲观锁，我们必须关闭MySQL数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。使用语句<code>set autocommit=0;</code>可以关闭autocommit模式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.关闭MySQL自动提交功能*/</span></span><br><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*2.开始事务*/</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">/*3.查询出商品信息，for update加上排它锁*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">/*4.根据商品信息生成订单*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders (<span class="keyword">id</span>,goods_id) <span class="keyword">values</span> (<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*5.修改商品status为2*/</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>;</span><br><span class="line"><span class="comment">/*6.提交事务*/</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>上面的查询语句中，我们使用了<code>select … for update</code>的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>上面我们提到，使用<code>select … for update</code>会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</p><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁，read lock，又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排它锁），直到已释放所有共享锁。</p><p>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获得共享锁的事务只能读数据，不能修改数据。</p><p>在查询语句后面增加LOCK IN SHARE MODE，MySQL会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排它锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p><p>下面是具体使用共享锁的例子：</p><p>打开第一个查询窗口，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.开启事务*/</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">/*2.lock in share mode，加上共享锁*/</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure><p>然后在另一个查询窗口中，对id为1的数据进行更新，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">"www.souyunku.com"</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>此时，操作界面进入了卡顿状态，过了超时间，提示错误信息。但是如果在超时前，执行commit，此更新语句就会成功。</p><pre><code>[SQL]update  test_one set name=&quot;www.souyunku.com&quot; where id =1;[Err] 1205 - Lock wait timeout exceeded; try restarting transaction</code></pre><h2 id="悲观锁的优缺点"><a href="#悲观锁的优缺点" class="headerlink" title="悲观锁的优缺点"></a>悲观锁的优缺点</h2><p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。</p><h1 id="行锁和表锁"><a href="#行锁和表锁" class="headerlink" title="行锁和表锁"></a>行锁和表锁</h1><p>前面提到过，在InnoDB引擎中共享锁和排它锁都存在行锁和表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？ 当SQL语句的条件使用到索引了，InnoDB才使用行级锁，否则，InnoDB将使用表锁。</p><p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是，由于需要请求大量的锁资源，所以速度慢，内存消耗大。</p><p>学习资料参考于：<br><a href="https://www.hollischuang.com/archives/934" target="_blank" rel="noopener">https://www.hollischuang.com/archives/934</a><br><a href="https://mp.weixin.qq.com/s/gWR1-511SAwVAHrtGrsZ8g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/gWR1-511SAwVAHrtGrsZ8g</a><br><a href="https://www.souyunku.com/2018/07/30/mysql/" target="_blank" rel="noopener">https://www.souyunku.com/2018/07/30/mysql/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL存储引擎</title>
      <link href="/2019/02/13/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2019/02/13/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="存储引擎介绍"><a href="#存储引擎介绍" class="headerlink" title="存储引擎介绍"></a>存储引擎介绍</h1><p>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p><p><strong>简单来说，存储引擎就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法</strong>。</p><p>在MySQL中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p><h1 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h1><p>MySQL常见的存储引擎有：</p><p>（1）MyISAM</p><p>MyISAM是MySQL提供的最早的存储引擎。MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器。每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：</p><pre><code>tb_demo.frm，存储表定义tb_demo.MYD，存储数据tb_demo.MYI，存储索引</code></pre><p>MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。</p><p>（2）InnoDB（默认的存储引擎）</p><p>InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。InnoDB是目前使用最多的存储引擎，支持“行级锁”，而其他的存储引擎一般只有“表级锁”。行级锁的意思是当要修改某一条记录时，MySQL只对该行加锁，而该表的其他行仍可以由其他的client来执行修改。</p><p>（3）Memery</p><p>将MySQL的数据存放到内存上。当主机宕掉，那么该机上的数据也将丢失。</p><p>（4）NDB</p><p>NDB引擎可以实现MySQL Cluster，分布式MySQL集群。</p><p>（5）Archive</p><p>（6）Federated</p><p>（7）Maria</p><p>（8）……</p><p>目前在实际应用中，我们主要使用MyISAM和InnoDB两种存储引擎。不同存储引起都有各自的特点，为适应不同的需求，需要选择不同的存储引擎，所以首先考虑这些存储引擎各自的功能和兼容。</p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th><th>ARCHIVE</th></tr></thead><tbody><tr><td>存储限制(Storage limits)</td><td>64TB</td><td>No</td><td>YES</td><td>No</td></tr><tr><td>支持事务(Transactions)</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>锁机制(Locking granularity)</td><td>行锁</td><td>表锁</td><td>表锁</td><td>行锁</td></tr><tr><td>B树索引(B-tree indexes)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>T树索引(T-tree indexes)</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>哈希索引(Hash indexes)</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>全文索引(Full-text indexes)</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>集群索引(Clustered indexes)</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>数据缓存(Data caches)</td><td>Yes</td><td>No</td><td>N/A</td><td>No</td></tr><tr><td>索引缓存(Index caches)</td><td>Yes</td><td>Yes</td><td>N/A</td><td>No</td></tr><tr><td>数据可压缩(Compressed data)</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>加密传输(Encrypted data<sup>[1]</sup>)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>集群数据库支持(Cluster databases support)</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>复制支持(Replication support<sup>[2]</sup>)</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>外键支持(Foreign key support)</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>存储空间消耗(Storage Cost)</td><td>高</td><td>低</td><td>N/A</td><td>非常低</td></tr><tr><td>内存消耗(Memory Cost)</td><td>高</td><td>低</td><td>N/A</td><td>低</td></tr><tr><td>数据字典更新(Update statistics for data dictionary)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>备份/时间点恢复(backup/point-in-time recovery<sup>[3]</sup>)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>多版本并发控制(Multi-Version Concurrency Control/MVCC)</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>批量数据写入效率(Bulk insert speed)</td><td>慢</td><td>快</td><td>快</td><td>非常快</td></tr><tr><td>地理信息数据类型(Geospatial datatype support)</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>地理信息索引(Geospatial indexing support<sup>[4]</sup>)</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr></tbody></table><h1 id="关于MySQL存储引擎的一些命令操作"><a href="#关于MySQL存储引擎的一些命令操作" class="headerlink" title="关于MySQL存储引擎的一些命令操作"></a>关于MySQL存储引擎的一些命令操作</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;                <span class="comment">/*查看MySQL支持的存储引擎*/</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> websites;  <span class="comment">/*可以查看某张表的使用的存储引擎*/</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">from</span> 数据库名名称 <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'表名称'</span>;   <span class="comment">/*可以查看某张表的使用的存储引擎*/</span></span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md" target="_blank" rel="noopener">https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中curl命令的使用</title>
      <link href="/2019/02/01/Linux%E4%B8%ADcurl%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/01/Linux%E4%B8%ADcurl%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="curl简介"><a href="#curl简介" class="headerlink" title="curl简介"></a>curl简介</h1><p>简单来说，curl是一个用url方式，来和服务器进行文件传输和下载的工具。它不仅仅支持HTTP协议，还支持了其他的众多的协议，例如<code>DICT/FILE/FTP/FTPS/Gopher/HTTP/HTTPS/IMAP/IMAPS/LDAP/LDAPS/POP3/POP3S/RTMP</code>等。</p><h1 id="curl工具格式和选项"><a href="#curl工具格式和选项" class="headerlink" title="curl工具格式和选项"></a>curl工具格式和选项</h1><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [options] [URL...]</span><br></pre></td></tr></table></figure><p>重要选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-X method, --request method      <span class="comment">#指定使用http的method，有GET/POST/PUT/DELETE等等，默认是GET方法</span></span><br><span class="line">-d key=value, --data key=value   <span class="comment">#指定HTTP请求中请求数据段，例如HTTP POST请求时需要传递给服务器的数据，一个curl命令中，可以用多个-d选项，curl会将他们合并成key1=value1&amp;key2=value2…</span></span><br><span class="line">--data-urlencode key=value       <span class="comment">#类似于-d key=value，但是会经过URL编码</span></span><br><span class="line">-F key=value, --form key=value   <span class="comment">#模拟向服务器提交表单form数据，curl会用multipart/form-data的格式传递给服务器，而-d选项使用的是application/x-www-form-urlencoded，一个curl命令中，同样可以有多个-F选项</span></span><br><span class="line">-e url, --referer url            <span class="comment">#在curl发起的http请求的请求头中，设置referer信息，向目标请求站点说明本次的http请求是来自那个http页面</span></span><br><span class="line">-H &lt;header&gt;, --header &lt;header&gt;   <span class="comment">#为http请求设置请求头信息，例如，--header "Content-Type:application/json" -H Host:www.baididu.com</span></span><br><span class="line">-A &lt;agent string&gt;, --user-agent&lt;agent string&gt;   <span class="comment">#为http请求设置user-agent信息，这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页</span></span><br><span class="line">-u &lt;user:password;options&gt;, --user&lt;user:password;options&gt;   <span class="comment">#为http请求设置用户名和密码</span></span><br><span class="line">-o filename           <span class="comment">#将curl返回的请求结果，写入到filename文件中</span></span><br><span class="line">-b &lt;name=data&gt;, --cookie&lt;name=data&gt;, -b &lt;cookie-file&gt;, --cookie &lt;cookie-file&gt;  <span class="comment">#为curl的http请求携带cookies信息，可以在命令行用key=value设置，也可以从一个文件中读取</span></span><br><span class="line">-c &lt;cookie-file&gt;, --cookie-jar &lt;cookie-file&gt;      <span class="comment">#将服务器返回的cookie信息写入到本地文件中</span></span><br><span class="line">-v, --verbose         <span class="comment">#显示curl的http请求的通信过程，直接打印到终端上</span></span><br><span class="line">--trace &lt;file&gt;        <span class="comment">#将curl的http请求通信过程写入到文件中</span></span><br><span class="line">--trace-ascii &lt;file&gt;  <span class="comment">#同--trace &lt;file&gt;类似，将curl的http请求通信过程写入到文件中</span></span><br><span class="line">-I          <span class="comment">#只输出HTTP响应报文的头部</span></span><br><span class="line">-i          <span class="comment">#输出HTTP响应报文的头部以及响应正文</span></span><br><span class="line">-s          <span class="comment">#让curl开启静默模式，即不输出进度或错误等信息</span></span><br><span class="line">-L          <span class="comment">#如果服务端返回3XX重定向，curl会继续向新地址发送请求</span></span><br><span class="line">-k          <span class="comment">#curl对于服务器发过来的任何证书不做校验，都认为是安全的</span></span><br><span class="line">-x ip:port  <span class="comment">#设置http请求的代理服务器，若端口不指定，默认为1080</span></span><br><span class="line">-w &lt;format&gt; <span class="comment">#输出curl过程中特定的对象值，如状态码http_code，总耗时time_total等</span></span><br></pre></td></tr></table></figure><h1 id="curl使用的例子"><a href="#curl使用的例子" class="headerlink" title="curl使用的例子"></a>curl使用的例子</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.example.com</span><br><span class="line">curl -o sina.output http://www.example.com</span><br><span class="line">curl -s -o /dev/null http://www.example.com</span><br><span class="line">curl -v http://www.example.com</span><br><span class="line">curl --trace output.txt http://www.example.com</span><br><span class="line">curl http://example.com/form.cgi?data=xxx</span><br><span class="line">curl -X POST --data <span class="string">"data=xxx"</span> http://example.com/form.cgi</span><br><span class="line">curl -X POST --data-urlencode <span class="string">"date=April 1"</span> http://example.com/form.cgi</span><br><span class="line">curl --referer http://www.example.com http://www.example1.com</span><br><span class="line">curl --form upload=@localfilename --form press=OK http://www.example.com  <span class="comment">#利用curl上传文件</span></span><br><span class="line">curl --cookie <span class="string">"name=xxx"</span> www.example.com</span><br><span class="line">curl --header <span class="string">"Content-Type:application/json"</span> http://example.com</span><br><span class="line">curl -X PUT -H <span class="string">"Accept: application/json"</span> http://example.com/v1/user/add --basic -u user:passwd \</span><br><span class="line">     -F proto_file=@task.proto                                          \</span><br><span class="line">     -F message_name=<span class="string">"adduser"</span>                                          \</span><br><span class="line">     -F host=hostname                                                   \</span><br><span class="line">     -F part_count=4                                                    \</span><br><span class="line">     -F replication=5                                                   \</span><br><span class="line">     -F part_rule=MOD                                                   \</span><br><span class="line">     -F cpu_num=20                                                      \</span><br><span class="line">     -F mem_mb=10000                                                    \</span><br><span class="line">     -F disk_mb=10000                                                   \</span><br><span class="line">     -F token_pattern=<span class="string">"token"</span>                                           \</span><br><span class="line"></span><br><span class="line">curl -I -H <span class="string">"Host:www.example.com"</span> http://10.16.34.23/</span><br><span class="line">curl https://www.example.com -x 10.16.34.23:443</span><br><span class="line">curl -k <span class="string">"https://www.example.com"</span></span><br><span class="line">curl -s <span class="string">"http://www.sohu.com"</span> -w <span class="string">'httpcode:%&#123;http_code&#125;;timetotal:%&#123;time_total&#125;'</span> -o /dev/null</span><br><span class="line">curl -I -H <span class="string">"Host:www.sohu.com"</span> http://[2409:8c00:3001::3]:80 -g</span><br></pre></td></tr></table></figure><p>备注：狭义地说，curl像是一个浏览器，但是比浏览器的支持的东西要多，因为它不仅支持HTTP协议，还支持其他很多的协议。</p><h1 id="关于使用curl命令的-d参数携带HTTP-request的请求体request-body一些问题"><a href="#关于使用curl命令的-d参数携带HTTP-request的请求体request-body一些问题" class="headerlink" title="关于使用curl命令的-d参数携带HTTP request的请求体request body一些问题"></a>关于使用curl命令的-d参数携带HTTP request的请求体request body一些问题</h1><p>HTTP Requset请求头中的<code>Content-Type</code>是用来说明请求体的MIME类型的，默认是<code>application/x-www-form-urlencoded</code>类型。<code>curl -d</code>参数是用携带<code>POST/PUT</code>请求的请求体内容的，有如下几种支持的格式：</p><p>（1）第一种</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d <span class="string">"param1=value1&amp;param2=value2"</span> -X POST http://localhost:3000/data</span><br></pre></td></tr></table></figure><p>备注：<code>Content-Type</code>缺省为<code>application/x-www-form-urlencoded</code>，所以使用<code>param1=value1&amp;param2=value2</code>格式时，可省略。</p><p>（2）第二种</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d <span class="string">"param1=value1&amp;param2=value2"</span> -H <span class="string">"Content-Type: application/x-www-form-urlencoded"</span> -X POST http://localhost:3000/data</span><br></pre></td></tr></table></figure><p>备注：使用<code>param1=value1&amp;param2=value2</code>格式时，也可以显式地指出<code>application/x-www-form-urlencoded</code>。</p><p>（3）第三种</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d <span class="string">'&#123;"key1":"value1", "key2":"value2"&#125;'</span> -H <span class="string">"Content-Type: application/json"</span> -X POST http://localhost:3000/data</span><br></pre></td></tr></table></figure><p>备注：使用json格式的数据，一定要显式地指明<code>Content-Type</code>为<code>application/json</code>。</p><p>（4）第四种</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d <span class="string">"@data.txt"</span> -X POST http://localhost:3000/data</span><br></pre></td></tr></table></figure><p>备注：将<code>param1=value1&amp;param2=value2</code>格式的数据单独放入文件，然后通过<code>-d &quot;@filename&quot;</code>来引入。</p><p>（5）第五种</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d <span class="string">"@data.json"</span> -H <span class="string">"Content-Type: application/json"</span> -X POST http://localhost:3000/data</span><br></pre></td></tr></table></figure><p>备注：将json格式的数据单独放入文件，然后通过<code>-d &quot;@filename&quot;</code>来引入。</p><h1 id="curl的一些其他问题"><a href="#curl的一些其他问题" class="headerlink" title="curl的一些其他问题"></a>curl的一些其他问题</h1><p>在使用curl做POST的时候，当要POST的数据大于1024字节的时候，curl并不会直接就发起POST请求，而是会分为两步：</p><p>（1）发送一个请求，包含一个Expect:100-continue，询问Server使用愿意接受数据</p><p>（2）接收到Server返回的100-continue应答以后，才把数据POST给Server</p><p>这是libcurl的行为。具体的RFC相关描述：<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3" target="_blank" rel="noopener">http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3</a></p><p>于是，这样就有了一个问题，并不是所有的Server都会正确应答100-continue，比如lighttpd，就会返回417 “Expectation Failed”，则会造成逻辑出错。</p><p>要解决的办法也挺容易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl_setopt($ch, CURLOPT_HTTPHEADER, array(&apos;Expect:&apos;));</span><br><span class="line">// Disable Expect: header (lighttpd does not support it)</span><br></pre></td></tr></table></figure><p><img src="/images/curl_1_1.png" alt></p><p>学习资料参考于：<br><a href="https://gist.github.com/subfuzion/08c5d85437d5d4f00e58" target="_blank" rel="noopener">https://gist.github.com/subfuzion/08c5d85437d5d4f00e58</a><br><a href="http://www.ruanyifeng.com/blog/2011/09/curl.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/curl.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中各种日志总结</title>
      <link href="/2018/12/14/MySQL%E4%B8%AD%E5%90%84%E7%A7%8D%E6%97%A5%E5%BF%97%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/14/MySQL%E4%B8%AD%E5%90%84%E7%A7%8D%E6%97%A5%E5%BF%97%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL中的日志种类"><a href="#MySQL中的日志种类" class="headerlink" title="MySQL中的日志种类"></a>MySQL中的日志种类</h1><p>MySQL中有六种日志文件，分别是错误日志（error log）、查询日志（general &amp; slow query log）、重做日志（redo log）、回滚日志（undo log）、二进制日志（binary log）以及中继日志（relay log）。</p><p>其中重做日志和回滚日志与事务操作息息相关，二进制日志也与事务操作有一定的关系，这三种日志，对理解MySQL中的事务操作有着重要的意义。</p><h1 id="错误日志（error-log）"><a href="#错误日志（error-log）" class="headerlink" title="错误日志（error log）"></a>错误日志（error log）</h1><p>记录MySQL服务进程在启动/关闭或者运行过程中遇到的错误消息，是数据库管理工作中排查错误的重要工具。执行如下命令可以查看错误日志的位置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'log_error'</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_log_1_1.png" alt></p><h1 id="查询日志（query-log）"><a href="#查询日志（query-log）" class="headerlink" title="查询日志（query log）"></a>查询日志（query log）</h1><p>查询日志包括普通查询日志（general query log）和慢查询日志（slow query log）。其中普通查询日志记录客户端连接和执行的SQL语句信息，慢查询日志记录执行时间超出指定值和没有利用索引（log_queries_not_using_indexes）的SQL语句。</p><p>普通查询日志，一般不开启，比较占空间。执行如下命令可以查看普通查询日志的开启状态和日志文件位置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'general_log%'</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_log_1_2.png" alt></p><p>执行如下命令可以查看慢查询日志的开启状态和日志文件位置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slow_%log%'</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_log_1_3.png" alt></p><h1 id="重做日志（redo-log）"><a href="#重做日志（redo-log）" class="headerlink" title="重做日志（redo log）"></a>重做日志（redo log）</h1><p>（1）重做日志简介</p><p>确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p><p>（2）重做日志相关配置</p><p>默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile0和ib_logfile1。innodb_log_group_home_dir指定日志文件组所在的路径，默认<code>./</code>，表示在数据库的数据目录下。innodb_log_files_in_group指定重做日志文件组中文件的数量，默认是2。innodb_log_file_size指定重做日志文件的大小。innodb_mirrored_log_groups指定了日志镜像文件组的数量，默认是1。</p><h1 id="回滚日志（undo-log）"><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h1><p>（1）回滚日志简介</p><p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p><p>（2）回滚日志相关配置</p><p>MySQL 5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。MySQL 5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数。如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。</p><h1 id="二进制日志（binary-log）"><a href="#二进制日志（binary-log）" class="headerlink" title="二进制日志（binary log）"></a>二进制日志（binary log）</h1><p>用于主从复制。在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。用于数据库的基于时间点的还原。具体参见<a href="https://wangjianno1.github.io/2018/02/02/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6replication%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/">《MySQL主从复制replication原理及配置》</a>。执行命令<code>show variables like &#39;log_bin&#39;;</code>可以查看二进制日志是否开启：</p><p><img src="/images/mysql_log_1_4.png" alt></p><h1 id="中继日志（relay-log）"><a href="#中继日志（relay-log）" class="headerlink" title="中继日志（relay log）"></a>中继日志（relay log）</h1><p>在主从复制的架构中，从库的IO线程接收到主库的binlog日志后，将接收到的日志内容依次添加到从库的relay-log文件的最末端，然后从库的SQL线程检测到relay-log中新增加了内容后，会马上解析relay-log的内容，并将其在从库中回放执行。</p><p>学习资料参考于：<br><a href="http://www.cnblogs.com/liulei-LL/p/7648006.html" target="_blank" rel="noopener">http://www.cnblogs.com/liulei-LL/p/7648006.html</a><br><a href="https://mp.weixin.qq.com/s/yGytaV7owibajI04Z7rHNw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/yGytaV7owibajI04Z7rHNw</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL在实际应用中的部署架构</title>
      <link href="/2018/12/14/MySQL%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84/"/>
      <url>/2018/12/14/MySQL%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="单机式架构"><a href="#单机式架构" class="headerlink" title="单机式架构"></a>单机式架构</h1><p>只在一台机器上部署一个MySQL Server，所有的client都连接这个MySQL Server。这种结构数据安全以及访问效率上都有一定的局限性。</p><h1 id="基于主从同步的分布式结构"><a href="#基于主从同步的分布式结构" class="headerlink" title="基于主从同步的分布式结构"></a>基于主从同步的分布式结构</h1><p>基于主从同步的分布式集群中，包括主节点，以及很多的从节点，从节点从主节点中同步数据。然后以MySQL-Proxy来实现“读写分离”，主库可以提供读写服务，从库只可以提供读服务。其中实现MySQL“读写分离”的MySQL-Proxy可以有很多的选择。</p><h1 id="基于NDB存储引擎的MySQL集群"><a href="#基于NDB存储引擎的MySQL集群" class="headerlink" title="基于NDB存储引擎的MySQL集群"></a>基于NDB存储引擎的MySQL集群</h1><p>类似于Oracle集群的“节点”概念，基于NDB存储引擎的MySQL集群也包含“节点”的概念，其中包括数据节点(ndbd)，管理节点(mgmd)，服务节点(mysqld)。</p><p>（1）数据节点</p><p>数据节点就是用来存储数据的，数据节点上只需启动ndbd服务就可以，不需要部署mysqld。</p><p>（2）管理节点</p><p>管理节点用来管理集群中各个节点，管理节点只需要部署ngmd服务就行了，不需要部署mysqld。</p><p>（3）服务节点</p><p>服务节点需要部署mysqld服务，用来供用户端来进行来进行连接，它是对外提供服务的接口。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础介绍</title>
      <link href="/2018/12/14/MySQL%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/12/14/MySQL%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL的发行版本"><a href="#MySQL的发行版本" class="headerlink" title="MySQL的发行版本"></a>MySQL的发行版本</h1><p>MySQL是一个开源的小型的关系型数据库，是由瑞典的MySQL AB公司开发，现在已经被Oracle公司收购了。Mysql的发行版本有：</p><p>（1）MySQL Community Server社区版本，开源免费，但不提供官方技术支持。</p><p>（2）MySQL Enterprise Edition企业版本，需付费，可以试用30天。</p><p>（3）MySQL Cluster集群版，开源免费。可将几个MySQL Server封装成一个Server。</p><p>（4）MySQL Cluster CGE高级集群版，需付费。</p><p>其中，MySQL Community Server是开源免费的，这也是我们通常用的MySQL的版本。</p><h1 id="MySQL体系架构"><a href="#MySQL体系架构" class="headerlink" title="MySQL体系架构"></a>MySQL体系架构</h1><p><img src="/images/mysql_arch_1_1.png" alt></p><p>从图中可以看出，MySQL将插件式地接入存储引擎。</p><h1 id="MySQL命令执行过程图"><a href="#MySQL命令执行过程图" class="headerlink" title="MySQL命令执行过程图"></a>MySQL命令执行过程图</h1><p><img src="/images/mysql_arch_1_2.png" alt></p><p>更简洁的一张架构图：</p><p><img src="/images/mysql_arch_1_3.png" alt></p><p>MySQL主要分为Server层和存储引擎层。</p><p>（1）Server层</p><p>主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块binglog日志模块。</p><p>连接器，当客户端连接MySQL时，Server层会对其进行身份认证和权限校验。</p><p>查询缓存，执行查询语句的时候，会先查询缓存，先校验这个SQL是否执行过，如果有缓存这个SQL，就会直接返回给客户端，如果没有命中，就会执行后续的操作。</p><p>分析器，没有命中缓存的话，SQL语句就会经过分析器，主要分为两步，词法分析和语法分析，先看SQL语句要做什么，再检查SQL语句语法是否正确。</p><p>优化器，优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划。</p><p>执行器，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。</p><p>（2）存储引擎</p><p>主要负责数据的存储和读取。Server层通过API与存储引擎进行通信。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP的长连接与短连接</title>
      <link href="/2018/12/09/TCP%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
      <url>/2018/12/09/TCP%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP的连接的建立与释放"><a href="#TCP的连接的建立与释放" class="headerlink" title="TCP的连接的建立与释放"></a>TCP的连接的建立与释放</h1><p>TCP是三次握手建立通信双方的连接，四次握手断开通信双方的连接。</p><h1 id="TCP短连接"><a href="#TCP短连接" class="headerlink" title="TCP短连接"></a>TCP短连接</h1><p>所谓短连接，简单来说，Client向Server通过三次握手建立连接后，Client向Server发起通信请求，Server回应数据，完成一次数据的读写后，双方通过四次握手关闭连接。</p><h1 id="TCP长连接"><a href="#TCP长连接" class="headerlink" title="TCP长连接"></a>TCP长连接</h1><p>所谓长连接，简单来说，Client向Server通过三次握手建立连接后，Client向Server发起通信请求，Server回应数据，完成一次数据的读写后，双方不会立即关闭这个连接，而是会继续保持这个连接，后续Client和Server端有数据通信时，就不需要再次三次握手建立通信连接。</p><h1 id="HTTP的TCP连接保持"><a href="#HTTP的TCP连接保持" class="headerlink" title="HTTP的TCP连接保持"></a>HTTP的TCP连接保持</h1><p><img src="/images/network_keepalive_1_1.jpg" alt></p><p>一次HTTP请求完成以后TCP连接能关闭吗？在HTTP/1.0中默认使用TCP短连接，也就是说，浏览器和WEB服务器每进行一次HTTP操作，就建立一次TCP连接，请求结束后就中断TCP连接。而从HTTP/1.1起，默认使用的是TCP长连接，用以保持连接特性。如果是HTTP/1.0，要使用TCP长连接的话，需要在HTTP Request Header中加入<code>Connetion:keep-alive</code>。</p><p><img src="/images/network_keepalive_1_4.jpg" alt></p><p>在使用TCP长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的WEB服务器软件（如Apache）中设定这个时间。实现TCP长连接需要浏览器和WEB服务器都支持TCP长连接。</p><p>TCP短连接下多个HTTP请求（同一个域名下的资源请求）的访问过程如下：</p><p><img src="/images/network_keepalive_1_2.jpg" alt></p><p>TCP长连接下多个HTTP请求（同一个域名下的资源请求）的访问过程如下：</p><p><img src="/images/network_keepalive_1_3.jpg" alt></p><p>简单来说，HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>传输层协议之TCP协议</title>
      <link href="/2018/12/08/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%B9%8BTCP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/12/08/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%B9%8BTCP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP协议特点"><a href="#TCP协议特点" class="headerlink" title="TCP协议特点"></a>TCP协议特点</h1><p>TCP，Transmission Control Protocol，传输控制协议。TCP是TCP/IP体系中非常复杂的一个协议。TCP协议的主要特点有：</p><p>（1）TCP是面向连接的运输层协议</p><p>应用程序在使用TCP协议发送应用数据之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。这就是说，应用进程之间的通信好像在“打电话”，通话前要先拨号建立连接，通话结束后要挂机释放连接。需要注意的是，TCP连接是一条虚连接而不是一条真正的物理连接。</p><p>（2）每条TCP连接只能有两个端口（endpoint），每条TCP连接只能是点对点的，一对一的。</p><p>（3）TCP提供可靠交付的服务</p><p>通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。</p><p>（4）TCP提供全双工通信</p><p>TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而TCP在合适的时候就把数据发送出去。在接收时，TCP把收到的数据放入缓存，在上层的应用进程在合适的时候读取缓存中数据。</p><p>（5）面向字节流</p><p>TCP中的“流”指的是流入到进程或从进程流出的字节序列。面向字节流的含义是，虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。TCP并不知道所传送的字节流的含义。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个TCP包就把收到的字节流交付给了上层的应用程序）。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。当然，接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。</p><p>简单来说，“面向字节流”就是TCP层看到上层协议数据，就是以单个字节为单位的连续字节流，TCP把每一个字节都按顺序编号。</p><p><img src="/images/network_tcp_1_1.png" alt></p><p>需要注意的是，TCP面向字节流的特点，并不是说一个TCP报文只包含一个字节的应用层数据啦。TCP会根据对端给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节。</p><p>正是因为TCP是面向字节流的，会对应用层交下来的数据包进行“拆包”和“合包”，从某种程度来说，会破坏应用层数据的语义结构，接收方应用程序就可能理解不了收到的数据包。简单举例来说，应用程序A向B发送了三条语句，分别为“我是谁？”、“我在哪里？”及“我要干什么？”，经过TCP的“拆包”和“合包”优化，在接收方B会收到二个TCP数据包，内容分别为“我是谁？我在”，“哪里？我要干什么？”，那么接收方就无法正确的解析出数据。我们称<strong>这种问题为“TCP粘包”</strong>。因此当我们的应用程序使用TCP作为传输层协议时，需要处理好“TCP粘包”问题，如在应用层增加消息边界，或者为应用每个消息指定消息长度。需要注意的是，HTTP报文是使用TCP协议来通信的，但并没有“TCP粘包”问题，因为HTTP报文自身就有一定的报文结构，所以接收方能够正确解析出HTTP报文。</p><h1 id="TCP-UDP协议通信中的X元组"><a href="#TCP-UDP协议通信中的X元组" class="headerlink" title="TCP/UDP协议通信中的X元组"></a>TCP/UDP协议通信中的X元组</h1><p>（1）四元组</p><pre><code>源IP地址、目的IP地址、源端口、目的端口</code></pre><p>（2）五元组</p><pre><code>源IP地址、目的IP地址、协议号、源端口、目的端口</code></pre><p>（3）七元组</p><pre><code>源IP地址、目的IP地址、协议号、源端口、目的端口、服务类型、接口索引</code></pre><p>其中协议号指的是协议类型，一般是协议蔟中的传输层协议，比如TCP是6，UDP是17；也可能是网络层协议，比如ICMP是1；也可能是应用层协议，比如OSPF是89。目的主机收到网络数据包后，根据协议号确定送给哪个模块（TCP/UDP/ICMP…）来处理，送给TCP/UDP模块的报文再根据端口号确定送给哪个应用程序来处理。</p><h1 id="TCP协议的报文格式"><a href="#TCP协议的报文格式" class="headerlink" title="TCP协议的报文格式"></a>TCP协议的报文格式</h1><p><img src="/images/network_tcp_1_2.png" alt></p><p>（1）序号</p><p>使用WireShark抓包就是<code>seq=m</code>，表示本次TCP报文的数据块的第一个字节的编号是m。例如一个TCP的seq是301，而携带的数据共用100个字节。这就表明，本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400，也即接下来的报文的seq将是401。</p><p>（2）确认号</p><p>使用WireShark抓包就是<code>ack=n</code>，表示已经收到对端<code>[1～n-1]</code>范围的字节流，期望对端下次发过来的TCP报文的seq是n。</p><p>备注：使用WireShark抓包标记位是大写，注意区分，如SYN|ACK|FIN等。</p><h1 id="TCP的可靠传输"><a href="#TCP的可靠传输" class="headerlink" title="TCP的可靠传输"></a>TCP的可靠传输</h1><p>TCP发送的报文段是交给IP层传送的，但IP层只能提供尽最大努力服务，也就是说，TCP下面的网络所提供的是不可靠的传输。因此TCP必须采用适当的措施才能使得两个运输层之间的通信变得可靠。TCP为了保证可靠传输，提供了如下三种可选的方案。</p><p>（1）停止等待协议</p><p>停止等待协议的粒度是分组。每发送完一个分组就停止发送，等待对方的ACK确认，在收到确认后再发送下一个分组。若发送方在超过一段时间仍然没有收到确认，就认为刚才发送的分组在网络上丢失了，因而重传这个分组，这个机制称为超时重传。</p><p><img src="/images/network_tcp_1_3.png" alt></p><p>需要注意的是，停止等待协议的信道利用率很低，传输的效率低下。</p><p>（2）连续ARQ协议</p><p>连续ARQ协议的粒度是分组。连续ARQ协议中，发送方会维持一个发送窗口，如发送窗口是5个分组，那么发送方可以将发送窗口中的5个分组连续发送出去，然后等待接收端的ACK确认，若此时收到接收到编号为1的分组确认了，那么发送窗口就向前移动一个分组的位置。</p><p>需要注意的是，接收方一般都是采用累积确认的方式，也就是说，接收方不必对收到的分组逐个发送确认，而是可以在收到几个分组后，对按序到达的最后一个分组发送确认。相当于告诉发送方，到这个分组为止的所有分组都已正确收到了。</p><p><img src="/images/network_tcp_1_4.png" alt></p><p>（3）以字节为单位的滑动窗口协议</p><p>以字节为单位的滑动窗口协议的粒度是字节。假设发送方收到了接收方发来的确认报文段，其中窗口是20字节，而确认号是31，这表明接收方期望收到的下一个序列是31，而序号30为止的数据已经收到了。根据这个信息，发送方就构造出了如下的发送窗口：</p><p><img src="/images/network_tcp_1_5.png" alt></p><p>关于以字节为单位的滑动窗口协议更多细节后续再补充。</p><h1 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1><p>一般来说，我们总是希望数据传输得更快一点。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。因此所谓流量控制，就是接收方告诉发送发的发送速率不要太快，要让接收方来得及接收。</p><p><img src="/images/network_tcp_1_6.png" alt></p><h1 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h1><p>TCP的流量控制是接收方通过可变窗口来调节发送方的发送速率。而TCP的流量控制，往往是发送方自己来主动控制的。目前，TCP的拥塞控制主要有四种算法：</p><pre><code>慢开始，slow-start拥塞避免，congestion avoidance快重传，fast retransmit快恢复，fast recovery</code></pre><h1 id="TCP三次握手连接与四次握手释放"><a href="#TCP三次握手连接与四次握手释放" class="headerlink" title="TCP三次握手连接与四次握手释放"></a>TCP三次握手连接与四次握手释放</h1><p><img src="/images/network_tcp_1_7.png" alt></p><p><img src="/images/network_tcp_1_8.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>传输层协议之UDP协议</title>
      <link href="/2018/12/08/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%B9%8BUDP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/12/08/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%B9%8BUDP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="UDP协议特点"><a href="#UDP协议特点" class="headerlink" title="UDP协议特点"></a>UDP协议特点</h1><p>UDP，User Datagram Protocol，用户数据报协议。用户数据报协议UDP只在IP层数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及差错检测的功能，UDP协议的主要特点有：</p><p>（1）UDP是无连接的</p><p>UDP发送数据之前不需要建立连接，当然发送数据结束时也没有连接可释放，因此减少了开销和发送数据之前的时延。</p><p>（2）UDP使用尽最大努力交付</p><p>UDP不保证可靠交付，因此主机不需要维持复杂的连接状态表。</p><p>（3）UDP是面向报文的</p><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是<strong>保留这些报文的边界</strong>。这就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。在接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付给上层的应用进程。也就是说，UDP一次交付一个完整的报文。因此，<strong>应用程序必须选择合适大小的报文（也就是应用层要确定合适的报文大小）</strong>。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。反之，若报文太短，UDP把它交给IP层后，会是IP数据报的首部的相对长度太大，这也降低了IP层的效率。</p><p>因此，<strong>UDP数据包是不会粘包的，因为对于应用层交给UDP的一条报文，UDP会把它直接封装到一个UDP包中，不会拆分，也不会合并</strong>。</p><p>（4）UDP没有拥塞控制</p><p>UDP在网络出现拥塞时，不会是源主机的发送速率降低。这对某些实际应用是很重要的，如很多的实时应用（如IP电话、实时视频会议等）要求源主机以很定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延。UDP正好适合这种要求。</p><p>（5）UDP支持一对一、一对多、多对一和多对多的交互通信。</p><p>（6）UDP的首部开销小</p><p>UDP的首部只有8个字节，比TCP的20个字节的首部要短。</p><h1 id="UDP报文格式"><a href="#UDP报文格式" class="headerlink" title="UDP报文格式"></a>UDP报文格式</h1><p><img src="/images/network_udp_1_1.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络层IP协议</title>
      <link href="/2018/12/08/%E7%BD%91%E7%BB%9C%E5%B1%82IP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/12/08/%E7%BD%91%E7%BB%9C%E5%B1%82IP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="IP协议数据包格式"><a href="#IP协议数据包格式" class="headerlink" title="IP协议数据包格式"></a>IP协议数据包格式</h1><p><img src="/images/network_ip_1_1.png" alt></p><h1 id="IP地址段划分"><a href="#IP地址段划分" class="headerlink" title="IP地址段划分"></a>IP地址段划分</h1><p>IP地址分为A，B，C，D，E五类，划分规则如下图所示：</p><p><img src="/images/network_ip_1_2.png" alt></p><p>其中A，B，C类地址是单播地址，也就是用来一对一通信，是最常用的。D类地址是用于多播，也就是一对多通信。E类地址保留为以后所用。A，B，C类地址可以指派给用户的范围如下：</p><p><img src="/images/network_ip_1_3.png" alt></p><h1 id="计算机网络IP规划"><a href="#计算机网络IP规划" class="headerlink" title="计算机网络IP规划"></a>计算机网络IP规划</h1><p><img src="/images/network_ip_1_4.png" alt></p><p>备注：主机号端都是0，则是网络地址；主机号端都是1，则是广播地址。这两个IP是有特殊用途的，不能拿来分配给上网主机的。</p><h1 id="闲杂知识"><a href="#闲杂知识" class="headerlink" title="闲杂知识"></a>闲杂知识</h1><p>（1）数据包在网络上转发时，IP协议层的源地址和目的地址始终不会变。但是数据链路层的帧中的源MAC地址和目的MAC地址会一直变化的哦</p><p>（2）当IP数据包的长度超过了数据链路层所容许的最大传送单元MTU时，就必须把过长的数据报进行分片后才能在网络上传送。</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础知识</title>
      <link href="/2018/12/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/12/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="数据通信的三种交换方式"><a href="#数据通信的三种交换方式" class="headerlink" title="数据通信的三种交换方式"></a>数据通信的三种交换方式</h1><ul><li>电路交换</li><li>报文交换</li><li>分组交换</li></ul><p><img src="/images/network_basic_1_1.png" alt></p><h1 id="计算机网络核心"><a href="#计算机网络核心" class="headerlink" title="计算机网络核心"></a>计算机网络核心</h1><p>网络分层。</p><h1 id="物理层的信道复用技术"><a href="#物理层的信道复用技术" class="headerlink" title="物理层的信道复用技术"></a>物理层的信道复用技术</h1><ul><li>频分复用，FDM（Frequency Division Multiplexing）</li><li>时分复用，TDM（Time Division Multiplexing）</li><li>统计时分复用</li><li>波分复用，WDM（Wavelength Division Multiplexing）</li><li>码分复用，CDM（Code Division Multiplexing）</li></ul><h1 id="OSI七层协议以及TCP-IP协议"><a href="#OSI七层协议以及TCP-IP协议" class="headerlink" title="OSI七层协议以及TCP/IP协议"></a>OSI七层协议以及TCP/IP协议</h1><p><img src="/images/network_osi_1_1.png" alt></p><p>TCP/UDP层的称为报文segment，IP层的称为分组或包package，数据链路层称为帧frame。</p><p>传输层有两种不同的运输协议，一是面向连接的TCP协议，一个是无连接的UDP协议。当运输层采用面向连接的TCP协议时，尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于一条全双工的可靠信道。当运输层采用无连接的UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。</p><p>有一点需要注意的是，在一台服务器上，TCP和UDP可以监听同一个端口，如DNS bind服务就可以同时监控TCP和UDP的53端口。但UDP的端口状态好像不叫监听LISTEN。如下：</p><p><img src="/images/network_osi_1_2.png" alt></p><h1 id="网络协议栈"><a href="#网络协议栈" class="headerlink" title="网络协议栈"></a>网络协议栈</h1><p><img src="/images/network_protocol_1_1.png" alt></p><p><img src="/images/network_protocol_1_2.png" alt></p><h1 id="基于TCP-IP网络封解包及数据传输过程"><a href="#基于TCP-IP网络封解包及数据传输过程" class="headerlink" title="基于TCP/IP网络封解包及数据传输过程"></a>基于TCP/IP网络封解包及数据传输过程</h1><h2 id="发送端主机侧"><a href="#发送端主机侧" class="headerlink" title="发送端主机侧"></a>发送端主机侧</h2><p>（1）应用层封装HTTP报文。</p><p>（2）TCP层封装应用报文，生成TCP数据包，包括源端口，目标端口，TCP会根据MSS以及TCP发送窗口大小来决定每个TCP报文的payload大小，进而会分割应用层的报文。</p><p>（3）IP层封装TCP数据包，生成IP数据包，IP包中源IP地址，目标IP地址等信息。</p><p>（4）数据链路层封装IP数据包，生成MAC数据帧，帧中包括源MAC地址，目标MAC地址。需要注意的是，目标MAC地址在经过链路中的三层网络设备节点时，会被三层设备修改为下一跳IP对应的MAC地址。目标MAC地址的生成还是有一些复杂：</p><ul><li>确定下一跳IP地址</li></ul><p>先查本地路由表，确定下一跳目标IP是什么。如果目标IP地址和自己不在同一个子网中，那么下一跳的IP地址就是缺省路由中的网关IP；如果目标IP地址和自己在同一个子网中，路由表中就没有下一跳路由器IP信息，那么下一跳IP地址其实就是最初的目标IP地址。</p><ul><li>确定下一跳IP的MAC地址</li></ul><p>查询本机ARP缓存表（IP-MAC映射表）中，是否有下一条IP的MAC地址，有就直接使用。若本地ARP缓存中没有对应IP的MAC地址缓存记录，则发送ARP广播报文，询问广播域中指定IP地址的MAC地址是多少，然后该IP的拥有者会响应正确的MAC地址。获取到目标MAC地址后，就会设置到数据帧的目标MAC地址中。</p><p>（5）通过物理层，也就是双绞线或光纤，将二进制数据流发送到网络中。</p><h2 id="交换机侧"><a href="#交换机侧" class="headerlink" title="交换机侧"></a>交换机侧</h2><p>交换机拆解数据链路层MAC帧，解析出目标MAC地址。然后交换机根据MAC地址转发表，将数据帧通过指定的交换机端口转发出去。</p><h2 id="路由器侧"><a href="#路由器侧" class="headerlink" title="路由器侧"></a>路由器侧</h2><p>路由器拆解IP层数据包，解析出源IP地址和目标IP地址，然后路由器查询本地路由表，查找下一跳IP地址，ARP缓存表中查找下一跳IP对应的MAC地址。然后就是路由器的封包过程，生成IP数据包，再封装MAC数据帧（要修改目标MAC地址），最后通过MAC地址转发表，将数据帧从指定的端口发送出去。</p><h2 id="接收端主机侧"><a href="#接收端主机侧" class="headerlink" title="接收端主机侧"></a>接收端主机侧</h2><p>接收端从数据链路层到应用层，依次拆包。确定数据包是不是发送给自己的，如果是，则将应用层的数据交给应用程序处理即可。</p><p><img src="/images/network_osi_1_3.png" alt></p><p><img src="/images/network_osi_1_4.png" alt></p><p>学习资料参考于：<br><a href="https://segmentfault.com/a/1190000022037918" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022037918</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中归档和压缩工具jar介绍和使用</title>
      <link href="/2018/12/07/JAVA%E4%B8%AD%E5%BD%92%E6%A1%A3%E5%92%8C%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7jar%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/12/07/JAVA%E4%B8%AD%E5%BD%92%E6%A1%A3%E5%92%8C%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7jar%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="jar工具及JAR文件"><a href="#jar工具及JAR文件" class="headerlink" title="jar工具及JAR文件"></a>jar工具及JAR文件</h1><p>jar是随JDK安装的，是JDK中自带的一个工具，在JDK安装目录下的bin目录中，Windows下文件名为jar.exe，Linux下文件名为jar。jar是一个归档和压缩工具，jar工具是基于zip和zlib创建出来的。使用jar工具打包压缩出来的文件称为JAR文件，即Java Archive File。顾名思义，它的应用是与Java息息相关的，是Java的一种文档格式。JAR文件非常类似ZIP文件，准确地说，它就是ZIP文件。JAR文件与ZIP文件唯一的区别就是在JAR文件的内容中，包含了一个META-INF目录，且该目录下有一个名称为MANIFEST.MF的文件，这个目录和文件是在使用jar工具生成JAR文件时自动创建的。</p><p>JAR文件包的扩展名是<code>.jar</code>，在Windows平台上，我们直接可以将JAR文件的扩展名改成.zip，然后使用WinRAR工具打开。</p><h1 id="JAR文件的目录结构"><a href="#JAR文件的目录结构" class="headerlink" title="JAR文件的目录结构"></a>JAR文件的目录结构</h1><p>假设有一个简单的JAR文件，它的基本目录结构如下：</p><p><img src="/images/java_jar_1_1.png" alt></p><p>备注：com.bat.adsl是包结构。</p><h1 id="jar命令格式及参数"><a href="#jar命令格式及参数" class="headerlink" title="jar命令格式及参数"></a>jar命令格式及参数</h1><p>jar命令的使用格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;ctxu&#125; [vfm0M] [jar-filename] [manifest-filename] [-C 目录] 文件名 ...</span><br></pre></td></tr></table></figure><p>jar命令各个选项和参数说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c  #创建新的JAR文件包</span><br><span class="line">v  #生成详细报告并打印到标准输出，即输出压缩和解压的详细过程信息</span><br><span class="line">f  #指定JAR文件名，通常这个参数是必须的</span><br><span class="line">m  #指定需要包含的MANIFEST清单文件</span><br><span class="line">t　#列出JAR文件包的内容列表</span><br><span class="line">x　#展开JAR文件包的指定文件或者所有文件</span><br><span class="line">u　#更新已存在的JAR文件包（添加文件到JAR文件包中）</span><br><span class="line">M  #不产生所有项的清单（MANIFEST）文件，此参数会忽略-m参数</span><br><span class="line">[jar-filename]      #表示需要生成、查看、更新或者解压的JAR文件包，它是f参数的附属参数</span><br><span class="line">[manifest-filename] #即MANIFEST清单文件，它是m参数的附属参数</span><br><span class="line">[-C 目录]   #表示需要转到指定目录下去执行这个jar命令的操作，它相当于先使用cd命令转该目录下再执行不带[-C 目录]参数的jar命令，它只能在创建和更新JAR文件包的时候可用</span><br><span class="line">文件名 ...  #指定一个文件/目录列表，这些文件/目录就是要添加到JAR文件包中的文件/目录。如果指定了目录，那么jar命令打包的时候会自动把该目录中的所有文件和子目录打入包中</span><br></pre></td></tr></table></figure><h1 id="jar命令使用举例"><a href="#jar命令使用举例" class="headerlink" title="jar命令使用举例"></a>jar命令使用举例</h1><p>（1）<code>jar cf test.jar test</code></p><p>该命令没有执行过程的显示，执行结果是在当前目录生成了test.jar文件。</p><p>（2）<code>jar cvf test.jar test</code></p><p>该命令与上例中的结果相同，但是由于v参数的作用，显示出了打包过程。</p><p>（3）<code>jar cvfM test.jar test</code></p><p>该命令与（2）结果类似，但在生成的test.jar中没有包含META-INF/MANIFEST文件。</p><p>（4）<code>jar cvfm test.jar manifest.mf test</code></p><p>运行结果与（2）相似，显示信息也相同，只是生成JAR包中的META-INF/MANIFEST是我们指定的manifest.mf文件的内容，而不是jar工具默认生成的META-INF/MANIFEST文件内容。</p><p>（5）<code>jar tf test.jar</code>或<code>jar tvf test.jar</code></p><p>在test.jar已经存在的情况下，可以查看test.jar中的内容，但并不会解压test.jar包文件哦。</p><p>（6）<code>jar xf test.jar</code>或<code>jar xvf test.jar</code></p><p>解压缩test.jar归档文件到当前目录。</p><h1 id="使用jar工具创建可执行jar文件"><a href="#使用jar工具创建可执行jar文件" class="headerlink" title="使用jar工具创建可执行jar文件"></a>使用jar工具创建可执行jar文件</h1><p>（1）编写Java代码，并使用javac编译</p><p>（2）创建MANIFEST.MF文件</p><p>这个MANIFEST.MF文件可以放在任何位置，也可以是其它任意文件名，但要创建可执行JAR包，MANIFEST.MF文件必须要有<code>Main-Class: test.Test</code>一行，且该行以一个回车符结束即可。Main-Class这一行指明了JAR包的执行入口，即包含了<code>public static void main(String[] args)</code>方法的类。</p><p>（3）执行打包命令<code>jar cvfm test.jar manifest.mf test</code></p><p>（4）执行<code>java -jar test.jar</code>命令来执行可执行jar文件</p><h1 id="一个典型MANIFEST-MF"><a href="#一个典型MANIFEST-MF" class="headerlink" title="一个典型MANIFEST.MF"></a>一个典型MANIFEST.MF</h1><p>MANIFEST.MF文件是JAR归档文件的清单文件，默认情况下，JAR文件中都包含了该文件，除非在生成JAR文件特别执行不需要MANIFEST.MF文件。</p><p>一个典型的MANIFEST.MF的文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Created-By: 1.8.0 (IBM Corporation)</span><br><span class="line">Main-Class: com.bat.adsl.Test</span><br></pre></td></tr></table></figure><p>一个稍复杂的可执行的SpringBoot JAR应用的MANIFEST.MF的文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: adsl</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Archiver-Version: Plexus Archiver</span><br><span class="line">Built-By: wangjianno1</span><br><span class="line">Implementation-Vendor-Id: com.bat</span><br><span class="line">Spring-Boot-Version: 1.5.2.RELEASE</span><br><span class="line">Implementation-Vendor: Pivotal Software, Inc.</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br><span class="line">Start-Class: com.bat.adsl.ADSLStart</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Created-By: Apache Maven 3.3.9</span><br><span class="line">Build-Jdk: 1.8.0_101</span><br><span class="line">Implementation-URL: http://maven.apache.org</span><br></pre></td></tr></table></figure><h1 id="其他闲杂知识"><a href="#其他闲杂知识" class="headerlink" title="其他闲杂知识"></a>其他闲杂知识</h1><p>（1）我们可以使用Eclipse IDE来生成jar文件，当然也可以使用Maven工具来生成jar文件。</p><p>学习资料参考于：<br><a href="https://blog.csdn.net/xlgen157387/article/details/23126933" target="_blank" rel="noopener">https://blog.csdn.net/xlgen157387/article/details/23126933</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中枚举Enum的介绍和使用</title>
      <link href="/2018/12/07/JAVA%E4%B8%AD%E6%9E%9A%E4%B8%BEEnum%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/12/07/JAVA%E4%B8%AD%E6%9E%9A%E4%B8%BEEnum%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举Enum类型简介"><a href="#枚举Enum类型简介" class="headerlink" title="枚举Enum类型简介"></a>枚举Enum类型简介</h1><p>枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。</p><h1 id="枚举的定义和使用"><a href="#枚举的定义和使用" class="headerlink" title="枚举的定义和使用"></a>枚举的定义和使用</h1><p>在没有枚举变量之前，开发者一般会按照如下的方式定义项目常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Week</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MONDAY = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TUESDAY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WEDNESDAY = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THURSDAY = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRIDAY = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SATURDAY = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUNDAY = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了枚举Enum类型之后，我们可以定义枚举来取代如上的方式，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Week.FRIDAY <span class="keyword">instanceof</span> Week); <span class="comment">//Week.FRIDAY是Week的实例</span></span><br><span class="line">        System.out.println(Week.FRIDAY.name()); <span class="comment">//Week.FRIDAY.name()是实例的名称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更复杂一点的定义和用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>, <span class="number">1</span>), TUESDAY(<span class="string">"星期二"</span>, <span class="number">2</span>), WEDNESDAY(<span class="string">"星期三"</span>, <span class="number">3</span>), THURSDAY(<span class="string">"星期四"</span>, <span class="number">4</span>), FRIDAY(<span class="string">"星期五"</span>, <span class="number">5</span>), SATURDAY(<span class="string">"星期六"</span>, <span class="number">6</span>), SUNDAY(<span class="string">"星期日"</span>, <span class="number">7</span>);</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String name, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Week.FRIDAY <span class="keyword">instanceof</span> Week);</span><br><span class="line">        System.out.println(Week.FRIDAY.name());</span><br><span class="line">        System.out.println(Week.FRIDAY.getName());</span><br><span class="line">        System.out.println(Week.FRIDAY.getNum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举类型实现的原理"><a href="#枚举类型实现的原理" class="headerlink" title="枚举类型实现的原理"></a>枚举类型实现的原理</h1><p>实际上，在使用关键字enum创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的<code>java.lang.Enum</code>类，也就是说通过关键字enum创建枚举类型在编译后事实上也是一个类类型而且该类继承自<code>java.lang.Enum</code>类。<br>举例来说，我们新建Week.java文件，其中定义了Enum类型Week，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Week &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用javac编译Week.java文件后，生成Week.class文件，经过反编译后，我们发现Week.class的实际内容大概如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Week</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ..... 具体内容在此省略 .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中装箱与拆箱</title>
      <link href="/2018/12/07/JAVA%E4%B8%AD%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
      <url>/2018/12/07/JAVA%E4%B8%AD%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h1><p>自动装箱就是Java自动将基础数据类型的值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱。反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的，而非人为转换，所以就称作为自动装箱和拆箱。</p><p>简单一点来说，装箱就是自动将基本数据类型转换为包装器类型。拆箱就是自动将包装器类型转换为基本数据类型。如下是一些需要装箱拆箱的类型：</p><p><img src="/images/java_box_1_1.png" alt></p><p><img src="/images/java_box_1_2.png" alt></p><h1 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自动装箱</span></span><br><span class="line">        Integer total = <span class="number">99</span>;</span><br><span class="line">        <span class="comment">// 自定拆箱</span></span><br><span class="line">        <span class="keyword">int</span> totalprim = total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：当执行<code>Integer total = 99</code>这句代码时，其实JVM为我们执行了<code>Integer total = Integer.valueOf(99)</code>。当执行<code>int totalprim = total</code>这句代码时，其实JVM为我们执行了<code>int totalprim = total.intValue()</code>。</p><h1 id="自动装箱-拆箱的原理"><a href="#自动装箱-拆箱的原理" class="headerlink" title="自动装箱/拆箱的原理"></a>自动装箱/拆箱的原理</h1><p>从字节码中，我们发现装箱其实就是调用了包装类的<code>valueOf()</code>方法，而拆箱其实就是调用了<code>xxxValue()</code>方法。需要注意的是，如果频繁拆装箱的话，也会严重影响系统的性能，我们应该尽量避免不必要的拆/装箱操作。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA虚拟机性能监控与故障处理工具</title>
      <link href="/2018/12/06/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/12/06/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h1><p>jps，全称为JVM Process Status Tool，该命令显示系统内所有的HotSpot虚拟机JVM进程，也即Java进程啦。另外，jps可以通过RMI协议查看开了RMI服务的远程虚拟机进程状态。</p><p>命令行参数选项说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-q  #不输出类名、Jar名和传入main方法的参数</span><br><span class="line">-m  #输出传入main方法的参数</span><br><span class="line">-l  #输出main类或Jar的全限名</span><br><span class="line">-v  #输出传入JVM的参数</span><br></pre></td></tr></table></figure><p>备注：Java程序启动以后，会在<code>/tmp</code>目录下生成一个<code>hsperfdata_${USER}</code>的文件夹，这个文件夹的文件，就是以Java进程的pid命名。使用jps查看当前进程的时候，其实就是把<code>/tmp/hsperfdata_${USER}</code>中的文件名遍历一遍之后输出。如果<code>/tmp/hsperfdata_${USER}</code>的文件所有者和文件所属用户组与启动进程的用户不一致的话，在进程启动之后，就没有权限写<code>/tmp/hsperfdata_${USER}</code>，所以<code>/tmp/hsperfdata_${USER}</code>是一个空文件夹，那么执行jps命令也就没有任何显示。这一点需要注意。</p><h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p>jstat，JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据。它可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p><p>jstat命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] pid interval count</span><br></pre></td></tr></table></figure><p>备注：option表示需要查看JVM哪方面（主要包括类装载、垃圾收集、运行期编译状况）的运行状态，interval表示多少时间采集一次，count表示一共采集几次。若省略interval，count参数，则只查询一次。</p><h1 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h1><p>jinfo，Configuration Info for Java，显示虚拟机配置信息。</p><h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><p>jmap，Memory Map for Java，生成虚拟机的内存转储快照，一般称为heapdump或dump文件。</p><h1 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h1><p>jhat，JVM Heap Dump Browser，与jmap命令配合使用，用于分析jmap生成的heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果。</p><h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><p>jstack，Stack Trace for Java，显示虚拟机的线程快照。</p><h1 id="JMX与jconsole可视化工具"><a href="#JMX与jconsole可视化工具" class="headerlink" title="JMX与jconsole可视化工具"></a>JMX与jconsole可视化工具</h1><h2 id="JMX简介"><a href="#JMX简介" class="headerlink" title="JMX简介"></a>JMX简介</h2><p>JMX是Java Management Extensions的简写，即Java管理扩展。JMX是用来对Java应用程序和JVM进行监控和管理的，它是Java官方提供的一套用于监控Java程序和JVM运行时状态的标准API。通过JMX，我们可以监控的内容有很多，比如：</p><pre><code>服务器中各种资源的使用情况：如CPU、内存等JVM内存使用情况JVM中的线程情况JVM中加载的类......</code></pre><p>另外，JMX是J2SE平台的标准组成部分，是从J2SE 5.0引入了JMX功能，意味着我们使用JMX时，不需要引入任何第三方jar包，直接可以进行开发。在我们的JAVA程序中，通过使用JMX机制，当我们的JAVA应用在运行时，就会对外暴露一些程序内部监控信息的获取接口。<br>如下即为通过使用JMX机制来获取JAVA应用运行时的一些状态：</p><p><img src="/images/java_jconsole_1_1.png" alt></p><h2 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h2><p>jconsole是一个基于JMX的GUI工具，用于连接正在运行的JVM，不过此JVM需要使用可管理的模式启动。所谓可管理的形式，指的是JAVA应用开启JMX端口，供外部工具获取监控信息。在启动JAVA应用时，通过配置如下的虚拟机参数即可：</p><pre><code>-Dcom.sun.management.jmxremote-Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false-Djava.rmi.server.hostname=10.16.20.96-Dcom.sun.management.jmxremote.port=8999</code></pre><p>即<code>${JDK_HOME}/bin/java -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false  -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=10.16.20.96 -Dcom.sun.management.jmxremote.port=8999 -jar my-java-app.jar</code></p><p>然后我们在windows中cmd中通过jconsole命令，打开jconsole，然后新建连接，如下：</p><p><img src="/images/java_jconsole_1_2.png" alt></p><h1 id="VisualVM可视化工具"><a href="#VisualVM可视化工具" class="headerlink" title="VisualVM可视化工具"></a>VisualVM可视化工具</h1><p>待补充。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机存储器相关</title>
      <link href="/2018/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="存储介质的分类"><a href="#存储介质的分类" class="headerlink" title="存储介质的分类"></a>存储介质的分类</h1><p>按照存储介质的原理可以分为如下几种：</p><p>（1）磁表面存储器</p><p>磁表面存储介质是在金属或塑料基体的表面上涂上一层磁性材料作为记录介质，工作时磁层随磁载体高速运转，用磁头在磁层上进行读/写操作，故称为磁表面存储器。这类存储介质有磁鼓、磁带以及磁盘。</p><p>（2）光盘存储器</p><p>光盘存储器是应用激光在记录介质（磁光材料）上进行读/写的存储器。这类存储介质有光盘。</p><p>（3）半导体存储器</p><p>存储元件有半导体器件组成的存储介质称为半导体存储器。这类存储介质有RAM、ROM等。半导体存储介质又可以分为：</p><p>A）RAM，随机存储器</p><p>RAM又分为动态RAM（DRAM），静态RAM（SRAM）两种。</p><p>B）ROM，只读存储器</p><p>按ROM的原始定义，一旦注入原始信息即不能改变，但随着用户的需要，总希望任意修改ROM内的原始信息，ROM因此有很多种。ROM有MROM、PROM、EPROM、EEPROM、Flash Memory、SSD等。其中SSD使用的是Flash Memory。</p><h1 id="计算机多级存储器结构"><a href="#计算机多级存储器结构" class="headerlink" title="计算机多级存储器结构"></a>计算机多级存储器结构</h1><p><img src="/images/pc_storage_1_1.jpg" alt></p><h1 id="磁盘的顺序-随机读写"><a href="#磁盘的顺序-随机读写" class="headerlink" title="磁盘的顺序/随机读写"></a>磁盘的顺序/随机读写</h1><p>磁盘读取时间，由下面三个部分组成：</p><pre><code>寻道时间，表示磁头在不同磁道之间移动的时间旋转延迟，表示在磁道找到时，中轴带动盘面旋转到合适的扇区开头处传输时间，表示盘面继续转动，实际读取数据的时间</code></pre><p>顺序读写可以大大减少寻道时间和旋转延迟。</p>]]></content>
      
      
      <categories>
          
          <category> HardWare </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>冯·诺依曼机理论原理</title>
      <link href="/2018/12/05/%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9C%BA%E7%90%86%E8%AE%BA%E5%8E%9F%E7%90%86/"/>
      <url>/2018/12/05/%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9C%BA%E7%90%86%E8%AE%BA%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="冯·诺依曼机"><a href="#冯·诺依曼机" class="headerlink" title="冯·诺依曼机"></a>冯·诺依曼机</h1><p>现代计算机的基本原理是冯·诺依曼机。冯·诺依曼机的核心概念是“存储程序”思想，具体展开来有如下几点：</p><p>（1）计算机是由运算器、控制器、存储器、输入/输出设备四大部分组成</p><p>（2）指令和数据以同等地位存放于存储器内，并可按地址寻访</p><p>（3）指令和数据均以二进制数表示</p><p>（4）指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置</p><p>（5）指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下，可根据运算结果或根据设定的条件改变执行的顺序</p><p>（6）机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成</p><p> “存储程序”思想是产生在1945年，数学家冯·诺依曼（von Neumann）在研究EDVAC机时提出的。</p><h1 id="实际的计算机架构"><a href="#实际的计算机架构" class="headerlink" title="实际的计算机架构"></a>实际的计算机架构</h1><p><img src="/images/os_arch_1_1.jpg" alt></p><p><img src="/images/os_arch_1_2.png" alt></p><p>指令和数据都在内存中，CPU从内存中获取指令和数据，然后机械式地逐条执行就行了。另外，CPU都是通过系统总线连接I/O桥，然后再到内存总线和I/O总线去跟内存、硬盘以及网卡等等设备进行交互。</p>]]></content>
      
      
      <categories>
          
          <category> HardWare </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>四大CPU体系架构ARM|X86/Atom|MIPS|PowerPC</title>
      <link href="/2018/12/05/%E5%9B%9B%E5%A4%A7CPU%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84ARM-X86-Atom-MIPS-PowerPC/"/>
      <url>/2018/12/05/%E5%9B%9B%E5%A4%A7CPU%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84ARM-X86-Atom-MIPS-PowerPC/</url>
      
        <content type="html"><![CDATA[<p>RISC，Reduced Instruction Set Computer，中文为精简指令集计算机，是一种执行较少类型计算机指令的微处理器，起源于80年代的MIPS主机（即RISC机），RISC机中采用的微处理器统称RISC处理器。这样一来，它能够以更快的速度执行操作（每秒执行更多百万条指令，即MIPS）。因为计算机执行每个指令类型都需要额外的晶体管和电路元件，计算机指令集越大就会使微处理器更复杂，执行操作也会更慢。　</p><p>其中ARM/MIPS/PowerPC均是基于精简指令集机器处理器的架构；X86则是基于复杂指令集的架构，Atom是x86或者是x86指令集的精简版。</p><p>根据各种新闻，Android在支持各种处理器的现状：</p><pre><code>ARM+Android最早发展、完善的支持，主要在手机市场、上网本、智能等市场X86+Android有比较完善的发展。有atom+Android的上网本，且支持Atom+Android和Atom+Window7双系统MIPS+Android目前在移植、完善过程中PowerPC+Android目前在移植、完善过程中</code></pre><h1 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h1><p>ARM架构，过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作Acorn RISC Machine），是一个32位精简指令集（RISC）处理器架构，其广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于行动通讯领域，符合其主要设计目标为低耗电的特性。</p><p>在今日，ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列。</p><p>ARM架构的优势是价格低、能耗低。</p><p>ARM公司本身并不靠自有的设计来制造或出售CPU ，而是将处理器架构授权给有兴趣的厂家。ARM提供了多样的授权条款，包括售价与散播性等项目。对于授权方来说，ARM提供了ARM内核的整合硬件叙述，包含完整的软件开发工具（编译器、debugger、SDK），以及针对内含ARM CPU硅芯片的销售权。对于无晶圆厂的授权方来说，其希望能将ARM内核整合到他们自行研发的芯片设计中，通常就仅针对取得一份生产就绪的智财核心技术（IP Core）认证。对这些客户来说，ARM会释出所选的ARM核心的闸极电路图，连同抽象模拟模型和测试程式，以协助设计整合和验证。需求更多的客户，包括整合元件制造商（IDM）和晶圆厂家，就选择可合成的RTL（暂存器转移层级，如Verilog）形式来取得处理器的智财权（IP）。借着可整合的RTL，客户就有能力能进行架构上的最佳化与加强。这个方式能让设计者完成额外的设计目标（如高震荡频率、低能量耗损、指令集延伸等）而不会受限于无法更动的电路图。虽然ARM并不授予授权方再次出售ARM架构本身，但授权方可以任意地出售制品（如芯片元件、评估板、完整系统等）。商用晶圆厂是特殊例子，因为他们不仅授予能出售包含ARM内核的硅晶成品，对其它客户来讲，他们通常也保留重制ARM内核的权利。</p><p>目前ARM的生产厂商有德州仪器TI、三星、飞思卡尔、Marvell以及Nvidia等等。</p><h1 id="x86架构"><a href="#x86架构" class="headerlink" title="x86架构"></a>x86架构</h1><p>x86或80x86是英代尔Intel首先开发制造的一种微处理器体系结构的泛称。x86架构是重要地可变指令长度的CISC（复杂指令集电脑，Complex Instruction Set Computer）。</p><p>Intel Atom（中文：凌动，开发代号：Silverthorne）是Intel的一个超低电压处理器系列。处理器采用45纳米工艺制造，集成4700万个晶体管。L2缓存为512KB，支持SSE3指令集，和VT虚拟化技术（部份型号）。</p><p>现在Atom处理器系列有6个型号，全部都是属于Z500系列。它们分别是Z500、Z510、Z520、Z530、Z540和Z550。最低端的Z500内核频率是800MHz，FSB则是400MHz。而最高速的Z550，内核频率则有2.0GHz，FSB则是533MHz。从Z520开始，所有的处理器都支持超线程技术，但只增加了不到10%的耗电。双内核版本为N系列，依然采用945GC芯片组。双内核版本仍会支持超线程技术，所以系统会显示出有4个逻辑处理器。这个版本的两个内核并非采用本地设计，只是简单的将两个单内核封装起来。</p><p>AMD也是使用x86架构。</p><h1 id="MIPS架构"><a href="#MIPS架构" class="headerlink" title="MIPS架构"></a>MIPS架构</h1><p>MIPS是世界上很流行的一种RISC处理器。MIPS的意思是“无内部互锁流水级的微处理器”（Microprocessor without interlockedpipedstages），其机制是尽量利用软件办法避免流水线中的数据相关问题。它最早是在80年代初期由斯坦福大学Hennessy教授领导的研究小组研制出来的。MIPS公司的R系列就是在此基础上开发的RISC工业产品的微处理器。这些系列产品为很多计算机公司采用构成各种工作站和计算机系统。</p><p>MIPS技术公司是美国著名的芯片设计公司，它采用精简指令系统计算结构(RISC)来设计芯片。和英特尔采用的复杂指令系统计算结构(CISC)相比，RISC具有设计更简单、设计周期更短等优点，并可以应用更多先进的技术，开发更快的下一代处理器。MIPS是出现最早的商业RISC架构芯片之一，新的架构集成了所有原来MIPS指令集，并增加了许多更强大的功能。MIPS自己只进行CPU的设计，之后把设计方案授权给客户，使得客户能够制造出高性能的CPU。</p><pre><code>1984年，MIPS计算机公司成立，开始设计RISC处理器1986年，推出R2000处理器1992年，SGI收购了MIPS计算机公司1988年，推出R3000处理器1991年，推出第一款64位商用微处器R4000；之后又陆续推出R8000（于1994年）、R10000（于1996年）和R12000（于1997年）等型号1998年，MIPS脱离SGI，成为MIPS技术公司；随后MIPS公司的战略发生变化，把重点放在嵌入式系统；1998年－MIPS科技股票在美国纳斯达克股票交易所公开上市1999年，MIPS公司发布MIPS32和MIPS64架构标准，为未来MIPS处理器的开发奠定了基础。新的架构集成了所有原来NIPS指令集，并且增加了许多更强大的功能。MIPS公司陆续开发了高性能、低功耗的32位处理器内核（core）MIPS324Kc与高性能64位处理器内核MIPS645Kc2000年，MIPS公司发布了针对MIPS32 4Kc的版本以及64位MIPS 64 20Kc处理器内核2007年8月16日，MIPS科技宣布，中科院计算机研究所的龙芯中央处理器获得其处理器IP的全部专利和总线、指令集授权2007年12月20日，MIPS科技宣布，扬智科技已取得其针对先进多媒体所设计的可定制化系统单芯片（SoC）核心“MIPS32 24KEcPro”授权</code></pre><h1 id="PowerPC架构"><a href="#PowerPC架构" class="headerlink" title="PowerPC架构"></a>PowerPC架构</h1><p>PowerPC是一种精简指令集（RISC）架构的中央处理器（CPU），其基本的设计源自IBM（国际商用机器公司）的IBMPowerPC 601微处理器POWER（Performance Optimized With Enhanced RISC）。二十世纪九十年代，IBM（国际商用机器公司）、Apple（苹果公司）和Motorola（摩托罗拉）公司成功开发了PowerPC芯片，并制造出基于PowerPC的多处理器计算机。PowerPC架构的特点是可伸缩性好、方便灵活。</p><p>PowerPC处理器有广泛的实现范围，包括从诸如Power4那样的高端服务器CPU到嵌入式CPU市场（任天堂Gamecube使用了PowerPC）。PowerPC处理器有非常强的嵌入式表现，因为它具有优异的性能、较低的能量损耗以及较低的散热量。除了像串行和以太网控制器那样的集成I/O，该嵌入式处理器与台式机CPU 存在非常显著的区别。</p>]]></content>
      
      
      <categories>
          
          <category> HardWare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中JVM垃圾回收算法与垃圾收集器</title>
      <link href="/2018/12/05/JAVA%E4%B8%ADJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2018/12/05/JAVA%E4%B8%ADJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="判断对象是否还被使用的算法"><a href="#判断对象是否还被使用的算法" class="headerlink" title="判断对象是否还被使用的算法"></a>判断对象是否还被使用的算法</h1><p>判断对象是否还在被使用的算法有：</p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能被使用的。但是Java语言中没有选用引用计数算法来管理内存，其最主要原因是它很难解决对象之间的相互循环引用的问题。</p><h2 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h2><p>也称为“可达性分析算法”，通过一系列的名为<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到<code>GC Roots</code>没有任何引用链相连，按照图论的话来说就是从<code>GC Roots</code>到这个对象不可达时，则证明此对象是不可用的。</p><p>在Java语言中，有如下的一些对象可以作为<code>GC Roots</code>对象：</p><pre><code>虚拟机栈（栈帧中的本地变量表）中引用的对象本地方法栈（Native方法）中引用的对象方法区中类静态属性引用的对象方法区中常量引用的对象</code></pre><p><img src="/images/java_gc_1_1.png" alt></p><h1 id="垃圾回收-收集算法"><a href="#垃圾回收-收集算法" class="headerlink" title="垃圾回收/收集算法"></a>垃圾回收/收集算法</h1><h2 id="标记-清除（Mark-Sweep）算法"><a href="#标记-清除（Mark-Sweep）算法" class="headerlink" title="标记-清除（Mark-Sweep）算法"></a>标记-清除（Mark-Sweep）算法</h2><p>算法分为“标记”和“清除”阶段。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题，一是效率问题， 二是空间问题（标记清除后会产生大量不连续的碎片）。</p><p><img src="/images/java_gc_1_2.png" alt></p><h2 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h2><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="/images/java_gc_1_3.png" alt></p><h2 id="标记-整理（Mark-Compact）算法"><a href="#标记-整理（Mark-Compact）算法" class="headerlink" title="标记-整理（Mark-Compact）算法"></a>标记-整理（Mark-Compact）算法</h2><p>根据老年代的特点推出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="/images/java_gc_1_4.png" alt></p><p>“标记-整理”算法一方面在“标记-清除”算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但从上图可以看到，它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。</p><h2 id="分代回收（Generational-Collection）算法"><a href="#分代回收（Generational-Collection）算法" class="headerlink" title="分代回收（Generational Collection）算法"></a>分代回收（Generational Collection）算法</h2><p>分代收集算法严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。一般来说，根据对象存活周期的不同将内存分为几块，一般将Java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 比如在新生代中，每次收集都会有大量对象死去，所以可以选择“复制”算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h1 id="垃圾回收-收集器"><a href="#垃圾回收-收集器" class="headerlink" title="垃圾回收/收集器"></a>垃圾回收/收集器</h1><p>垃圾回收算法是内存回收的方法论，垃圾回收器则是内存回收的具体实现。Java虚拟机规范中对垃圾收集器的实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。如下为Sun HotSpot虚拟机所提供的所有收集器：</p><p><img src="/images/java_gc_1_5.png" alt></p><p>从图中可以看出每个垃圾收集器所适用于的JVM运行时内存区域，如Serial/ParNew/Parallel Scavenge是年轻代区域的垃圾收集器，Serial Old/Parallel Old/CMS是年老代的垃圾收集器，而G1可以同时对年轻代和年老代的内存进行回收。在上图中如果两个收集器之间存在连线，则说明它们可以搭配在一起使用。</p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial收集器是最基本、历史最悠久的收集器，在JDK 1.3.1版本前是虚拟机新生代垃圾收集的唯一选择。Serial收集器是一个单线程的收集器，而且在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接受的。图展示了Serial收集器（老年代采用Serial Old收集器搭配）的运行过程：</p><p><img src="/images/java_gc_1_6.png" alt></p><p>Serial收集器采用复制算法在新生代工作，Serial Old收集器采用标记-整理算法在老年代工作。</p><p>Serial收集器简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。实际上到现在为止，它依然是HotSpot虚拟机运行在Client模式下的默认的新生代收集器。</p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器就是Serial收集器的多线程版本，它也是一个新生代收集器。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。ParNew收集器的工作过程如下图（老年代采用Serial Old收集器搭配）：</p><p><img src="/images/java_gc_1_7.png" alt></p><p>ParNew收集器采用复制算法在新生代工作，Serial Old收集器采用标记-整理算法在老年代工作。</p><p>ParNew收集器除了使用多线程收集外，其他与Serial收集器相比并无太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，这其中有一个与性能无关的重要原因是，除了Serial收集器外，目前只有它能和CMS收集器配合工作，CMS收集器是JDK 1.5推出的一个具有划时代意义的收集器。</p><p>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。在多CPU环境下，随着CPU的数量增加，它对于GC时系统资源的有效利用是很有好处的。ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用<code>-XX:ParallerGCThreads</code>参数设置。</p><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器也是一个并行的多线程新生代收集器，类似于ParNew收集器，它也使用复制算法。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等其他收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（高效率的利用CPU）。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Scavenge收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个参数<code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（<code>-Xmn</code>）、Eden和Survivor区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为GC自适应的调节策略（GC Ergonomics）。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p><p>另外值得注意的一点是，Parallel Scavenge收集器无法与CMS收集器配合使用，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。</p><p><img src="/images/java_gc_1_8.png" alt></p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”（Mark-Compact）算法。此收集器的主要意义也是在于给Client模式下的虚拟机使用。</p><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种“标记-清除”算法实现的。CMS收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。CMS收集器是适用在年代老区域的垃圾收集。它的运作过程相比于前面几种垃圾收集器来说更加复杂一些，整个过程分为四个步骤：</p><p>（1）初始标记</p><p>仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</p><p>（2）并发标记</p><p>同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p><p>（3）重新标记</p><p>重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</p><p>（4）并发清除</p><p>开启用户线程，同时GC线程开始对为标记的区域做清扫。</p><p><img src="/images/java_gc_1_9.png" alt></p><p>由于整个过程中耗时最长的并发标记和并发清除的两个阶段，收集器线程都可以与用户线程一起工作。所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点，一是对CPU资源敏感，二是无法处理浮动垃圾，三是它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</p><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1（Garbage-First）是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。G1收集器是当今收集器技术发展最前沿的成果之一，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，它具备一下特点：</p><p>（1）并行与并发</p><p>G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</p><p>（2）分代收集</p><p>虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</p><p>（3）空间整合</p><p>与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器，从局部上来看是基于“复制”算法实现的。</p><p>（4）可预测的停顿</p><p>这是G1相对于CMS的另一个大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</p><p>G1收集器的运作大致可划分为以下几个步骤：</p><p>（1）初始标记</p><p>仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。</p><p>（2）并发标记</p><p>从GC Roots开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。</p><p>（3）最终标记</p><p>继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</p><p>（4）筛选回收</p><p>首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p><p>通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段：</p><p><img src="/images/java_gc_1_10.png" alt></p><p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region（这也就是它的名字Garbage-First的由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/images/java_gc_1_11.png" alt></p><p>到JDK8为止，默认的垃圾收集器是Parallel Scavenge和Parallel Old。从JDK9开始，G1收集器成为默认的垃圾收集器。目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在JDK8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge回收新生代停顿长达1.5秒，G1回收器回收同样大小的新生代只停顿0.2秒。</p><h1 id="Minor-GC、-Major-GC、-Full-GC"><a href="#Minor-GC、-Major-GC、-Full-GC" class="headerlink" title="Minor GC、 Major GC、 Full GC"></a>Minor GC、 Major GC、 Full GC</h1><h2 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h2><p>Minor GC指对年轻代的堆内存进行垃圾回收。</p><p>Minor GC触发条件是Eden区域满了。Minor GC的工作内容主要有：</p><p>（1）将Eden中没有引用的对象直接被GC掉，其他还有引用的对象会复制到To Survivor区域。</p><p>（2）会将From Survivor中还存活的对象，一部分复制到To Survivor，一部分满足条件（这个条件后面会说明）的对象复制到年老代。</p><p>（3）From Survivor和To Survivor互换角色，From Survivor会变成To Survivor，To Survivor会变成From Survivor。</p><p>通过Minor GC之后，<strong>Eden会被清空</strong>，Eden区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到Survivor区。在Survivor区会将Eden区和From存活的对象放到Survivor的To区（如果To区不够，则直接进入Old区）。然后From Survivor和To Survivor互换角色，等待下次的Minor GC的到来。</p><h2 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h2><p>Major GC指对年老代的堆内存进行垃圾回收。</p><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>Full GC指即对年轻代又对年老代堆内存进行垃圾回收。Full GC时会同时进行Major GC和Minor GC。Full GC触发条件如下：</p><p>（1）调用System.GC时，系统建议执行Full GC，但是不必然执行</p><p>（2）老年代空间不足</p><p>（3）方法区空间不足</p><p>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p><h2 id="一点补充"><a href="#一点补充" class="headerlink" title="一点补充"></a>一点补充</h2><p>Survivor中的对象进入年老代的满足如下条件之一即可：</p><p>（1）部分对象会在From Survivor和To Survivor区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认是15），最终如果还是存活，就存入到老年代。</p><p>（2）如果对象的大小大于Eden的二分之一会直接分配在年老代</p><p>（3）动态年龄判断，大于等于某个年龄的对象超过了Survivor空间一半，这些大于等于某个年龄的对象直接进入老年代</p><p>学习资料参考于：<br><a href="https://cloud.tencent.com/developer/article/1592943" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1592943</a><br><a href="https://mp.weixin.qq.com/s/feJKRqYJTVEIxl6jvjevAg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/feJKRqYJTVEIxl6jvjevAg</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA虚拟机内存管理机制</title>
      <link href="/2018/12/05/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/12/05/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存会包括以下几个区域：</p><p><img src="/images/java_mem_1_1.png" alt></p><p><img src="/images/java_mem_1_4.png" alt></p><p><img src="/images/java_mem_1_5.png" alt></p><p>备注：方法区和堆是所有线程共享的内存区域，而虚拟机栈、本地方法栈以及程序计数器是每个线程所独享的一片区域。</p><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。在JAVA虚拟机中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、跳转、循环、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。每一个线程都需要有一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>虚拟机栈描述的是JAVA方法执行的内存模型。每个方法在执行时，都会创建一个栈帧，用于存储局部变量（基础类型的变量，如int/short/long/float等）、对象句柄、操作数栈、动态链接、方法出口等信息。虚拟机栈中有很多的栈帧，因为方法是嵌套调用的嘛。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p><img src="/images/java_mem_1_7.png" alt></p><p>举例来说，有如下方法被调用时，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果局部变量是Java的8种基本基本数据类型，则存在局部变量表中，如果是引用类型。如new出来的Object，局部变量表中存的是引用，而实例在堆中。</p><p><img src="/images/java_mem_1_8.png" alt></p><p>在C++内存管理中，我们知道“栈内存”和“堆内存”，JAVA中“栈内存”其实指的就是虚拟机栈。JAVA虚拟机栈也是线程私有的，它的生命周期与线程相同。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>本地方法栈与虚拟机栈所发挥的作用是非常类似的，它们之间的区别不过是虚拟机栈为虚拟机执行JAVA方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><h1 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h1><p>Java堆是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。Java堆内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是Java GC的最主要考虑的内存空间。因此Java堆也被称为“GC堆”。</p><p>从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为新生代和老年代，新生代又可以细分为Eden空间、From Survivor、To Survivor空间等。之所以对Java堆内存进一步划分是为了更好地回收内存，或者更快地分配内存。</p><p><img src="/images/java_mem_1_2.png" alt></p><p>在JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</p><p>如下是JVM在创建一个新对象时分配堆内存的过程图如下：</p><p><img src="/images/java_mem_1_6.png" alt></p><p>JVM默认情况下，堆内存中不同的内存区域的大概占比如下：</p><p><img src="/images/java_mem_1_9.png" alt></p><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区，一个Eden区，两个Survivor区（一般而言）。大部分对象首先在Eden区中生成。为了整理内存的需要，对象会在Minor GC时在两个Survivor区复制来复制去，Survivor总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><h2 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a>年老代</h2><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><h2 id="持久代"><a href="#持久代" class="headerlink" title="持久代"></a>持久代</h2><p>用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=<n>进行设置。</n></p><h1 id="方法区-元空间MetaSpace"><a href="#方法区-元空间MetaSpace" class="headerlink" title="方法区/元空间MetaSpace"></a>方法区/元空间MetaSpace</h1><p>JDK1.8之后方法区就改为元空间MetaSpace。</p><p>方法区用于存储已被虚拟机加载的类信息、方法、常量、静态变量、即时编译器编译后的代码等数据。</p><p>需要明确说明的是，程序计数器、虚拟机栈以及本地方法栈三个区域随线程而生，随线程而灭。因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随回收了。而JAVA堆和方法区则不一样，这部分的内存的分配和回收都是动态的，垃圾收集器所关注的是这部分的内存。</p><h1 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h1><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）。既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><p>JDK1.7及之后版本的JVM已经将运行时常量池从方法区中移了出来，在Java堆（Heap）中开辟了一块区域存放运行时常量池。</p><p><img src="/images/java_mem_1_3.png" alt></p><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。</p><p>JDK1.4中新加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓存区（Buffer）的I/O方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在Java堆和Native堆之间来回复制数据。</p><p>本机直接内存的分配不会受到Java堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><p>学习资料参考于：<br><a href="https://mp.weixin.qq.com/s/Y1MW20Qm1wqx2oVoT5tPDw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Y1MW20Qm1wqx2oVoT5tPDw</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle/Sun JDK与OpenJDK的区别和联系</title>
      <link href="/2018/12/04/Oracle-Sun-JDK%E4%B8%8EOpenJDK%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/"/>
      <url>/2018/12/04/Oracle-Sun-JDK%E4%B8%8EOpenJDK%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Oracle-Sun-JDK与OpenJDK的区别和联系"><a href="#Oracle-Sun-JDK与OpenJDK的区别和联系" class="headerlink" title="Oracle/Sun JDK与OpenJDK的区别和联系"></a>Oracle/Sun JDK与OpenJDK的区别和联系</h1><p>OpenJDK原是Sun Microsystems公司为Java平台构建的Java开发环境（JDK）的开源版本，完全自由，开放源码。Sun Microsystems公司在2006年的JavaOne大会上称将对Java开放源代码，于2009年4月15日正式发布OpenJDK。甲骨文在2010年收购Sun Microsystem之后接管了这个项目。</p><p>Oracle/Sun JDK里面包含的JVM是HotSpotVM，HotSpot VM只有非常非常少量的功能没有在OpenJDK里，那部分在Oracle内部的代码库里。这些私有部分都不涉及JVM的核心功能。所以说，Oracle/Sun JDK与OpenJDK其实使用的是同一个代码库。</p><p>从一个Oracle内部员工的角度来看，当他要构建OracleJDK时，他同样需要先从<code>http://hg.openjdk.java.net</code>签出OpenJDK，然后从Oracle内部的代码库签出私有的部分，放在OpenJDK代码下的一个特定目录里，然后构建。</p><p>值得注意的是，Oracle JDK只发布二进制安装包，而OpenJDK只发布源码。</p><p>学习资料参考于：<br><a href="http://www.zhihu.com/question/19882320" target="_blank" rel="noopener">http://www.zhihu.com/question/19882320</a><br><a href="https://zh.wikipedia.org/wiki/OpenJDK" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/OpenJDK</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA虚拟机的发展史</title>
      <link href="/2018/12/04/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
      <url>/2018/12/04/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA虚拟机的发展史"><a href="#JAVA虚拟机的发展史" class="headerlink" title="JAVA虚拟机的发展史"></a>JAVA虚拟机的发展史</h1><p>实际上，目前有很多JAVA虚拟机的实现，有Sun公司开发的，也有其他公司开发的商业JAVA虚拟机。比较出名的有：</p><p>（1）Sun Classic / Exact VM</p><p>它是Sun公司最早开发的JVM版本。</p><p>（2）Sun HotSpot VM</p><p>HotSpot VM是目前使用范围最广的JAVA虚拟机，它是Sun JDK和Open JDK所带的虚拟机。</p><p>（3）Sun Mobile-Embedded VM / Meta-Circular VM</p><p>（4）BEA JRockit / IBM J9 VM</p><p>（5）Azul VM / BEA Liquid VM</p><p>（6）Apache Harmony / Google Android Dalvik VM</p><p>（7）Microsoft JVM</p><p>（8）….</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中virtualenv和virtualenvwrapper工具介绍和使用</title>
      <link href="/2018/10/10/Python%E4%B8%ADvirtualenv%E5%92%8Cvirtualenvwrapper%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/10/Python%E4%B8%ADvirtualenv%E5%92%8Cvirtualenvwrapper%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="virtualenv工具介绍"><a href="#virtualenv工具介绍" class="headerlink" title="virtualenv工具介绍"></a>virtualenv工具介绍</h1><p>在我们日常Python项目开发中，比如除了基于Flask的项目外，还会有其他项目用到Python。当项目越来越多时就会面对使用Python的不同版本问题，或者至少会遇到使用不同版本的Python库的问题。摆在你面前的是：库常常不能向后兼容，更不幸的是任何成熟的应用都不是零依赖。如果两个项目依赖出现冲突，就会比较麻烦。</p><p>而virtualenv就可以用来解决Python多版本环境的问题。它的基本原理是为每个项目安装一套Python，多套Python并存。但它不是真正地安装多套独立的Python拷贝，而是使用了一种巧妙的方法让不同的项目处于各自独立的环境中。</p><h1 id="virtualenv的使用"><a href="#virtualenv的使用" class="headerlink" title="virtualenv的使用"></a>virtualenv的使用</h1><p>（1）virtualenv的安装</p><p>执行<code>pip install virtualenv</code>或<code>easy_install virtualenv</code>或<code>apt-get install python-virtualenv</code>（Ubuntu系统中）命令即可安装virtualenv。</p><p>（2）virtualenv的使用</p><p>执行<code>virtualenv my-env</code>创建一个名称为my-env的Python虚拟环境。</p><p>执行<code>source my-env/bin/activate</code>命令激活my-env Python虚拟环境，并进入Python虚拟环境，然后可以干各种操作。注意这时终端提示符有变化，但是可以切换到任何目录中执行，而不局限于在my-env目录中。</p><p>执行<code>deactivate</code>命令，即可退出my-env Python虚拟环境，需要注意的是，virtualenv虚拟环境退出后，在虚拟环境中启动的服务进程，并不会退出哦。</p><p>备注：</p><p>我们在创建Python虚拟环境时，可以指定虚拟环境要使用的Python版本，命令如下（使用-p参数指明Python解释器的路径就好了）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -p /usr/bin/python2.7 ENV2.7  <span class="comment">#创建python2.7的虚拟环境</span></span><br><span class="line">virtualenv -p /usr/bin/python3.4 ENV3.4  <span class="comment">#创建python3.4的虚拟环境</span></span><br></pre></td></tr></table></figure><h1 id="virtualenvwrapper工具介绍"><a href="#virtualenvwrapper工具介绍" class="headerlink" title="virtualenvwrapper工具介绍"></a>virtualenvwrapper工具介绍</h1><p>virtualenvwrapper是virtualenv的扩展管理包，用于更方便管理虚拟环境，它可以做：</p><p>（1）将所有虚拟环境整合在一个目录下</p><p>（2）管理（新增，删除，复制）虚拟环境</p><p>（3）切换虚拟环境</p><p>与virtualenv相比，virtualenvwrapper将虚拟环境创建出现的文件统一管理，对用户更友好。而且virtualenvwrapper提供了更多好用的工具，如workon。在virtualenv中，我们需要切换到虚拟环境的目录并执行<code>source env-name/bin/activate</code>命令，才能进入虚拟环境。而使用virtualenvwrapper，我们可以在任意目录下执行<code>workon env-name</code>就可以激活或进入到虚拟环境中。</p><h1 id="virtualenvwrapper的安装配置和使用"><a href="#virtualenvwrapper的安装配置和使用" class="headerlink" title="virtualenvwrapper的安装配置和使用"></a>virtualenvwrapper的安装配置和使用</h1><p>（1）执行<code>pip install virtualenv virtualenvwrapper</code>命令安装virtualenv和virtualenvwrapper工具。</p><p>（2）配置virtualenvwrapper</p><p>在<code>~/.bashrc</code>中添加下列内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><p>接着执行<code>source ~/.bashrc</code>命令使之生效。最终利用virtualenvwrapper创建的虚拟环境相关的文件目录都放入到WORKON_HOME这个环境变量所指定的目录中。</p><p>（3）virtualenvwrapper的常用工具命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv [环境名] <span class="comment">#创建基本环境，也可以通过-p /usr/bin/python3.4等参数来指定虚拟环境中python版本</span></span><br><span class="line">rmvirtualenv [环境名] <span class="comment">#删除环境</span></span><br><span class="line">workon [环境名]       <span class="comment">#激活环境</span></span><br><span class="line">deactivate           <span class="comment">#退出环境</span></span><br><span class="line">workon 或者 lsvirtualenv -b  <span class="comment">#列出所有环境</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React框架中的虫洞Context简介和使用</title>
      <link href="/2018/09/24/React%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%99%AB%E6%B4%9EContext%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/24/React%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%99%AB%E6%B4%9EContext%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="context的介绍"><a href="#context的介绍" class="headerlink" title="context的介绍"></a>context的介绍</h1><p>当开发React应用时，我们总是通过改变State和传递Prop对view进行控制。但是随着我们的应用变的越来越复杂，组件嵌套也变的越来越深，有时甚至需要从最外层将一个数据一直传递到最里层（比如当前user的信息）。 </p><p>理论上，通过prop一层层传递下去当然是没问题的。不过这也太麻烦啦，要是能在最外层和最里层之间开一个穿越空间的虫洞就好了。 幸运的是，React的开发者也意识到这个问题，为我们开发出了这个空间穿越通道—context。</p><h1 id="context的使用"><a href="#context的使用" class="headerlink" title="context的使用"></a>context的使用</h1><p>假设我们有下面这样的组件结构，若D组件需要获取在A组件中用户信息，就可以使用context来获取到。</p><p><img src="/images/react_context_1_1.png" alt></p><p>代码的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外层组件A的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    getChildContext() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            user: <span class="string">"testuser123"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;div&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">A.childContextTypes = &#123;</span></span><br><span class="line"><span class="regexp">    user: React.PropTypes.object</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 内层组件D的定义</span></span><br><span class="line"><span class="regexp">class D extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;this.context.user&#125;&lt;/</span>div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">D.contextTypes = &#123;</span><br><span class="line">    user: React.PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或如下写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外层组件A的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    getChildContext() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            user: <span class="string">"testuser123"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    childContextTypes = &#123;</span><br><span class="line">        user: React.PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;div&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 内层组件D的定义</span></span><br><span class="line"><span class="regexp">class D extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    contextTypes = &#123;</span></span><br><span class="line"><span class="regexp">        user: React.PropTypes.object</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;this.context.user&#125;&lt;/</span>div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：只要在外层组件A定义一个getChildContext方法以及childContextTypes声明。在里层组件D中声明contextTypes，则就可以在里层组件D中使用this.context.xxx来获取外层组件A传递出来的值了。另外，组件A的其他子组件均可以像组件D一样地获取到组件A传递过来的context值。</p><p>学习资料参考于：<br><a href="https://segmentfault.com/a/1190000004636213" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004636213</a></p>]]></content>
      
      
      <categories>
          
          <category> ReactJS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络中MTU|MSS的概念及实际应用</title>
      <link href="/2018/09/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%ADMTU-MSS%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
      <url>/2018/09/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%ADMTU-MSS%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>MTU，Maximum Transmit Unit，中文全称为最大传输单元。即物理接口（数据链路层）提供给其上层最大一次传输数据的大小，比如IP层、MPLS层等等，因为目前应用最多的接口是以太网，所以谈谈以太网口的MTU，假定其上层协议是IP，缺省MTU=1500，意思是：整个IP包最大从这个接口发送出去的是1500个字节。可以通过配置修改成更大或更小的值，只要在系统的边界值以内即可，但是切记要在链路的两端都要修改，而且要大小一样，如果不一样，会造成大侧的数据被小侧丢弃。</p><p>简单来说，MTU是数据链路层的概念，用来限制其上层网络IP协议层的数据包最大长度（包括协议头和数据内容）。常见数据链路层技术的MTU如下：</p><p><img src="/images/mtu_mss_1_1.png" alt></p><h1 id="MSS"><a href="#MSS" class="headerlink" title="MSS"></a>MSS</h1><p>MSS，Maximum Segment Size ，中文全称为最大TCP分段大小，不包含TCP头和option，只包含TCP Payload ，TCP用来限制自己每次发送的最大分段尺寸。MSS就是TCP数据包每次能够传输的最大数据分段。为了达到最佳的传输效能TCP协议在建立连接的时候通常要协商双方的MSS值，通讯双方会根据双方提供的MSS值得最小值确定为这次连接的最大MSS值。</p><h1 id="MTU和MSS的关系图"><a href="#MTU和MSS的关系图" class="headerlink" title="MTU和MSS的关系图"></a>MTU和MSS的关系图</h1><p>以TCP/UDP+IP+Ethernet的网络模型为例来说，以太网的MTU为1500Bytes，因为IP层Header固定20Bytes，TCP/UDP层header固定20Bytes，则要求TCP/UDP层payload最大为1500-20-20=1460Bytes。</p><p><img src="/images/mtu_mss_1_2.png" alt></p><h1 id="对于使用GRE-Tunnel的私有网络的一个坑"><a href="#对于使用GRE-Tunnel的私有网络的一个坑" class="headerlink" title="对于使用GRE Tunnel的私有网络的一个坑"></a>对于使用GRE Tunnel的私有网络的一个坑</h1><p>由于使用了GRE Tunnel技术的使用网络，在数据通信时，会在IP层数据包的基础上再另外加上GRE Header，这个GRE Header一共24 Bytes。因此在这样的网络环境中我们必须重新设置网络的MTU值，即Ethernet网MTU需要设置成1500-24=1476Bytes啦，否则网络通信会出现问题。</p><h1 id="查看和修改Linux的MTU值"><a href="#查看和修改Linux的MTU值" class="headerlink" title="查看和修改Linux的MTU值"></a>查看和修改Linux的MTU值</h1><p>（1）使用ip a或ifconfig查看网卡的MTU设置</p><p><img src="/images/mtu_mss_1_3.png" alt></p><p>（2）修改网卡MTU设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 mtu number</span><br></pre></td></tr></table></figure><p>或编辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth0  <span class="comment">#增加MTU=XXX</span></span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://teenyscrew.blogspot.com/2014/06/gre-tunnel-mtu.html" target="_blank" rel="noopener">http://teenyscrew.blogspot.com/2014/06/gre-tunnel-mtu.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 30X重定向跳转小结</title>
      <link href="/2018/08/26/HTTP-30X%E9%87%8D%E5%AE%9A%E5%90%91%E8%B7%B3%E8%BD%AC%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/08/26/HTTP-30X%E9%87%8D%E5%AE%9A%E5%90%91%E8%B7%B3%E8%BD%AC%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="30X重定向"><a href="#30X重定向" class="headerlink" title="30X重定向"></a>30X重定向</h1><p>HTTP 301代表永久性转移（Permanently Moved）。</p><p>HTTP 302代表暂时性转移（Temporarily Moved）。</p><h1 id="301-302对搜索引擎来说的异同"><a href="#301-302对搜索引擎来说的异同" class="headerlink" title="301/302对搜索引擎来说的异同"></a>301/302对搜索引擎来说的异同</h1><p>302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址，因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p><p>举例来说，假如我们把<code>www.example.com</code>域名302重定向到网易<code>www.163.com</code>，搜索引擎会索引网易的内容到<code>www.example.com</code>域名下；如果使用301重定向，搜索引擎则会直接使用新域名w<code>ww.163.com</code>来做索引，放弃使用<code>www.example.com</code>来做索引。 对于搜索引擎来说，302重定向会让搜索引擎公司索引重复的内容。</p><h1 id="使用HTTP-200来间接实现页面跳转"><a href="#使用HTTP-200来间接实现页面跳转" class="headerlink" title="使用HTTP 200来间接实现页面跳转"></a>使用HTTP 200来间接实现页面跳转</h1><p>除了30X可以实现重定向的效果外，状态200其实也可以间接实现页面跳转的效果，以知乎跳转到百度首页的做法，请求地址为<code>https://link.zhihu.com/?target=https://www.baidu.com</code>，在浏览器器中输入该地址后，对应的请求过程如下：</p><p><img src="/images/http_redirect_1_1.png" alt></p><p>可以看到，请求上述地址后，响应的状态码是200，响应的内容是空，但浏览器之后却访问（跳转到）了<code>http://www.baidu.com</code>的页面。<br>其实我们使用<code>curl &quot;https://link.zhihu.com/?target=https://www.baidu.com&quot;</code>，内容如下：</p><p><img src="/images/http_redirect_1_2.png" alt></p><p>正如上图中看到，关键部分在<code>window.location.href=decodeURIComponent(URI);</code>这个JS会在浏览器中打开<code>https://www.baidu.com</code>页面，即浏览器自动发起了一次<code>https://www.baidu.com</code>的请求。需要注意的是，这段JS在Chrome的调试面板中是看不到的哦。有很多的SSO产品也用到了这个知识点哦。</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React组件的生命周期机制及生命周期函数</title>
      <link href="/2018/07/09/React%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/"/>
      <url>/2018/07/09/React%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="React组件的生命周期机制"><a href="#React组件的生命周期机制" class="headerlink" title="React组件的生命周期机制"></a>React组件的生命周期机制</h1><p><img src="/images/react_lifecycle_1_1.png" alt></p><p><img src="/images/react_lifecycle_1_2.png" alt></p><h1 id="React组件的生命周期函数"><a href="#React组件的生命周期函数" class="headerlink" title="React组件的生命周期函数"></a>React组件的生命周期函数</h1><p>React组件本质上是一个状态机，输入确定，则输出一定确定。React组件的生命周期包括初始化阶段、运行中阶段、销毁阶段三个阶段。React框架为组件的不同生命阶段，提供了近十个钩子Hook函数。 例如：</p><p>（1）初始化阶段钩子函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getDefaultProps()</span><br><span class="line">getInitialState()</span><br><span class="line">componentWillMount()</span><br><span class="line">render  <span class="comment">//render函数中只能访问this.props和this.state，只能有一个顶层组件，不允许修改状态和DOM输出</span></span><br><span class="line">componentDidMount</span><br></pre></td></tr></table></figure><p>备注：上述五个钩子是按执行顺序排序的。</p><p>（2）运行中阶段的钩子函数</p><p>此时组件已经渲染好并且用户可以与它进行交互，比如鼠标点击，手指点按，或者其它的一些事件，导致应用状态的改变，将会看到下面的方法依次被调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps()</span><br><span class="line">shouldComponentUpdate()  <span class="comment">//如果该函数返回false，那么会阻止接下来的render函数调用</span></span><br><span class="line">componentWillUpdate()</span><br><span class="line">render  <span class="comment">//和上面的是同一个render函数哦</span></span><br><span class="line">componentDidUpdate <span class="comment">//该函数中可以修改DOM</span></span><br></pre></td></tr></table></figure><p>（3）销毁阶段的钩子函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount</span><br></pre></td></tr></table></figure><p>举例来说，组件可以通过Ajax请求，从服务器获取数据。Ajax请求一般在<code>componentDidMount()</code>方法里面发出，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">'...'</span>;</span><br><span class="line">    $.getJSON(url)</span><br><span class="line">      .done()</span><br><span class="line">      .fail();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="各钩子函数的说明"><a href="#各钩子函数的说明" class="headerlink" title="各钩子函数的说明"></a>各钩子函数的说明</h1><p>（1）getDefaultProps()</p><p>对于每个组件实例来讲，这个方法只会调用一次，该组件类的所有后续应用，getDefaultPops将不会再被调用，其返回的对象可以用于设置默认的props(properties的缩写) 值。该函数只在<code>React.createClass({})</code>创建的组件中存在，在<code>class Welcome extends React.Component {}</code>创建的组件中是不存在该函数的。</p><p>（2）getInitialState()</p><p>对于组件的每个实例来说，这个方法的调用有且只有一次，用来初始化每个实例的state，在这个方法里，可以访问组件的props。每一个React组件都有自己的state，其与props的区别在于state只存在组件的内部，props在所有实例中共享。该函数只在<code>React.createClass({})</code>创建的组件中存在，在<code>class Welcome extends React.Component {}</code>创建的组件中是不存在该函数的。</p><p>（3）componentWillMount()</p><p>该方法在首次渲染之前调用，也是在render方法调用之前修改state的最后一次机会。</p><p>（4）render()</p><p>render方法会创建一个虚拟DOM，用来表示组件的输出。对于一个组件来讲，render方法是唯一一个必需的方法。render方法返回的结果并不是真正的DOM元素，而是一个虚拟的表现，类似于一个DOM tree的结构的对象。react之所以效率高，就是这个原因。render()函数执行结果就是页面被重新渲染啦。</p><p>（5）componentDidMount()</p><p>该方法不会在服务端被渲染的过程中调用。该方法被调用时，已经渲染出真实的DOM，可以在该方法中通过this.getDOMNode()访问到真实的DOM（推荐使用ReactDOM.findDOMNode()）。</p><p>（6）componentWillReceiveProps()</p><p>组件的props属性可以通过父组件来更改，这时componentWillReceiveProps将来被调用。可以在这个方法里更新state，以触发render方法重新渲染组件。</p><p>（7）shouldComponentUpdate()</p><p>如果你确定组件的props或者state的改变不需要重新渲染，可以通过在这个方法里通过返回false来阻止组件的重新渲染，返回false则不会执行render 以及后面的componentWillUpdate，componentDidUpdate方法。这个函数必须返回值必须是布尔型，若返回false，则不重新渲染页面，若返回true，则会重新渲染页面。</p><p>（8）componentWillUpdate()</p><p>这个方法和componentWillMount类似，在组件接收到了新的props或者state即将进行重新渲染前，componentWillUpdate(object nextProps, object nextState) 会被调用，注意不要在此方面里再去更新props或者state。</p><p>（9）componentDidUpdate()</p><p>这个方法和componentDidMount类似，在组件重新被渲染之后，componentDidUpdate(object prevProps, object prevState) 会被调用。可以在这里访问并修改DOM。</p><p>（10）componentWillUnmount()</p><p>每当React使用完一个组件，这个组件必须从DOM中卸载后被销毁，此时componentWillUnmout会被执行，完成所有的清理和销毁工作，在componentDidMount中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。</p><h1 id="一点补充说明"><a href="#一点补充说明" class="headerlink" title="一点补充说明"></a>一点补充说明</h1><p>（1）当我们在组件中调用setState函数去更新组件的this.state时，就会依次调用shouldComponentUpdate、componentWillUpdate、render以及componentDidUpdate等函数，可能还会去调用其他函数啦。</p><p>（2）当我们的组件的属性props变化时，也会调用一些组件的生命周期函数，会依次调用componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render以及componentDidUpdate等函数。也就是说，当React组件的props被修改时，也是会重新渲染该组件的啦。</p><p>（3）一般来说，我们很少重写componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate以及componentDidUpdate这四个函数。componentWillUnmount我们一般也很少重写啦。</p><p>学习资料参考于：<br><a href="https://segmentfault.com/a/1190000004168886" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004168886</a></p>]]></content>
      
      
      <categories>
          
          <category> ReactJS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React中JSX</title>
      <link href="/2018/07/08/React%E4%B8%ADJSX/"/>
      <url>/2018/07/08/React%E4%B8%ADJSX/</url>
      
        <content type="html"><![CDATA[<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><p>JSX，全称是JavaScript XML，JSX是对JavaScript语法的扩展。JSX和CoffeeScript、TypeScript类似，它们最终被转换成JavaScript后被浏览器解释执行。可以说他们是JavaScript是语法糖。React WEB APP开发不一定要使用JSX，但一般建议使用。更简单来说，JSX并不是一个模板语言，是语法糖，JSX能够让开发者在JavaScript代码中直接编写HTML标签。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;h1&gt;Hello, world!&lt;<span class="regexp">/h1&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('example')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h1 id="JSX中className"><a href="#JSX中className" class="headerlink" title="JSX中className"></a>JSX中className</h1><p>在JSX中HTML代码，并非真实的DOM结构，是虚拟的DOM，它是要被React框架解析后并挂载到DOM上才可以的。我们知道在普通的HTML标签中，要为某个标签设置CSS样式，可以为该标签定义一个class的属性，然后再CSS中通过该class找到HTML元素，并设置样式。但是在ES6中，class是一个关键字，我们就不能直接为HTML标签或者我们通过React自定义的组件设置class属性啦，而是要换成className的属性，然后在CSS中，通过className属性来设置样式。</p><p>普通的HTML中，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"submit_button"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在JSX中，要是用className，替代class，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">"submit_button"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><h1 id="JSX中花括号"><a href="#JSX中花括号" class="headerlink" title="JSX中花括号{}"></a>JSX中花括号<code>{}</code></h1><p>在JSX中的花括号<code>{}</code>是用来表示去JS表达式的值，如<code>{this.state.xxoo}</code>表示获取组件State中的xxoo的属性值。当我们要获取一个对象时，就会出现出现两个花括号，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="attr">foo</span>: <span class="number">122</span>, <span class="attr">bar</span>: <span class="string">'kaka'</span>&#125;&#125; <span class="comment">//外面的花括号的含义同前面，里面的花括号是对象自己的花括号啦。</span></span><br></pre></td></tr></table></figure><p>备注：其实JSX中花括号<code>{}</code>中内容是JS代码，可能会表达式，也可能是一行JS语句等。</p>]]></content>
      
      
      <categories>
          
          <category> ReactJS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React组件的状态State和属性Props</title>
      <link href="/2018/07/08/React%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81State%E5%92%8C%E5%B1%9E%E6%80%A7Props/"/>
      <url>/2018/07/08/React%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81State%E5%92%8C%E5%B1%9E%E6%80%A7Props/</url>
      
        <content type="html"><![CDATA[<h1 id="组件状态State"><a href="#组件状态State" class="headerlink" title="组件状态State"></a>组件状态State</h1><p>React把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染UI，让用户界面和数据保持一致。React里，只需更新组件的state，然后根据新的state重新渲染用户界面（不要操作DOM）。</p><p>以下实例中创建了<code>LikeButton</code>组件，<code>getInitialState</code>方法用于定义初始状态，也就是一个对象，这个对象可以通过<code>this.state</code>属性读取。当用户点击组件，导致状态变化，<code>this.setState</code>方法就修改状态值，每次修改以后，React框架会自动调用<code>this.render</code>方法来渲染组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LikeButton = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">liked</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">liked</span>: !<span class="keyword">this</span>.state.liked&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> text = <span class="keyword">this</span>.state.liked ? <span class="string">'喜欢'</span> : <span class="string">'不喜欢'</span>;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;p onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">              你&lt;b&gt;&#123;text&#125;&lt;<span class="regexp">/b&gt;我。点我切换状态。</span></span><br><span class="line"><span class="regexp">            &lt;/</span>p&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;LikeButton /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>关于组件状态State的一些API如下：</p><p>（1）setState()</p><p><code>setState()</code>用来设置状态，合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(object nextState[, <span class="function"><span class="keyword">function</span> <span class="title">callback</span>])</span></span><br></pre></td></tr></table></figure><p>nextState，将要设置的新状态，该状态会和当前的state合并。也就是说如果<code>this.setState({xxoo: somedata})</code>设置state中xxoo字段，会合并原来的state，也就是在原来的state中多了一个xxoo字段。若this.state中已经有了xxoo字段，就会覆盖这个字段的对应的值。</p><p>callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。</p><p>备注：每次调用this.setState，render方法都会被再次调用，同时也会调用一些相关的生命周期函数。this.setState接受一个对象作为新状态的patch，也就是说这个对象不会覆盖现有的this.state，而是一个类似extend的行为。</p><p>（2）replaceState()</p><p>replaceState()用来替换状态，replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replaceState(object nextState[, <span class="function"><span class="keyword">function</span> <span class="title">callback</span>])</span></span><br></pre></td></tr></table></figure><p>nextState，将要设置的新状态，该状态会替换当前的state。</p><p>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</p><h1 id="组件属性Props"><a href="#组件属性Props" class="headerlink" title="组件属性Props"></a>组件属性Props</h1><p>state和props主要的区别在于props是不可变的，而state可以根据与用户交互来改变。这就是为什么有些容器组件需要定义state来更新和修改数据。而子组件只能通过props来传递数据。因此，一定要注意的是，开发者一般不需要在组件中去修改props的值哦，当然修改了props前台也不会报错，只是一个开发规范或约束的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage name=<span class="string">"Runoob"</span> /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可以通过<code>getDefaultProps()</code>方法为props设置默认值，实例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</span><br><span class="line">    getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">'Runoob'</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Props验证使用propTypes，它可以保证我们的应用组件被正确使用，React.PropTypes提供很多验证器(validator) 来验证传入数据是否有效。当向 props传入无效数据时，JavaScript控制台会抛出警告。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> title = <span class="string">"菜鸟教程"</span>;</span><br><span class="line"><span class="keyword">var</span> MyTitle = React.createClass(&#123;</span><br><span class="line">    propTypes: &#123;</span><br><span class="line">        title: React.PropTypes.string.isRequired,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> &#123;this.props.title&#125; <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;MyTitle title=&#123;title&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="关于组件state和props的初始化"><a href="#关于组件state和props的初始化" class="headerlink" title="关于组件state和props的初始化"></a>关于组件state和props的初始化</h1><p>若使用<code>React.createClass({})</code>来定义React组件，可以使用<code>getDefaultProps()</code>和<code>getInititalState()</code>来初始化组件的state和props。若使用<code>class Welcome extends React.Component {}</code>来定义组件，那么则没有<code>getDefaultProps()</code>和<code>getInititalState()</code>，则可以在构造函数中初始化state，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            xxoo: <span class="string">'wahaha'</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于属性props的初始化待确认。</p>]]></content>
      
      
      <categories>
          
          <category> ReactJS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React简介和简单使用</title>
      <link href="/2018/07/08/React%E7%AE%80%E4%BB%8B%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/08/React%E7%AE%80%E4%BB%8B%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h1><p>React是一个用于构建用户界面的JAVASCRIPT库。 React主要用于构建UI，很多人认为React是MVC中的V（视图）。 React拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。React最核心的场景就是开发widget，或者说组件，大型React项目本质上就是有widget堆积而成，面向组件的开发模式。也就是说，React的核心理念是组件式开发，通过React构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</p><p>React的主要发展历程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2013.6 Facebook官方发布React</span><br><span class="line">2013.9 React热度开始上涨</span><br><span class="line">2015.3 React Native发布，用React来编写跨平台的移动端应用，即使用React编写IOS，Android，Windows Phone应用</span><br></pre></td></tr></table></figure><p>当组件中的状态发生改变时，在内存中计算出（新的）DOM结构后与已有的DOM结构进行对比。实际上，这是非常昂贵的。因而React框架采取将真实DOM映射为虚拟DOM ，通过对比状态变化前后虚拟DOM的不同，计算出变化后再改变真实DOM结构，这个过程称为调和（reconciliation）。一定要注意这里的虚拟DOM的概念，是React更新UI的核心原理。</p><p>备注：React是单向数据绑定，而AngularJS是双向绑定。</p><h1 id="React的HelloWorld"><a href="#React的HelloWorld" class="headerlink" title="React的HelloWorld"></a>React的HelloWorld</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/react/15.4.2/react.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/react/15.4.2/react-dom.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line">            ReactDOM.render(</span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>,</span></span><br><span class="line"><span class="javascript">              <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span></span><br><span class="line">            );</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="React官网上推荐的创建React项目的方法"><a href="#React官网上推荐的创建React项目的方法" class="headerlink" title="React官网上推荐的创建React项目的方法"></a>React官网上推荐的创建React项目的方法</h1><p>React官网上推荐的创建React项目的步骤如下：</p><p>（1）安装npm工具</p><p>（2）执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br><span class="line">create-react-app my-app</span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm run start  <span class="comment">#启动了web-app</span></span><br></pre></td></tr></table></figure><p>（3）访问测试</p><p>浏览器输入<code>http://ip:port/</code>来访问页面，效果如下：</p><p><img src="/images/react_1_1.png" alt></p><p>备注：在实际项目中，不推荐这种方式，可以使用一些脚手架来初始化一个React项目，也可以使用已有的项目来构建一个初始化的React项目，如<code>https://github.com/wangjianno1/fifa-fe</code>或<code>https://github.com/wangjianno1/houyi-fe</code>。</p><h1 id="React中的一些重要概念"><a href="#React中的一些重要概念" class="headerlink" title="React中的一些重要概念"></a>React中的一些重要概念</h1><p>（1）React elements  - React元素</p><p>React elements类似如下形式，可以简单理解成是一段html标签。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>（2）React Components  - React组件</p><p>React组件可以是函数组件，也可以是Class组件。组件可以被用来重用哦。一个组件的输入是JavaScript对象，输出是一个React元素。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional式React组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class式React组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：<code>React.createClass</code>方法也可以生成一个组件类。</p><h1 id="React开发包的结构"><a href="#React开发包的结构" class="headerlink" title="React开发包的结构"></a>React开发包的结构</h1><p>React package被拆分为react及react-dom两个package。其中react package中包含React.createElement、.createClass、.Component、.PropTypes以及.Children等这些API，而react-dom package中包含ReactDOM.render、.unmountComponentAtNode、.findDOMNode等这些API。一般来说，React项目是放在服务端转码成原生JS后再在浏览器端执行，当然React也可以直接在浏览器端解释执行，则react对应的是react.min.js，react-dom对应的是react-dom.min.js。</p><p>参考资料来源于：<br><a href="https://github.com/ruanyf/jstraining/blob/master/docs/react.md" target="_blank" rel="noopener">https://github.com/ruanyf/jstraining/blob/master/docs/react.md</a> （非常好的React技术栈的说明）</p>]]></content>
      
      
      <categories>
          
          <category> ReactJS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS的盒子模型</title>
      <link href="/2018/07/08/CSS%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/07/08/CSS%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS的盒子模型"><a href="#CSS的盒子模型" class="headerlink" title="CSS的盒子模型"></a>CSS的盒子模型</h1><p><img src="/images/css_1_2.png" alt></p><p>（1）Margin（外边距）</p><p>清除边框外的区域，外边距是透明的。</p><p>（2）Border（边框）</p><p> 围绕在内边距和内容外的边框。</p><p>（3）Padding（内边距）</p><p>清除内容周围的区域，内边距是透明的。</p><p>（4）Content（内容）</p><p>盒子的内容，显示文本和图像。</p><p>备注：当指定一个CSS元素的宽度和高度属性时，我们只是设置内容区域的宽度和高度。要知道你还可以添加填充，边框和边距等属性。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS的使用方式</title>
      <link href="/2018/07/08/CSS%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/07/08/CSS%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h1><p>外部样式表就是将CSS的内容定义在一个单独的文件中，这样就可以使用同一个CSS样式表来控制多个HTML文档。然后HTML文档使用<code>&lt;link&gt;</code>标签链接到外部样式表。 <code>&lt;link&gt;</code>标签在HTML文档的头部：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h1><p>当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用<code>&lt;style&gt;</code>标签在文档头部定义内部样式表，像如下方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">hr</span> &#123;<span class="attribute">color</span>:sienna;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>:<span class="number">20px</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">"images/back40.gif"</span>);&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h1><p>内联样式，就是在HTML标签内使用样式<code>style</code>属性，<code>style</code>属性可以包含任何CSS属性。如下例子是用来控制段落的颜色和左外边距：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:sienna;margin-left:20px"</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="各种使用方式的优先级"><a href="#各种使用方式的优先级" class="headerlink" title="各种使用方式的优先级"></a>各种使用方式的优先级</h1><p>当一个HTML文档同时使用了外部样式表、内部样式表和内联样式。这时候各个样式表会合并成一个样式，假设样式表1中定义了<code>a</code>元素，样式表2中定义了<code>b</code>元素上，那么最终的<code>a</code>和<code>b</code>都会得到控制。但是如果不同的样式表对同一个元素进行了重复的定义，那么就会使用样式表的优先级来覆盖，优先级为<code>内联样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 浏览器缺省值</code>，也就是内联样式的优先级最大。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS基本介绍</title>
      <link href="/2018/07/08/CSS%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/07/08/CSS%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h1><p>CSS指层叠样式表（Cascading Style Sheets），CSS定义如何显示 HTML元素。CSS的出现是为了解决内容与表现分离的问题，使WEB文档样式风格相关的定义和申明都放在独立的文件中，也就是CSS文件中。而HTML中只包含了文档标签和文档内容。CSS是在HTML 4.0时候提出来的。</p><p>现在最新的CSS版本是CSS3，里面有好多新的样式定义，例如圆角属性border-radius、渐变属性等等。</p><h1 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h1><p>CSS规则由两个主要的部分构成：选择器以及一条或多条声明：</p><p><img src="/images/css_1_1.png" alt></p><p>选择器通常是需要改变样式的HTML元素。每条声明由一个属性和一个值组成。属性（property）是希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。例如，定义段落的颜色和对齐方式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中选择器除了可以是普通的HTML标签元素，也可以是id选择器和class选择器：</p><p>（1）id选择器</p><p>id选择器可以为标有特定id的HTML元素指定特定的样式。HTML元素以id属性来设置id选择器，CSS中id选择器以”#”来定义。以下的样式规则应用于<code>id=&quot;para1&quot;</code>的HTML标签元素:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#para1</span><br><span class="line">&#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）class选择器</p><p>class选择器用于描述一组元素的样式，class选择器有别于id选择器，class可以在多个元素中使用。class选择器在HTML中以class属性表示, 在 CSS中，类选择器以一个点”.”号显示：在下面的例子中，所有class属性为center的 HTML元素均居中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）混合模式选择器</p><p>可以使用HTML元素和class属性来作为选择器。例如，下面的例子中，为html文档中所有class属性的值为center的p标签定义样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.center</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）选择器的组合与嵌套</p><p>形式一：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上写法表示html元素h1、h2、p使用相同的样式。</p><p>形式二：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.marked</span> <span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上写法表示为所有<code>class=&quot;marked&quot;</code>元素内的<code>p</code>元素指定一个样式。</p><p>形式三：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上写法表示为<code>div</code>标签中所有<code>p</code>元素设置样式。</p><p>形式四：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>+<span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上写法表示选中<code>div</code>标签后第一个<code>p</code>元素，为其设置样式。注意<code>div</code>和<code>p</code>元素必须是同级的元素。</p><p>形式五：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>~<span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上写法表示选中<code>div</code>标签后所有<code>p</code>元素，为其设置样式。注意<code>div</code>和<code>p</code>元素必须是同级的元素。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础</title>
      <link href="/2018/07/08/HTML%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/07/08/HTML%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h1><p>HTML指的是超文本标记语言，HyperText Markup Language，它不是一种编程语言，而是一种标记语言。由HTML标签和文本内容加在一起就是HTML文档或WEB页面。</p><p>目前，HTML有好多版本，具体如下：</p><p><img src="/images/html_1_1.png" alt></p><p>为了让浏览器能正确显示不同HTML版本的网页，需要在WEB页面中使用<code>&lt;!DOCTYPE&gt;</code>声明来表明HTML文档所使用的HTML的版本，例如下面是HTML 4.01的类型：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h1><p>HTML标记标签通常被称为HTML标签(HTML tag)。HTML标签是由尖括号包围的关键词，比如<code>&lt;html&gt;</code>。HTML标签通常是成对出现的，比如<code>&lt;b&gt;</code>和<code>&lt;/b&gt;</code>。标签对中的第一个标签是开始标签，也称为开始标签；第二个标签是结束标签，也称为闭合标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">标签</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由HTML元素组成的WEB页面如下图所示：</p><p><img src="/images/html_1_2.png" alt></p><h1 id="HTML标签的属性"><a href="#HTML标签的属性" class="headerlink" title="HTML标签的属性"></a>HTML标签的属性</h1><p>HTML元素可以设置属性，属性可以在元素中添加附加信息，属性一般描述于开始标签，属性总是以名称/值对的形式出现，比如：<code>name=&quot;value&quot;</code>。例如超链接标签<code>&lt;a&gt;</code>，其跳转的目的地址就时放到属性<code>herf</code>中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>超链接到百度首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般来讲，HTML元素一般有很多属性，通用的属性有：</p><p>（1）class</p><p>可以为标签定义一个或多个类名。同一个class名称就代表了WEB页面元素的某个集合。</p><p>（2）id</p><p>定义元素的唯一id</p><p>（3）style</p><p>指明html元素的样式风格</p><p>（4）title</p><p>描述了元素的额外信息</p><h1 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h1><p>DOM，全称为Document Object Model，中文为文档对象模型。HTML DOM就是HTML语言对外界开通的接口，以便其他语言能够访问或修改HTML内部的元素。</p><h1 id="HTML文档的编码声明"><a href="#HTML文档的编码声明" class="headerlink" title="HTML文档的编码声明"></a>HTML文档的编码声明</h1><p>目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为<code>UTF-8</code>。在<code>&lt;head&gt;</code>标签里面加入<code>&lt;metacharset=&quot;UTF-8&quot;&gt;</code>标签，表明文档的编码类型为<code>UTF-8</code>。</p><h1 id="关于H5的一点闲话"><a href="#关于H5的一点闲话" class="headerlink" title="关于H5的一点闲话"></a>关于H5的一点闲话</h1><p>HTML5是HTML的第五个版本。HTML5本质上不是什么新的技术，但是由于其在功能特性上有了极大的丰富，在加上各大浏览器性能上的支持，HTML5相对以前的HTML4有着更广泛的应用。当通常人们说的“H5技术”或“H5页面”等等，并不等于HTML5标准，其实这里面的H5，实际上是一个解决方案，一个用来制作出看起来酷炫的移动端OnePage网站的解决方案。而这个解决方案不仅包含了HTML5新增的audio标签、canvas、拖拽特性、本地存储、websocket通信，同时也包括了盒模型、绝对定位以及一切前端知识。</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6中类class编程</title>
      <link href="/2018/07/08/ES6%E4%B8%AD%E7%B1%BBclass%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/07/08/ES6%E4%B8%AD%E7%B1%BBclass%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6类class编程简介"><a href="#ES6类class编程简介" class="headerlink" title="ES6类class编程简介"></a>ES6类class编程简介</h1><p>ES6提供了更接近传统语言的写法，引入了class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dosth() &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point ();</span><br><span class="line">p.dosth();</span><br></pre></td></tr></table></figure><p>备注：定义“类”的方法时，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。<code>constructor</code>是类的构造函数。</p><h1 id="ES6中类继承"><a href="#ES6中类继承" class="headerlink" title="ES6中类继承"></a>ES6中类继承</h1><p>ES6中class是可以继承的，语法规则如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ColorPoint继承了Point</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。<code>super()</code>函数会调用父类的构造函数，进行对象初始化工作。</p><h1 id="类的构造函数constructor"><a href="#类的构造函数constructor" class="headerlink" title="类的构造函数constructor()"></a>类的构造函数constructor()</h1><p><code>constructor</code>方法就是ES6中类的构造方法。constructor方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p><h1 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h1><p>私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。通常来说，在类方法名前面加上下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p><p>举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 公有方法</span></span><br><span class="line">    foo (baz) &#123;</span><br><span class="line">        <span class="keyword">this</span>._bar(baz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    _bar(baz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS/ES中函数的定义和使用</title>
      <link href="/2018/07/08/JS-ES%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/08/JS-ES%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-ES中函数的定义"><a href="#JS-ES中函数的定义" class="headerlink" title="JS/ES中函数的定义"></a>JS/ES中函数的定义</h1><p>JavaScript中的函数，也称为函数对象，因为函数在JavaScript中是一个对象的数据类型。JavaScript中函数的定义有两种形式：</p><p>（1）函数声明式定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）函数表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="ES6中箭头函数的定义和使用"><a href="#ES6中箭头函数的定义和使用" class="headerlink" title="ES6中箭头函数的定义和使用"></a>ES6中箭头函数的定义和使用</h1><p>ES6允许使用“箭头”（<code>=&gt;</code>）来定义函数，称为是“箭头函数”。</p><p>（1）基本格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(参数<span class="number">1</span>, 参数<span class="number">2</span>, …, 参数N) =&gt; &#123; 函数声明 &#125;</span><br><span class="line">(参数<span class="number">1</span>, 参数<span class="number">2</span>, …, 参数N) =&gt; 表达式（单一）  <span class="comment">//等价于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125;</span></span><br><span class="line">(单一参数) =&gt; &#123;函数声明&#125;   <span class="comment">//当只有一个参数时，圆括号是可选的：单一参数 =&gt; &#123;函数声明&#125;</span></span><br><span class="line">() =&gt; &#123;函数声明&#125;          <span class="comment">//没有参数的函数应该写成一对圆括号。() =&gt; &#123;函数声明&#125;</span></span><br><span class="line">参数 =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)      <span class="comment">//加括号的函数体返回对象字面表达式</span></span><br><span class="line">(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...rest) =&gt; &#123;函数声明&#125;   <span class="comment">//支持可变参数</span></span><br><span class="line">(参数<span class="number">1</span> = 默认值<span class="number">1</span>,参数<span class="number">2</span>, …, 参数N = 默认值N) =&gt; &#123;函数声明&#125;   <span class="comment">//支持默认参数和可变参数</span></span><br></pre></td></tr></table></figure><p>（2）举例说明</p><p>//#1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6写法</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等同于ES5代码</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>//#2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6,如果函数不需要参数，就直接用圆括号括起来</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等同于ES5代码</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>//#3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等同于ES5代码</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>//#4</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6, 若函数体有多行语句，则使用花括号括起来</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br><span class="line"><span class="comment">//ES6, 若函数需要返回对象，为了和上面的区分，需要再在外面加上圆括号</span></span><br><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br></pre></td></tr></table></figure><h1 id="JS-ES中函数的特殊用法"><a href="#JS-ES中函数的特殊用法" class="headerlink" title="JS/ES中函数的特殊用法"></a>JS/ES中函数的特殊用法</h1><p>（1）立即执行函数表达式</p><p>定义函数后会立即执行啦，形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>（2）命名式的函数表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add =<span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（3）将函数表达式作为<code>return</code>返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS/ES中操作符|表达式|语句</title>
      <link href="/2018/07/08/JS-ES%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%AC%A6-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/07/08/JS-ES%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%AC%A6-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>Javascript中有的操作符不限于下面这些：</p><p>a).基础运算符</p><p><code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>+=</code>，<code>|</code>等。</p><p>b).特殊运算符</p><p><code>c?a:b</code>，<code>delete</code>，<code>in</code>，<code>instanceof</code>，<code>typeof</code>，<code>new</code>，<code>this</code>，<code>void</code>等。</p><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>表达式有如下几种：</p><p>（1）原始表达式</p><p>例如<code>b + c</code></p><p>（2）对象和数据初始化表达式</p><p>例如，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"east"</span>,<span class="string">"west"</span>, <span class="string">"north"</span>, <span class="string">"south"</span>]</span><br><span class="line">&#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>:<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>（3）函数定义表达式</p><p>例如，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x * x;&#125;</span><br></pre></td></tr></table></figure><p>（4）对象创建表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">newPoint(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span></span><br></pre></td></tr></table></figure><p>如果后面的函数不需要传递参数的话，可以省略不写。</p><p>（5）。。。</p><h1 id="JavaScript中的语句"><a href="#JavaScript中的语句" class="headerlink" title="JavaScript中的语句"></a>JavaScript中的语句</h1><p>（1）块语句</p><p>用来组合多个语句。形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    …</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：Javascript中没有块级作用域。</p><p>（2）var变量声明语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>（3）try-catch-finally语句</p><p>有三种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try-catch语句</span><br><span class="line">try-finally语句</span><br><span class="line">try-catch-finally语句</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"test"</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ex);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"finally"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）函数定义语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）循环语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//while</span></span><br><span class="line"><span class="keyword">while</span>(expr)&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//do-while</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">while</span>(expr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//for语句</span></span><br><span class="line"><span class="keyword">for</span> (i =<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6）switch语句</p><p>（7）with语句</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS/ES中变量的声明和定义</title>
      <link href="/2018/07/08/JS-ES%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89/"/>
      <url>/2018/07/08/JS-ES%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-ES中变量声明和定义"><a href="#JS-ES中变量声明和定义" class="headerlink" title="JS/ES中变量声明和定义"></a>JS/ES中变量声明和定义</h1><p>ES5中只有两种声明变量的方法，即var命令和function命令。ES6中除了var/funtion命令，还增加了let/const/import/class命令。因此ES6一共有6种声明变量的方法。</p><h1 id="var"><a href="#var" class="headerlink" title="var"></a>var</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> a= <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>; b = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>备注，需要注意的是var关键字声明的变量是全局变量，即使var语句在代码段中。</p><h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><p>ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。也就是是一个局部变量。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：let声明的变量i只在for循环体中有效。而在JS中var声明的变量，会有变量提升的问题，即var声明的变量会是全局变量。</p><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">aaa</span>: <span class="number">1</span>, <span class="attr">bbb</span>:<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>备注：声明的PI变量，之后是不可以修改的。这里需要注意的是，const常量指定是变量的引用不可以修改，但是变量的内部属性可以变化，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">aaa</span>: <span class="number">1</span>, <span class="attr">bbb</span>:<span class="number">2</span>&#125;; </span><br><span class="line">obj = &#123;<span class="attr">ccc</span>: <span class="number">1</span>, <span class="attr">ddd</span>: <span class="number">3</span>&#125;;   <span class="comment">//报错，因为修改了常量obj的引用</span></span><br><span class="line">obj.aaa = <span class="number">3</span>;      <span class="comment">//没问题，因为只是修改了变量内部的属性，和Java中final常量差不多啦</span></span><br></pre></td></tr></table></figure><h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><p>参见JS/ES中函数的定义。</p><h1 id="import"><a href="#import" class="headerlink" title="import"></a>import</h1><p>和export关键字一起，构成了ES6标准中模块化编程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Table, Badge, Button, Modal, Divider &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br></pre></td></tr></table></figure><h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><p>参见JS/ES中类编程。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS/ES中的数据类型</title>
      <link href="/2018/07/08/JS-ES%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/07/08/JS-ES%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Javascript中数据类型"><a href="#Javascript中数据类型" class="headerlink" title="Javascript中数据类型"></a>Javascript中数据类型</h1><p>Javascript是弱类型的语言，也就是Javascript中定义变量时，不会显式地指明一个变量的数据类型。例如<code>var aa=3</code>。JavaScript的数据类型分为两类：</p><ul><li>一类是原始类型或基础数据类型</li><li>一类是对象类型。</li></ul><h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><p>Javascript中的基础数据类型有：number、string、boolean、null、undefined五种。</p><h1 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h1><p>Javascript对象类型是属性的集合。对象类型具体又有好多种，例如function、Array、Date、正则、Error、{x:2, y:4}等等。</p><p>（1）对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    topic: <span class="string">"JavaScript"</span>,</span><br><span class="line">    fat: ture</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以通过<code>.</code>或<code>[]</code>来访问对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book.topic;</span><br><span class="line">book[<span class="string">"fata"</span>];</span><br></pre></td></tr></table></figure><p>（2）数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br></pre></td></tr></table></figure><p>同样可以通过<code>.</code>或<code>[]</code>来访问数组元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primes[<span class="number">0</span>];</span><br><span class="line">primes.length;</span><br></pre></td></tr></table></figure><p>（3）function</p><p>（4）…..</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript语言基本介绍</title>
      <link href="/2018/07/08/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/07/08/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript的语言简介"><a href="#JavaScript的语言简介" class="headerlink" title="JavaScript的语言简介"></a>JavaScript的语言简介</h1><p>JavaScript是一门动态、弱类型的编程语言，JavaScript的编程风格具体面向对象和函数式编程的特点。JavaScript的语法源自Java；一等函数来自于Scheme；基于原型的继承来自于Self。</p><h1 id="JavaScript的运行环境"><a href="#JavaScript的运行环境" class="headerlink" title="JavaScript的运行环境"></a>JavaScript的运行环境</h1><p>JavaScript可以在浏览器中执行，也可以使用chrome V8引擎的nodejs那样执行。我们最熟悉的是在浏览器中执行JavaScript代码，但是一定要注意在浏览器的执行上下文中，浏览器提供了很多的api，例如表示浏览器窗口的window对象，表示web页面的document对象。</p><h1 id="JavaScript中的基础词法规则"><a href="#JavaScript中的基础词法规则" class="headerlink" title="JavaScript中的基础词法规则"></a>JavaScript中的基础词法规则</h1><p>（1）JavaScript中的标识符是区分大小写</p><p>（2）JavaScript的语句分割符</p><p>JavaScript中可以使用分号(;)来分割不同的语句，当然也可以省略。如果在书写JavaScript代码时，省略了分号，那么JavaScript在解释执行时，会在何时的地方添加上分号；但是在不需要分隔符的换行上，JavaScript解释器就不会加上分号，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"this is mydemo program.."</span>);</span><br></pre></td></tr></table></figure><p>可以等价写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span></span><br><span class="line">.log(<span class="string">"this is my demo program.."</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，JavaScript就不会在console后面加上分号。</p><p>（3）JavaScript的注释写法</p><p>注释有两种方式：</p><ul><li>使用<code>//</code>来单行注释</li><li>使用<code>/* ... */</code>来多行注释</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text 3的安装和使用</title>
      <link href="/2018/07/07/Sublime-Text-3%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/07/Sublime-Text-3%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Sublime-Text3的安装"><a href="#Sublime-Text3的安装" class="headerlink" title="Sublime Text3的安装"></a>Sublime Text3的安装</h1><p>（1）安装Sublime Text 3</p><p>官网<code>http://www.sublimetext.com/3</code>下载最新的程序包，然后解压即可使用。</p><p>（2）安装Package Control</p><p>Sublime Text编辑器支持很多插件，安装创建有两种方式：一种是直接安装，先下载安装包解压缩到Sublime Text的Packages目录，然后在<code>preferences | Browse Packages</code>中选择插件即可。另一种是通过Package Control来在线安装插件，我们要使用Package Control就需要先安装Package Control。</p><p>打开ST3，点击菜单<code>View | Show Console</code>，会在底部出现一个命令输入框，然后将下面的命令拷贝到输入框中，回车，等待，安装成功。命令如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os,hashlib; h = <span class="string">'6f4c264a24d933ce70df5dedcf1dcaee'</span> + <span class="string">'ebe013ee18cced0ef93d5f746d80ef60'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="string">'http://packagecontrol.io/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> open(os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by)</span><br></pre></td></tr></table></figure><p>安装方法官方指导：<a href="https://sublime.wbond.net/installation" target="_blank" rel="noopener">https://sublime.wbond.net/installation</a></p><p>（3）安装支持中文编码的插件ConvertToUTF8</p><p>ConvertToUTF8是支持GBK，BIG5，EUC-KR，EUC-JP，Shift_JIS等编码的插件。使用<code>Ctrl+Shift+P</code>打开PackageControl，然后输入Install Package安装插件窗口，然后输入ConvertToUTF8即可安装。</p><p>备注：其他的插件的安装方法也是类似的。</p><h1 id="Sublime-Text3中一些常用的快捷键"><a href="#Sublime-Text3中一些常用的快捷键" class="headerlink" title="Sublime Text3中一些常用的快捷键"></a>Sublime Text3中一些常用的快捷键</h1><p>（1）Ctrl+Shift+P</p><p>用来打开PackageControl，然后输入Install Package，既可以选择安装自己需要的插件。</p><p>（2）Ctrl+P</p><p>根据文件名来快速查找文件。</p><p>（3）Ctrl+R</p><p>在源文件中查找定位方法。</p><p>（4）Ctrl+D</p><p>可以多出编译同一个变量等。</p><p>（5）Ctrl+F</p><p>在源文件中查找指定的关键词。</p><p>（6）F12</p><p>代码跳转快捷键，非常好用。</p><p>（7）F11</p><p>全屏沉浸式编码。</p><h1 id="Sublime-Text3中一些其他的技巧"><a href="#Sublime-Text3中一些其他的技巧" class="headerlink" title="Sublime Text3中一些其他的技巧"></a>Sublime Text3中一些其他的技巧</h1><p>（1）语法提示</p><p>在View菜单中选择Syntax中为源文件指定语言类型，就会有语法提示和语法高亮效果。当语法提示出备选目标时，移动到目标位置，然后输入Tab键选中。</p><p>（2）在Sublime Text中出创建工程Project</p><ul><li>打开一个新的Sublime Text</li><li>选择<code>Project | Add Folder to Project</code>，将我们的项目文件加加入工程中</li><li>选择<code>Project | Save Project As…</code>，将工程保存下来</li><li>选择<code>Project | Close Project</code>关闭工程，然后重复ABC可以创建其他的工程</li></ul><p>之后我们就可以直接打开这些Project来进行工作，选择<code>Project | Quick Swith Project…</code>来切换工程Project。</p><p>（3）为Sublime Text3设置隐藏文件</p><p>选择<code>Preferences | Settings</code>，然后在Preferences.subline-settings-User中添加如下的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;file_exclude_patterns&quot;:</span><br><span class="line">[</span><br><span class="line">    &quot;.*.sw*&quot;,</span><br><span class="line">    &quot;.*.un~&quot;,</span><br><span class="line">    &quot;*.pyc&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>上述表示过滤了三种特殊的文件格式，这样的文件将不会显示到Sublime Text左边的目录树中。</p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中free命令详解</title>
      <link href="/2018/06/11/Linux%E4%B8%ADfree%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/06/11/Linux%E4%B8%ADfree%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h1><p>下面是free的运行结果，一共有4行。为了方便说明，我加上了列号。这样可以把free的输出看成一个二维数组FO(Free Output)。例如：</p><pre><code>                   1          2          3         4         5          61              total       used       free    shared   buffers     cached2 Mem:      24677460   23276064    1401396         0    870540   120840083 -/+ buffers/cache:   10321516   143559444 Swap:     25151484     224188   24927296</code></pre><p>通过二维数组的定义，我们可以很容易的得出：</p><pre><code>FO[2][1] = 24677460FO[3][2] = 10321516</code></pre><p>free的输出一共有四行，第四行为交换区的信息（就是虚拟内存，所占用的空间是物理磁盘），分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free），这个比较清楚，不说太多。</p><p>free输出地第二行和第三行是比较让人迷惑的。这两行都是说明内存使用情况的。第一列是总量（total），第二列是使用量（used），第三列是可用量（free）。</p><p>第一行的输出是从操作系统（OS）来看的。也就是说，从OS的角度来看，计算机上一共有:</p><pre><code>24677460KB（缺省时free的单位为KB）物理内存，即FO[2][1]；在这些物理内存中有23276064KB（即FO[2][2]）被使用了；还用1401396KB（即FO[2][3]）是可用的；</code></pre><p>这里得到第一个等式：</p><pre><code>FO[2][1] = FO[2][2] + FO[2][3]</code></pre><p>FO[2][4]表示被几个进程共享的内存的，现在已经deprecated，其值总是0（当然在一些系统上也可能不是0，主要取决于free命令是怎么实现的）。</p><p>FO[2][5]表示被OS buffer住的内存。FO[2][6]表示被OS cache的内存。在有些时候buffer和cache这两个词经常混用。不过在一些比较低层的软件里是要区分这两个词的，看老外的洋文:</p><pre><code>A buffer is something that has yet to be &quot;written&quot; to disk. A cache is something that has been &quot;read&quot; from the disk and stored for later use.</code></pre><p>也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据（就是os会将经常使用的数据先从磁盘上读取到内存上）。这二者是为了提高IO性能的，并由OS管理。</p><p>Linux和其他成熟的操作系统（例如windows），为了提高IO read的性能，总是要多cache一些数据，这也就是为什么FO[2][6]（cached memory）比较大，而FO[2][3]比较小的原因。</p><p>free输出的第二行是从一个应用程序的角度看系统内存的使用情况。</p><pre><code>对于FO[3][2]，即-buffers/cache，表示一个应用程序认为系统被用掉多少内存；对于FO[3][3]，即+buffers/cache，表示一个应用程序认为系统还有多少内存可以使用；</code></pre><p>因为被系统cache和buffer占用的内存可以被快速回收，所以通常FO[3][3]比FO[2][3]会大很多。</p><p>这里还用两个等式：</p><pre><code>FO[3][2] = FO[2][2] - FO[2][5] - FO[2][6]FO[3][3] = FO[2][3] + FO[2][5] + FO[2][6]（很重要）</code></pre><p>free命令的所有输出值都是从<code>/proc/meminfo</code>中读出的。</p><p>备注：使用free时，默认的单位是KB，我们可以使用如下选项来改变数值的单位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-b   #数值单位是B</span><br><span class="line">-k   #数值单位是KB</span><br><span class="line">-m   #数值单位是MB</span><br><span class="line">-g   #数值单位是GB</span><br></pre></td></tr></table></figure><h1 id="linux平台释放buffer-cache内存资源"><a href="#linux平台释放buffer-cache内存资源" class="headerlink" title="linux平台释放buffer/cache内存资源"></a>linux平台释放buffer/cache内存资源</h1><p>（1）释放buffer占用资源</p><p>执行<code>sync</code>命令，释放buffer占用的内存。sync命令将所有未写的系统缓冲区写到磁盘中，包含已修改的 i-node、已延迟的块I/O和读写映射文件。</p><p>（2）释放cache占用资源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches  <span class="comment">#释放pagecache占用空间</span></span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches  <span class="comment">#释放dentries和inodes占用空间</span></span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches  <span class="comment">#释放pagecache、dentries和inodes占用空间</span></span><br></pre></td></tr></table></figure><h1 id="关于cache的一点补充"><a href="#关于cache的一点补充" class="headerlink" title="关于cache的一点补充"></a>关于cache的一点补充</h1><p>在实际的机器运维中，我们可能会看到某台服务器的cache占用很高，一般来说没有什么大问题。但是如果我们想弄清楚到底是哪个程序把cache弄的那么高，这并不是一件非常容易的事。不过可以借助一些第三方的工具来达到这个目的。</p><p>学习资料参考于：<br><a href="http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html" target="_blank" rel="noopener">http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html</a><br><a href="http://colobu.com/2017/03/07/what-is-in-linux-cached/" target="_blank" rel="noopener">http://colobu.com/2017/03/07/what-is-in-linux-cached/</a><br><a href="http://www.linuxfly.org/post/320/" target="_blank" rel="noopener">http://www.linuxfly.org/post/320/</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中equals | hashCode | toString简介和使用</title>
      <link href="/2018/06/06/JAVA%E4%B8%ADequals-hashCode-toString%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/06/JAVA%E4%B8%ADequals-hashCode-toString%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA中equals-hashCode-toString方法简介"><a href="#JAVA中equals-hashCode-toString方法简介" class="headerlink" title="JAVA中equals | hashCode | toString方法简介"></a>JAVA中equals | hashCode | toString方法简介</h1><p>在<code>java.lang.Object</code>类中有<code>equals</code>、<code>hashCode</code>和<code>toString</code>这些基础的方法。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h1><p><code>equals()</code>方法用来判断两个对象是否“相等”，在<code>Object</code>中<code>equals()</code>方法中是判断两个对象的引用地址是否相等。若开发者在自定义类中根据具体需求覆写了<code>equals()</code>方法，那就会是另外的比较策略了，例如，String类中就重写了<code>equals()</code>方法，重写后的<code>equals()</code>方法用来判断两个字符串的内容是否相等。</p><p>另外，Math、Integer、Double等这些类都是重写了Object类的equals()方法的，都进行的是内容的比较。</p><p>总之，不管是否覆写了<code>equal()</code>方法，<code>equal()</code>目的就是用来判断两个对象是否“<strong>相等/相同</strong>”。</p><p>补充：对于基本数据类型，<code>==</code>比较的是两个变量的值是不是相等；而对于抽象数据类型，<code>==</code>比较的是两个变量的引用是否相等，即变量在内存中的地址是否相等。</p><h1 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h1><p><code>hashCode()</code>方法返回该对象的哈希码值。Object的<code>hashCode()</code>方法是本地方法，也就是用C/C++语言实现的，该方法通常用来将对象的内存地址转换为整数之后返回。在Java中，<code>hashCode()</code>方法的主要作用是为了配合基于散列/哈希的集合类使用，这样的散列集合包括HashSet、HashMap以及HashTable，用来快速判断两个对象是否相等/相同。</p><p>要想了解hashcode()，要和equal()放在一起学习。在Java中，不管一个类是否覆写了<code>hashcode()</code>和<code>equal()</code>，要遵循如下规则：</p><p>（1）经过<code>equal()</code>判断相等的两个对象，必须二者的<code>hashcode()</code>是一样的。</p><p>（2）若两个对象的<code>hashcode()</code>不一样，两个对象通过<code>equal()</code>比较也一定不相等</p><p>（3）若两个对象的<code>hashcode()</code>一样，但是不能保证两个对象通过<code>equal()</code>比较也一定相等，因为存在哈希函数冲突碰撞</p><p>一定要注意的是，在重写了某个类的<code>equal()</code>方法后，也一定需要重写该类的<code>hashcode()</code>方法，保证满足上面的原则，不然该类的对象在用到一些基于散列的集合类就会出现问题。</p><p>拿HashSet来说，Set中不能存储相等的元素。当往集合中增加一个对象时，HastSet对象先要判断该对象是否已经存在于集合中了，若存在就不添加了，若不存在才需要添加。对于这个判断是否集合中已经有相等的元素了，如果都用<code>equal()</code>来判断，若集合中的对象数量多，那效率会非常低。这时<code>hashcode()</code>就派上用场了，先比较<code>hashcode()</code>，若在哈希表中Hash到的位置没有元素，那HashSet中一定没有相等的对象，直接插入即可，若在哈希表中Hash到的位置已经有元素了，即有冲突了，说明可能存在相等的元素，这时再拿<code>equal()</code>来比较一下，若相等不插入，若不相等再插入。整个过程就大大降低了执行<code>equal()</code>的次数。</p><h1 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h1><p><code>toString()</code>方法返回该对象的字符串表示。通常<code>toString</code>方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。开发者可以根据实际需求覆写该方法。</p><p>Object类的<code>toString()</code>方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at标记符<code>&quot;@&quot;</code>和此对象哈希码的无符号十六进制表示组成。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA设计模式之代理模式</title>
      <link href="/2018/06/06/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/06/06/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="代理模式定义"><a href="#代理模式定义" class="headerlink" title="代理模式定义"></a>代理模式定义</h1><p>为被代理对象提供一种代理，以控制对这个对象的访问。使用代理模式，可以对某些类进行增强或扩展的功能，Spring AOP实现的核心基础就是代理模式的运用。</p><h1 id="Java中代理模式的实现"><a href="#Java中代理模式的实现" class="headerlink" title="Java中代理模式的实现"></a>Java中代理模式的实现</h1><p>在Java中，有静态代理和动态代理两种，所谓静态代理，就是代理类在源码阶段或编译阶段是确定的。而动态代理，代理类在源码或编译阶段是不存在的，在程序运行中动态生成的。需要注意的是，动态代理的实现有很多种方式，如JDK动态代理、CGLIB动态代理等等。</p><h1 id="Java静态代理"><a href="#Java静态代理" class="headerlink" title="Java静态代理"></a>Java静态代理</h1><p>代理和被代理对象在代理之前是确定的，它们都实现相同的接口或继承相同的抽象类。</p><p><img src="/images/design_pattern_1_1.png" alt></p><p>下面以代码举例来说明静态代理的使用：</p><p>（1）定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Moveable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）定义被代理类，被代理类要实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bike.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"自行车骑行中..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）定义代理类，代理类也要实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BikeProxy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BikeProxy</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Bike bike;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BikeProxy</span><span class="params">(Bike bike)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.bike = bike;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bike静态代理类增强/扩展逻辑开始..."</span>);</span><br><span class="line">        bike.move();</span><br><span class="line">        System.out.println(<span class="string">"Bike静态代理类增强/扩展逻辑结束..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）测试代理类的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bike bike = <span class="keyword">new</span> Bike();</span><br><span class="line">        BikeProxy bikeProxy = <span class="keyword">new</span> BikeProxy(bike);</span><br><span class="line">        bikeProxy.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果如下：</p><pre><code>Bike静态代理类增强/扩展逻辑开始...自行车骑行中...Bike静态代理类增强/扩展逻辑结束...</code></pre><h1 id="Java-JDK动态代理"><a href="#Java-JDK动态代理" class="headerlink" title="Java JDK动态代理"></a>Java JDK动态代理</h1><p>通过静态代理的代码可以发现每一个代理类只能为一个接口服务，这样一来程序开发中必然会产生过多的代理。如果可以在程序运行中能够动态地生成代理类那就极好了。呵呵，JDK动态代理就可以达到这个目的。动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码，代理类也会实现该接口。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java反射机制可以生成任意类型的动态代理类。<code>java.lang.reflect</code>包中的<code>Proxy</code>类和<code>InvocationHandler</code>接口提供了生成动态代理类的能力。</p><p><img src="/images/design_pattern_1_2.png" alt></p><p>下面用代码来演示JDK动态代理的使用：</p><p>（1）定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Moveable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）定义被代理类，被代理类要实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bike.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"自行车骑行中..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）定义实现了java.lang.reflect.InvocationHandler接口的InvocationHandler类</p><p><code>InvocationHandler</code>接口实现类中，要实现<code>invoke()</code>方法，该方法中需要通过反射调用被代理类的方法，以及加入一些增强/扩展逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyInvocationHandler.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;   <span class="comment">// target是被代理类的实例对象</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bike JDK动态代理类增强/扩展逻辑开始..."</span>);</span><br><span class="line">        method.invoke(target, args); <span class="comment">//调用被代理类的方法</span></span><br><span class="line">        System.out.println(<span class="string">"Bike JDK动态代理类增强/扩展逻辑结束..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：<code>invoke</code>方法中有三个参数，<code>proxy</code>是代理类的实例对象，<code>method</code>是被代理类的方法，<code>args</code>是被代理类的方法参数。</p><p>（4）使用Proxy.newProxyInstance动态生成代理类对象，并测试使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bike bike = <span class="keyword">new</span> Bike();</span><br><span class="line">        InvocationHandler hander = <span class="keyword">new</span> MyInvocationHandler(bike);</span><br><span class="line">        <span class="comment">// 生成代理类对象</span></span><br><span class="line">        Moveable m = (Moveable) Proxy.newProxyInstance(bike.getClass().getClassLoader(),</span><br><span class="line">                bike.getClass().getInterfaces(), hander);</span><br><span class="line">        <span class="comment">// Moveable m = (Moveable) Proxy.newProxyInstance(Bike.class.getClassLoader(),</span></span><br><span class="line">        <span class="comment">// Bike.class.getInterfaces(), hander);</span></span><br><span class="line">        m.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：<code>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>的有三个参数，<code>loader</code>是被代理类的类加载器，<code>interfaces</code>是被代理类实现的接口，<code>h</code>是<code>InvocationHandler</code>实现类的实例对象。</p><p>程序输出结果如下：</p><pre><code>Bike JDK动态代理类增强/扩展逻辑开始...自行车骑行中...Bike JDK动态代理类增强/扩展逻辑结束...</code></pre><h1 id="Java-CGLIB动态代理"><a href="#Java-CGLIB动态代理" class="headerlink" title="Java CGLIB动态代理"></a>Java CGLIB动态代理</h1><p>JDK动态代理的前提条件是被代理类实现了某些接口，若被代理类没有实现任何接口，则不能使用JDK动态代理哦。</p><p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。</p><p>CGLIB原理是动态生成一个被代理类的子类，子类重写被代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用Java反射的JDK动态代理要快。</p><p>CGLIB底层使用字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。CGLIB缺点是对于final方法，无法进行代理。</p><p>CGLIB广泛地被许多AOP的框架使用，例如Spring AOP和dynaop。Hibernate使用CGLIB来代理单端single-ended（多对一和一对一）关联。</p><p>下面用代码实例来说明CGLIB动态代理的使用：</p><p>（1）引入CGLIB的JAR包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>（2）定义被代理类，被代理类可以不实现任何接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WarPlane.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarPlane</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"战斗机巡航中..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）定义被代理类的方法拦截器，需要实现net.sf.cglib.proxy.MethodInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method m, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WarPlane CGLIB动态代理类增强/扩展逻辑开始..."</span>);</span><br><span class="line">        proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">"WarPlane CGLIB动态代理类增强/扩展逻辑结束..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：<code>MyMethodInterceptor</code>有点类似于JDK动态代理中<code>MyInvocationHandler</code>类，<code>MethodInterceptor</code>接口中<code>intercept(Object obj, Method m, Object[] args, MethodProxy proxy)</code>方法有四个参数，<code>obj</code>是被代理类的实例，<code>m</code>是被代理类的方法，<code>args</code>被代理类的方法参数，<code>proxy</code>是代理类的实例。</p><p>（4）生成代理类并测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test.java</span></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(WarPlane<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MyMethodInterceptor());</span><br><span class="line">        WarPlane wp = (WarPlane) enhancer.create();  <span class="comment">//生成代理类对象</span></span><br><span class="line">        wp.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果为：</p><pre><code>WarPlane CGLIB动态代理类增强/扩展逻辑开始...战斗机巡航中...WarPlane CGLIB动态代理类增强/扩展逻辑结束...</code></pre><p>学习资料参考于：<br><a href="http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html" target="_blank" rel="noopener">http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html</a><br><a href="http://www.runoob.com/design-pattern/proxy-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/proxy-pattern.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Design Pattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA的序列化与反序列化机制</title>
      <link href="/2018/06/04/JAVA%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/06/04/JAVA%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA的序列化与反序列化机制"><a href="#JAVA的序列化与反序列化机制" class="headerlink" title="JAVA的序列化与反序列化机制"></a>JAVA的序列化与反序列化机制</h1><p>Java提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。整个过程都是Java虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p><p>在JAVA中，一个对象要想被序列化和反序列化，则必须满足两个条件：</p><ul><li>该类必须实现java.io.Serializable接口。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂（transient）的。</li></ul><h1 id="ObjectInputStream与ObjectOutputStream"><a href="#ObjectInputStream与ObjectOutputStream" class="headerlink" title="ObjectInputStream与ObjectOutputStream"></a>ObjectInputStream与ObjectOutputStream</h1><p>类<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>是高层次的数据流，它们包含反序列化和序列化对象的方法。<code>ObjectOutputStream</code>类用来序列化一个对象，即将一个对象序列化到一个文件中。需要注意的是，当序列化一个对象到文件时， 按照Java的标准约定，被序列化对象的文件的扩展名为<code>.ser</code>。</p><h1 id="序列化机制中serialVersionUID作用"><a href="#序列化机制中serialVersionUID作用" class="headerlink" title="序列化机制中serialVersionUID作用"></a>序列化机制中serialVersionUID作用</h1><p>在进行对象序列号之前，我们需要在对象中增加一个<code>serialVersionUID</code>属性，因为Java的序列化机制是通过在运行时判断类的<code>serialVersionUID</code>来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的<code>serialVersionUID</code>与本地相应实体（类）的<code>serialVersionUID</code>进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p><p>一般来说，定义serialVersionUID的方式有两种，分别为：</p><p>（1）采用默认的<code>1L</code>，具体为<code>private static final long serialVersionUID = 1L;</code></p><p>（2）根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，例如<code>private static final long serialVersionUID = XXXL;</code></p><p>当你一个类实现了<code>Serializable</code>接口，如果没有显式地定义<code>serialVersionUID</code>，Eclipse会发出警告，告诉开发者去定义<code>serialVersionUID</code>属性 。在Eclipse中点击类中warning的图标一下，Eclipse就会自动给定两种生成的方式。如果不想定义它，在Eclipse的设置中关掉该特性。</p><p>当实现<code>java.io.Serializable</code>接口的实体（类）没有显式地定义一个名为<code>serialVersionUID</code>的long型的变量，Java序列化机制会根据编译的class（它通过类名，方法名等诸多因素经过计算而得，理论上是一一映射的关系，也就是唯一的）自动生成一个<code>serialVersionUID</code>作为序列化版本比较用。这种情况下，如果class文件（类名，方法明等）没有发生变化（增加空格、换行或增加注释等等），就算再编译多少次，<code>serialVersionUID</code>也是不会变化的。</p><h1 id="Java中对象的序列化和反序列化的代码范例"><a href="#Java中对象的序列化和反序列化的代码范例" class="headerlink" title="Java中对象的序列化和反序列化的代码范例"></a>Java中对象的序列化和反序列化的代码范例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bat.testmaven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> SSN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mailing a check to "</span> + name + <span class="string">" "</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDeserializeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        doSerializeObject();    <span class="comment">//执行序列化操作</span></span><br><span class="line">        doDeserializeObject();  <span class="comment">//执行反序列化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Employee对象序列化到D:\\workbench\\employee.ser文件中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSerializeObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">        e.name = <span class="string">"laotansuancai"</span>;</span><br><span class="line">        e.address = <span class="string">"Beijing, China"</span>;</span><br><span class="line">        e.SSN = <span class="number">213219</span>;</span><br><span class="line">        e.number = <span class="number">7304</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\workbench\\employee.ser"</span>);</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">            out.writeObject(e);</span><br><span class="line">            out.close();</span><br><span class="line">            fileOut.close();</span><br><span class="line">            System.out.printf(<span class="string">"Serialized data is saved in D:\\workbench\\employee.ser"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException i) &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将D:\\workbench\\employee.ser文件中对象进行反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doDeserializeObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\workbench\\employee.ser"</span>);</span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">            e = (Employee) in.readObject();</span><br><span class="line">            in.close();</span><br><span class="line">            fileIn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException i) &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException c) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Employee class not found"</span>);</span><br><span class="line">            c.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Deserialized Employee..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Name: "</span> + e.name);</span><br><span class="line">        System.out.println(<span class="string">"Address: "</span> + e.address);</span><br><span class="line">        System.out.println(<span class="string">"SSN: "</span> + e.SSN);</span><br><span class="line">        System.out.println(<span class="string">"Number: "</span> + e.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：当对象被序列化时，属性SSN的值为213219，但是因为该属性是短暂的（transient），该值没有被发送到输出流。所以反序列化后Employee对象的SSN属性为0。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中域名正解反解工具命令host | nslookup | dig | whois简介和使用</title>
      <link href="/2018/06/04/Linux%E4%B8%AD%E5%9F%9F%E5%90%8D%E6%AD%A3%E8%A7%A3%E5%8F%8D%E8%A7%A3%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4host-nslookup-dig-whois%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/04/Linux%E4%B8%AD%E5%9F%9F%E5%90%8D%E6%AD%A3%E8%A7%A3%E5%8F%8D%E8%A7%A3%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4host-nslookup-dig-whois%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="DNS正解反解客户端工具"><a href="#DNS正解反解客户端工具" class="headerlink" title="DNS正解反解客户端工具"></a>DNS正解反解客户端工具</h1><p>在Linux中与域名解析和反解的命令主要有下面三个：</p><ul><li>host</li><li>nslookup</li><li>dig</li></ul><h1 id="host工具"><a href="#host工具" class="headerlink" title="host工具"></a>host工具</h1><p>（1）命令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host [option] domain [server]</span><br></pre></td></tr></table></figure><p>其中的domain为要解析的域名，server为指定向哪个DNS服务器发起DNS解析请求。</p><p>常用的选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a    #显示详细信息</span><br></pre></td></tr></table></figure><p>（2）使用举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析域名</span></span><br><span class="line">host www.sina.com</span><br><span class="line"><span class="comment"># 不使用/etc/resolv.conf默认的DNS服务器，指定一个特定的DNS发起请求</span></span><br><span class="line">host www.sina.com 211.161.46.84  <span class="comment">#向211.161.46.84 DNS服务器发起域名www.sina.com的解析请求</span></span><br><span class="line"><span class="comment"># ip反解析域名</span></span><br><span class="line">host 202.108.33.60</span><br></pre></td></tr></table></figure><h1 id="nslookup工具"><a href="#nslookup工具" class="headerlink" title="nslookup工具"></a>nslookup工具</h1><p>nslookup支持交互式和非交互式两种查询。当直接在命令提示符后输入nslookup命令时，就进入了nslookup的交互式操作。否则直接返回给用户解析结果。</p><p>（1）命令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup [option] hostname</span><br></pre></td></tr></table></figure><p>常用的选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-query=type #type可以是mx、cname以及mx等等，可以查询指定类型的DNS记录</span><br></pre></td></tr></table></figure><p>（2）使用举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析域名</span></span><br><span class="line">nslookup www.sina.com</span><br><span class="line"><span class="comment"># ip反解析域名</span></span><br><span class="line">nslookup 202.108.33.60</span><br></pre></td></tr></table></figure><h1 id="dig工具"><a href="#dig工具" class="headerlink" title="dig工具"></a>dig工具</h1><p>dig是比nslookup和host更强大的DNS查询工具。</p><p>（1）命令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig [options] domain [@server]</span><br></pre></td></tr></table></figure><p>其中<code>@server</code>表示不使用<code>/etc/resolv.conf</code>默认的DNS服务器，指定一个特定的DNS发起请求。</p><p>重要的选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+trace  #输出域名解析过程中详细的debug信息</span><br><span class="line">-t type #制定查询的DNS记录类型，例如A记录、CNAME记录以及NS记录等等</span><br><span class="line">-x      #从ip反解析域名</span><br><span class="line">+short  #精简地输出dig结果</span><br><span class="line">+subnet ip/submask  #向dns服务器传递客户端所属的网络地址</span><br></pre></td></tr></table></figure><p>（2）使用举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析域名</span></span><br><span class="line">dig www.sina.com</span><br><span class="line"><span class="comment"># 不使用/etc/resolv.conf默认的DNS服务器，指定一个特定的DNS发起请求</span></span><br><span class="line">dig www.sina.com @211.161.46.84  <span class="comment">#向211.161.46.84 DNS服务器发起域名www.sina.com的解析请求</span></span><br><span class="line"><span class="comment"># 查询域名的SOA记录相关信息</span></span><br><span class="line">dig -t soa www.sina.com</span><br><span class="line"><span class="comment"># 查询某个域的NS服务器</span></span><br><span class="line">dig -t ns baidu.com</span><br><span class="line"><span class="comment"># ip反解析域名</span></span><br><span class="line">dig -x 202.108.33.60</span><br></pre></td></tr></table></figure><p>如下为一个关于edns的一个用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig www.zhxfei.com @172.16.130.129 +subnet=120.0.0.1/24</span><br></pre></td></tr></table></figure><p>如上命令中，dig工具需要安装支持edns的版本，<code>+subnet</code>指定客户端所属的子网，<code>@server</code>指定Local DNS，假设172.16.130.129支持了edns，那么她会依照+subnet来解析出一个离客户端比较近的IP，而不是根据Local DNS来解析出较近的IP。这种情况下，DNS的GLSB负载均衡将会更准确。</p><p>备注：<br><code>dig domainname +trace</code>表示从本机开始迭代查询，即从根域开始查，每次迭代查询结果直接返回给本机，然后本机再继续进行下一步迭代查询。<code>dig domainname</code>不加trace时，那么本机是直接向local DNS发起请求（本机和local DNS是递归查询），然后local DNS再去迭代查询并将最终的结果返回给本机。因此，+trace时，若本机访问不了公网，那么就dig不出外网的域名，因为本机与公网上dns根本连接不了。若不加trace，那么就和本机有没有公网连接就没有关系，只要local DNS能够查询到结果就会返回给本机了。</p><h1 id="whois命令"><a href="#whois命令" class="headerlink" title="whois命令"></a>whois命令</h1><p>我们可以使用whois可以查询一个域名的一些注册信息，包括域名是谁注册的，什么时候注册的，什么时候过期失效，注册该域名的人或组织的联络方式等等。</p><p>whois常见使用举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whois domainname <span class="comment">#查看某个域名的注册信息</span></span><br><span class="line">whois ip         <span class="comment">#查看某个IP所属地区及运营商等</span></span><br></pre></td></tr></table></figure><h1 id="闲杂"><a href="#闲杂" class="headerlink" title="闲杂"></a>闲杂</h1><p>nslookup和dig工具的安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install <span class="built_in">bind</span>-utils         <span class="comment">#RedHat系</span></span><br><span class="line">sudo apt-get install dnsutils  <span class="comment">#Debian系</span></span><br></pre></td></tr></table></figure><p>注意host|nslookup|dig是和域名解析相关的，与traceroute等不同哦。</p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS胶水记录glue record说明</title>
      <link href="/2018/06/04/DNS%E8%83%B6%E6%B0%B4%E8%AE%B0%E5%BD%95glue-record%E8%AF%B4%E6%98%8E/"/>
      <url>/2018/06/04/DNS%E8%83%B6%E6%B0%B4%E8%AE%B0%E5%BD%95glue-record%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="DNS胶水记录举例说明"><a href="#DNS胶水记录举例说明" class="headerlink" title="DNS胶水记录举例说明"></a>DNS胶水记录举例说明</h1><p>假设我们有一个域名<code>example.com</code>，同时搭建了DNS服务，有2台机器，即<code>ns1.example.com</code>和<code>ns2.example.com</code>。如果让互联网上的网民能够解析到<code>*.example.com</code>的域名，我们需要在<code>.com</code>的域名服务器上添加如下记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">example.com NS ns1.example.com</span><br><span class="line">example.com NS ns2.example.com</span><br><span class="line"></span><br><span class="line">ns1.example.com A 192.0.2.10</span><br><span class="line">ns2.example.com A 192.0.2.20</span><br></pre></td></tr></table></figure><p>备注：如果不提供上面DNS服务器的A记录的话，域名解析时就会出现死循环。即<code>.com</code>的DNS告诉需要到<code>ns1~ns2.example.com</code>上去解析<code>example.com</code>的域名。然后用户询问<code>ns1~ns2.example.com</code>的ip，当请求达到<code>.com</code>的DNS时，又会被告知到<code>ns1~ns2.example.com</code>上去查询。</p><h1 id="关于胶水记录的实际应用中注意点"><a href="#关于胶水记录的实际应用中注意点" class="headerlink" title="关于胶水记录的实际应用中注意点"></a>关于胶水记录的实际应用中注意点</h1><p>假设我们有域名<code>example.com</code>，之前的DNS为<code>ns1.example.com</code>和<code>ns2.example.com</code>两个，现在新增一个DNS为<code>ns3.example.com</code>，那么我们需要在域名注册商（例如MarkMonitor、万网等）做如下修改：</p><p>（1）host注册</p><p>在域名商的管理控制台上，添加新增DNS的host注册，即<code>ns3.example.com</code>映射到<code>112.*.*.*</code>。</p><p>（2）添加NS记录</p><p>将<code>example.com</code>的DNS域名服务器，修改为<code>ns1.example.com</code>，<code>ns2.example.com</code>和<code>ns3.example.com</code>。</p><p>另外，除了注册商那边做如上修改，我们自己的<code>ns1.example.com</code>，<code>ns2.example.com</code>和<code>ns3.example.com</code>也要做相应地修改，每一个NS的zone file中都需要有如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ NS   ns1.example.com</span><br><span class="line">@ NS   ns2.example.com</span><br><span class="line">@ NS   ns3.example.com</span><br><span class="line">ns1.example.com   A   1.1.1.1</span><br><span class="line">ns2.example.com   A   2.2.2.2</span><br><span class="line">ns3.example.com   A   3.3.3.3</span><br></pre></td></tr></table></figure><p>备注：一定要注意的是，上面的信息如IP地址要和注册商或上层DNS上保持一致，否则可能会出现一些奇奇怪怪的问题。</p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A | CNAME | NS | SOA记录说明和使用</title>
      <link href="/2018/06/04/A-CNAME-NS-SOA%E8%AE%B0%E5%BD%95%E8%AF%B4%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/04/A-CNAME-NS-SOA%E8%AE%B0%E5%BD%95%E8%AF%B4%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="A记录、CNAME记录、NS记录、SOA记录"><a href="#A记录、CNAME记录、NS记录、SOA记录" class="headerlink" title="A记录、CNAME记录、NS记录、SOA记录"></a>A记录、CNAME记录、NS记录、SOA记录</h1><p>无论是A记录还是CNAME记录，还是其他什么记录，都是一个<code>key：value</code>结构，存储在DNS服务器中的一条记录。例如CNAME记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.taobao.com.    CNAME   www.gslb.taobao.com.danuoyi.tbcache.com</span><br></pre></td></tr></table></figure><p>（1）A记录</p><p>比如我们访问域名<code>www.a.com</code>，经过DNS服务解析，最终解析了一个32b IP返回给了网民，网名通过ip获取服务器的访问。这个域名和iP的对应关系就称为A记录。</p><p>（2）CNAME记录</p><p>比如我们访问域名<code>www.a.com</code>时，经过DNS解析，告诉你这个<code>www.a.com</code>其实是<code>www.b.com</code>的一个别名，然后告诉网名直接去解析<code>www.b.com</code>就好了。那么<code>www.a.co</code>m就是<code>www.b.com</code>的一个CNAME，而<code>www.b.com</code>和IP的对应关系就是A记录。</p><p>（3）NS记录</p><p>NS记录是这样的一条记录，key是一个域名或者域名服务器，value是另外一个域名服务器的名称。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sina.com.cn.            5       IN      NS      ns1.sina.com.cn.</span><br></pre></td></tr></table></figure><p>在<code>.com</code>的域名服务器中有上面这条NS记录。表示要查sina域下的域名，得到<code>ns1.sina.com.cn.</code>域名服务器上查询。也可以理解为管理<code>sina.com.cn.</code>这个域的域名服务器是<code>ns1.sina.com.cn.</code>。</p><p>（4）SOA记录</p><p>SOA，Start of Authority，称为起始授权资源记录。如果有多台DNS服务器管理同一个域名，那么最好使用Master/Slave架构来进行搭建。既然采用这样的架构，那就需要声明被管理的zone file是如何进行传输的，此时就需要SOA（Start Of Authority）的标志了。也就是说，在DNS的每个zone file中都会有SOA记录的。下面来举例说明SOA记录的格式及字段含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp.bat.com              IN SOA  ns.cp.bat.com. dnsadmin.sina.com. (</span><br><span class="line">                                180525000 ; serial</span><br><span class="line">                                1800      ; refresh (30 minutes)</span><br><span class="line">                                600       ; retry (10 minutes)</span><br><span class="line">                                1209600   ; expire (2 weeks)</span><br><span class="line">                                60        ; minimum (1 minute)</span><br><span class="line">                                )</span><br></pre></td></tr></table></figure><p>备注：在zone file中，@是保留关键字，代表当前域名的意思。这里最开始的cp.bat.com可以用@符号来代替。</p><p>SOA后面一共有七个参数，下面分别来介绍：</p><ul><li><p>Master DNS服务器的主机名<br>这个字段是用来说明哪台DNS服务器作为Master，在本例中ns.cp.bat.com是Master/Slave架构中的Master服务器。</p></li><li><p>管理员的邮箱地址<br>如果该域名的解析有问题，可以联系该邮箱地址。需要注意的是，@符号在bind中有特殊含义，因此邮箱地址的@符号不能直接写出来，而是用点号来代替。在本例中dnsadmin.sina.com其实相当于<a href="mailto:dnsadmin@sina.com" target="_blank" rel="noopener">dnsadmin@sina.com</a>。</p></li><li><p>序号（Serial）<br>这个序号代表的是该zone file的新旧，序号越大表示越新。当Slave要判断是否主动下载新的zone file时，就以此序号是否比Slave上的还要新来判断，若是则下载，若不是则不下载。所以当我们需要了zone file时，一定要将这个Serial值变大才可以，否则Slave是不会同步下载该zone file的。需要注意的是，序号不可以大于2的32次方，亦即必须小于4294967296才行。</p></li><li><p>更新频率（Refresh）<br>Slave会依据该数值来定期地从Master中下载zone file。在本例中设置的是1800，表示Salve会每隔30分钟就试图向Master获取最新的zone file，若serial数值没有变大，则就不会去更新zone file了。</p></li><li><p>失败重新尝试时间（Retry）<br>如果由于某些因素导致Slave无法对Master实现连接，那么在依据该数值再去尝试连接到Master服务器。在本例中设置的是600，表示Slave连接Master失败，则会尝试每隔10分钟就去重新尝试连接Master，若在某次重试时连接成功，则会再次恢复到Refresh设置的更新频率。</p></li><li><p>失效时间（Expire）<br>如果Slave连接Master一直失败，一直到Expire设置的时间时，那么Slave将不在继续尝试连接，并且尝试删除这个zone file的信息。如本例中设置的1209600，表示连续2week Slave都连不上Master，那么Slave将不再尝试去连接Master，且会删除zone file，也就是在Slave上是解析不了这个域名了，很危险哦。</p></li><li><p>缓存时间（Minumum TTL）<br>如果在zone file中，没有显式的指明TTL时，将会这个TTL设置为主。</p></li></ul><p>备注：当出现如下场景之一时，DNS服务器会返回SOA记录：</p><ul><li>当查询的类型不存在时，会在“AUTHORITY SECTION”返回SOA记录</li><li>当查询的域名不存在时，会在“AUTHORITY SECTION”返回SOA记录</li></ul><h1 id="使用CNAME的场景"><a href="#使用CNAME的场景" class="headerlink" title="使用CNAME的场景"></a>使用CNAME的场景</h1><p>使用别名记录，对于多网站、多域名的人来说，是一个非常方便的管理方法。特别是对租用虚拟主机的用户，更是简单。做一个别名记录后，就不用再去管服务器的IP怎么变了。</p><p>（1）使用域名的别名记录(CNAME)，让多域名管理轻松到极点</p><p>别名记录(CNAME)：也被称为规范名字。这种记录允许您将多个名字映射到同一台计算机。 通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为<code>host.mydomain.com</code>(A记录)。 它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名(CNAME)：WWW和MAIL。 这两个别名的全称就是<code>www.mydomain.com</code>和<code>mail.mydomain.com</code>。实际上他们都指向<code>host.mydomain.com</code>。 同样的方法可以用于当您拥有多个域名需要指向同一服务器IP，此时您就可以将一个域名做A记录指向服务器IP然后将其他的域名做别名到之前做A记录的域名上，那么当您的服务器IP地址变更时您就可以不必麻烦的一个一个域名更改指向了 只需要更改做A记录的那个域名其他做别名的那些域名的指向也将自动更改到新的IP地址上了。如果你是租用虚拟主机的话，一般的服务商都会提供一个三级或者四级的域名给你，那个地址解析的IP永远是服务器的最新IP，所以，大家如果是租用虚拟主机的，就直接做别名记录指向到那个赠送的域名就可以了。</p><p>（2）使用域名的别名记录(CNAME)，让你的域名解析不再蜗牛</p><p>众所周知，国内很多域名注册机构的DNS服务器解析生效速度很慢，这便给很多人带来了麻烦，当网站需要更换IP或其他必须对域名重新解析的时候，如果存在大量网站，第一麻烦就是多域名的解析问题，我们可以通过第一条技巧轻松解决!但对于生效速度，通过普通的解析估计我们就无法解决了。</p><p>其实，我们可以通过使用域名的别名(CNAME)另类使用达到加速解析的目的。首先我们最好选择一个主域名如：qqya.com，将该域名转移到国外(推荐：ENom)注册商平台下，解析速度与国内的注册商可不是一个两个等级的差别了，然后将其他的相关域名使用CNAME记录：(<code>www.abc.com.</code>)切记最后有一英文状态下的“句号”。</p><p>以后当需要更换域名解析的时候，只需要变动<code>abc.com</code>，立即解决了所有问题，因为你其他的域名都已经跟随你的<code>abc.com</code>域名了，只要你解析了<code>abc.com</code>，其他也都相应变化，不再担心国内解析慢的问题了。</p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bind远程管理工具RNDC</title>
      <link href="/2018/06/04/Bind%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7RNDC/"/>
      <url>/2018/06/04/Bind%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7RNDC/</url>
      
        <content type="html"><![CDATA[<h1 id="rndc工具简介"><a href="#rndc工具简介" class="headerlink" title="rndc工具简介"></a>rndc工具简介</h1><p>rndc，英文全称为Remote Name Domain Controllor，是一个远程管理bind的工具，通过这个工具可以在本地或者远程了解当前DNS服务器的运行状况，也可以对DNS服务器进行关闭、重载、刷新缓存、增加删除zone等操作。</p><p>使用rndc可以在不停止DNS服务器工作的情况进行数据的更新，使修改后的配置文件生效。在实际情况下，DNS服务器是非常繁忙的，任何短时间的停顿都会给用户的使用带来影响。因此，使用rndc工具可以使DNS服务器更好地为用户提供服务。在使用rndc管理bind前需要使用rndc生成一对密钥文件，一半保存于rndc的配置文件中，另一半保存于bind主配置文件中。rndc的配置文件为<code>/etc/rndc.conf</code>，在CentOS或者RHEL中，rndc的密钥保存在<code>/etc/rndc.key</code>文件中。rndc默认监听在953号端口（TCP），其实在bind9中rndc默认就是可以使用，不需要配置密钥文件。</p><p>rndc与DNS服务器实行连接时，需要通过数字证书进行认证，而不是传统的username/password方式。在当前版本下，rndc和named都只支持HMAC-MD5认证算法，在通信两端使用预共享密钥。在当前版本的rndc和named中，唯一支持的认证算法是HMAC-MD5，在连接的两端使用共享密钥。它为命令请求和名字服务器的响应提供TSIG类型的认证。所有经由通道发送的命令都必须被一个服务器所知道的key_id签名。为了生成双方都认可的密钥，可以使用rndc-confgen命令产生密钥和相应的配置，再把这些配置分别放入named.conf和rndc的配置文件rndc.conf中。</p><h1 id="rndc的配置"><a href="#rndc的配置" class="headerlink" title="rndc的配置"></a>rndc的配置</h1><p>执行命令<code>rndc-confgen</code>，生成rndc的key，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Start of rndc.conf</span><br><span class="line">key &quot;rndc-key&quot; &#123;</span><br><span class="line">    algorithm hmac-md5;</span><br><span class="line">    secret &quot;P9M+wf6zK47ynypJZiB/uQ==&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">options &#123;</span><br><span class="line">    default-key &quot;rndc-key&quot;;</span><br><span class="line">    default-server 127.0.0.1;</span><br><span class="line">    default-port 953;</span><br><span class="line">&#125;;</span><br><span class="line"># End of rndc.conf</span><br><span class="line"># Use with the following in named.conf, adjusting the allow list as needed:</span><br><span class="line"># key &quot;rndc-key&quot; &#123;</span><br><span class="line">#     algorithm hmac-md5;</span><br><span class="line">#     secret &quot;P9M+wf6zK47ynypJZiB/uQ==&quot;;</span><br><span class="line"># &#125;;</span><br><span class="line">#</span><br><span class="line"># controls &#123;</span><br><span class="line">#     inet 127.0.0.1 port 953</span><br><span class="line">#         allow &#123; 127.0.0.1; &#125; keys &#123; &quot;rndc-key&quot;; &#125;;</span><br><span class="line"># &#125;;</span><br><span class="line"># End of named.conf</span><br></pre></td></tr></table></figure><p>然后新建rndc.conf配置文件，将rndc-confgen生成的如下部分复制到rndc.conf文件中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">key &quot;rndc-key&quot; &#123;</span><br><span class="line">    algorithm hmac-md5;</span><br><span class="line">    secret &quot;P9M+wf6zK47ynypJZiB/uQ==&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">options &#123;</span><br><span class="line">    default-key &quot;rndc-key&quot;;</span><br><span class="line">    default-server 127.0.0.1;</span><br><span class="line">    default-port 953;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再然后新建rndc.key配置文件，将rndc-confgen生成的如下部分复制到rndc.key文件中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key &quot;rndc-key&quot; &#123;</span><br><span class="line">    algorithm hmac-md5;</span><br><span class="line">    secret &quot;P9M+wf6zK47ynypJZiB/uQ==&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">controls &#123;</span><br><span class="line">    inet 127.0.0.1 port 953</span><br><span class="line">        allow &#123; 127.0.0.1; &#125; keys &#123; &quot;rndc-key&quot;; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再然后在named.conf中使用<code>include &quot;/etc/named/rndc.key&quot;;</code>指令将rndc.key的文件内容引入到named.conf中。</p><h1 id="rndc的常用操作命令"><a href="#rndc的常用操作命令" class="headerlink" title="rndc的常用操作命令"></a>rndc的常用操作命令</h1><p>rndc命令的通用操作格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rndc [-c config-file] [-k key-file] [-s server] [-p port] &#123;command&#125;</span><br></pre></td></tr></table></figure><p>其中<code>-c config-file</code>指定rndc的配置文件，若不显式指定，则默认为<code>/etc/rndc.conf</code>。<code>-k key-file</code>执行rndc的eky文件，若不显式指定，则默认为<code>/etc/rndc.key</code>。</p><p>常用的执行的命令command有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">rndc status   <span class="comment">#显示bind服务器的工作状态</span></span><br><span class="line">rndc reload   <span class="comment">#重新加载配置文件和zone file</span></span><br><span class="line">rndc reload zone_name <span class="comment">#重新加载指定zone file</span></span><br><span class="line">rndc reconfig   <span class="comment">#重读配置文件并加载新增的区域</span></span><br><span class="line">rndc querylog   <span class="comment">#关闭或开启查询日志</span></span><br><span class="line">rndc dumpdb     <span class="comment">#将高速缓存转储到转储文件 (named_dump.db)</span></span><br><span class="line">rndc freeze     <span class="comment">#暂停更新所有动态zone</span></span><br><span class="line">rndc freeze zone [class [view]]  <span class="comment">#暂停更新一个动态zone</span></span><br><span class="line">rndc flush [view]    <span class="comment">#刷新服务器的所有高速缓存</span></span><br><span class="line">rndc flushname name  <span class="comment">#为某一视图刷新服务器的高速缓存</span></span><br><span class="line">rndc stats    <span class="comment">#将服务器统计信息写入统计文件中</span></span><br><span class="line">rndc stop     <span class="comment">#将暂挂更新保存到主文件并停止服务器</span></span><br><span class="line">rndc halt     <span class="comment">#停止服务器，但不保存暂挂更新</span></span><br><span class="line">rndc trace    <span class="comment">#打开debug, debug有级别的概念，每执行一次提升一次级别</span></span><br><span class="line">rndc trace LEVEL   <span class="comment">#指定 debug 的级别, trace 0 表示关闭debug</span></span><br><span class="line">rndc notrace       <span class="comment">#将调试级别设置为 0</span></span><br><span class="line">rndc restart       <span class="comment">#重新启动服务器（尚未实现）</span></span><br><span class="line">rndc addzone zone [class [view]] &#123; zone-options &#125; <span class="comment">#增加一个zone</span></span><br><span class="line">rndc delzone zone [class [view]] <span class="comment">#删除一个zone</span></span><br><span class="line">rndc tsig-delete keyname [view]  <span class="comment">#删除一个TSIG key</span></span><br><span class="line">rndc tsig-list      <span class="comment">#查询当前有效的TSIG列表</span></span><br><span class="line">rndc validation newstate [view]  <span class="comment">#开启/关闭dnssec</span></span><br></pre></td></tr></table></figure><p>备注：rndc命令后面可以跟<code>-s</code>和<code>-p</code>选项连接到远程DNS服务器，以便对远程DNS服务器进行管理，但此时双方的密钥要一致才能正常连接。在设置rndc.conf时一定要注意key的名称和预共享密钥一定要和named.conf相同，否则rndc工具无法正常工作。</p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中挂载及mount命令使用</title>
      <link href="/2018/05/30/Linux%E4%B8%AD%E6%8C%82%E8%BD%BD%E5%8F%8Amount%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/05/30/Linux%E4%B8%AD%E6%8C%82%E8%BD%BD%E5%8F%8Amount%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux挂载基本概念"><a href="#Linux挂载基本概念" class="headerlink" title="Linux挂载基本概念"></a>Linux挂载基本概念</h1><p>通常概念的挂载mount的单位是一个文件系统，而非一个分区的，更非一个设备。</p><h1 id="挂载和卸载的常用操作"><a href="#挂载和卸载的常用操作" class="headerlink" title="挂载和卸载的常用操作"></a>挂载和卸载的常用操作</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/hdc6 /mnt/hdc6   <span class="comment">#表示将/dev/hdc6这个文件系统挂载到/mnt/hdc6这个挂载点上。</span></span><br><span class="line">umount /dev/hdc6   <span class="comment">#表示用设备名称（文件系统）进行卸载</span></span><br><span class="line">umount /mnt/hdc6   <span class="comment">#表示用挂载点进行卸载</span></span><br><span class="line">mount -a           <span class="comment">#根据/etc/fstab配置文件的内容，挂载所有的文件系统</span></span><br><span class="line">mount -l           <span class="comment">#查看所有被挂载的文件系统</span></span><br><span class="line">mount -l -t ext2   <span class="comment">#查看文件系统类型为ext2的被挂载的文件系统</span></span><br></pre></td></tr></table></figure><h1 id="mount-–bind"><a href="#mount-–bind" class="headerlink" title="mount –bind"></a>mount –bind</h1><p>mount –bind是一种特殊的用法，不再是将一个文件系统挂载到一个目录，而是将一个目录挂载到另外一个目录，在chroot中很有用哦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount --<span class="built_in">bind</span> olddir newdir  <span class="comment">#将一个目录olddir挂载到另外一个目录newdir上。等价于mount -B olddir newdir</span></span><br><span class="line">mount --rbind olddir newdir <span class="comment">#同mount --bind olddir newdir一样，只是若olddir中存在mount bind的操作，会在newdir中同样</span></span><br></pre></td></tr></table></figure><h1 id="设置重启自动挂载磁盘的方法"><a href="#设置重启自动挂载磁盘的方法" class="headerlink" title="设置重启自动挂载磁盘的方法"></a>设置重启自动挂载磁盘的方法</h1><p>编辑/etc/fstab文件，添加一行要挂载的设备和挂载点。如下为某台机器的/etc/fstab文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[@someclienthost ~]# cat /etc/fstab</span><br><span class="line">/dev/sda1               /                       ext3    defaults        1 1</span><br><span class="line">/dev/sda6               /opt                    ext3    defaults,noatime,nodiratime        0 0</span><br><span class="line">/dev/sda3               /var                    ext3    defaults        1 2</span><br><span class="line">/dev/sda5               /usr                    ext3    defaults        1 2</span><br><span class="line">tmpfs                   /dev/shm                tmpfs   defaults        0 0</span><br><span class="line">devpts                  /dev/pts                devpts  gid=5,mode=620  0 0</span><br><span class="line">sysfs                   /sys                    sysfs   defaults        0 0</span><br><span class="line">proc                    /proc                   proc    defaults        0 0</span><br><span class="line">LABEL=SWAP-sda2         swap                    swap    defaults        0 0</span><br><span class="line">/dev/shm                /tmp                    none    rw,bind         0 0</span><br><span class="line">/opt                    /var/named/opt          none    rw,bind         0 0</span><br></pre></td></tr></table></figure><h1 id="关于-etc-fstab和-etc-mtab配置文件"><a href="#关于-etc-fstab和-etc-mtab配置文件" class="headerlink" title="关于/etc/fstab和/etc/mtab配置文件"></a>关于/etc/fstab和/etc/mtab配置文件</h1><p><code>/etc/fstab</code>配置信息，系统在重启的时候会依据此文件来挂载文件系统。</p><p><code>/etc/mtab</code>配置信息，是当前系统中已经挂载的文件系统的状态。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中arp命令的使用</title>
      <link href="/2018/05/29/Linux%E4%B8%ADarp%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/05/29/Linux%E4%B8%ADarp%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="arp命令介绍"><a href="#arp命令介绍" class="headerlink" title="arp命令介绍"></a>arp命令介绍</h1><p>arp命令用于操作服务器的arp表缓冲区，它可以显示arp缓冲区中的所有条目、删除指定的条目或者添加静态的IP地址与MAC地址对应关系。</p><h1 id="arp命令的使用格式及常用选项"><a href="#arp命令的使用格式及常用选项" class="headerlink" title="arp命令的使用格式及常用选项"></a>arp命令的使用格式及常用选项</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp [options] parameter1 parameter2...</span><br></pre></td></tr></table></figure><p>常用的命令选项有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a: 显示本机中arp缓存区中所有的arp条目</span><br><span class="line">-d: 从arp缓冲区中删除指定主机的arp条目</span><br><span class="line">-i: 指定要操作指定网卡的arp缓存区</span><br><span class="line">-s: 设置指定的主机的IP地址与MAC地址的静态映射</span><br><span class="line">-n: 以数字方式显示arp缓冲区中的条目</span><br></pre></td></tr></table></figure><h1 id="arp常用的操作命令使用举例"><a href="#arp常用的操作命令使用举例" class="headerlink" title="arp常用的操作命令使用举例"></a>arp常用的操作命令使用举例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arp             <span class="comment">#显示本机arp缓存中所有arp条目</span></span><br><span class="line">arp -n          <span class="comment">#只显示ip，不反解成主机名</span></span><br><span class="line">arp -a          <span class="comment">#显示本机arp缓存中所有的arp条目</span></span><br><span class="line">arp -n -i eth0  <span class="comment">#显示指定网卡的所有的arp表项目</span></span><br><span class="line">arp -d 10.1.10.118          <span class="comment">#删除arp表缓存中10.1.10.118对应的arp表项</span></span><br><span class="line">arp -i eth0 -d 10.1.10.118  <span class="comment">#删除指定网卡的arp表缓存中10.1.10.118对应的arp表项</span></span><br><span class="line">arp -s 10.1.1.1 00:11:22:33:44:55:66  <span class="comment">#新增一条IP到MAC地址的映射记录</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA开发中一些日常编程规范</title>
      <link href="/2018/05/24/JAVA%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
      <url>/2018/05/24/JAVA%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h1><p>在import之后，class声明之前进行注释，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类是用来产生随机数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  zhangsan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  lisi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#toString()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.StringBuffer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>   1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomNum</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h1><p>在方法定义之前进行注释说明，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomNum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法用来生成随机数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num The value to be squared. </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> num squared. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">genRandomNum</span><span class="params">(<span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num * num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><p>Java中类名，方法名等使用的命名风格是“驼峰式”规范。</p><ul><li>包名</li></ul><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.baidu.ai.autodriven</span><br><span class="line">com.sina.webo.as</span><br></pre></td></tr></table></figure><ul><li>类名</li></ul><p>类名都以<code>UpperCamelCase</code>风格编写。类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。</p><ul><li>方法名</li></ul><p>方法名都以<code>lowerCamelCase</code>风格编写。方法名通常是动词或动词短语。</p><ul><li>常量名</li></ul><p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。</p><ul><li>非常量字段名</li></ul><p>非常量字段名以<code>lowerCamelCase</code>风格编写。这些名字通常是名词或名词短语。</p><ul><li>参数名</li></ul><p>参数名以<code>lowerCamelCase</code>风格编写。参数应该避免用单个字符命名。</p><ul><li>局部变量名</li></ul><p>局部变量名以<code>lowerCamelCase</code>风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p><h1 id="Java编程规范的一些最佳实践"><a href="#Java编程规范的一些最佳实践" class="headerlink" title="Java编程规范的一些最佳实践"></a>Java编程规范的一些最佳实践</h1><p>（1）抽象类命名使用Abstract或Base开头。异常类命名使用Exception结尾。测试类命名以它要测试的类的名称开始，以Test结尾。</p><p>（2）Service/DAO层方法命名规约：</p><pre><code>获取单个对象的方法用get做前缀获取多个对象的方法用list做前缀获取统计值的方法用count做前缀插入的方法用save/insert做前缀删除的方法用remove/delete做前缀修改的方法用update做前缀</code></pre><p>（3）领域模型命名规约</p><pre><code>数据对象:xxxDO，xxx即为数据表名数据传输对象:xxxDTO，xxx为业务领域相关的名称展示对象:xxxVO，xxx一般为网页名称POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO</code></pre><p>（4）不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。大而全的常量类，不利于理解和维护。建议缓存相关常量放在类CacheConsts下；系统配置相关常量放在类ConfigConsts下。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中Lambda表达式（匿名函数）</title>
      <link href="/2018/05/24/JAVA%E4%B8%ADLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%89/"/>
      <url>/2018/05/24/JAVA%E4%B8%ADLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda表达式简介"><a href="#Lambda表达式简介" class="headerlink" title="Lambda表达式简介"></a>Lambda表达式简介</h1><p>Lambda表达式，也可称为闭包，它是推动Java 8发布的最重要新特性。Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用Lambda表达式可以使代码变的更加简洁紧凑。Lambda表达式是一种匿名函数（对Java而言这并不完全正确，但现在姑且这么认为），简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。开发者可以将其当做一种速记，在你需要使用某个方法的地方写上它。当某个方法只使用一次，而且定义很简短，使用这种速记替代之尤其有效，这样，你就不必在类中费力写声明与方法了。</p><p>由于<strong>Lambda表达式的结果就是被当成对象，因此程序中完全可以使用Lambda表达式进行赋值</strong>。</p><p>Java中的Lambda表达式的书写格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><p>关于格式有几点特性需要注意：</p><pre><code>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号可选的大括号：如果主体包含了一个语句，就不需要使用大括号可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值</code></pre><h1 id="Lambda表达式的简单例子"><a href="#Lambda表达式的简单例子" class="headerlink" title="Lambda表达式的简单例子"></a>Lambda表达式的简单例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5</span></span><br><span class="line">() -&gt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值</span></span><br><span class="line">x -&gt; <span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值</span></span><br><span class="line">(x, y) -&gt; x – y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和</span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)</span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line">(String s) -&gt; &#123; System.out.println(s); &#125;</span><br><span class="line"></span><br><span class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="number">3.1415</span> &#125;;</span><br></pre></td></tr></table></figure><h1 id="Lambda表达式实践"><a href="#Lambda表达式实践" class="headerlink" title="Lambda表达式实践"></a>Lambda表达式实践</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 7中编写线程的代码 -- 匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Jimmy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8中编写线程的代码 -- 匿名函数，Lambda表达式</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Jimmy"</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java 7中当我们对一个集合进行排序时</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java 8中当我们对一个集合进行排序时</span></span><br><span class="line">Collections.sort(list, (Integer o1, Integer o2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;);</span><br><span class="line">Collections.sort(list, (o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中内部类与匿名内部类</title>
      <link href="/2018/05/24/JAVA%E4%B8%AD%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2018/05/24/JAVA%E4%B8%AD%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。内部类是一个非常有用的特性但又比较难理解使用的特性。举例来说，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            name = <span class="string">"chenssy"</span>;</span><br><span class="line">            age = <span class="number">23</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>匿名内部类是一种特殊的内部类。使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。举例来说，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Bird bird)</span> </span>&#123;</span><br><span class="line">        System.out.println(bird.getName() + <span class="string">"能够飞 "</span> + bird.fly() + <span class="string">"米"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.test(<span class="keyword">new</span> Bird() &#123;            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">            &#125;          </span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"大雁"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述使用了匿名内部类的语法和如下代码是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildGoose</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"大雁"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WildGoose wildGoose = <span class="keyword">new</span> WildGoose();</span><br><span class="line">test.test(wildGoose);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中final关键字-final变量/final方法/final类</title>
      <link href="/2018/05/24/JAVA%E4%B8%ADfinal%E5%85%B3%E9%94%AE%E5%AD%97-final%E5%8F%98%E9%87%8F-final%E6%96%B9%E6%B3%95-final%E7%B1%BB/"/>
      <url>/2018/05/24/JAVA%E4%B8%ADfinal%E5%85%B3%E9%94%AE%E5%AD%97-final%E5%8F%98%E9%87%8F-final%E6%96%B9%E6%B3%95-final%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="final关键字简介"><a href="#final关键字简介" class="headerlink" title="final关键字简介"></a>final关键字简介</h1><p>final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。</p><h1 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h1><p>凡是对成员变量或者本地变量（在方法中的或者代码块中的变量称为本地变量）声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。下面是final变量的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> User user = <span class="keyword">new</span> User(<span class="string">"zhangsan"</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    user.setName(<span class="string">"lisi"</span>);          <span class="comment">//修改final常量的内部状态是没有问题的</span></span><br><span class="line">    user = <span class="keyword">new</span> User(<span class="string">"wangwu"</span>, <span class="number">31</span>); <span class="comment">//修改final常量的引用指向则编译器会报错</span></span><br><span class="line">    System.out.println(user.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h1><p>final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。下面是final方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonalLoan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"personal loan"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheapPersonalLoan</span> <span class="keyword">extends</span> <span class="title">PersonalLoan</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"cheap personal loan"</span>; <span class="comment">//此处覆写父类中的final方法，编译会报错，overridden method is final</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h1><p>使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。下面是final类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonalLoan</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheapPersonalLoan</span> <span class="keyword">extends</span> <span class="title">PersonalLoan</span> </span>&#123;  <span class="comment">//此处试图继承一个final类，编译器会报错，cannot inherit from final class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="final关键字的好处"><a href="#final关键字的好处" class="headerlink" title="final关键字的好处"></a>final关键字的好处</h1><p>下面总结了一些使用final关键字的好处</p><ul><li>final关键字提高了性能。JVM和Java应用都会缓存final变量。</li><li>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li><li>使用final关键字，JVM会对方法、变量及类进行优化。</li></ul><p>学习资料参考于：<br><a href="http://www.importnew.com/7553.html" target="_blank" rel="noopener">http://www.importnew.com/7553.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中反射机制</title>
      <link href="/2018/05/24/JAVA%E4%B8%AD%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/05/24/JAVA%E4%B8%AD%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的反射Reflection机制"><a href="#Java的反射Reflection机制" class="headerlink" title="Java的反射Reflection机制"></a>Java的反射Reflection机制</h1><p>JAVA反射机制是在运行状态中，对于任意一个类/对象，都能够知道这个类/对象的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p><p>在JAVA或一些JAVA框架中，都有很多的注解Annotation，注解的实现原理，一部分就是使用到了JAVA反射技术。举例来说，Spring中使用@Bean注解来表示某个类是Bean对象，那么Spring在初始化时，会通过JAVA反射机制去搜索项目工程中的所有Class对象，是否包含了@Bean注解，如果有则创建Bean的Java实例，并放到Spring容器中统一管理。</p><p>JAVA中关于反射相关的类在<code>java.lang.reflect</code>包中。</p><h1 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h1><p>Java中，每个类被加载之后，JVM就会为该类生成一个对应的Class对象，通过该Class对象就可以访问到JVM中的这个类。在Java中获取某个类的Class对象通常有如下三种方式：</p><p>（1）Class.forName(String clazzName)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">"com.sohu.testmaven.Test"</span>);</span><br><span class="line">System.out.println(cls.getName());</span><br></pre></td></tr></table></figure><p>（2）任何类的class属性，如Person.class将会返回Person类对应的Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Test<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">System.out.println(cls1.getName());</span><br></pre></td></tr></table></figure><p>（3）调用某个对象的getClass()方法，该方法是java.lang.Object类中的一个方法，该方法将返回该对象所属类对应的Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">Class cls2 = test.getClass();</span><br><span class="line">System.out.println(cls2.getName());</span><br></pre></td></tr></table></figure><p>备注：直白来说，获取到一个类的Class对象是使用反射机制的前提条件。</p><h1 id="通过Class对象进行各种操作"><a href="#通过Class对象进行各种操作" class="headerlink" title="通过Class对象进行各种操作"></a>通过Class对象进行各种操作</h1><p>如下通过获取到Test类的Class对象之后，就可以进行很多反射相关的操作了。具体如下：</p><p><img src="/images/java_reflect_1_1.png" alt></p><h1 id="反射机制中的一些相关类"><a href="#反射机制中的一些相关类" class="headerlink" title="反射机制中的一些相关类"></a>反射机制中的一些相关类</h1><pre><code>Field类，用来表示Class对象中的成员变量/类变量Constructor类，用来表示Class对象中的构造函数Method类，用来表示Class对象中的成员方法/类方法</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中static关键字-静态代码块/静态方法/静态变量</title>
      <link href="/2018/05/24/JAVA%E4%B8%ADstatic%E5%85%B3%E9%94%AE%E5%AD%97-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
      <url>/2018/05/24/JAVA%E4%B8%ADstatic%E5%85%B3%E9%94%AE%E5%AD%97-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><p>在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。</p><p>static可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问，形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassName.propertyName</span><br><span class="line">ClassName.methodName(……)</span><br></pre></td></tr></table></figure><p>Static修饰的代码块表示静态代码块，当JVM装载类的时候，就会执行这块代码，其用处非常大。</p><p>被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的对象实例，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。</p><h1 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h1><p>static修饰的变量我们称之为“静态变量”，或称为“类变量”，而没有用static修饰的变量称之为实例变量。静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。</p><h1 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h1><p>static修饰的方法我们称之为静态方法，或称为“类方法”。我们通过类名对其进行直接调用。由于它在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。静态方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。</p><p>备注：static方法中，只能使用静态变量和静态方法，不能使用类中的实例变量或实例方法哦。</p><h1 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h1><p>被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且它可以随意放，可以存在于该类的任何地方。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经“准备好了”，也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB服务中的cookies和session机制小结</title>
      <link href="/2018/05/23/WEB%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84cookies%E5%92%8Csession%E6%9C%BA%E5%88%B6%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/05/23/WEB%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84cookies%E5%92%8Csession%E6%9C%BA%E5%88%B6%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要cookies和session"><a href="#为什么需要cookies和session" class="headerlink" title="为什么需要cookies和session"></a>为什么需要cookies和session</h1><p>由于HTTP协议是无状态的协议，为了能够记住请求的状态，于是引入了Session和Cookie的机制，从而能够间接地实现让HTTP请求带有状态。</p><h1 id="cookies机制"><a href="#cookies机制" class="headerlink" title="cookies机制"></a>cookies机制</h1><p>（1）cookies机制简介</p><p>Cookie（复数形态为Cookies），指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据。定义于RFC2109。是网景公司的前雇员卢·蒙特利在1993年3月的发明。Cookie会存储浏览信息，例如您的网站偏好设置或个人资料信息等等。</p><p>Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。</p><p>因为HTTP协议是无状态的，对于一个浏览器发出的多次请求，WEB服务器无法区分是不是来源于同一个浏览器。所以，需要额外的数据用于维护会话。Cookie正是这样的一段随HTTP请求一起被传递的额外数据。Cookie只是一段文本，所以它只能保存字符串。而且浏览器对它有大小限制以及它会随着每次请求被发送到服务器，所以应该保证它不要太大。Cookie的内容也是明文保存的，有些浏览器提供界面修改，所以， 不适合保存重要的或者涉及隐私的内容。</p><p>（2）cookies的设置和读取过程</p><ul><li>服务器端</li></ul><p>服务器端在HTTP响应Response Headers中设置一个Set-Cookie的HTTP头，来告诉浏览器端创建一个cookie。如下图所示，每个Set-Cookie表示一个cookie（如果有多个cookie，需写多个Set-Cookie），每个属性也是以名/值对的形式（除了secure），属性间以分号加空格隔开。格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: name=value[; expires=GMTDate][; domain=domain][; path=path][; secure]</span><br></pre></td></tr></table></figure><p>其中只有cookie的名字和值是必需的，其他都是可选的。注意这些通过Set-Cookie指定的可选项（域、路径、失效时间、secure标志）只会在浏览器端使用，它们都是服务器给浏览器的指示，以指定何时应该发送cookie。这些参数不会被发送至服务器端，只有name和value才会被发送到服务端。</p><ul><li>浏览器端</li></ul><p>浏览器在HTTP Request头中设置Cookie请求头中，将相关的cookeise发送到服务端的。</p><p>（3）cookies的格式及含义说明</p><p>cookies的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=value[; expires=GMTDate][; domain=domain][; path=path][; secure]</span><br></pre></td></tr></table></figure><p>举例来说：</p><p><img src="/images/cookies_session_1_1.png" alt></p><p>下面分别说明各部分的含义：</p><ul><li>name和value</li></ul><p>name和value是cookies最核心的key-value键值对了。</p><ul><li>domain和path</li></ul><p>domain和path这两个选项共同决定了哪些页面可以使用这个cookies，即访问哪些页面可以读取浏览器本地的cookies并且发送给服务器端。</p><p>举例来说：</p><p><img src="/images/cookies_session_1_2.png" alt></p><p>domain参数是用来控制cookie对「哪个域」有效，默认为设置cookie的那个域。这个值可以包含子域，也可以不包含它。如上图的例子，domain选项中，可以是<code>.google.com.hk</code>（是不包含子域的，表示它对google.com.hk下的所有子域都有效，例如aa.google.com.hk等），也可以是<code>www.google.com.hk</code>（是包含子域的，该cookies仅能被<a href="http://www.google.com.hk所使用）。" target="_blank" rel="noopener">www.google.com.hk所使用）。</a></p><p>path用来控制cookie发送的指定域的「路径」，它是在域名的基础下，指定可以访问的路径。默认为”/“，表示指定域下的所有路径都能访问。例如cookie设置为<code>domain=.google.com.hk; path=/webhp</code>，那么只有<code>.google.com.hk/webhp</code>及<code>/webhp</code>下的任一子目录如<code>/webhp/aaa</code>或<code>/webhp/bbb</code>会可以读取cookie信息，而<code>.google.com.hk</code>就不会发送，即使它们来自同一个域。</p><ul><li>expires/max-age</li></ul><p>expries和max-age是用来决定cookie的生命周期的，也就是cookie何时会被删除。</p><ul><li>secure</li></ul><p>secure是cookie的安全标志，通过cookie直接包含一个secure单词来指定，也是cookie中唯一一个非名值对儿的部分。指定后，cookie只有在使用SSL连接（如HTTPS请求）时才会发送到服务器。 默认情况为空，不指定secure选项，即不论是http请求还是https请求，均会发送cookie。</p><p>（4）Google Chrome清除和禁止浏览器Cookies</p><ul><li>清除Cookies</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置 --&gt; 显示高级设置 --&gt; 内容设置 --&gt; 所有Cookie和网站数据</span><br></pre></td></tr></table></figure><ul><li>禁止浏览器Cookies</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置 --&gt; 显示高级设置 --&gt; 内容设置</span><br></pre></td></tr></table></figure><h1 id="session机制"><a href="#session机制" class="headerlink" title="session机制"></a>session机制</h1><h2 id="session机制原理"><a href="#session机制原理" class="headerlink" title="session机制原理"></a>session机制原理</h2><p>在计算机中，尤其是在网络应用中，称为“会话控制”。 每个用户（浏览器）首次与WEB服务器建立连接时，就会产生一个Session，同时服务器会分配一个SessionId给用户的浏览器。我们可以用浏览器开发者工具查看cookies信息，会看到有类似于SessionId的cookie，当然不同的语言或WEB服务器这个key是不一样的，例如有ASP.Net_SessionId、JSESSIONID以及SESSION等等。服务端通过这个SessionId就可以很容易获取到session状态中各种信息。大家都知道HTTP是无状态请求，但是有了Session仿佛又让HTTP请求变得有状态。这里一定要注意的是，SessionId是一个特殊的cookie，它是与Session相关的，是真正维系客户端和服务端的桥梁。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p><p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含一个sessionid则说明以前已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的session id，sessionid的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个sessionid的方式可以采用cookie，当然也可以拼接到请求URL中，这样在交互过程中浏览器可以自动的按照规则把这个标识发给服务器。一般这个cookie的名字都是类似于SEEESIONID。比如weblogic对于web应用程序生成的cookie，如<code>JSESSIONID=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764</code>，它的名字就是JSESSIONID。</p><p>session工作的主要过程如下：</p><pre><code>（1）用户向服务器发送用户名和密码。（2）服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。（3）服务器向用户返回一个session_id，写入用户的Cookie。（4）用户随后的每一次请求，都会通过Cookie，将session_id传回服务器。（5）服务器收到session_id，找到前期保存的数据，由此得知用户的身份。</code></pre><p>简单来说，WEB服务器会为每一个客户端创建一个session，web应用可以将一些信息保存到session中，然后WEB服务器生成一个session id传给客户端，然后客户端带着这个session id去请求WEB服务器，WEB服务器根据客户端的session id来找到对应的session对象，并获取其中的信息。</p><h2 id="HTTP-Session管理机制"><a href="#HTTP-Session管理机制" class="headerlink" title="HTTP Session管理机制"></a>HTTP Session管理机制</h2><p>（1）非共享Session</p><p>单体WEB服务端应用自己维护所有的Session，这个Session是不共享的，只有请求到这个单体的WEB应用服务器进程才能访问到Session。以JAVA WEB应用来说，使用Tomcat/Jetty这样的Servlet容器，它们会将我们的Session进行管理，也即放入JVM内存到当中。</p><p>（2）共享Session</p><p>以Java WEB应用来说，实现Session共享的方案很多，其中一种常用的就是使用Tomcat/Jetty等服务器提供的Session共享功能，将Session的内容统一存储在一个数据库（如MySQL）或缓存（如Redis）中。另一种实现Session共享的方案，不依赖于Servlet容器，而是Web应用代码层面的实现，直接在已有项目基础上加入Spring Session框架来实现Session统一存储在Redis中。如果你的Web应用是基于Spring框架开发的，只需要对现有项目进行少量配置，即可将一个单机版的Web应用改为一个分布式应用，由于不基于Servlet容器，所以可以随意将项目移植到其他容器。</p><p>备注：sessionid使用Cookie机制存储，有一定的不安全性，即用户在浏览器中通过修改sessionid，就可以冒充其他用户啦。</p><h1 id="cookie和session机制的区别与联系"><a href="#cookie和session机制的区别与联系" class="headerlink" title="cookie和session机制的区别与联系"></a>cookie和session机制的区别与联系</h1><p>举例来说，某家咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，这时就需要某种方式来纪录某位顾客的消费数量。有下面的几种方案：</p><ul><li><p>服务员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。</p></li><li><p>发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。</p></li><li><p>发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。</p></li></ul><p>将上面的例子映射到HTTP请求的状态信息上来，由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。</p><p>学习资料参考于：<br><a href="http://www.2cto.com/kf/201206/135471.html" target="_blank" rel="noopener">http://www.2cto.com/kf/201206/135471.html</a><br><a href="https://segmentfault.com/a/1190000004743454" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004743454</a></p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器HTTP缓存机制（Last-Modified/Etag/Expires/Cache-Control等）</title>
      <link href="/2018/05/18/%E6%B5%8F%E8%A7%88%E5%99%A8HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%88Last-Modified-Etag-Expires-Cache-Control%E7%AD%89%EF%BC%89/"/>
      <url>/2018/05/18/%E6%B5%8F%E8%A7%88%E5%99%A8HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%88Last-Modified-Etag-Expires-Cache-Control%E7%AD%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器HTTP缓存简介"><a href="#浏览器HTTP缓存简介" class="headerlink" title="浏览器HTTP缓存简介"></a>浏览器HTTP缓存简介</h1><p>WEB缓存是一种保存WEB资源副本并在下次请求时直接使用该副本的技术。WEB缓存可以分为如下几种：</p><ul><li>浏览器HTTP缓存</li><li>CDN缓存</li><li>服务器缓存</li><li>数据库数据缓存</li></ul><p>因为可能会直接使用副本免于重新发送请求，或者仅仅确认资源没变无需重新传输资源实体，WEB缓存可以减少延迟加快网页打开速度、重复利用资源减少网络带宽消耗、降低请求次数或者减少传输内容从而减轻服务器压力。</p><p>该篇文章主要讨论浏览器HTTP缓存机制，浏览器HTTP缓存可以分为强缓存和协商缓存。强缓存和协商缓存最大也是最根本的区别是：强缓存命中的话不会发请求到服务器（比如chrome中的200 from memory cache），协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。</p><p>浏览器HTTP缓存机制是通过一些HTTP请求头或响应头来控制的，浏览器HTTP缓存相关的头部有<code>Last-Modified/Etag/Expires/Cache-Control</code>等等。</p><h1 id="浏览器HTTP缓存机制之强缓存相关的请求头-响应头"><a href="#浏览器HTTP缓存机制之强缓存相关的请求头-响应头" class="headerlink" title="浏览器HTTP缓存机制之强缓存相关的请求头/响应头"></a>浏览器HTTP缓存机制之强缓存相关的请求头/响应头</h1><p>（1）Pragma</p><p>Pragma是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。虽然它是一个通用首部，但是它在响应报文中时的行为没有规范，依赖于浏览器的实现。RFC中该字段只有no-cache一个可选值，会通知浏览器不直接使用缓存，要求向服务器发请求校验新鲜度。因为它优先级最高，当存在时一定不会命中强缓存。</p><p>（2）Cache-Control</p><p>Cache-Control是一个通用首部字段，也是HTTP/1.1控制浏览器缓存的主流字段。Cache-Control头部的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: cache-directive</span><br></pre></td></tr></table></figure><p>作为请求首部时，cache-directive的可选值有：</p><p><img src="/images/httpcache_1_1.png" alt></p><p>作为响应首部时，cache-directive的可选值有：</p><p><img src="/images/httpcache_1_2.png" alt></p><p>举例来说，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=3600</span><br></pre></td></tr></table></figure><p>这里声明的是一个相对的秒数，表示从现在起，3600秒内缓存都是有效的，这样就避免了服务端和客户端时间不一致的问题。但是Cache-Control是HTTP1.1才有的，不适用于HTTP1.0，而Expires既适用于HTTP1.0，也适用于HTTP1.1，所以说在大多数情况下同时发送这两个头会是一个更好的选择，当客户端两种头都能解析的时候，会优先使用Cache-Control。</p><p>另外，Cache-Control 允许自由组合可选值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=3600, must-revalidate</span><br></pre></td></tr></table></figure><p>它意味着该资源是从原服务器上取得的，且其缓存（新鲜度）的有效时间为一小时，在后续一小时内，用户重新访问该资源则无须发送请求。 当然这种组合的方式也会有些限制，比如 no-cache 就不能和 max-age、min-fresh、max-stale 一起搭配使用。</p><p>（3）Expires</p><p>Expires是一个响应首部字段，它指定了一个日期/时间，在这个时间/日期之前，HTTP缓存被认为是有效的。无效的日期比如0，表示这个资源已经过期了。如果同时设置了Cache-Control响应首部字段的max-age，则Expires会被忽略。它也是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。</p><p>举例来说，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Thu, 10 Dec 2015 23:21:37 GMT</span><br></pre></td></tr></table></figure><p>浏览器端收到包含Expires字段的响应报文后，下一次再次请求该资源时，当前时间是在Expires的日期之前，客户端会认为浏览器缓存是有效的，因此浏览器不会连接服务器，直接从本地缓存中读取。不过Expires有缺点，比如说，服务端和客户端的时间设置可能不同，这就会使缓存的失效可能并不能精确的按服务器的预期进行。</p><h1 id="浏览器HTTP缓存机制之协商缓存相关的请求头-响应头"><a href="#浏览器HTTP缓存机制之协商缓存相关的请求头-响应头" class="headerlink" title="浏览器HTTP缓存机制之协商缓存相关的请求头/响应头"></a>浏览器HTTP缓存机制之协商缓存相关的请求头/响应头</h1><p>（1）ETag/If-None-Match</p><p>ETag是一个响应首部字段，它是根据实体内容生成的一段hash字符串，标识资源的状态，由服务端产生。If-None-Match是一个条件式的请求首部。如果请求资源时在请求首部加上这个字段，值为之前服务器端返回的资源上的ETag，则当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的时候，服务器才会返回带有所请求资源实体的200响应，否则服务器会返回不带实体的304响应。ETag优先级比Last-Modified高，同时存在时会以ETag为准。</p><p><img src="/images/httpcache_1_3.png" alt></p><p>HTTP 协议规格说明定义 ETag 为“被请求变量的实体值”。 服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端，以下是服务器端返回的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;d41d8cd98f00b204e9800998ecf8427e&quot;</span><br></pre></td></tr></table></figure><p>客户端的查询更新格式是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: W/&quot;d41d8cd98f00b204e9800998ecf8427e&quot;</span><br></pre></td></tr></table></figure><p>如果ETag没改变，则返回状态304，内容为空，这也和Last-Modified一样。</p><p>（2）Last-Modified/If-Modified-Since</p><p>If-Modified-Since是一个请求首部字段，并且只能用在GET或者HEAD请求中。Last-Modified是一个响应首部字段，包含服务器认定的资源作出修改的日期及时间。当带着If-Modified-Since头访问服务器请求资源时，服务器会检查Last-Modified，如果Last-Modified的时间早于或等于If-Modified-Since则会返回一个不带主体的304响应，否则将重新返回资源。</p><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性<br>标记此文件在服务期端最后被修改的时间，格式类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Mon, 30 Nov 2015 23:21:37 GMT</span><br></pre></td></tr></table></figure><p>浏览器第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头，询问该时间之后文件是否有被修改过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Mon, 30 Nov 2015 23:21:37 GMT</span><br></pre></td></tr></table></figure><p>如果服务器端的资源没有变化，则自动返回HTTP 304（Not Changed）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</p><h1 id="浏览器HTTP缓存相关的头部优先级"><a href="#浏览器HTTP缓存相关的头部优先级" class="headerlink" title="浏览器HTTP缓存相关的头部优先级"></a>浏览器HTTP缓存相关的头部优先级</h1><p>（1）强缓存相关的请求头/响应头优先级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pragma -&gt; Cache-Control -&gt; Expires</span><br></pre></td></tr></table></figure><p>（2）协商缓存相关的请求头/响应头优先级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag/If-None-Match -&gt; Last-Modified/If-Modified-Since</span><br></pre></td></tr></table></figure><p>备注：强缓存的优先级高于协商缓存，也就是说只有本地强缓存策略失效后，才会考虑向考虑向后端询问协商。</p><h1 id="其他闲杂知识"><a href="#其他闲杂知识" class="headerlink" title="其他闲杂知识"></a>其他闲杂知识</h1><p>（1）HTTP响应头Date和Age</p><p>HTTP响应头中的Date和Age的含义：</p><p><img src="/images/httpcache_1_4.png" alt></p><p>Date是服务器返回本次HTTP响应的时间，而Last-Modified表示对应的资源在服务器端最后被修改的时间点，注意二者的区别哦； Age的存在暗示你访问的服务器不是源服务器，而是一台缓存服务器，Age的大小表示这个资源已经“存活了”多长时间（也即资源被缓存了多长时间），所以这个值不会大于源服务器设置的最大缓存时间<code>Cache-Control: max-age=****</code>。</p><p>学习资料参考于：<br><a href="https://juejin.im/post/5a673af06fb9a01c927ed880" target="_blank" rel="noopener">https://juejin.im/post/5a673af06fb9a01c927ed880</a><br><a href="http://blog.wpjam.com/m/last-modified-etag-expires-cache-control/" target="_blank" rel="noopener">http://blog.wpjam.com/m/last-modified-etag-expires-cache-control/</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6/JSX转码工具babel</title>
      <link href="/2018/03/08/ES6-JSX%E8%BD%AC%E7%A0%81%E5%B7%A5%E5%85%B7babel/"/>
      <url>/2018/03/08/ES6-JSX%E8%BD%AC%E7%A0%81%E5%B7%A5%E5%85%B7babel/</url>
      
        <content type="html"><![CDATA[<h1 id="babel简介"><a href="#babel简介" class="headerlink" title="babel简介"></a>babel简介</h1><p>Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。这意味着，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。Babel是所有ES6转换编译器中与ES6规范兼容度最高的，甚至超过了谷歌创建已久的Traceur编译器。Babel允许开发者使用ES6的所有新特性，而且不会影响与老版本浏览器的兼容性。</p><p>备注：可以说，有了Babel这一类转码工具，一些JS的最新的标准或特性，在没有被大多的浏览器厂商支持的情况下，让前端开发者提前使用上了这些新特性。</p><p>举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转码前</span></span><br><span class="line">input.map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Babel转码后</span></span><br><span class="line">input.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>备注：上面的原始代码用了箭头函数，Babel将其转为普通函数，就能在不支持箭头函数的JavaScript环境执行了。</p><h1 id="babel的使用方法"><a href="#babel的使用方法" class="headerlink" title="babel的使用方法"></a>babel的使用方法</h1><p>Babel有三种使用方式，如下：</p><p>（1）直接安装babel的命令行工具</p><p>执行命令<code>npm install babel-cli -g</code>或<code>npm install babel-cli</code>即可安装babel的命令行工具。然后执行<code>babel test.js</code>就可以将我们编写的非原生JS代码转换成原生的JS代码啦，前提是要配置好<code>.babelrc</code>啦。</p><p>（2）结合webpack的babel-loader进行转码</p><p>（3）在浏览器中直接转码</p><p>在浏览器中转码时，需要在HTML中做如下配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>babel<span class="string">"&gt;</span></span><br><span class="line"><span class="string">// Your ES6 code</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>备注：从Babel 6.0开始，不再直接提供浏览器版本，而是要用构建工具构建出来。即需要使用第一种方式来使用Babel，因为直接在浏览器中转码，会增加浏览器的性能损耗。</p><h1 id="babel工具在项目中基础配置"><a href="#babel工具在项目中基础配置" class="headerlink" title="babel工具在项目中基础配置"></a>babel工具在项目中基础配置</h1><p>当需要在服务端使用babel对ES6进行转码时，我们首先需要配置babel的转码规则和插件。babel有两种配置方法，一种是配置.babelrc；另一种是在package.json中增加babel的配置。二者选择其一即可。</p><p>（1）.babelrc文件的配置</p><p>在项目的根目录中增加一个.babelrc文件，文件内容的基本格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [],</span><br><span class="line">  &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>presets字段设定转码规则，也就是从什么语法转换成浏览器能直接支持的原生JS，官方提供以下的规则集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ES2015转码规则</span></span><br><span class="line">npm install --save-dev babel-preset-es2015</span><br><span class="line"></span><br><span class="line"><span class="comment"># react转码规则</span></span><br><span class="line">npm install --save-dev babel-preset-react</span><br><span class="line"></span><br><span class="line"><span class="comment"># ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个</span></span><br><span class="line">npm install --save-dev babel-preset-stage-0</span><br><span class="line">npm install --save-dev babel-preset-stage-1</span><br><span class="line">npm install --save-dev babel-preset-stage-2</span><br><span class="line">npm install --save-dev babel-preset-stage-3</span><br></pre></td></tr></table></figure><p>假设我们的JS代码中有ES2015、JSX的语法，那么我们需要在.babelrc文件中增加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      &quot;es2015&quot;,</span><br><span class="line">      &quot;react&quot;,</span><br><span class="line">      &quot;stage-2&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在package.json中增加babel的配置</p><p>在package.json中增加babel的配置，需要在package.json中增加一个babel字段，形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;my-package&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    // my babel config here</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="babel的项目实践"><a href="#babel的项目实践" class="headerlink" title="babel的项目实践"></a>babel的项目实践</h1><p>待补充。。</p><p>学习资料参考于：<br><a href="http://www.infoq.com/cn/news/2015/05/ES6-TypeScript" target="_blank" rel="noopener">http://www.infoq.com/cn/news/2015/05/ES6-TypeScript</a><br><a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/01/babel.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SPA项目打包工具webpack</title>
      <link href="/2018/03/07/SPA%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7webpack/"/>
      <url>/2018/03/07/SPA%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>webpack是一个JavaScript应用程序的模块打包器(module bundler)。当webpack处理应用程序时，它会递归地构建一个资源依赖关系图表(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的bundle。通常只有一个，由浏览器加载。简单来说，webpack是一个前端资源加载、打包工具，主要是用来打包在浏览器端使用的javascript的，同时也能转换、捆绑、打包其他的静态资源，包括css、image、font file、template等。另外可以通过自己开发loader和plugin来满足自己个性化的需求。</p><p><img src="/images/webpack_1_1.png" alt></p><h1 id="webpack的安装和使用"><a href="#webpack的安装和使用" class="headerlink" title="webpack的安装和使用"></a>webpack的安装和使用</h1><p>前提申明，这里演示的是webpack 2.4.1版本。</p><p>（1）安装</p><p>使用npm安装即可，执行命令<code>npm install webpack</code></p><p>备注：当在本地安装webpack后，能够从node_modules/.bin/webpack访问webpack的可执行bin文件，后面如果需要在命令行中直接执行webpack命令时，可以使用<code>node_modules/.bin/webpack</code>来执行。</p><p>（2）准备js/css/img等资源文件</p><p>（3）编写webpack配置文件</p><p>（4）执行webpack命令，开始打包资源文件</p><p>webpack打包命令范例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">webpack --config webpack.config.js --progress --colors</span><br><span class="line">webpack-dev-server --config webpack-dev-server.config.js --progress --inline --colors</span><br></pre></td></tr></table></figure><p>备注：也可以将webpack的命令写入到npm的package.json中，需要打包前端资源时，只要执行<code>npm run scriptname</code>即可</p><h1 id="webpack中的一些其他概念"><a href="#webpack中的一些其他概念" class="headerlink" title="webpack中的一些其他概念"></a>webpack中的一些其他概念</h1><p>（1）入口Entry</p><p>（2）输出</p><p>（3）loader</p><p>loader是在webpack对web项目打包过程中，用来对一些静态文件(js/css/img等等)做特殊的处理。例如将es6转换成es5的loader，将scss/less转成css的loader，对图片压缩或base编码的loader等等。</p><p>（4）插件plugins</p><p>（5）模块</p><p>…..</p><h1 id="一个简单的webpack的配置文件"><a href="#一个简单的webpack的配置文件" class="headerlink" title="一个简单的webpack的配置文件"></a>一个简单的webpack的配置文件</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        bundle :<span class="string">'./index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        path:<span class="string">'./target'</span>,</span><br><span class="line">        filename:<span class="string">'[name].js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p>备注：其实config就是一个遵循CommonJS的规范的JS模块。webpack是根据config里面描述的内容对一个项目进行打包的。上述配置文件表示，webpack要打包的前端WEB APP的入口文件是index.js，webpack会从这个文件开始来生成整个WEB APP的依赖关系图表。output表示打包完成后，文件的输出路径以及文件名。</p><p>一个config文件，基本是由以下几个配置项组成的：</p><p>（1）entry</p><p>配置要打包的文件的入口，可以配置多个入口文件。</p><p>（2）output</p><p>配置经过webpack打包后产出的文件的存储路径和文件名等。</p><p>（3）module(loaders)</p><p>配置要使用的loader，以对文件进行一些相应的处理。比如babel-loader可以把es6的文件转换成es5。大部分的对文件的处理的功能都是通过loader实现的。loader可以用来处理在入口文件中require进来或其他方式引用进来的文件。loader一般是一个独立的node模块，要单独安装。</p><p>（4）plugins</p><p>配置webpack要使用的插件。</p><h1 id="webpack监测项目变化，自动重新打包"><a href="#webpack监测项目变化，自动重新打包" class="headerlink" title="webpack监测项目变化，自动重新打包"></a>webpack监测项目变化，自动重新打包</h1><p>webpack中提供了几种方式，可以帮助我们在代码发生变化后自动重新打包代码，分别如下：</p><p>（1）webpack Watch Mode</p><p>要使用这样方式，只需要在webpack命令后加上–watch参数即可。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --config webpack.config.js --watch --progress --colors</span><br></pre></td></tr></table></figure><p>（2）webpack-dev-server</p><p>webpack-dev-server是webpack官方提供的一个小型Express服务器，webpack-dev-server是一个独立的工具，需要使用npm install来安装。使用它可以为webpack打包生成文件以及其他的一些静态资源文件提供web服务。webpack-dev-server主要提供两个功能：</p><ul><li><p>为静态文件提供WEB服务</p></li><li><p>自动刷新和热替换(HMR)</p></li></ul><p>自动刷新指的是，每次修改代码后，webpack可以自动重新打包 ，且浏览器可以响应代码变化并自动刷新。而当我们使用webpack-dev-server的自动刷新功能时，浏览器会整页刷新，热替换（HMR）的区别就在于，当前端代码变动时，无需刷新整个页面，只把变化的部分替换掉。</p><p>webpack-dev-server提供了iframe和inline两种自动刷新模式。iframe模式是默认的模式，页面被嵌套在一个iframe下，使用此模式无需额外配置，只需访问<code>http://localhost:8080/webpack-dev-server/index.html</code>即可。inline模式需要在启动webpack-dev-server加上inline参数。</p><p>热替换（HMR）则需要启动webpack-dev-server时加上hot参数。</p><p>我们可以在webpack.config.js中添加一端devserver的配置，其中contentBase指定了webpack-dev-server作为web服务器的DocumentRoot。</p><p>备注：当我们使用webpack-dev-server来启动我们的项目时，webpack-dev-server会自动监视我们文件的变化，若某个文件被修改后，webpack-dev-server会自动重新打包文件，但是不会在本地生成打包后的bundle文件，只会在内存中生成bundle文件，因此我们需要在html中使用<code>http://localhost:8080/bundle.js</code>路径来访问，也就是src=/bundle.js即可。也就是我们使用webpack-dev-server仅仅做开发调试，也没必要生成本地bundle文件，所以webpack-dev-server只在内存中生成。当调试完毕后，我们再执行webpack打包出bundle本地文件就好了。</p><p>（3）webpack-dev-middleware</p><p>通常来说，我们在项目开发中使用webpack-dev-server比较多一些。</p><h1 id="webpack中遇到的一些知识点"><a href="#webpack中遇到的一些知识点" class="headerlink" title="webpack中遇到的一些知识点"></a>webpack中遇到的一些知识点</h1><p>（1）source map</p><p>当使用webpack打包源代码时，可能会很难追踪到错误和警告在源代码中的原始位置。例如，如果将三个源文件（a.js,b.js和c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会简单地指向到 bundle.js。这并通常没有太多帮助，因为你可能需要准确地知道错误来自于哪个源文件。 为了更容易地追踪错误和警告，JavaScript提供了source map功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map就会明确的告诉你。</p><p>在webpack的config中，是通过devtool这个参数来指定一种source map（也即是在webpack.config.js中的devtool参数）。webpack中有很多种source map可以选择，举例来说：</p><p><img src="/images/webpack_1_2.png" alt></p><h1 id="webpack在实践中的一些最佳实践"><a href="#webpack在实践中的一些最佳实践" class="headerlink" title="webpack在实践中的一些最佳实践"></a>webpack在实践中的一些最佳实践</h1><p>（1）一般来说，我们根据部署环境的不同，分别创建<code>webpack-dev.config.js</code>、<code>webpack-test.config.js</code>以及<code>webpack-prod.config.js</code>三个webpack的配置文件，分别代表开发环境/测试环境/生产环境的webpack配置文件。</p><p>（2）有时我们需要在使用webpack打包的过程中，进行一个文件copy的操作，例如我们需要将src中的一些文件copy到webpack的output目录中，我们就可以使用一个webpack的第三方plugins，名称为TransferWebpackPlugin，官网地址为<code>https://github.com/molforp/transfer-webpack-plugin</code>.</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>YAML数据格式介绍和使用</title>
      <link href="/2018/02/27/YAML%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/27/YAML%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h1><p>与XML或JSON一样，YAML是一种利于人们读写的数据格式。</p><h1 id="YAML文件的编写"><a href="#YAML文件的编写" class="headerlink" title="YAML文件的编写"></a>YAML文件的编写</h1><p>一个YAML文件的开始行都应该是三个横杠（<code>---</code>），这是YAML格式的一部分，表明一个YAML文件的开始。YAML中有两种数据结构，一种是列表，一种是字典。</p><p>（1）列表</p><p>列表中的所有成员都开始于相同的缩进级别，并且使用一个“- ”作为开头（一个横杠和一个空格），举例来说：</p><pre><code>---- Apple- Orange- Strawberry- Mango</code></pre><p>（2）字典</p><p>一个字典是由一个简单的“键: 值”的形式组成（这个冒号后面必须是一个空格），举例来说：</p><pre><code>---name: Example Developerjob: Developerskill: Elite</code></pre><h1 id="YAML文件的范例"><a href="#YAML文件的范例" class="headerlink" title="YAML文件的范例"></a>YAML文件的范例</h1><p>一个YAML文件的内容是由列表、字典以及列表字典的嵌套组成，如下为一个YAML文件的范例：</p><pre><code>---name: Example Developerjob: Developerskill: Eliteemployed: Truefoods:  - Apple  - Orange  - Strawberry  - Mangolanguages:  ruby: Elite  python: Elite  dotnet: Lame</code></pre>]]></content>
      
      
      <categories>
          
          <category> 杂货铺 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RawGit_为GitHub服务的Global CDN</title>
      <link href="/2018/02/24/RawGit-%E4%B8%BAGitHub%E6%9C%8D%E5%8A%A1%E7%9A%84Global-CDN/"/>
      <url>/2018/02/24/RawGit-%E4%B8%BAGitHub%E6%9C%8D%E5%8A%A1%E7%9A%84Global-CDN/</url>
      
        <content type="html"><![CDATA[<h1 id="RawGit介绍"><a href="#RawGit介绍" class="headerlink" title="RawGit介绍"></a>RawGit介绍</h1><p>RawGit是一个全球性的CDN服务，它是专门用来缓存GitHub上的代码文件的。值得注意的是，RawGit不是GitHub提供的服务，这个服务是由GitHub使用者Ryan Grove自发性提供的，因此不保证SLA。</p><h1 id="RawGit的使用"><a href="#RawGit的使用" class="headerlink" title="RawGit的使用"></a>RawGit的使用</h1><p>打开网址<code>https://rawgit.com/</code>，将GitHub上的文件路径地址，复制到页面的文本框中，就会自动生成rawgit相关的地址。通过新生成的地址访问文件时，就会使用到RawGit提供的CDN加速服务。举例来说，原始GitHub文件地址为<code>https://github.com/wangjianno1/MyFirstProject/blob/master/HelloWorld.java</code>，生成RawGit  CDN地址如下：</p><pre><code>https://cdn.rawgit.com/wangjianno1/MyFirstProject/1f914100/HelloWorld.javahttps://rawgit.com/wangjianno1/MyFirstProject/master/HelloWorld.java</code></pre><p>其中<code>https://rawgit.com/xxx</code>用于开发或测试环境，文件更新后几分钟内会生效。<code>https://cdn.rawgit.com/xxx</code>用于正式环境，它走的是全球的CDN，沒有流量限制，文件第一次被缓存后就会被永久Cache。</p><p>学习资料参考于：<br><a href="https://blog.ccjeng.com/2015/07/GitHub-RawGit-Raw-File.html" target="_blank" rel="noopener">https://blog.ccjeng.com/2015/07/GitHub-RawGit-Raw-File.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂货铺 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的strace|pstack工具的使用</title>
      <link href="/2018/02/24/Linux%E4%B8%AD%E7%9A%84strace-pstack%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/24/Linux%E4%B8%AD%E7%9A%84strace-pstack%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h1><p>使用strace工具可以追踪一个命令或进程在执行期间的系统调用和信号接收的情况。也就是进程和os打交道的一些过程。</p><p>strace命令的执行格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strace <span class="built_in">command</span></span><br><span class="line">strace -p pid   <span class="comment">#使用strace attach到pid进程上</span></span><br></pre></td></tr></table></figure><p>strace常用的选项：</p><pre><code>-p pid       #指定待attach进程的进程号-o filename  #指定strace命令的执行结果输出到指定的文件中-ff          #配合-o使用，将不同进程的trace结果，输出到以进程号为后缀的文件filename.pid中</code></pre><p>使用举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace rm output.log  <span class="comment">#查看rm命令在执行过程中有哪些系统调用</span></span><br></pre></td></tr></table></figure><h1 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h1><p>pstack可以打印出一个进程当前的堆栈信息，如果这个进程包含有多个线程，那么每个线程的堆栈信息都会被打印。</p><p>pstack命令执行格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstack pid</span><br></pre></td></tr></table></figure><p>学习参考资料来源：<br><a href="http://www.dbabeta.com/2009/strace.html" target="_blank" rel="noopener">http://www.dbabeta.com/2009/strace.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中top命令的使用和理解</title>
      <link href="/2018/02/24/Linux%E4%B8%ADtop%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3/"/>
      <url>/2018/02/24/Linux%E4%B8%ADtop%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="top命令的帮助"><a href="#top命令的帮助" class="headerlink" title="top命令的帮助"></a>top命令的帮助</h1><p>进入top视图后，输入h可以查看在top视图中可以操作的命令，很重要的哈。</p><h1 id="top输出结果解析"><a href="#top输出结果解析" class="headerlink" title="top输出结果解析"></a>top输出结果解析</h1><p><img src="/images/linux_top_1_1.png" alt></p><p>top的输出结果中包括两个部分。上半部分是显示这个系统的资源使用状态。下半部分是显示每个进程使用的资源情况。</p><p>（1）上半部分</p><p>第一行：包含的信息有当前的时间、开机到现在所经过的时间、系统当前登录的用户数、最近一分钟CPU负载均值、最近五分钟CPU负载均值、最近十五分钟CPU负载均值。</p><p>第二行：显示的是目前进程的总数和各状态下进程的数量。</p><p>第三行：是各个项目占用CPU时间的比例，详细解释如下：</p><pre><code>us：用户态使用的cpu时间比  sy：系统态使用的cpu时间比  ni：用做nice加权的进程分配的用户态cpu时间比  id：空闲的cpu时间比  wa：cpu等待磁盘写入完成时间  hi：硬中断消耗时间  si：软中断消耗时间  st：虚拟机偷取时间</code></pre><p>备注，以上列出来的几项的数值加起来等于100%.</p><p>第四行和第五行：表示物理内存和虚拟内存(MEM/SWAP)的使用情况。参见<a href="http://blog.csdn.net/wangjianno2/article/details/48886093" target="_blank" rel="noopener">linux中free命令详解</a></p><p>第六行：top工具与用户交互的位置。</p><p>（2）下半部分</p><p>显示每个进程使用的资源情况：</p><pre><code>VIRT：进程的虚拟内存空间大小，包括进程目前已经映射到物理内存，以及未映射到物理内存的总大小。注意，这里可不是SWAP的东东哦RES：进程使用的物理内存的大小。公式为RES = CODE + DATASHR：进程所使用内存中是和其他进程共享的内存的大小。%MEM：进程的RES占总物理内存的大小。</code></pre><p>备注：看进程内存占用大小，看RES就好了。它们的详细区别参见<a href="https://wangjianno1.github.io/2018/02/03/%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98VIRT-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98RES-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98SHR/">关于进程的虚拟内存VIRT|物理内存RES|共享内存SHR</a></p><h1 id="关于CPU平均负载load-average"><a href="#关于CPU平均负载load-average" class="headerlink" title="关于CPU平均负载load average"></a>关于CPU平均负载load average</h1><p>（1）对于单核CPU</p><p>假设我们的系统是单CPU单内核的，把它比喻成是一条单向马路，把CPU任务比作汽车。当车不多的时候，load&lt;1；当车占满整个马路的时候，load=1；当马路都站满了，而且马路外还堆满了汽车的时候，load&gt;1。</p><ul><li>Load &lt; 1</li></ul><p><img src="/images/linux_top_load_less_1.png" alt></p><ul><li>Load = 1</li></ul><p><img src="/images/linux_top_load_equal_1.png" alt></p><ul><li>Load &gt; 1</li></ul><p><img src="/images/linux_top_load_more_1.png" alt></p><p>（2）对于多核CPU</p><p>我们经常会发现服务器Load &gt; 1但是运行仍然不错，那是因为服务器是多核处理器（Multi-core）。假设我们服务器CPU是2核，那么将意味我们拥有2条马路，我们的Load = 2时，所有马路都跑满车辆。</p><p><img src="/images/linux_top_load_equal_2.png" alt></p><p>备注：Load = 2时马路都跑满了</p><p>总结来说，load average指CPU运行队列的平均长度，也就是等待CPU的平均进程数。如果机器是多核CPU，那么除以核数，就是每个核的load average。单核的load average小于1，说明CPU的负载较轻；单核的load average等于1，说明CPU的负载正常。单核的load average大于1，说明在运行队列中的进程数大于1，也就是有进程在等待CPU调度，当然这种情况下，CPU是超负载的。</p><h1 id="top中-CPU理解"><a href="#top中-CPU理解" class="headerlink" title="top中%CPU理解"></a>top中%CPU理解</h1><p>对于多核CPU，在Irix mode模式下，显示的是该进程占用一个核的计算时间的比例，也就说当前进程比较耗费资源的时候，那这个比例就大于了100%。例如200%就表示该进程用了两个核。在Solaris mode模式下，是在将进程占用的单核的CPU比例除以总核数。也就是说分摊到每个核上面的负载。</p><p>总之，无论在那个模式下，这个比例就是指以一个核的计算资源为基数的。一个体现的是总的消耗，一个体现的是分摊到各个核之后每个核的消耗。</p><h1 id="CPU的iowait-wait-IO-wa时间"><a href="#CPU的iowait-wait-IO-wa时间" class="headerlink" title="CPU的iowait/wait IO/wa时间"></a>CPU的iowait/wait IO/wa时间</h1><p>iowait/wait IO/wa等，表示某些进程已经获取了CPU的时间片，但由于磁盘IO性能低，或进程IO请求过多超过了磁盘的处理能力，那么CPU就会等待IO完成，这段时间其实CPU是空闲的，这个CPU消耗就称为CPU的iowait/wait IO/wa时间。虽然CPU在waitIO时，CPU是空闲的，但这时的CPU资源也不能分配给其他的进程。</p><h1 id="top命令的常用用法"><a href="#top命令的常用用法" class="headerlink" title="top命令的常用用法"></a>top命令的常用用法</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top -b -n 1     <span class="comment">#-b参数开启top的batch mode，也即top像普通命令一样，直接在控制台输出结果，而不是交互模式。-n表示top命令刷新的次数，-n 2表示刷新两次，-n 1表示刷新一次。使用top -b -n 1 &gt; output可以将top命令的结果写入到文件中。</span></span><br><span class="line">top -H -b -n 1  <span class="comment">#查看一台机器上完整的进程和线程信息，-H表示开启线程信息</span></span><br><span class="line">top -H -p &#123;pid&#125; <span class="comment">#显示一个进程的所有thread</span></span><br></pre></td></tr></table></figure><p>另外，<code>pstree -p {pid}</code>也可以显示一个进程的子进程以及线程的信息。</p><h1 id="闲杂"><a href="#闲杂" class="headerlink" title="闲杂"></a>闲杂</h1><p>（1）在top视图中，可以使用P和M直接进行cpu和mem的使用率列进行排序，和用h中的操作是一样的.</p><p>（2）可以使用<code>top -p pid</code>来监视进程号为pid的进程</p><p>学习资料参考于：<br><a href="http://www.penglixun.com/tech/system/how_to_calc_load_cpu.html" target="_blank" rel="noopener">http://www.penglixun.com/tech/system/how_to_calc_load_cpu.html</a><br><a href="http://heipark.iteye.com/blog/1340384" target="_blank" rel="noopener">http://heipark.iteye.com/blog/1340384</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中流量控制内核模块Traffic Control及tc命令的学习</title>
      <link href="/2018/02/24/Linux%E4%B8%AD%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97Traffic-Control%E5%8F%8Atc%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/02/24/Linux%E4%B8%AD%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97Traffic-Control%E5%8F%8Atc%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="TC内核模块及tc工具简介"><a href="#TC内核模块及tc工具简介" class="headerlink" title="TC内核模块及tc工具简介"></a>TC内核模块及tc工具简介</h1><p>在传统的TCP/IP网络的路由器中，所有的IP数据包的传输都是采用FIFO（先进先出），尽最大努力传输的处理机制。在早期网络数据量和关键业务数据不多的时候，并没有体现出非常大的缺点，路由器简单的把数据报丢弃来处理拥塞。但是随着计算机网络的发展， 数据量的急剧增长，以及多媒体，VOIP数据等对延时要求高的应用的增加。路由器简单丢弃数据包的处理方法已经不再适合当前的网络。单纯的增加网络带宽也不能从根本上解决问题。所以网络的开发者们提出了服务质量的概念。概括的说：就是针对各种不同需求，提供不同服务质量的网络服务功能。提供QoS能力将是对未来IP网络的基本要求。Linux内核网络协议栈从2.2.x开始，就实现了对服务质量的支持模块，即从内核的层面支持QOS，具体的代码位于net/sched/目录。在linux里面，对这个内核功能模块的称呼是Traffic Control，简称TC。简单来说，TC就是Linux进行流量控制的工具。</p><p>在Linux中，Traffic Control提供了一个tc命令工具，可以用来查看和配置Traffic Control内核模块。</p><h1 id="流量控制的处理对象"><a href="#流量控制的处理对象" class="headerlink" title="流量控制的处理对象"></a>流量控制的处理对象</h1><p>Traffic Control内核模块通过三种对象来进行流量控制，分别是qdisc（排队规则）、class（类别）和filter（过滤器）。</p><p>Traffic Control模块进行流量控制的基础是队列(qdisc)，每个网卡都与一个队列(qdisc)相联系，每当内核需要将报文分组从网卡发送出去，都会首先将该报文分组添加到该网卡所配置的队列中，由该队列决定报文分组的发送顺序。然后，内核会按照队列的顺序尽可能多地从qdisc里面取出数据包，把它们交给网络适配器驱动模块。</p><p>有些队列的功能是非常简单的，它们对报文分组实行先来先走的策略，我们把这些简单的队列称为不可分类（Classless）的队列。而有些队列则功能复杂，会将不同的报文分组进行排队、分类，并根据不同的原则，以不同的顺序发送队列中的报文分组。为实现这样的功能，这些复杂的队列需要使用不同的过滤器(Filter)来把报文分组分成不同的类别(Class)，我们把这些复杂的队列称为可分类(Classiful)的队列。通常，要实现功能强大的流量控制，可分类的队列是必不可少的。因此，类别(Class)和过滤器(Filter)也是流量控制的另外两个重要的基本概念。</p><p>下图是可分类队列的概念图：</p><p><img src="/images/traffic_control_1_1.png" alt></p><p>由上图可以看出，类别(Class)和过滤器(Filter)都是队列的内部结构，并且可分类的队列可以包含多个类别，同时，一个类别又可以进一步包含有子队列，或者子类别。所有进入该类别的报文分组可以依据不同的原则放入不同的子队列或子类别中，以此类推。而过滤器(Filter)是队列用来对数据报文进行分类的工具，它决定一个数据报文将被分配到哪个类别中。</p><p>下面分别简单介绍下qdisc（排队规则）、class（类别）和filter（过滤器）：</p><p>（1）qdisc</p><p>qdisc，英文全称为queueing discipline。qdisc分成不可分类的qdisc和可分类的qdisc两种。</p><p>不可分类的qdisc的有：</p><ul><li>[p|b]fifo</li></ul><p>使用最简单的qdisc，纯粹的先进先出。只有一个参数limit，用来设置队列的长度。pfifo是以数据包的个数为单位。bfifo是以字节数为单位。</p><ul><li>pfifo_fast</li></ul><p>在编译内核时，如果打开了高级路由器(Advanced Router)编译选项，pfifo_fast就是系统的标准QDISC。它的队列包括三个波段(band)。在每个波段里面，使用先进先出规则。而三个波段(band)的优先级也不相同，band 0的优先级最高，band 2的最低。如果band里面有数据包，系统就不会处理band 1里面的数据包，band 1和band 2之间也是一样。数据包是按照服务类型(Type of Service,TOS)被分配多三个波段(band)里面的。</p><ul><li>red</li></ul><p>red是Random Early Detection(随机早期探测)的简写。如果使用这种QDISC，当带宽的占用接近于规定的带宽时，系统会随机地丢弃一些数据包。它非常适合高带宽应用。</p><ul><li>sfq</li></ul><p>sfq是Stochastic Fairness Queueing的简写。它按照会话(session–对应于每个TCP连接或者UDP流)为流量进行排序，然后循环发送每个会话的数据包。</p><ul><li>tbf</li></ul><p>tbf是Token Bucket Filter的简写，适合于把流速降低到某个值。</p><p>可分类的qdisc的有：</p><ul><li>CBQ</li></ul><p>CBQ是Class Based Queueing(基于类别排队)的缩写。它实现了一个丰富的连接共享类别结构，既有限制(shaping)带宽的能力，也具有带宽优先级管理的能力。带宽限制是通过计算连接的空闲时间完成的。空闲时间的计算标准是数据包离队事件的频率和下层连接(数据链路层)的带宽。</p><ul><li>HTB</li></ul><p>HTB是Hierarchy Token Bucket的缩写。通过在实践基础上的改进，它实现了一个丰富的连接共享类别体系。使用HTB可以很容易地保证每个类别的带宽，虽然它也允许特定的类可以突破带宽上限，占用别的类的带宽。HTB可以通过TBF(Token Bucket Filter)实现带宽限制，也能够划分类别的优先级。</p><ul><li>PRIO</li></ul><p>PRIO QDisc不能限制带宽，因为属于不同类别的数据包是顺序离队的。使用PRIO QDisc可以很容易对流量进行优先级管理，只有属于高优先级类别的数据包全部发送完毕，才会发送属于低优先级类别的数据包。为了方便管理，需要使用iptables或者ipchains处理数据包的服务类型(Type Of Service,ToS)。</p><p>（2）Class</p><p>（3）Filter</p><h1 id="流量控制对象的命名规则"><a href="#流量控制对象的命名规则" class="headerlink" title="流量控制对象的命名规则"></a>流量控制对象的命名规则</h1><p>所有的qdisc、类和过滤器都有ID。ID可以手工设置，也可以有内核自动分配。ID由一个主序列号和一个从序列号组成，两个数字用一个冒号分开。 </p><p>（1）qdisc</p><p>一个qdisc会被分配一个主序列号，叫做句柄(handle)，然后把从序列号作为类的命名空间。句柄采用像10:这样的表达方式。 备注队列的从序号默认是0，所以一般可以省略从序列号，例如队列1:和1:0其实是等价的。</p><p>（2）类(CLASS)</p><p>在同一个qdisc里面的类分享这个qdisc的主序列号，但是每个类都有自己的从序列号，叫做类识别符(classid)。</p><p>（3）过滤器(FILTER)</p><p>过滤器的ID有三部分，只有在对过滤器进行散列组织才会用到。详情请参考tc-filters手册页。</p><h1 id="tc工具配置的基本步骤"><a href="#tc工具配置的基本步骤" class="headerlink" title="tc工具配置的基本步骤"></a>tc工具配置的基本步骤</h1><p>在Linux中，流量控制都是通过TC这个工具来完成的。通常，要对网卡进行流量控制的配置，需要进行如下的步骤：</p><p>（1）为网卡配置一个队列</p><p>（2）在该队列上建立分类</p><p>（3）根据需要建立子队列和子分类</p><p>（4）为每个分类建立过滤器</p><p>我的理解是，filter圈定满足一定规则的所有数据包，然后将这些数据包引入到某一个类Class中（class中会设定非常多的流量控制策略），然后会关联到一个队列qdisc中（qdisc中实现一些数据包排队的算法）</p><h1 id="tc命令的使用方法"><a href="#tc命令的使用方法" class="headerlink" title="tc命令的使用方法"></a>tc命令的使用方法</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc  [ add | change | replace | link ] dev DEV [ parent qdisc-id | root ] [ handle qdisc-id ] qdisc [ qdisc  specific parameters ]</span><br><span class="line">tc class [ add | change | replace ] dev DEV parent qdisc-id [ classid class-id ] qdisc [ qdisc  specific  parameters ]</span><br><span class="line">tc filter  [ add | change | replace ] dev DEV [ parent qdisc-id | root ] protocol protocol prio priority filtertype [ filtertype specific parameters ] flowid flow-id</span><br><span class="line">tc [ FORMAT ] qdisc show [ dev DEV ]</span><br><span class="line">tc [ FORMAT ] class show dev DEV</span><br><span class="line">tc filter show dev DEV</span><br><span class="line">tc [ -force ] [ -OK ] -b[atch] [ filename ]</span><br></pre></td></tr></table></figure><p>常用的命令举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc list dev eth0        <span class="comment">#查看指定网卡eth0上的所有队列qdisc</span></span><br><span class="line">tc class list dev eth0        <span class="comment">#查看指定网卡eth0上的所有过滤器class</span></span><br><span class="line">tc filter list dev eth0       <span class="comment">#查看指定网卡eth0上的所有过滤器filter</span></span><br><span class="line">tc -s -d qdisc show dev eth0  <span class="comment">#查看指定网卡eth0的qdisc的详细的工作状态，其中-s表示统计数据，-d表示详细内容</span></span><br><span class="line">tc -s -d class show dev eth0  <span class="comment">#查看指定网卡eth0的class的详细的工作状态，其中-s表示统计数据，-d表示详细内容</span></span><br><span class="line">tc -s -d filter show dev eth0 <span class="comment">#查看指定网卡eth0的filter的详细的工作状态，其中-s表示统计数据，-d表示详细内容</span></span><br></pre></td></tr></table></figure><h1 id="tc进行流量控制的举例"><a href="#tc进行流量控制的举例" class="headerlink" title="tc进行流量控制的举例"></a>tc进行流量控制的举例</h1><p>假设eth0出口有100mbit/s的带宽，分配给WWW、E-mail和Telnet三种数据流量，其中分配给WWW的带宽为40Mbit/s，分配给Email的带宽为40Mbit/s，分配给Telnet的带宽为20Mbit/S。这里，我们以HTB队列为例，来讲述tc工具的使用，详细步骤如下：</p><p>（1）创建HTB队列</p><p>首先，需要为网卡eth0配置一个HTB队列，使用下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root handle 1: htb default 11</span><br></pre></td></tr></table></figure><p>备注：命令中的”add”表示要添加qdisc；“dev eth0”表示要操作的网卡为eth0；“root”表示为网卡eth0添加的是一个根队列；“handle 1:”表示队列的句柄为1:0；“htb”表示要添加的队列为HTB队列；命令最后的“default 11”是htb特有的队列参数，意思是所有未分类的流量都将分配给类别1:11。</p><p>（2）为根队列创建相应的类别</p><p>可以利用下面这三个命令为根队列1:0创建三个class类别，分别是1:11、1:12和1:13，它们分别占用40、40和20Mbit/s的带宽。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tc class add dev eth0 parent 1: classid 1:11 htb rate 40mbit ceil 40mbit   <span class="comment">#创建class，类识别符为1:11，其中1是与父qdisc的主序号一致</span></span><br><span class="line">tc class add dev eth0 parent 1: classid 1:12 htb rate 40mbit ceil 40mbit   <span class="comment">#创建class，类识别符为1:12，其中1是与父qdisc的主序号一致</span></span><br><span class="line">tc class add dev eth0 parent 1: classid 1:13 htb rate 20mbit ceil 20mbit  <span class="comment">#创建class，类识别符为1:13，其中1是与父qdisc的主序号一致</span></span><br></pre></td></tr></table></figure><p>备注：命令中，“parent 1:”表示类别class的父亲为根队列1: ；“classid 1:11”表示创建一个标识为1:11的类别；“rate 40mbit”表示系统将为该类别确保带宽40mbit；“ceil 40mbit”表示该类别的最高可占用带宽为40mbit。</p><p>（3）为各个类别设置过滤器</p><p>由于需要将WWW、E-mail、Telnet三种流量分配到三个类别，即上述1:11、1:12和1:13，因此，需要创建三个过滤器，如下面的三个命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip dport 80 0xffff flowid 1:11</span><br><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip dport 25 0xffff flowid 1:12</span><br><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip dport 23 oxffff flowid 1:13</span><br></pre></td></tr></table></figure><p>备注：“protocol ip”表示该过滤器应该检查报文分组的协议字段；“prio 1”表示它们对报文处理的优先级是相同的，对于不同优先级的过滤器，系统将按照从小到大的优先级顺序来执行过滤器，对于相同的优先级，系统将按照命令的先后顺序执行；“u32”说明这几个过滤器用到了u32选择器（命令中u32后面的部分）来匹配不同的数据流。以第一个命令为例，判断的是dport字段，如果该字段与Oxffff进行与操作的结果是80，则“flowid 1:11”表示将把该数据流分配给类别1:11。</p><h1 id="一个使用tc工具组成的流量控制脚本"><a href="#一个使用tc工具组成的流量控制脚本" class="headerlink" title="一个使用tc工具组成的流量控制脚本"></a>一个使用tc工具组成的流量控制脚本</h1><p>附上如下为工作中用到tc工具编写的一个shell流量控制脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.清空队列</span></span><br><span class="line">tc qdisc del dev eth0 root</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加htb队列</span></span><br><span class="line">tc qdisc add dev eth0 root handle 1: htb default 30</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.添加class</span></span><br><span class="line">tc class add dev eth0 parent 1:  classid 1:1  htb rate 1000mbit burst 10mbit</span><br><span class="line">tc class add dev eth0 parent 1:1 classid 1:10 htb rate 1000mbit burst 5mbit</span><br><span class="line">tc class add dev eth0 parent 1:1 classid 1:20 htb rate 1mbit burst 10k</span><br><span class="line">tc class add dev eth0 parent 1:1 classid 1:30 htb rate 1mbit burst 10k</span><br><span class="line">tc class add dev eth0 parent 1:1 classid 1:40 htb rate 300mbit burst 1mbit</span><br><span class="line"></span><br><span class="line">4.为子类别添加子队列</span><br><span class="line">tc qdisc add dev eth0 parent 1:10 handle 10: sfq perturb 10</span><br><span class="line">tc qdisc add dev eth0 parent 1:20 handle 20: sfq perturb 10</span><br><span class="line">tc qdisc add dev eth0 parent 1:30 handle 30: sfq perturb 10</span><br><span class="line">tc qdisc add dev eth0 parent 1:40 handle 40: sfq perturb 10</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.添加filter</span></span><br><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 2 u32 match ip dst 10.13.85.177/32  flowid 1:30</span><br><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 2 u32 match ip dst 10.13.91.52/32  flowid 1:30</span><br><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 2 u32 match ip src 10.13.91.52/32  flowid 1:30</span><br><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 2 u32 match ip dst 10.13.91.53/32  flowid 1:20</span><br><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 2 u32 match ip src 10.13.91.53/32  flowid 1:20</span><br><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 100 u32 match ip dst 0.0.0.0/0  flowid 1:40</span><br><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 100 u32 match ip src 0.0.0.0/0  flowid 1:40</span><br><span class="line"></span><br><span class="line"><span class="comment">#6.查看统计信息</span></span><br><span class="line">tc qdisc list dev eth0</span><br><span class="line">tc filter list dev eth0</span><br><span class="line">tc -s -d class  show dev eth0</span><br><span class="line">tc -s -d filter show dev eth0</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://www.ibm.com/developerworks/cn/linux/kernel/l-qos/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/kernel/l-qos/</a><br><a href="https://www.ibm.com/developerworks/cn/linux/1412_xiehy_tc/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/1412_xiehy_tc/index.html</a><br><a href="http://blog.csdn.net/qinyushuang/article/details/46611709" target="_blank" rel="noopener">http://blog.csdn.net/qinyushuang/article/details/46611709</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下网络排查之ping|traceroute|mtr工具</title>
      <link href="/2018/02/24/Linux%E4%B8%8B%E7%BD%91%E7%BB%9C%E6%8E%92%E6%9F%A5%E4%B9%8Bping-traceroute-mtr%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/02/24/Linux%E4%B8%8B%E7%BD%91%E7%BB%9C%E6%8E%92%E6%9F%A5%E4%B9%8Bping-traceroute-mtr%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h1><p>ping使用了ICMP回送请求和回送应答报文。ping工具发出去的数据包没有通过tcp/udp协议，但是要经过ip协议。ping命令计算的时间是数据包的往返总时间。</p><p>ping命令每一个发出一个探测包，会指定一个连续递增的icmp_seq编号，所以在ping的结果中，每一行都会显示icmp_seq编号。当网络有丢包时，即客户端没有收到ping的响应包，那么就会导致ping的结果中icmp_seq编号不连续。</p><p><img src="/images/ping_1_1.png" alt></p><p>ping命令常用的选项如下：</p><pre><code>-c num        #表示使用ping发出去num个数据包-n            #表示ping的输出中包含主机信息的都用ip表示，不在进行ip和主机名之间的映射，那样ping的响应速度会更快-s packetsize #指定ping发出去的数据包的大小，单位是B.  如果不配置此选项将默认为56B-t ttl        #设定数据包在网络上传输的Time To Live（TTL）生命周期-f            #快速ping，Flood ping，发送接收ICMP Echo报文的频率快了非常多</code></pre><p>举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ping -c 3 -s 512 www.baidu.com  <span class="comment">#表示向www.baidu.com发送3个512B大小的数据包，来进行网络探测</span></span><br><span class="line">ping -I 10.21.70.25 10.52.10.21 <span class="comment">#一台服务器上配置了多个IP，可以指定某一个IP作为源IP。本例源IP为10.21.70.25，向10.52.10.21发起ping探测</span></span><br><span class="line">ping -f www.baidu.com           <span class="comment">#ping -f是快速ping，也就是非常快速地向目的端发送ICMP报文。当发出一个ICMP报文时，会在终端显示一个点，同时当收到一个ICMP报文响应时，就是在终端上删除一个点。因此使用ping -f时，终端显示的点号的数量，其实就是丢包的数量。</span></span><br></pre></td></tr></table></figure><p>备注：关于ping工具，有一个线上问题案例，就是ping某个域名很慢，但是ping该域名下的IP却很快。这是因为，执行<code>ping www.xxx.com</code>时，即做正向解析也会做IP的反向解析，因此ping域名慢的问题往往可能是IP到域名的方向解析出了问题导致。我们在执行ping命令时，加上-n选项就不会做IP的反向解析啦，可以暂时解决这个问题。</p><h1 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h1><p>traceroute也是使用ICMP协议，使用了ICMP的时间超过差错差错报告报文以及ICMP终点不可达报文。对于ICMP协议，其原理为：</p><p><img src="/images/traceroute_1_1.png" alt></p><p>traceroute在探测网络时，每一个TTL轮次，缺省情况下会发送3个探测包。例如当traceroute把TTL设置为2时，它默认会发三个探测包。所以在traceroute的结果中，每一行有三个响应延迟值，分别对应三次探测。另外，每个TTL的三次探测到路由器，并不一定是同一个哦，因此在traceroute结果中每一行可能有多个ip哦。另外，当某次探测没有得到响应时，traceroute结果中就会显示星号（*）.</p><p><img src="/images/traceroute_1_2.png" alt></p><p>traceroute的重要选项有：</p><pre><code>-U   #使用UDP协议来探测，这是默认的检测协议。  -I   #使用ICMP协议来探测  -T   #使用TCP协议来探测  </code></pre><p>使用举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.baidu.com               <span class="comment">#向www.baidu.com发起traceroute探测</span></span><br><span class="line">traceroute -s 10.21.70.25 10.52.10.21  <span class="comment">#一台服务器上配置了多个IP，可以指定某一个IP作为源IP。本例中指定源IP为10.21.70.25，向10.52.10.21发起traceroute探测</span></span><br></pre></td></tr></table></figure><p>备注：使用traceroute返回的每行信息中有三个时间值，那是因为对于每个节点或者路由器，源端发了三次探测请求。</p><h1 id="mtr"><a href="#mtr" class="headerlink" title="mtr"></a>mtr</h1><p>在Linux中有一个更好的网络连通性判断工具，它可以结合ping | nslookup | tracert 来判断网络的相关特性，这个命令就是mtr.</p><p>使用格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr [options] hostname</span><br></pre></td></tr></table></figure><p>常用的选项：</p><pre><code>-r      #将mtr设置为报告模式，追踪结果以报告模式输出。若没有-r显现，那么将进入mtr的实时交互模式-c num  #定义追踪的次数，每次是1s，且-c必须和-r配合使用，默认的10次</code></pre><p>使用举例：</p><p>（1）mtr的实时显示模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr 202.108.33.94</span><br></pre></td></tr></table></figure><p>（2）mtr的报告模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@10.10.90.97 ~]<span class="comment"># mtr -r 202.108.33.94  </span></span><br><span class="line">FOCUS9097                         Snt: 10    Loss%  Last   Avg  Best  Wrst StDev  </span><br><span class="line">220.181.61.252                                0.0%   6.8   3.3   1.8   7.4   2.2  </span><br><span class="line">220.181.17.217                                0.0%   0.4   0.5   0.4   0.7   0.1  </span><br><span class="line">220.181.16.17                                 0.0%   0.6   0.5   0.5   0.6   0.0  </span><br><span class="line">202.97.53.14                                 10.0%   0.7   0.7   0.7   0.8   0.0  </span><br><span class="line">219.158.35.1                                  0.0%   0.8   0.8   0.8   0.9   0.0  </span><br><span class="line">219.158.5.81                                  0.0%   1.2   1.3   1.2   1.6   0.1  </span><br><span class="line">123.126.0.138                                 0.0%   1.2   1.1   1.1   1.3   0.1  </span><br><span class="line">61.148.153.126                                0.0%   1.9  10.5   1.5  89.9  27.9  </span><br><span class="line">61.148.143.22                                 0.0%   1.5   1.6   1.5   1.7   0.0  </span><br><span class="line">210.74.178.198                                0.0%   1.6   1.6   1.5   1.9   0.1  </span><br><span class="line">202.108.33.94                                 0.0%   1.5   1.5   1.4   1.5   0.0</span><br></pre></td></tr></table></figure><p>输出解释：</p><pre><code>第一列：显示的是IP地址和本机域名，这点和tracert很像第二列：snt:10 设置追踪的次数，默认值是10 可以通过参数 -c来定制，例如mtr -r -c 15 202.108.33.94第三列：Loss: 是显示的每个对应IP的丢包率第四列：Last: 显示的最近一次的返回时延第五列：Avg : 是平均值 这个应该是发送ping包的平均时延第六列：Best: 是最好或者说时延最短的第七列：Wrst: 是最差或者说时延最常的第八列：StDev: 是标准偏差</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在苹果手机上SSH模拟终端Termius</title>
      <link href="/2018/02/24/%E5%9C%A8%E8%8B%B9%E6%9E%9C%E6%89%8B%E6%9C%BA%E4%B8%8ASSH%E6%A8%A1%E6%8B%9F%E7%BB%88%E7%AB%AFTermius/"/>
      <url>/2018/02/24/%E5%9C%A8%E8%8B%B9%E6%9E%9C%E6%89%8B%E6%9C%BA%E4%B8%8ASSH%E6%A8%A1%E6%8B%9F%E7%BB%88%E7%AB%AFTermius/</url>
      
        <content type="html"><![CDATA[<h1 id="Termius"><a href="#Termius" class="headerlink" title="Termius"></a>Termius</h1><p>Termius是类似于SecureCRT/XShell的终端登陆工具，支持SSH/Telnet协议。在苹果手机上Termius的操作界面如下：</p><p><img src="/images/iphone_1_1.png" alt></p><h1 id="Termius的一些使用小技巧"><a href="#Termius的一些使用小技巧" class="headerlink" title="Termius的一些使用小技巧"></a>Termius的一些使用小技巧</h1><p>（1）双击屏幕，相当于TAB键，可以进行命令提示和补全。</p><p>（2）点击上图中红框按钮，然后再苹果上滑动，可以模拟上、下、左、右以及PageUP/PageDOWN键。</p>]]></content>
      
      
      <categories>
          
          <category> 杂货铺 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安卓模拟器的简介和使用</title>
      <link href="/2018/02/23/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/23/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="安卓模拟器"><a href="#安卓模拟器" class="headerlink" title="安卓模拟器"></a>安卓模拟器</h1><p>目前来说，网上有很多种安卓模拟器可以使用，例如夜神安卓模拟器、逍遥安卓模拟器等。通过在PC上安装安卓模拟器，就可以在电脑上模拟安卓手机的操作，安装和使用各种Android APP。本人已体验过夜神安卓模拟器的安装和使用。下面是安装成功并启动后的模拟器界面：</p><p><img src="/images/android_1_1.png" alt></p><h1 id="夜神安卓模拟器安装和使用过程的一些问题"><a href="#夜神安卓模拟器安装和使用过程的一些问题" class="headerlink" title="夜神安卓模拟器安装和使用过程的一些问题"></a>夜神安卓模拟器安装和使用过程的一些问题</h1><p>（1）安装安卓模拟器前，需要关闭Windows系统的Hyper-V功能，否则启动模拟器会导致系统蓝屏。可以在控制面板 | 程序和功能 | 启用和关闭Windows功能中去掉Hyper-V前的复选框，并重启操作系统即可。</p><p>（2）待补充</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS包管理工具npm</title>
      <link href="/2018/02/05/JS%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7npm/"/>
      <url>/2018/02/05/JS%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7npm/</url>
      
        <content type="html"><![CDATA[<h1 id="npm简介"><a href="#npm简介" class="headerlink" title="npm简介"></a>npm简介</h1><p>npm，全称为node package manager，是Node的模块管理器，也可以说是JavaScript的包管理工具。npm体系有npm工具客户端和npm包仓库两部分。npm包官方仓库为<code>https://www.npmjs.com</code>，使用npm客户端工具可以在本地安装、删除JavaScript包，功能非常强大。</p><h1 id="npm客户端工具的安装"><a href="#npm客户端工具的安装" class="headerlink" title="npm客户端工具的安装"></a>npm客户端工具的安装</h1><p>npm客户端工具并不需要单独安装。安装完nodejs后，会连带将npm工具安装好。通常来说，这样得到的npm版本比较低。我们可以通过如下命令来升级npm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm@latest -g</span><br></pre></td></tr></table></figure><h1 id="npm工具的一些常用操作命令"><a href="#npm工具的一些常用操作命令" class="headerlink" title="npm工具的一些常用操作命令"></a>npm工具的一些常用操作命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">npm install express -g          <span class="comment">#安装npm包到全局目录</span></span><br><span class="line">npm install express             <span class="comment">#安装npm包到当前目录中的./node_modules</span></span><br><span class="line">npm install express@3.0.6       <span class="comment">#安装指定版本的npm包</span></span><br><span class="line">npm install express@latest      <span class="comment">#表示要下载最新的版本</span></span><br><span class="line">npm install express --save-dev  <span class="comment">#安装npm包到当前目录中的./node_modules中，并将依赖关系写入到当前目录的package.json的devDependencies中</span></span><br><span class="line">npm install express --save-prod <span class="comment">#安装npm包到当前目录中的./node_modules中，并将依赖关系写入到当前目录的package.json的dependencies中</span></span><br><span class="line">npm install express --no-save   <span class="comment">#安装npm包到当前目录中的./node_modules中，但不将依赖写入到devDependencies或dependencies中。npm install默认是带--save-prod的</span></span><br><span class="line">npm install                     <span class="comment">#若获取到一个npm package源码，执行npm install可以安装该项目所有的依赖</span></span><br><span class="line">npm uninstall express           <span class="comment">#卸载npm包</span></span><br><span class="line"></span><br><span class="line">npm update express              <span class="comment">#升级npm包</span></span><br><span class="line">npm search express              <span class="comment">#搜索npm包</span></span><br><span class="line"></span><br><span class="line">npm init          <span class="comment">#初始化，生成package.json文件</span></span><br><span class="line">npm adduser       <span class="comment">#向npm远程仓库注册用户</span></span><br><span class="line">npm publish       <span class="comment">#向npm远程仓库发布npm包</span></span><br><span class="line"></span><br><span class="line">npm list -g       <span class="comment">#查看全局安装了哪些npm包</span></span><br><span class="line">npm list          <span class="comment">#查看当前目录中安装了那些npm包</span></span><br><span class="line">npm list express  <span class="comment">#查看某个npm包的版本</span></span><br></pre></td></tr></table></figure><p>另外，关于npm install package@version的版本问题还有一个特殊注意的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install package@*       #表示安装最新的版本，相当于npm install package@latest</span><br><span class="line">npm install package@1.1.0   #表示安装指定的版本，本例中即1.1.0</span><br><span class="line">npm install package@~1.1.0  #表示满足&gt;=1.1.0 &amp;&amp; &lt; 1.2.0条件中最新的版本号</span><br><span class="line">npm install package@^1.1.0  #表示满足&gt;=1.1.0 &amp;&amp; &lt; 2.0.0条件中最新的版本号</span><br></pre></td></tr></table></figure><p>其中~和^两个前缀让人比较迷惑，简单的来说：</p><pre><code>~ 前缀表示，安装大于指定的这个版本，并且匹配到x.y.z中z最新的版本^ 前缀在^0.y.z时的表现和~0.y.z是一样的，然而^1.y.z的时候，就会匹配到y和z都是最新的版本</code></pre><h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>npm管理的JavaScript模块包中会包含一个package.json文件，该文件包括了该package包的名称、版本、作者、该包的依赖等等信息，如下为package.json常见的属性配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name             <span class="comment">#包名</span></span><br><span class="line">version          <span class="comment">#包的版本号</span></span><br><span class="line">description      <span class="comment">#包的描述</span></span><br><span class="line">homepage         <span class="comment">#包的官网url</span></span><br><span class="line">author           <span class="comment">#包的作者姓名</span></span><br><span class="line">contributors     <span class="comment">#包的其他贡献者姓名</span></span><br><span class="line">dependencies     <span class="comment">#依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在node_module目录下</span></span><br><span class="line">devDepandencies  <span class="comment">#开发环境依赖的npm包，例如测试用的npm包等</span></span><br><span class="line">repository       <span class="comment">#包代码存放的地方的类型，可以是git或svn，git可在Github 上</span></span><br><span class="line">main             <span class="comment">#main字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫express，然后用户安装它，然后require("express")</span></span><br><span class="line">keywords         <span class="comment">#关键字</span></span><br><span class="line">license          <span class="comment">#许可证</span></span><br><span class="line">scripts          <span class="comment">#定义npm script脚本，然后通过npm run *来执行</span></span><br></pre></td></tr></table></figure><h1 id="npm包script脚本"><a href="#npm包script脚本" class="headerlink" title="npm包script脚本"></a>npm包script脚本</h1><p>举例来说，如下是一个package.json的scripts脚本段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">        <span class="string">"build"</span>: <span class="string">"node build.js"</span> ,</span><br><span class="line">        <span class="string">"test"</span>: <span class="string">"test command here"</span>,</span><br><span class="line">        <span class="string">"xxoo"</span>: <span class="string">"xxoo command here"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过<code>npm run build</code>、<code>npm run test</code>、<code>npm run xxoo</code>来分别执行。</p><p>值得注意的是，npm scripts脚本段有两个默认的配置，如下（前提是目录下有server.js或node-gyp才可以）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"start"</span>: <span class="string">"node server.js"</span>，</span><br><span class="line"><span class="string">"install"</span>: <span class="string">"node-gyp rebuild"</span></span><br></pre></td></tr></table></figure><h1 id="npm闲杂问题"><a href="#npm闲杂问题" class="headerlink" title="npm闲杂问题"></a>npm闲杂问题</h1><p>（1）npm代理设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm search express --proxy http://10.17.29.112:3128</span><br></pre></td></tr></table></figure><p>详细参考于：<br><a href="http://www.cnblogs.com/youfeng365/p/5846674.html" target="_blank" rel="noopener">http://www.cnblogs.com/youfeng365/p/5846674.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript各个编程版本</title>
      <link href="/2018/02/05/JavaScript%E5%90%84%E4%B8%AA%E7%BC%96%E7%A8%8B%E7%89%88%E6%9C%AC/"/>
      <url>/2018/02/05/JavaScript%E5%90%84%E4%B8%AA%E7%BC%96%E7%A8%8B%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript各个编程版本"><a href="#JavaScript各个编程版本" class="headerlink" title="JavaScript各个编程版本"></a>JavaScript各个编程版本</h1><p>（1）原生JS</p><p>就是常说的JavaScript，也称为ECMAScript，即ES5.1版及以前的JS版本。</p><p>（2）ES6</p><p>ES6既是一个历史名词，也是一个泛指，含义是5.1版以后的JavaScript的下一代标准，涵盖了ES2015、ES2016、ES2017等等，其中ES20XX则是正式名称，特指该年发布的正式版本的语言标准。ECMAScript 6.0，简称ES6，正式名称是《ECMAScript 2015标准》，是JavaScript语言的下一代标准，已经在2015年6月正式发布了，它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><p>（3）TypeScript</p><p>微软开发的。</p><p>（4）CoffeeScript</p><p>（5）JSX</p><p>facebook React项目中定义的。</p><h1 id="各个JavaScript版本的关系"><a href="#各个JavaScript版本的关系" class="headerlink" title="各个JavaScript版本的关系"></a>各个JavaScript版本的关系</h1><p>其实ES6/TypeScript/CoffeeScript/JSX可以说都是基于原生JS的语法糖，它们能够实现的功能使用原生的JS同样可以完成。但是原生JS编写效率、学习成本等等有一定的问题。所以在当前的前端开发项目中，一般会选择ES6/TypeScript/CoffeeScript/JSX等其中的一种语言去开发，然后通过前端或服务端转码工具（如Babel）将其转换成原生的JS语法，浏览器才可以支持，否则浏览器会不完全支持。另外，ES官方每年都会发布一版ES，以ES+年份命名，例如ES2015、ES2016、ES2017等等。</p><h1 id="目前JavaScript编程规范迭代方式"><a href="#目前JavaScript编程规范迭代方式" class="headerlink" title="目前JavaScript编程规范迭代方式"></a>目前JavaScript编程规范迭代方式</h1><p>任何人都可以向标准委员会（又称TC39委员会）提案，要求修改语言标准。一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由TC39委员会批准。</p><pre><code>Stage 0 - Strawman（展示阶段）Stage 1 - Proposal（征求意见阶段）Stage 2 - Draft（草案阶段）Stage 3 - Candidate（候选人阶段）Stage 4 - Finished（定案阶段）</code></pre><p>一个提案只要能进入Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript当前的所有提案，可以在TC39的官方网站github.com/tc39/ecma262中查看。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于html中外链元素http/https的简写问题汇总</title>
      <link href="/2018/02/05/%E5%85%B3%E4%BA%8Ehtml%E4%B8%AD%E5%A4%96%E9%93%BE%E5%85%83%E7%B4%A0http-https%E7%9A%84%E7%AE%80%E5%86%99%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2018/02/05/%E5%85%B3%E4%BA%8Ehtml%E4%B8%AD%E5%A4%96%E9%93%BE%E5%85%83%E7%B4%A0http-https%E7%9A%84%E7%AE%80%E5%86%99%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="关于URL中协议的省略——相对URL"><a href="#关于URL中协议的省略——相对URL" class="headerlink" title="关于URL中协议的省略——相对URL"></a>关于URL中协议的省略——相对URL</h1><p>HTML和CSS代码中引用的图片、媒体、CSS和JS文件中的URL都可以去掉协议部分（http:和https:），比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.google-analytics.com/ga.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://www.google-analytics.com/ga.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>都可以换成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//www.google-analytics.com/ga.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只要是使用http/https这两种协议都可以省略。原因是可以节省一点文件体积（当然只是那么一点点），另外一个原因是可以解决混合内容(mix-content)的问题（即https页面中引用了http元素，造成mix-content问题）。</p><p>以<code>//</code>开头的叫做相对URL（protocol-relative URL），相关的标准可以看RFC 3986 Section 4.2。总之浏览器遇到相对URL，则会根据当前的网页协议，自动在<code>//</code>前面加上相同的协议。如当前网页是http访问，那么所有的相对引用<code>//</code>都会变成<code>http://</code>，若当前网页是https访问，那么所有的相对引用<code>//</code>都会变成<code>https://</code>。如果你在本地查看，协议就会变成<code>file://</code>。</p><h1 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h1><p>假设现在有如下的文件目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d:\dreamdu\exe\1.html</span><br><span class="line">d:\dreamdu\exe\first\2.html</span><br><span class="line">d:\dreamdu\exe\first\3.html</span><br><span class="line">d:\dreamdu\exe\first\second\4.html</span><br></pre></td></tr></table></figure><p>（1）相对路径<br>2.html和3.html在同一个文件夹下，如果2.html链接到3.html，可以在2.html中这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"3.html"</span>&gt;</span>同目录下文件间互相链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1.html是2.html和3.html的上级目录中的文件，如果2.html或3.html链接到1.html，可以在2.html或3.html中这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"../1.html"</span>&gt;</span>链接到上级目录中的文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>../ 代表一级上级目录(间隔一个目录) </p><p>../../代表二级上级目录(间隔两个目录)，比如4.html链接到1.html，可以在4.html中这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"../../1.html"</span>&gt;</span>链接到上级目录的上级目录中的文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.html和3.html是1.html的下级目录中的文件，如果在1.html中链接到2.html， 可以在1.html中这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"first/2.html"</span>&gt;</span>链接到下级目录(first)中的文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果在1.html中链接到4.html，可以在1.html中这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"first/second/4.html"</span>&gt;</span>链接到下级目录(first/second/)中的文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）绝对路径(Absolute Path)</p><p>绝对路径就是带有网址的路径，比如你有一个域名<a href="http://www.dreamdu.com，和一个网站空间，上面的四个文件就可以这么表示。" target="_blank" rel="noopener">www.dreamdu.com，和一个网站空间，上面的四个文件就可以这么表示。</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.dreamdu.com/exe/1.html"</span>&gt;</span>链接到1.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.dreamdu.com/exe/first/2.html"</span>&gt;</span>链接到2.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.dreamdu.com/exe/first/3.html"</span>&gt;</span>链接到3.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.dreamdu.com/exe/first/second/4.html"</span>&gt;</span>链接到4.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）根目录</p><p>使用根目录的方式表示的路径和绝对路径的表示方式相似，去掉前面的域名就可。比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/exe/1.html"</span>&gt;</span>链接到1.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/exe/first/2.html"</span>&gt;</span>链接到2.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://pandacafe.net/post/231" target="_blank" rel="noopener">http://pandacafe.net/post/231</a><br><a href="http://www.dreamdu.com/webbuild/relativepath_vs_absolutepath/" target="_blank" rel="noopener">http://www.dreamdu.com/webbuild/relativepath_vs_absolutepath/</a></p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BKM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS模块化编程规范AMD | CMD | CommonJS | ES6</title>
      <link href="/2018/02/05/JS%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83AMD-CMD-CommonJS-ES6/"/>
      <url>/2018/02/05/JS%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83AMD-CMD-CommonJS-ES6/</url>
      
        <content type="html"><![CDATA[<p>随着JS模块化编程的发展，处理模块之间的依赖关系成为了维护的关键，而原生的JavaScript是没有模块化编程的支持，直到ES6中才有了模块化编程的支持。社区中也有很多JS的模块化编程的规范，如AMD、CMD、CommonJS是目前最常用的三种模块化书写规范。</p><h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>CommonJS规范是诞生比较早的。NodeJS就采用了CommonJS。是这样加载模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clock = <span class="built_in">require</span>(<span class="string">'clock'</span>);</span><br><span class="line">clock.start();</span><br></pre></td></tr></table></figure><p>这种写法适合服务端，因为在服务器读取模块都是在本地磁盘，加载速度很快。但是如果在客户端，加载模块的时候有可能出现“假死”状况。比如上面的例子中clock的调用必须等待clock.js请求成功，加载完毕。那么，能不能异步加载模块呢？</p><h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p>AMD，英文全称为Asynchronous Module Definition，这种规范是异步的加载模块，requireJS应用了这一规范。先定义所有依赖，然后在加载完成后的回调函数中执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br></pre></td></tr></table></figure><p>用AMD写上一个模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'clock'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">clock</span>)</span>&#123;</span><br><span class="line">    clock.start();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>AMD虽然实现了异步加载，但是开始就把所有依赖写出来是不符合书写的逻辑顺序的，能不能像commonJS那样用的时候再require，而且还支持异步加载后再执行呢？</p><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>CMD，Common Module Definition，是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clock = <span class="built_in">require</span>(<span class="string">'clock'</span>);</span><br><span class="line">    clock.start();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。</p><p>AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</p><h1 id="ES6的模块化编程"><a href="#ES6的模块化编程" class="headerlink" title="ES6的模块化编程"></a>ES6的模块化编程</h1><p>（1）ES6模块编程简介</p><p>JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的require、Python的import，甚至就连CSS都有@import，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。ES6模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。</p><p>（2）export和import</p><p>ES6的模块功能主要由两个命令构成，即export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。说白了，export是显式地说明模块中有哪些变量、函数、类要暴露出来，用来给其他模块使用。而import是导入其他模块中被export的实体。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;  <span class="comment">//从./profile.js中导入模块接口firstName, lastName, year</span></span><br><span class="line"><span class="keyword">import</span> &#123;myMethod&#125; <span class="keyword">from</span> <span class="string">'util'</span>;  <span class="comment">//这里util是模块名，而不是一个js文件</span></span><br></pre></td></tr></table></figure><p>备注：import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js路径可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉JavaScript引擎该模块的位置。</p><p>（3）export default</p><p>使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.js, 使用export default导出默认的接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file2.js, import不用严格指定和export中同样的名字，可以随便地取一个名字，注意这里就不需要用花括号括起来了</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line">customName();</span><br></pre></td></tr></table></figure><p>（4）index.js</p><p>如果一个JS APP的目录结构为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|- reducers</span><br><span class="line">    |- index.js</span><br><span class="line">    |- test1.js</span><br><span class="line">    |- test2.js</span><br></pre></td></tr></table></figure><p>那么我们可以在另外一个JS文件中，使用<code>import * from &#39;/reducers&#39;</code>语句，可以自动导入index.js中的接口。其中*可以是任意的名字。</p><p>学习资料参考于：<br><a href="http://www.jianshu.com/p/09ffac7a3b2c" target="_blank" rel="noopener">http://www.jianshu.com/p/09ffac7a3b2c</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse使用小结</title>
      <link href="/2018/02/05/Eclipse%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/02/05/Eclipse%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Eclipse与MyEclipse"><a href="#Eclipse与MyEclipse" class="headerlink" title="Eclipse与MyEclipse"></a>Eclipse与MyEclipse</h1><p>MyEclipse是基于Eclipse的一个开发工具，它整合了一些插件并做了一些自己的开发。 使用MyEclipse开发J2EE程序会更加方便些。但它不是免费的，不过费用不是很高。Eclipse是Java的集成开发环境（IDE），当然Eclipse也可以作为其他开发语言的集成开发环境，如C，C++，PHP，和Ruby等。</p><p>Eclipse是开源免费的软件，MyEclipse是收费软件。</p><h1 id="Eclipse的变更历程"><a href="#Eclipse的变更历程" class="headerlink" title="Eclipse的变更历程"></a>Eclipse的变更历程</h1><p>从2006年起，Eclipse基金会每年都会安排同步发布。至今，同步发布主要在6月进行，并且会在接下来的9月及2月释放出SR1及SR2版本。具体如下所示：</p><p><img src="/images/eclipse_1_1.png" alt></p><h1 id="Eclipse的安装"><a href="#Eclipse的安装" class="headerlink" title="Eclipse的安装"></a>Eclipse的安装</h1><p>Eclipse是基于Java的可扩展开发平台，所以安装Eclipse前你需要确保你的电脑已安装JDK。</p><h1 id="Eclipse的透视图"><a href="#Eclipse的透视图" class="headerlink" title="Eclipse的透视图"></a>Eclipse的透视图</h1><p>Eclipse的透视图是一个包含一系列视图和内容编辑器的可视容器。</p><h1 id="Eclipse工程的JAVA构建路径Build-Path"><a href="#Eclipse工程的JAVA构建路径Build-Path" class="headerlink" title="Eclipse工程的JAVA构建路径Build Path"></a>Eclipse工程的JAVA构建路径Build Path</h1><p>Build Path是指定Java工程所包含的资源属性集合。在一个成熟的Java工程中，不仅仅有自己编写的源代码，还需要引用系统运行库（JRE）、第三方的功能扩展库、工作空间中的其他工程，甚至外部的类文件，所有这些资源都是被这个工程所依赖的，并且只有被引用后，才能够将该工程编译成功，而Build Path就是用来配置和管理对这些资源的引用的。Build Path一般包括：</p><pre><code>JRE运行库第三方的功能扩展库（`*.jar`格式文件）其他的工程其他的源代码或Class文件</code></pre><p><code>右键点击项目&gt;&gt;Properties&gt;&gt;Java Build Path</code>即可打开Java构建路径设置窗口，如下：</p><p><img src="/images/eclipse_1_2.png" alt></p><p>其中，</p><pre><code>Source选项，指定工程自身的源代码文件或配置文件。Projects选项，可以添加、编辑、移除当前项目所依赖的项目。Libraries选项，可以添加、编辑、移除当前项目所依赖的库文件。Order and Export选项，可以为当前项目已经添加进来的库进行排序，也可以设置当前项目导出时，库文件是否也跟随项目导出。</code></pre><p>例如引用jar包可以在Libraries选项卡中完成，在Libraries选项卡中我们可以通过点击<code>Add JARs</code>来添加Eclipse工作空间中存在的jar包或点击<code>External JARs</code>来引入其他文件中的jar包。</p><p>另外，在Libraries选项卡选择<code>Add Library</code>按钮，可以修改项目所使用的JRE版本哦。</p><h1 id="Eclipse插件安装"><a href="#Eclipse插件安装" class="headerlink" title="Eclipse插件安装"></a>Eclipse插件安装</h1><p>Eclipse插件安装有如下几种方式：</p><p>（1）点击Help菜单中的<code>Eclipse Marketplace</code>选项来查找插件，并安装。是在线安装。</p><p>（2）点击Help菜单上的<code>Install New Software</code>菜单项，输入插件的url地址即可安装插件。是在线安装。</p><p>（3）手动下载插件到本地并解压，压缩后得到两个文件夹（features和plugins），分别拷贝到%ECLIPSE_HOME%\目录下对应的features和plugins文件夹下，重新启动eclipse即可。</p><p>（4）手动下载插件到本地并解压，将解压后的文件直接拷贝到%ECLIPSE_HOME%\目录下dropins文件夹下。</p><h1 id="Eclipse快捷键设置及常用快捷键"><a href="#Eclipse快捷键设置及常用快捷键" class="headerlink" title="Eclipse快捷键设置及常用快捷键"></a>Eclipse快捷键设置及常用快捷键</h1><p>打开<code>Windows -&gt; Preferences -&gt; General -&gt; Keys</code>，即可设置Eclipse操作快捷键，另外可以使用<code>Ctrl+Shift+L</code>快速打开快捷键设置列表。常用的快捷键如下：</p><pre><code>Alt+/            #内容自动补全Ctrl+o           #显示类中方法和属性的大纲，能快速定位类的方法和属性Ctrl+/           #快速添加注释，能为光标所在行或所选定行快速添加注释或取消注释Ctrl+d           #删除当前行Ctrl+m           #窗口最大化和还原Ctrl+Shift+f     #格式化代码Ctrl+Shift+t     #查找工作空间（Workspace）构建路径中的可找到Java类文件Ctrl+Alt+UP/DOWN #复制当前行</code></pre><h1 id="Eclipse的Project-Facets设定"><a href="#Eclipse的Project-Facets设定" class="headerlink" title="Eclipse的Project Facets设定"></a>Eclipse的Project Facets设定</h1><p>在项目上右击点击Properties，选择Project Facets选项，会出现Project Facets设定界面如下：</p><p><img src="/images/eclipse_1_4.png" alt></p><p>Project Facets可理解为项目的特性，主流 IDE (Eclipse IDEA) 都提供了facet的配置。在Eclipse中，新建的Java Project都有一个默认的Java facet，那么Eclipse就只提供JavaSE项目支持，当你需要将该项目升级为Java web项目时，可以为项目添加Dynamic Web Module（就是一个支持Web的facet），这样Eclipse就会将项目结构调整为带有WebContent or WebRoot目录的标准结构且添加 deployment descriptor（web.xml）并调整默认的classpath，同时，如果你要用到javascript，可以对应地添加javascript facet，这样Eclipse就会为项目添加JavaScript相关的支持（构建、校验、提示等等），如果你的项目用到了Hibernate，则可以添加Jpa facet来让Eclipse提供对应的功能支持等等。尤其在Eclipse中创建Maven的web项目时，常会用到上面的配置，给项目添加动态web功能。</p><h1 id="Eclipse-Problems试图"><a href="#Eclipse-Problems试图" class="headerlink" title="Eclipse Problems试图"></a>Eclipse Problems试图</h1><p>点击<code>Windows-&gt;Show View-&gt;Problems</code>会打开Eclipse的Problems窗体，如下：</p><p><img src="/images/eclipse_1_5.png" alt></p><p>当我们Eclipse中的工程上出现“红叉”，但是又没有明确地提示错误信息时，我们就可以打开Eclipse的Problems窗体，查看详细的错误信息。</p><h1 id="Maven-WEB应用部署到本地Tomcat的方式"><a href="#Maven-WEB应用部署到本地Tomcat的方式" class="headerlink" title="Maven WEB应用部署到本地Tomcat的方式"></a>Maven WEB应用部署到本地Tomcat的方式</h1><p>（1）将webapps中的文件收到copy到Tomcat的webapps目录</p><p>（2）使用Eclipse的export功能，导出为WAR包，并将WAR包copy到webapps目录</p><p>（3）使用MyEclipse插件自动部署到本地Tomcat中</p><h1 id="Eclipse的Python开发环境配置"><a href="#Eclipse的Python开发环境配置" class="headerlink" title="Eclipse的Python开发环境配置"></a>Eclipse的Python开发环境配置</h1><p>（1）本机上安装Python，将Python配置到PATH环境变量中</p><p>（2）安装Eclipse，并安装PyDev插件即可</p><h1 id="Eclipse中的一些闲杂知识"><a href="#Eclipse中的一些闲杂知识" class="headerlink" title="Eclipse中的一些闲杂知识"></a>Eclipse中的一些闲杂知识</h1><p>（1）点击Windows | Show View | Progress即可打开Eclipse Progress窗格，效果如下：</p><p><img src="/images/eclipse_1_3.png" alt></p><p>在Eclipse Progress窗格中可以看到Eclipse当前正在处理的各种任务及任务状态。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA项目构建工具Maven技术调研</title>
      <link href="/2018/02/05/JAVA%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Maven%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/02/05/JAVA%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Maven%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h1><p>Apache Maven是一个软件（特别是Java软件）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（POM）概念，Maven利用一小段描述信息来管理一个项目的构建、报告和文档等。Maven也可被用于构建和管理各种项目，例如C#，Ruby，Scala和其他语言编写的项目。Maven曾是Jakarta项目的子项目，现为由Apache软件基金会主持的独立Apache项目。</p><p>备注：Maven同类别的工具有Ant以及gradle等。</p><h1 id="Windows平台下Maven的环境配置和搭建"><a href="#Windows平台下Maven的环境配置和搭建" class="headerlink" title="Windows平台下Maven的环境配置和搭建"></a>Windows平台下Maven的环境配置和搭建</h1><p>（1）安装JDK并配置JAVA环境变量</p><p>（2）Apache Maven上下载二进制安装包，解压即可，不需要安装哦</p><p>（3）为Maven配置系统环境变量</p><p>首先新建环境变量M2_HOME，值为Maven的部署路径；然后修改系统PATH变量，增加%M2_HOME/bin</p><p>（4）测试验证</p><p>在Windows的cmd中输入<code>mvn -v</code>即可。</p><h1 id="Maven管理的项目的目录结构"><a href="#Maven管理的项目的目录结构" class="headerlink" title="Maven管理的项目的目录结构"></a>Maven管理的项目的目录结构</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">|-src</span><br><span class="line">    |-main</span><br><span class="line">        |-java</span><br><span class="line">            |-package <span class="comment">#即用户的自己的代码，例如com.baidu.xxoomon等</span></span><br><span class="line">        |-resources   <span class="comment">#存放一些配置文件或静态资源文件，如模板文件、静态图片等</span></span><br><span class="line">            |-static</span><br><span class="line">            |-templates</span><br><span class="line">    |-<span class="built_in">test</span></span><br><span class="line">        |-java</span><br><span class="line">            |-package <span class="comment">#即用户的自己的代码</span></span><br><span class="line">        |-resources   <span class="comment">#存放测试需要用到的一些配置文件或静态资源文件，如模板文件、静态图片等</span></span><br><span class="line">            |-static</span><br><span class="line">            |-templates</span><br><span class="line">|-pom.xml     <span class="comment">#Maven的项目管理配置文件</span></span><br></pre></td></tr></table></figure><h1 id="使用Maven进行项目开发的流程"><a href="#使用Maven进行项目开发的流程" class="headerlink" title="使用Maven进行项目开发的流程"></a>使用Maven进行项目开发的流程</h1><p>（1）按照Maven项目的目录结构创建目录</p><p>（2）开发自己的代码</p><p>（3）新建pom.xml文件，并配置</p><p>（4）编译项目</p><p>cd到Maven项目根目录，然后执行<code>mvn compile</code>。</p><p>（5）执行单元测试</p><p>执行<code>mvn test</code>对项目进行单元测试，并生成测试报告。</p><p>（6）对项目进行打包</p><p><code>mvn package</code></p><h1 id="Maven中的一些概念"><a href="#Maven中的一些概念" class="headerlink" title="Maven中的一些概念"></a>Maven中的一些概念</h1><p>（1）坐标</p><p>坐标是由groupId，artifactId及version等组成。其中groupId为组织名，一般是“公司域名的反写+项目名”，例如com.baidu.xxoomon。artifaceId为项目模块在组织中的标识，一般为“项目名-模块名”，例如xxoomon-api。</p><p>（2）仓库</p><p>仓库分为本地仓库和远程仓库两个。</p><ul><li>本地仓库</li></ul><p>本地仓库是开发者本地的仓库，本地仓库在本机的${user.home}/.m2/repository目录中，即编译我们的项目时，就会将依赖安装到该目录中哦。</p><ul><li>远程仓库</li></ul><p>在本地仓库中若找不到对应的依赖，那么就会到maven的官方仓库中查找，然后下载到本地仓库中，供本地项目使用。maven中央仓库的地址为<a href="https://repo.maven.apache.org/maven2" target="_blank" rel="noopener">https://repo.maven.apache.org/maven2</a></p><p>（3）镜像仓库</p><p>maven的中央仓库是部署在国外的，国内访问有点慢。其实在国内有很多maven官方仓库的镜像仓库，我们可以将maven中央仓库修改为国内的镜像仓库，那么在安装依赖jar包就会快很多哦。具体可以在<code>${MAVEN_HOME}/conf/settings.xml</code>中设置，即在该配置文件的mirrors标签中添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven-central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven central<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="mvn常见的使用命令"><a href="#mvn常见的使用命令" class="headerlink" title="mvn常见的使用命令"></a>mvn常见的使用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn compile  <span class="comment">#编译项目，会在项目的根目录生成的target目录及生成字节码文件</span></span><br><span class="line">mvn <span class="built_in">test</span>     <span class="comment">#运行项目的测试用例</span></span><br><span class="line">mvn package  <span class="comment">#打包生成项目的jar文件</span></span><br><span class="line">mvn clean    <span class="comment">#删除编译生成class字节码文件以及项目jar文件等等，即删除由mvn compile命令生成的target目录</span></span><br><span class="line">mvn install  <span class="comment">#安装项目jar包到本地仓库中，然后再其他项目中可以直接在pom.xml中引入该jar包</span></span><br></pre></td></tr></table></figure><p>备注：这里是<code>mvn [options] [&lt;phase(s)&gt;]</code>的命令执行格式。</p><h1 id="使用archetype插件创建maven项目的目录结构"><a href="#使用archetype插件创建maven项目的目录结构" class="headerlink" title="使用archetype插件创建maven项目的目录结构"></a>使用archetype插件创建maven项目的目录结构</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> workspace &amp;&amp; mvn archetype:generate</span><br></pre></td></tr></table></figure><p>或者如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> worksapce &amp;&amp; mvn archetype:generate -DgroupId=组织名（公司域名的反写+项目名） </span><br><span class="line">                                       -DartifactId=项目名-模块名 </span><br><span class="line">                                       -Dversion=版本号 </span><br><span class="line">                                       -Dpackage=代码所存在的包名</span><br></pre></td></tr></table></figure><h1 id="pom-xml文件编写"><a href="#pom-xml文件编写" class="headerlink" title="pom.xml文件编写"></a>pom.xml文件编写</h1><p>pom.xml的完整的标签和结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- The Basics --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>...<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>...<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>...<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span>...<span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>...<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- Build Settings --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span>...<span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- More Project Information --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>...<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>...<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>...<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inceptionYear</span>&gt;</span>...<span class="tag">&lt;/<span class="name">inceptionYear</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span>...<span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span>...<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span>...<span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contributors</span>&gt;</span>...<span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- Environment Settings --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span>...<span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span>...<span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span>...<span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span>...<span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如下为一个pom.xml配置文件的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>公司域名反写+项目名<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>项目名-模块名<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>打包方式，默认为jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>项目描述名<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>项目地址<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>项目描述信息<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span>项目开发人员列表<span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span>许可证<span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span>组织描述信息<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>第三方库groupId<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>第三方库artifactId<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>第三方库版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        .....</span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>插件引入<span class="tag">&lt;<span class="name">plugin</span>&gt;</span><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="在Eclipse中配置Maven环境"><a href="#在Eclipse中配置Maven环境" class="headerlink" title="在Eclipse中配置Maven环境"></a>在Eclipse中配置Maven环境</h1><p>（1）按照第2部分在windows本地安装maven工具</p><p>（2）在Eclipse中选择<code>Window | Preferences | Maven | Installations</code>中，选择add按钮，将本地maven的安装路径配置进去，如下：</p><p><img src="/images/maven_1_1.png" alt></p><p>（3）如果需要的话，可以做一些Maven的用户设置，界面如下：</p><p><img src="/images/maven_1_2.png" alt></p><h1 id="在Eclipse中执行Maven命令"><a href="#在Eclipse中执行Maven命令" class="headerlink" title="在Eclipse中执行Maven命令"></a>在Eclipse中执行Maven命令</h1><p>在使用Eclipse开发Maven项目时，可以右击项目，并选择Run As菜单项，会出现类似如下的菜单，</p><p><img src="/images/maven_1_3.png" alt></p><p><img src="/images/maven_1_4.png" alt></p><p>其中<code>Maven build...</code>是用来添加自定义的运行方法；<code>Maven build</code>可以使用指定的运行方法来运行项目，若添加了多个运行方法，点击<code>Maven build</code>时，会弹出一个可以选择运行方法的窗口。另外，在<code>Run Configurations...</code>中可以配置更多的运行方法哦。</p><p>学习资料参考于：<br><a href="http://blog.csdn.net/u011939453/article/details/43017865" target="_blank" rel="noopener">http://blog.csdn.net/u011939453/article/details/43017865</a></p><h1 id="Maven-pom-xml中变量properties的使用"><a href="#Maven-pom-xml中变量properties的使用" class="headerlink" title="Maven pom.xml中变量properties的使用"></a>Maven pom.xml中变量properties的使用</h1><p>通过<code>&lt;properties&gt;</code>元素用户可以自定义一个或多个Maven属性，然后在POM的其他地方使用<code>${属性名}</code>的方式引用该属性，这种做法的最大意义在于消除重复和统一管理。Maven总共有6类属性，内置属性、POM属性、自定义属性、Settings属性、java系统属性和环境变量属性：</p><p>（1）内置属性</p><p>有两个常用内置属性，<code>${basedir}</code>表示项目跟目录，即包含pom.xml文件的目录；<code>${version}</code>表示项目版本。</p><p>（2）POM属性</p><p>用户可以使用该类属性引用POM文件中对应元素的值。如${project.artifactId}就对应了<project> <artifactid>元素的值，常用的POM属性包括：</artifactid></project></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$&#123;project.build.sourceDirectory&#125;     #项目的主源码目录，默认为src/main/java/</span><br><span class="line">$&#123;project.build.testSourceDirectory&#125; #项目的测试源码目录，默认为src/test/java/</span><br><span class="line">$&#123;project.build.directory&#125;     #项目构建输出目录，默认为target/</span><br><span class="line">$&#123;project.outputDirectory&#125;     #项目主代码编译输出目录，默认为target/classes/</span><br><span class="line">$&#123;project.testOutputDirectory&#125; #项目测试主代码输出目录，默认为target/testclasses/</span><br><span class="line">$&#123;project.groupId&#125;    #项目的groupId</span><br><span class="line">$&#123;project.artifactId&#125; #项目的artifactId</span><br><span class="line">$&#123;project.version&#125;    #项目的version,与$&#123;version&#125; 等价</span><br><span class="line">$&#123;project.build.finalName&#125; #项目打包输出文件的名称，默认为$&#123;project.artifactId&#125;-$&#123;project.version&#125;</span><br></pre></td></tr></table></figure><p>（3）自定义属性</p><p>用户可以自定义一些属性，举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;spring.version&gt;2.5&lt;/spring.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;depencencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactid&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactid&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactid&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/depencencies&gt;</span><br></pre></td></tr></table></figure><p>备注：这里配置了一个<code>spring.version</code>的属性变量，然后通过<code>${spring.version}</code>来引用该变量，这样就避免了在多个地方配置版本号。</p><p>（4）Settings属性</p><p>与POM属性同理，用户使用以<code>settings.</code>开头的属性引用<code>settings.xml</code>文件中的XML元素的值。</p><p>（5）Java系统属性</p><p>所有java系统属性都可以用Maven属性引用，如<code>${user.home}</code>指向了用户目录。</p><p>（6）环境变量属性</p><p>所有环境变量属性都可以使用以<code>env.</code>开头的Maven属性引用，如<code>${env.JAVA_HOME}</code>指代了<code>JAVA_HOME</code>环境变量的的值。</p><h1 id="Maven中dependency的scope作用域"><a href="#Maven中dependency的scope作用域" class="headerlink" title="Maven中dependency的scope作用域"></a>Maven中dependency的scope作用域</h1><ul><li>test</li></ul><p>表明该dependency在测试范围有效，在编译和打包时都不会使用这个依赖。</p><ul><li>compile</li></ul><p>表明该dependency在编译范围有效，在编译和打包时都会将依赖包含进去。</p><ul><li>provided</li></ul><p>在编译和测试的过程有效，最后生成war包时不会加入。以servlet-api依赖来说，tomcat等web服务器已经存在了，如果再打包会冲突 </p><ul><li>runtime</li></ul><p>在运行的时候依赖，在编译的时候不依赖 。</p><p>备注：若不指明dependency的scope，则默认的依赖范围是compile.</p><p>举例来说，如下为junit只在测试阶段使用该依赖，打包部署到生成环境时，则不会依赖junit包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;depencencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/depencencies&gt;</span><br></pre></td></tr></table></figure><h1 id="Maven生命周期与插件"><a href="#Maven生命周期与插件" class="headerlink" title="Maven生命周期与插件"></a>Maven生命周期与插件</h1><h2 id="Maven的生命周期与插件关系"><a href="#Maven的生命周期与插件关系" class="headerlink" title="Maven的生命周期与插件关系"></a>Maven的生命周期与插件关系</h2><p>一个完整的项目构建过程通常包括清理、编译、测试、打包、集成测试、验证、部署等步骤，Maven从中抽取了一套完善的、易扩展的生命周期。Maven中的生命周期是一个抽象概念，并没有实际的实现。而具体任务是由插件来完成。</p><h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><p>Maven定义了三套生命周期，分别是clean、default以及site。每个生命周期又包含了很多的阶段（phase）。三套生命周期相互独立，互不影响。但各个生命周期中的phase却是有执行顺序的，后面的phase依赖于前面的phase。执行某个phase时，其前面的phase会依顺序执行，但不会触发另外两套生命周期中的任何phase。</p><p>（1）clean生命周期</p><p>clean生命周期的各个阶段phase如下：</p><pre><code>pre-clean  #执行清理前的工作clean      #清理上一次构建生成的所有文件post-clean #执行清理后的工作</code></pre><p>（2）default生命周期</p><p>default生命周期是最核心的，它包含了构建项目时真正需要执行的所有步骤。其各个阶段phase如下：</p><pre><code>validateinitializegenerate-sourcesprocess-sourcesgenerate-resourcesprocess-resources  #复制和处理资源文件到target目录，准备打包compile            #编译项目的源代码；process-classesgenerate-test-sourcesprocess-test-sourcesgenerate-test-resourcesprocess-test-resourcestest-compile       #编译测试源代码；process-test-classestest        #运行测试代码；prepare-packagepackage     #打包成jar或者war或者其他格式的分发包；pre-integration-testintegration-testpost-integration-testverifyinstall     #将打好的包安装到本地仓库，供其他项目使用；deploy      #将打好的包安装到远程仓库，供其他项目使用；</code></pre><p>（3）site生命周期</p><pre><code>pre-sitesite        #生成项目的站点文档post-sitesite-deploy #发布生成的站点文档</code></pre><p>备注：上面的各个生命周期的每个阶段都是Maven从工程实践中抽象出来的一个流程概念，Maven本身并没有对每个phase要完成的具体工作去编写工具。而这个实际完成工作的工具正是下面介绍的插件。</p><h2 id="Maven插件"><a href="#Maven插件" class="headerlink" title="Maven插件"></a>Maven插件</h2><p>Maven的核心文件很小，主要的任务都是由插件来完成。进入<code>%本地仓库%\org\apache\maven\plugins</code>，可以看到一些下载好的插件如下：</p><p><img src="/images/maven_1_5.png" alt></p><p>Maven官网上提供了很多官方插件，开发者也可以自己开发自定义Maven插件。一些插件可以完成多种功能，则每一种功能称为该插件的一个目标goal，如maven-compiler-plugin插件不仅可以编译项目业务代码，也可以编译项目的测试代码，因此它至少有compile和testcompile两个goal。</p><p>Maven的插件是通过<code>groupId:artifactId:version</code>这种形式来定位的，和普通的Maven JAR是一样的。当要显示指定某个插件的某一goal时，就需要用到<code>groupId:artifactId:version:goal</code>这样的形式。如<code>org.apache.maven.plugins:maven-help-plugin:2.1</code>就是定位了一个插件，但是从用户使用上看是有些不方便的，因为一般的groupId、artifactId都会很长，字符太多。 所以就发明了目标前缀的概念，其实就是给<code>groupId:artifactId:version</code>起了一个简短的别名而已。比如，上面的<code>org.apache.maven.plugins:maven-help-plugin:2.1</code>插件的目标前缀是help，我们在使用的使用时候直接用<code>help:2.1</code>就可以啦。</p><h2 id="Maven生命周期的阶段和插件的目标绑定"><a href="#Maven生命周期的阶段和插件的目标绑定" class="headerlink" title="Maven生命周期的阶段和插件的目标绑定"></a>Maven生命周期的阶段和插件的目标绑定</h2><p>Maven的生命周期是抽象的，实际工作需要插件来完成，这一过程是通过将插件的目标（goal）绑定到生命周期的具体阶段（phase）来完成的。如将maven-compiler-plugin插件的compile目标绑定到default生命周期的compile阶段，完成项目的源代码编译：</p><p><img src="/images/maven_1_6.png" alt></p><p>Maven对一些生命周期的阶段（phase）默认绑定了插件的目标，所以我们不用在pom.xml中配置大量的生命周期和插件的绑定关系。当然用户可以根据需要将任何插件目标绑定到任何生命周期的阶段，如将maven-source-plugin的jar-no-fork目标绑定到default生命周期的package阶段，这样以后在执行mvn package命令打包项目时，在package阶段之后会执行源代码打包。</p><h2 id="Maven执行命令和生命周期以及插件是怎么关联起来的"><a href="#Maven执行命令和生命周期以及插件是怎么关联起来的" class="headerlink" title="Maven执行命令和生命周期以及插件是怎么关联起来的"></a>Maven执行命令和生命周期以及插件是怎么关联起来的</h2><p>Maven的命令执行格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn [options] [&lt;goal(s)&gt;] [&lt;phase(s)&gt;]</span><br></pre></td></tr></table></figure><p>其中options是执行mvn命令的一些选项参数。<code>[&lt;goal(s)&gt;]</code>和<code>[&lt;phase(s)&gt;]</code>代表了mvn的两种不同的执行方式。</p><p>（1）<code>mvn [options] [&lt;phase(s)&gt;]</code></p><p>这种形式其实就是我们使用最多的形式，如<code>mvn clean</code>，<code>mvn package</code>，<code>mvn clean package</code>等等。这里面是phase就是Maven生命周期的各个阶段phase。当我们执行<code>mvn xxxphase</code>时，maven首先判断xxxphase是属于哪个生命周期，确定了之后，从该生命周期的第一个phase开始按顺序依次执行到xxxphase。如<code>mvn package</code>，首先判断出package属于default生命周期，然后依次执行default生命周期的validate、initialize、generate-sources、process-sources、generate-resources、process-resources、compile、process-classes、generate-test-sources、process-test-sources、generate-test-resources、processtest-resources、test-compile、process-test-classes、test、prepare-package以及package阶段。</p><p>（2）<code>mvn [options] [&lt;goal(s)&gt;]</code></p><p>这里的goal就是插件中目标的概念，这与maven定义的生命周期没有什么关系，也就是不会像执行<code>mvn [options] [&lt;phase(s)&gt;]</code>那样，从一个生命周期的第一个phase开始执行。<code>mvn [options] [&lt;goal(s)&gt;]</code>表示直接在maven项目中执行某个插件的指定的目标goal。如<code>mvn archetype:generate</code>表示生成一个Maven项目结构，<code>mvn checkstyle:check</code>表示检查代码风格。</p><h1 id="Maven中profile多环境配置概念和应用"><a href="#Maven中profile多环境配置概念和应用" class="headerlink" title="Maven中profile多环境配置概念和应用"></a>Maven中profile多环境配置概念和应用</h1><p>在开发过程中，我们的软件会面对不同的运行环境，比如开发环境、测试环境、生产环境，而我们的软件在不同的环境中，有的配置可能会不一样，比如数据源配置、日志文件配置、以及一些软件运行过程中的基本配置，那每次我们将软件部署到不同的环境时，都需要修改相应的配置文件，这样来回修改，很容易出错，而且浪费劳动力。Maven提供了一种方便的解决这种问题的方案，就是profile功能。profile可以让我们定义一系列的配置信息，然后指定其激活条件。这样我们就可以定义多个profile，然后每个profile对应不同的激活条件和配置信息，从而达到不同环境使用不同配置信息的效果。假设我们的Maven工程有开发、测试和生产环境的配置，在打包项目时，我们期望在不同环境可以使用不同的配置文件。具体配置方法如下：</p><p>（1）为不同环境建立相应的配置文件</p><p><img src="/images/maven_1_7.png" alt></p><p>（2）在项目pom.xml添加如下三个profile配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>local<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profiles.proj.env</span>&gt;</span>local<span class="tag">&lt;/<span class="name">profiles.proj.env</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profiles.proj.env</span>&gt;</span>test<span class="tag">&lt;/<span class="name">profiles.proj.env</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>production<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profiles.proj.env</span>&gt;</span>production<span class="tag">&lt;/<span class="name">profiles.proj.env</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中profiles.proj.env是我们自定义的一个变量，名字可以随便取。</p><p>（3）在项目pom.xml中使用我们自定义的profiles.proj.env变量</p><p>我们可以在pom.xml中加入如下resources配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/$&#123;profiles.proj.env&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）执行mvn命令针对不同的环境打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn package -Plocal      <span class="comment">#为开发环境打包，会将src/main/resources/$&#123;profiles.proj.env&#125;替换成src/main/resources/local，从而加载开发环境的配置</span></span><br><span class="line">mvn package -Ptest       <span class="comment">#为测试环境打包，会将src/main/resources/$&#123;profiles.proj.env&#125;替换成src/main/resources/test，从而加载测试环境的配置</span></span><br><span class="line">mvn package -Pproduction <span class="comment">#为生成环境打包，会将src/main/resources/$&#123;profiles.proj.env&#125;替换成src/main/resources/production，从而加载生成环境的配置</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在pom.xml的profile的<code>&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</code>表示默认激活的是local，也就是直接执行<code>mvn package</code>将会开发环境打包。</p><h1 id="Maven构建多模块项目"><a href="#Maven构建多模块项目" class="headerlink" title="Maven构建多模块项目"></a>Maven构建多模块项目</h1><h2 id="Maven多模块项目简介"><a href="#Maven多模块项目简介" class="headerlink" title="Maven多模块项目简介"></a>Maven多模块项目简介</h2><p>Maven 3支持Maven项目的多模块（multi-modules）结构。这样的Maven项目也被称为聚合项目，通常由一个父模块和若干个子模块构成。所有用mavan管理的项目最好都是分模块的，每个模块对应着一个pom.xml，他们之间继承和聚合互相关联。划分模块后，导入Eclipse变成了N个项目，这会带来复杂度，给开发带来不便，那为什么还要用呢？原因有以下几点：</p><p>（1）方便复用，如app-common这些模块可以渐渐进化成一个基础公共类，供所有项目使用，这是模块化最重要的一个目的</p><p>（2）由于你划分了模块，每个模块的配置都在各自的pom.xml，不用再到一个纷繁复杂的pom中寻找自己的配置</p><p>（3）如果你只是在app-common上工作，你不需要build整个项目，只要在app-common目录运行mvn命令即可，这样可以节省时间，尤其是当项目很庞大，build越来越耗时的时候</p><p>（4）某些模块，如app-common被很多人依赖，但你不想给所有人修改，完全可以把app-common拿出来做成另一个项目，只提供jar包，没有修改权限</p><h2 id="一个简单的Maven多模块项目结构"><a href="#一个简单的Maven多模块项目结构" class="headerlink" title="一个简单的Maven多模块项目结构"></a>一个简单的Maven多模块项目结构</h2><p>一个简单的Maven多模块项目结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-xxoo</span><br><span class="line">    |-xxoo-common</span><br><span class="line">        |-pom.xml(jar)</span><br><span class="line">    |-xxoo-utils</span><br><span class="line">        |-pom.xml(jar)</span><br><span class="line">    |-xxoo-core</span><br><span class="line">        |-pom.xml(jar)</span><br><span class="line">    |-xxoo-web</span><br><span class="line">        |-pom.xml(war)</span><br><span class="line">    |-pom.xml(pom)</span><br></pre></td></tr></table></figure><p>在上图中，有一个父项目（xxoo）聚合很多子模块（xxoo-common、xxoo-utils、xxoo-core以及xxoo-web）。每个项目或模块都含有一个pom.xml文件，需要注意的是，小括号中标出了每个项目的打包类型。父项目是pom，也必须是pom。子项目有jar或war，根据模块的功能来决定。父模块xxoo必须以pom打包类型，同时以<code>&lt;modules&gt;</code>给出所有的子模块，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bat.sysadmin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxoo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>xxoo-common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>xxoo-utils<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>xxoo-core<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>xxoo-web<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="使用Eclipse创建Maven多模块项目"><a href="#使用Eclipse创建Maven多模块项目" class="headerlink" title="使用Eclipse创建Maven多模块项目"></a>使用Eclipse创建Maven多模块项目</h2><p>（1）创建一个父项目xxoo</p><p><code>new-&gt;project-&gt;maven-&gt;maven project</code>，点击下一步，选择项目原型maven-archetype-site-simple，配置在groupid和artifactid，完成之后，在Eclipse会生成一个项目。在pom.xml中将packaging修改为pom，同时将xxoo中src目录删除，父项目xxoo主要功能是管理其他子项目，本身并不用写代码，所以只保留一个pom.xml就可以了。</p><p>（2）创建子模块xxoo-common，xxoo-utils以及xxoo-core</p><p>在项目xxoo上点击右键，选择<code>new-&gt;project-&gt;maven-&gt;maven module</code>，填写module name，比如xxoo-common点击下一步， 在选择模块原型为maven-archetype-quickstart，确定后生成xxoo-common项目。创建xxoo-utils以及xxoo-core同xxoo-common过程一样，这里忽略。</p><p>（3）创建子模块xxoo-web</p><p>xxoo-web是个web应用模块，在项目xxoo上点击右键，选择<code>new-&gt;project-&gt;maven-&gt;maven module</code>，填写module name为xxoo-web，点击下一步， 再选择模块原型为maven-archetype-webapp，确定后生成xxoo-web项目。</p><p>通过上面的操作后，在Eclipse的Package Explorer中会展示如下的项目结构：</p><p><img src="/images/maven_1_8.png" alt></p><p>在Eclipse中xxoo-common、xxoo-utils、xxoo-core以及xxoo-web单独的Project是虚拟出来的，其实在本地磁盘的目录结构如下：</p><p><img src="/images/maven_1_9.png" alt></p><p>备注：在Eclipse IDE中多模块项目，一般来说，我们将聚合项目折叠起来，如xxoo。而是到Eclipse虚拟出来的工程中去编辑具体的子模块。当然在xxoo聚合模块，还是子模块中编辑开发，在两边都会有体现的啦。另外，在创建子模块时，注意package结构。</p><h2 id="Maven聚合、继承及二者区别"><a href="#Maven聚合、继承及二者区别" class="headerlink" title="Maven聚合、继承及二者区别"></a>Maven聚合、继承及二者区别</h2><p>（1）Maven聚合</p><p>在一个要聚合多个模块的Maven工程pom.xml中，配置如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxoo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>xxoo-common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>xxoo-utils<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>xxoo-core<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>xxoo-web<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过上述配置后，xxoo就对xxoo-common、xxoo-utils、xxoo-core以及xxoo-web进行了聚合，这样在打包时，各个项目会同时打包。</p><p>（2）Maven继承</p><p>在子模块的pom.xml中，配置如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxoo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若子项目不在父项目的目录中，那么还需要<code>&lt;relativePath&gt;&lt;/relativePath&gt;</code>标签来配置相对路径。通过继承的应用，各个子项目会继承很多父项目pom.xml中的配置，更合理方便的管理各个子项目的第三方jar包依赖问题。</p><p>（3）Maven继承和聚合的关系</p><p>虽然聚合通常伴随着继承关系，但是这两者不是必须同时存在的，实际上在Maven中聚合（多模块）和继承是两回事，两者不存在直接联系。继承是Maven中很强大的一种功能，继承可以使得子POM可以获得parent中的各项配置，可以对子pom进行统一的配置和依赖管理，父POM是为了抽取统一的配置信息和依赖版本控制，方便子POM直接引用，简化子POM的配置。聚合（多模块）则是为了方便一组项目进行统一的操作而作为一个大的整体，所以要真正根据这两者不同的作用来使用，不必为了聚合而继承同一个父POM，也不比为了继承父POM而设计成多模块。</p><h2 id="在一个子模块需要使用到另一个子项目的类"><a href="#在一个子模块需要使用到另一个子项目的类" class="headerlink" title="在一个子模块需要使用到另一个子项目的类"></a>在一个子模块需要使用到另一个子项目的类</h2><p>假设xxoo-web需要用到xxoo-common中的工具类，那么需要在xxoo-web的pom.xml中加入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxoo-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么在<code>maven package</code>子模块xxoo-web时，就会将xxoo-common的jar包xxoo-common-0.0.1-SNAPSHOT.jar，拷贝一份到xxoo-web的<code>target/xxoo-web/WEB-INF/lib</code>下，这样就会像使用第三方JAR包一样使用我们自己开发的JAR包模块啦。</p><h2 id="Maven-SpringBoot项目多模块管理的最佳实践"><a href="#Maven-SpringBoot项目多模块管理的最佳实践" class="headerlink" title="Maven+SpringBoot项目多模块管理的最佳实践"></a>Maven+SpringBoot项目多模块管理的最佳实践</h2><p>模块的拆分有两种方式，</p><p>（1）按照MVC分层结构来拆分模块，结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-xxoo</span><br><span class="line">    |-xxoo-common</span><br><span class="line">        |-pom.xml(jar)</span><br><span class="line">    |-xxoo-controller</span><br><span class="line">        |-pom.xml(war)</span><br><span class="line">    |-xxoo-service</span><br><span class="line">        |-pom.xml(jar)</span><br><span class="line">    |-xxoo-dao</span><br><span class="line">        |-pom.xml(jar)</span><br><span class="line">    |-pom.xml(pom)</span><br></pre></td></tr></table></figure><p>（2）按照业务逻辑结构来拆分模块，结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-xxoo</span><br><span class="line">    |-xxoo-common</span><br><span class="line">        |-pom.xml(jar)</span><br><span class="line">    |-xxoo-order</span><br><span class="line">        |-pom.xml(war)</span><br><span class="line">    |-xxoo-accout</span><br><span class="line">        |-pom.xml(war)</span><br><span class="line">    |-xxoo-pay</span><br><span class="line">        |-pom.xml(war)</span><br><span class="line">    |-pom.xml(pom)</span><br></pre></td></tr></table></figure><p>网络上的一个项目结构参考如下：</p><p><img src="/images/maven_1_10.png" alt></p><p>在实际的工程实践中，一定要注意，xxoo-common是一个抽离出来的工具库，其他模块会引用xxoo-common，假设xxoo-order依赖xxoo-common，因为xxoo-common是xxoo的子模块，maven继承了xxoo的pom.xml中的配置，那其实xxoo-common也是一个SpringBoot的项目，如果在xxoo的pom.xml中有如下的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么xxoo-common也会继承这个配置，那么SpringBoot工程编译打包时，xxoo-common会生成两种jar包，一种是普通的jar，另一种是可执行jar。默认情况下，这两种jar的名称相同，在不做配置的情况下，普通的jar先生成，可执行jar后生成，造成可执行jar会覆盖普通的jar。而xxoo-order无法依赖xxoo-common工程的可执行jar，所以编译打包时，xxoo-order就会报出“程序包com.baidu.xxoo.common不存在”失败。当前想到的解决方式是把插件spring-boot-maven-plugin的配置挪到xxoo-order中，这样xxoo-common就不会继承到spring-boot-maven-plugin的插件。xxoo-common仅仅是一个普通的工具包，我们并不想编译成可执行的包哦。</p><h1 id="其他闲杂知识"><a href="#其他闲杂知识" class="headerlink" title="其他闲杂知识"></a>其他闲杂知识</h1><h2 id="关于-lt-packaging-gt-lt-packaging-gt-使用"><a href="#关于-lt-packaging-gt-lt-packaging-gt-使用" class="headerlink" title="关于&lt;packaging&gt;...&lt;/packaging&gt;使用"></a>关于<code>&lt;packaging&gt;...&lt;/packaging&gt;</code>使用</h2><p>packaging指明项目打包的格式，目前支持的格式有pom，jar，maven-plugin，ejb，war，ear，rar，par等，若不显式指定packaging，则缺省的packaging格式为jar。</p><p>若packaging指定为pom，则该Maven工程不会打包出任何东西。不像jar/war等，会打包出jar包或war包。</p><h2 id="关于dependencyManagement与dependencies"><a href="#关于dependencyManagement与dependencies" class="headerlink" title="关于dependencyManagement与dependencies"></a>关于dependencyManagement与dependencies</h2><p>当我们的项目有很多模块组成时，我们往往会在父类项目的pom.xml中看到dependencyManagement配置，通过dependencyManagement元素来管理jar包的版本，让子项目中引用一个依赖而不用显示的列出版本号。Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement元素中指定的版本号。</p><p>这样做便于统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，才能保证测试的和发布的是相同的成果，因此，在顶层pom.xml中定义共同的依赖关系。同时可以避免在每个使用的子项目中都声明一个版本号，这样想升级或者切换到另一个版本时，只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个版本号时，只需要在dependencies中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。</p><p>在父项目的pom.xml中可能会看到<code>&lt;dependencyManagement&gt;&lt;dependencies&gt;&lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code>，也会直接看到<code>&lt;dependencies&gt;&lt;/dependencies&gt;</code>。它们的区别如下：</p><p>（1）dependencies即使在子项目中不写该依赖项，那么子项目仍然会从父项目中继承该依赖项（全部继承）</p><p>（2）dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom；另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</p><h2 id="Maven-pom-xml中resources配置的概念和使用"><a href="#Maven-pom-xml中resources配置的概念和使用" class="headerlink" title="Maven pom.xml中resources配置的概念和使用"></a>Maven pom.xml中resources配置的概念和使用</h2><p>构建Maven项目的时候，如果没有进行特殊的配置，Maven会按照标准的目录结构查找和处理各种类型文件。举例来说：</p><p><code>src/main/java</code>和<code>src/test/java</code>这两个目录中的所有<code>*.java</code>文件会分别在comile和test-comiple阶段被编译，编译结果分别放到了<code>target/classes</code>和<code>targe/test-classes</code>目录中，但是这两个目录中的其他文件都会被忽略掉。</p><p><code>src/main/resouces</code>和<code>src/test/resources</code>这两个目录中的文件也会分别被复制到<code>target/classes</code>和<code>target/test-classes</code>目录中。</p><p>打包插件默认会把<code>target/classes</code>这个目录中的所有内容打入到jar包或者war包中。</p><p>resources代表了Maven的资源文件，是项目中要使用的文件，代码在执行的时候会到指定位置去查找这些文件。前面已经说了Maven默认的处理方式，但是有时候我们需要进行自定义配置。比如说，有时候有些配置文件通常与<code>*.java</code>文件一起放在<code>src/main/java</code>目录（如Mybatis或Hibernate的表映射文件）。有的时候还希望把其他目录中的资源也复制到classes目录中。有的时候我们需要排除<code>src/main/resouces</code>下某下配置文件。这些情况下就需要在pom.xml文件配置resource啦。</p><p>举例来说：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 资源根目录排除各环境的配置，使用单独的资源目录来指定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>local/*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>test/*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>production/*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/template<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第三方库查找"><a href="#第三方库查找" class="headerlink" title="第三方库查找"></a>第三方库查找</h2><p>可以在<code>https://mvnrepository.com/</code>页面中搜索第三方JAVA库。</p><h2 id="jetty-tomcat插件"><a href="#jetty-tomcat插件" class="headerlink" title="jetty/tomcat插件"></a>jetty/tomcat插件</h2><p>使用maven构建Servlet WEB项目时，可以直接在pom.xml中引入jetty plugin，然后可以直接在jetty servlet容器中运行WEB项目了哦，开发测试非常方便。当然我们也可以引入tomcat plugin哦。</p><h2 id="Maven-Wrapper"><a href="#Maven-Wrapper" class="headerlink" title="Maven Wrapper"></a>Maven Wrapper</h2><p>我们使用Maven时，基本上只会用到mvn这一个命令。有些童鞋可能听说过mvnw，这个是啥？mvnw是Maven Wrapper的缩写。因为我们安装Maven时，默认情况下，系统所有项目都会使用全局安装的这个Maven版本。但是，对于某些项目来说，它可能必须使用某个特定的Maven版本，这个时候，就可以使用Maven Wrapper，它可以负责给这个特定的项目安装指定版本的Maven，而其他项目不受影响。简单地说，Maven Wrapper就是给一个项目提供一个独立的，指定版本的Maven给它使用。实际使用中使用mvnw代替mvn，如<code>mvnw clean package</code>。</p><p>学习资料参考于：<br><a href="https://www.cnblogs.com/luotaoyeah/p/3819001.html" target="_blank" rel="noopener">https://www.cnblogs.com/luotaoyeah/p/3819001.html</a><br><a href="https://maven.apache.org/run.html" target="_blank" rel="noopener">https://maven.apache.org/run.html</a><br><a href="https://blog.csdn.net/liutengteng130/article/details/46991829" target="_blank" rel="noopener">https://blog.csdn.net/liutengteng130/article/details/46991829</a><br><a href="https://www.cnblogs.com/pixy/p/4798089.html" target="_blank" rel="noopener">https://www.cnblogs.com/pixy/p/4798089.html</a><br><a href="https://www.cnblogs.com/0201zcr/p/6262762.html" target="_blank" rel="noopener">https://www.cnblogs.com/0201zcr/p/6262762.html</a><br><a href="https://blog.csdn.net/jrainbow/article/details/50546524" target="_blank" rel="noopener">https://blog.csdn.net/jrainbow/article/details/50546524</a><br><a href="http://www.blogways.net/blog/2013/05/13/maven-multi-modules-demo.html" target="_blank" rel="noopener">http://www.blogways.net/blog/2013/05/13/maven-multi-modules-demo.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetty技术调研</title>
      <link href="/2018/02/05/Jetty%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/02/05/Jetty%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetty简介"><a href="#Jetty简介" class="headerlink" title="Jetty简介"></a>Jetty简介</h1><p>Jetty是一个纯粹的基于Java的网页服务器和Java Servlet容器。从功能上看，Jetty和Tomcat是差不多的，都提供Http Server和Servlet容器功能。</p><h1 id="Jetty的目录结构"><a href="#Jetty的目录结构" class="headerlink" title="Jetty的目录结构"></a>Jetty的目录结构</h1><p><img src="/images/jetty_1_1.png" alt></p><h1 id="Jetty的安装和使用"><a href="#Jetty的安装和使用" class="headerlink" title="Jetty的安装和使用"></a>Jetty的安装和使用</h1><p>前提声明：</p><pre><code>系统：Red Hat Enterprise Linux Server release 6.8 (Santiago)JAVA：1.8.0jetty：jetty-9.4.8.v20171121</code></pre><p>Jetty安装的步骤如下：</p><p>（1）配置JAVA环境</p><p>（2）官网上现在jetty tarball，并解压即可。不需要编译安装哦。</p><p>（3）启动jetty</p><p>方式一（前台启动）：<code>cd ${JETTY_HOME} &amp;&amp; java -jar start.jar</code><br>方式二（后台启动）：<code>cd ${JETTY_HOME} &amp;&amp; ./bin/jetty.sh start</code></p><p>备注：我们可以将自己开发的war包部署到${JETTY_HOME}/webapps目录下，jetty会自动加载war包，然后在浏览器中输入<code>http://127.0.0.1/war_name/xxx</code>即可访问。</p><h1 id="Jetty的一些常见配置修改"><a href="#Jetty的一些常见配置修改" class="headerlink" title="Jetty的一些常见配置修改"></a>Jetty的一些常见配置修改</h1><p>（1）修改默认http端口</p><p>修改${JETTY_HOME}/etc/jetty-http.xml配置文件中如下配置：</p><pre><code>&lt;Set name=&quot;port&quot;&gt;&lt;Property name=&quot;jetty.http.port&quot; deprecated=&quot;jetty.port&quot; default=&quot;8086&quot; /&gt;&lt;/Set&gt;</code></pre><p>学习资料参考于：<br><a href="http://www.cnblogs.com/yiwangzhibujian/p/5832597.html" target="_blank" rel="noopener">http://www.cnblogs.com/yiwangzhibujian/p/5832597.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat技术调研</title>
      <link href="/2018/02/05/Tomcat%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/02/05/Tomcat%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h1><p>Java servlet容器。Tomcat的主要的目录结构如下：</p><pre><code>bin，存放tomcat的启停脚本等conf，Tomcat的全局配置文件lib，Tomcat依赖的jar文件webapps，WEB应用的部署目录logs，Tomcat输出日志的目录</code></pre><h1 id="Tomcat一些配置文件"><a href="#Tomcat一些配置文件" class="headerlink" title="Tomcat一些配置文件"></a>Tomcat一些配置文件</h1><p>（1）server.xml</p><p>Tomcat的主配置文件，包含service、connectors、engine、realm、valve、hosts等组件。比如Tomcat监听的http端口就是该文件中配置的。</p><p>（2）web.xml</p><p>遵循Servlet规范标准的配置文件，用于配置Servlet，并为所有的Web应用程序提供包括MIME映射等默认配置信息。如下为web.xml中关于一个Servlet的配置举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;ServletName&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;xxxpackage.xxxServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;参数名称&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;参数值&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;ServletName&lt;/servlet-name&gt;             </span><br><span class="line">    &lt;url-pattern&gt;/aaa/xxx&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>然后，在地址栏中输入<code>http://localhost:8080/web-App/aaa/xxx</code>就可以访问了。</p><p>（3）tomcat-user.xml</p><p>Realm认证时用到的相关角色、用户和密码等信息；Tomcat自带的manager默认情况下会用到此文件；在Tomcat中添加/删除用户，为用户指定角色等将通过编辑此文件实现。</p><p>（4）catalina.policy</p><p>Java相关的安全策略配置文件，在系统资源级别上提供访问控制的能力。</p><p>（5）catalina.properties</p><p>Tomcat内部package的定义及访问相关的控制，也包括对通过类装载器装载的内容的控制；Tomcat在启动时会事先读取此文件的相关设置。</p><p>（6）logging.properties</p><p>Tomcat通过自己内部实现的JAVA日志记录器来记录操作相关的日志，此文件即为日志记录器相关的配置信息，可以用来定义日志记录的组件级别以及日志文件的存在位置等。</p><p>（7）context.xml</p><p>所有host的默认配置信息。</p><h1 id="Tomcat的安装"><a href="#Tomcat的安装" class="headerlink" title="Tomcat的安装"></a>Tomcat的安装</h1><p>前提声明，本次安装使用的是apache-tomcat-9.0.2和JDK 1.8。</p><p>（1）JDK环境配置</p><p>（2）Tomcat下载</p><p>选择Binary Distributions中Core目录下载即可。需要注意的是Full documenttion是文档，Deployer仅仅是一个发布器。</p><p><img src="/images/tomcat_1_1.png" alt></p><p>（3）解压Tomcat的tarball即可，不需要编译安装的哦。</p><p>（4）启动Tomcat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;TOMCAT_HOME&#125;</span> &amp;&amp; ./bin/startup.sh         <span class="comment">#启动tomcat</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;TOMCAT_HOME&#125;</span> &amp;&amp; ./bin/catalina.sh start  <span class="comment">#启动tomcat</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;TOMCAT_HOME&#125;</span> &amp;&amp; ./bin/shutdown.sh        <span class="comment">#关闭tomcat</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;TOMCAT_HOME&#125;</span> &amp;&amp; ./bin/catalina.sh stop   <span class="comment">#关闭tomcat</span></span><br></pre></td></tr></table></figure><p>（5）访问测试</p><p>在浏览器中输入<code>http://127.0.0.1:8080/</code>即可。</p><p>备注：我们可以将自己开发的war包部署到${TOMCAT_HOME}/webapps目录下，tomcat会自动加载war包，然后在浏览器中输入<code>http://127.0.0.1/war_name/xxx</code>即可访问。</p><h1 id="关于Tomcat的端口配置"><a href="#关于Tomcat的端口配置" class="headerlink" title="关于Tomcat的端口配置"></a>关于Tomcat的端口配置</h1><p>Tomcat的端口是在<code>${TOMCAT_HOME}/conf/server.xml</code>中配置，在server.xml有多个地方配置端口，它们的含义各不相同，具体如下：</p><p>（1）Server元素中端口配置</p><p>如<code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code>，port用来指定一个端口，这个端口负责监听关闭tomcat的请求；shutdown用来指定向端口发送的命令字符串。当我们kill tomcat进程时，就会向该端口发送shutdown指令。</p><p>（2）Connector元素中端口配置</p><p><connector>元素代表与客户程序实际交互的组件，它负责接收客户请求，以及向客户返回响应结果。一个server.xml会有多个<connector>的配置，一般来说有：</connector></connector></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</span><br><span class="line">&lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</span><br><span class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; /&gt;</span><br><span class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; /&gt;</span><br><span class="line">&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><p>备注：一般来说，可以通过protocol这个字段来判断这个Connector监听的端口是用来提供什么服务的。比如说<code>protocol=&quot;HTTP/1.1&quot;</code>说明这个端口是用来提供HTTP服务的。</p><h1 id="Tomcat的WEB应用的部署方法"><a href="#Tomcat的WEB应用的部署方法" class="headerlink" title="Tomcat的WEB应用的部署方法"></a>Tomcat的WEB应用的部署方法</h1><h2 id="静态部署"><a href="#静态部署" class="headerlink" title="静态部署"></a>静态部署</h2><p>静态部署有三种方法：</p><p>（1）直接将web应用放到webapps目录下</p><p>（2）通过<code>$TOMCAT_HOME/conf/server.xml</code>文件配置web应用的存放路径，此时web应用就不需要放到<code>$TOMCAT_HOME/webapps</code>中</p><p>（3）在<code>$TOMCAT_HOME/conf/</code>目录下新建<code>Catalina\localhost</code>目录，然后创建一个和web应用同名的xml文件，xml内容中指定web应用的存放路径</p><h2 id="动态部署"><a href="#动态部署" class="headerlink" title="动态部署"></a>动态部署</h2><p>通过Tomcat自动的管理平台来实现动态部署。</p><h1 id="Tomcat的闲杂知识"><a href="#Tomcat的闲杂知识" class="headerlink" title="Tomcat的闲杂知识"></a>Tomcat的闲杂知识</h1><p>（1）tomcat不仅是非常受欢迎的Servlet容器，也同时为我们提供了很多非常实用组件，JDBC pool就是其中一个有用的组件。JDBC pool是非常实用且高效的JDBC连接池的实现。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单页面应用SPA</title>
      <link href="/2018/02/04/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8SPA/"/>
      <url>/2018/02/04/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8SPA/</url>
      
        <content type="html"><![CDATA[<h1 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h1><p>单页应用，或单页面应用，或单页Web应用，英文为single page web application，简写为SPA。单页应用就是只有一张WEB页面的应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面的WEB应用程序。</p><p>单页应用能非常好地做到前后端分离，且用户与前端页面交互流畅。但是单页应用的页面是动态生成的，所以在SEO方面存在很大的问题。</p><h1 id="实现单页应用常用的框架"><a href="#实现单页应用常用的框架" class="headerlink" title="实现单页应用常用的框架"></a>实现单页应用常用的框架</h1><p>实现单页应用常用的前端JS框架有AngularJS、React、Vue.js、Backbone、Ember等。</p><h1 id="传统的WEB应用与SPA区别"><a href="#传统的WEB应用与SPA区别" class="headerlink" title="传统的WEB应用与SPA区别"></a>传统的WEB应用与SPA区别</h1><p>（1）传统架构</p><p><img src="/images/spa_1_1.png" alt></p><p>（2）SPA的架构</p><p><img src="/images/spa_1_2.png" alt></p><p>学习资料参考于：<br><a href="https://github.com/xufei/blog/issues/5" target="_blank" rel="noopener">https://github.com/xufei/blog/issues/5</a></p>]]></content>
      
      
      <categories>
          
          <category> WebFrontEnd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的同源政策及CORS解决跨域问题</title>
      <link href="/2018/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E5%8F%8ACORS%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2018/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E5%8F%8ACORS%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器的同源政策"><a href="#浏览器的同源政策" class="headerlink" title="浏览器的同源政策"></a>浏览器的同源政策</h1><p>同源是针对两个网页资源来说的，如果两个网页同时满足下面三个条件：</p><p>（1）协议相同</p><p>（2）域名相同</p><p>（3）端口相同</p><p>那么就称这两个网页资源是同源的。</p><p>同源政策是在1995年，由Netscape公司引入浏览器。目前，所有浏览器都实行这个政策。浏览器安全的基石是“同源政策”（same-origin policy）。</p><h1 id="同源政策的限制"><a href="#同源政策的限制" class="headerlink" title="同源政策的限制"></a>同源政策的限制</h1><p>最初遵循同源政策的浏览器让A网页设置的Cookie，B网页不能打开，除非这两个网页“同源”。随着互联网的发展，“同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制：</p><p>（1）Cookie、LocalStorage和IndexDB无法读取</p><p>（2）DOM无法获得</p><p>（3）AJAX请求不能发送</p><p>备注：虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。</p><h1 id="规避同源政策导致跨域AJAX问题"><a href="#规避同源政策导致跨域AJAX问题" class="headerlink" title="规避同源政策导致跨域AJAX问题"></a>规避同源政策导致跨域AJAX问题</h1><p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。 一般来说，有如下几种方式来规避同源问题：</p><p>（1）架设反向代理服务器，不同源的经过反向代理服务器后，就成为同源的服务器，然后由反向代理服务器将请求分发给不同的服务器来处理。</p><p>（2）JSONP</p><p>（3）WebSocket</p><p>（4）CORS</p><p>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。相比JSONP只能发GET请求，CORS允许任何类型的请求。</p><h1 id="CORS解决跨域AJAX问题细谈"><a href="#CORS解决跨域AJAX问题细谈" class="headerlink" title="CORS解决跨域AJAX问题细谈"></a>CORS解决跨域AJAX问题细谈</h1><p>（1）简单请求 与 非简单请求</p><p>浏览器将HTTP分为简单请求和非简单请求。其中非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json等等。</p><p>（2）简单请求</p><p>对于简单请求，浏览器直接发出CORS请求。</p><p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。</p><pre><code>GET /sfs HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><pre><code>Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8</code></pre><p>（3）非简单请求</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（cors-preflight-request）， 预检的HTTP Request Method为OPTIONS。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><p>由此可见，当触发预检时，一次AJAX请求会消耗掉两个TTL，严重影响性能。那么如何节省掉OPTIONS请求来提升性能呢？从上文可以看出，有两个方案：一是，发出简单请求；二是服务器端设置Access-Control-Max-Age字段，那么当第一次请求该URL时会发出OPTIONS请求，浏览器会根据返回的Access-Control-Max-Age字段缓存该请求的OPTIONS预检请求的响应结果（具体缓存时间还取决于浏览器的支持的默认最大值，取两者最小值，一般为10分钟）。在缓存有效期内，该资源的请求（URL和header字段都相同的情况下）不会再触发预检。</p><p>学习资料参考于：<br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a><br><a href="http://javascript.ruanyifeng.com/#bom" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/#bom</a></p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何禁用一个根证书</title>
      <link href="/2018/02/04/%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%B9%E8%AF%81%E4%B9%A6/"/>
      <url>/2018/02/04/%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%B9%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<p>以吊销 CNNIC 根证书为例来说明在各个平台吊销根证书的方法，有如下方法：</p><h1 id="全自动可疑证书吊销工具"><a href="#全自动可疑证书吊销工具" class="headerlink" title="全自动可疑证书吊销工具"></a>全自动可疑证书吊销工具</h1><p>GitHub上的Revoke China Certificates项目。这是最简单的方法。具体参见<a href="https://github.com/chengr28/RevokeChinaCerts" target="_blank" rel="noopener">https://github.com/chengr28/RevokeChinaCerts</a></p><h1 id="Windows平台（适用IE、Chrome、Safari）"><a href="#Windows平台（适用IE、Chrome、Safari）" class="headerlink" title="Windows平台（适用IE、Chrome、Safari）"></a>Windows平台（适用IE、Chrome、Safari）</h1><p>（1）运行Windows的证书管理器（到命令行执行certmgr.msc）。</p><p>（2）选中“受信任的根证书颁发机构”=&gt;“证书”。</p><p>（3）查看右边的证书列表，找到CNNIC证书</p><p>（4）选中CNNIC证书，点右键。在右键菜单中点“属性”。</p><p>（5）在跳出的属性对话框中，选中“停用这个证书的所有目的”，然后确定。</p><p>注：上述操作仅对当前用户生效。如果你的Windows系统中有多个常用的用户帐号，要对每一个用户进行上述设置。</p><h1 id="OS-X（适用Safari、Chrome）"><a href="#OS-X（适用Safari、Chrome）" class="headerlink" title="OS X（适用Safari、Chrome）"></a>OS X（适用Safari、Chrome）</h1><p>请到<code>“实用工具”=&gt;“钥匙串访问”=&gt;“系统根证书”=&gt;“证书”</code>，找到CNNIC的证书并双击，改为“永不信任”。</p><h1 id="Linux（适用Chrome）"><a href="#Linux（适用Chrome）" class="headerlink" title="Linux（适用Chrome）"></a>Linux（适用Chrome）</h1><p>对于Debian和Ubuntu系统，以管理员权限进行如下操作：</p><p>方法1：运行命令<code>dpkg-reconfigure ca-certificates</code>会出现一个图形界面，把CNNIC证书不选，并确认。</p><p>方法2：编辑/etc/ca-certificates.conf文件，把CNNIC证书对应的行删除或注释掉。然后用命令<code>update-ca-certificates</code>使之生效。</p><p>注：对于其它Linux发行版本，也有类似操作。</p><h1 id="清理Firefox的证书"><a href="#清理Firefox的证书" class="headerlink" title="清理Firefox的证书"></a>清理Firefox的证书</h1><p>不论是在哪个操作系统下，只要你用的是Firefox浏览器（它的证书体系独立于操作系统的），则需要执行如下步骤：</p><p>（1）从菜单“工具”=&gt;“选项” ，打开选项对话框</p><p>（2）切换到“高级”部分，选中“加密”标签页，点“查看证书”按钮。</p><p>（3）在证书对话框中，切换到“证书机构”。</p><p>（4）里面的证书列表是按字母排序的。把CNNIC打头的都删除。</p><p>注：如果某个证书是Firefox自带的，则删除之后，下次再打开该对话框，此证书还在。不过不要紧，它的所有“信任设置”，都已经被清空了。</p><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>设置 - 安全 - 受信任的凭据(显示受信任的CA证书)，点击进入需要禁用的证书并下拉到最下面，点击 禁用 按钮即可。操作完毕建议清空所有浏览器数据和系统缓存，并重启网络连接。</p><h1 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h1><p>iOS没有任何官方提供的方法禁用自带的根证书，请放弃在iOS下禁用根证书的想法。</p><p>备注：chrome浏览器默认使用的操作系统的证书管理器，而Firefox使用的是其自己的证书管理器。</p><p>学习内容参见于：<br><a href="https://qdan.me/list/VRIio9hA0FujGWYP" target="_blank" rel="noopener">https://qdan.me/list/VRIio9hA0FujGWYP</a></p>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Win10 linux子系统小结</title>
      <link href="/2018/02/04/%E4%BD%BF%E7%94%A8Win10-linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/02/04/%E4%BD%BF%E7%94%A8Win10-linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="win10下安装linux子系统方法"><a href="#win10下安装linux子系统方法" class="headerlink" title="win10下安装linux子系统方法"></a>win10下安装linux子系统方法</h1><p><a href="https://jingyan.baidu.com/article/5552ef47ef0b87518ffbc935.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/5552ef47ef0b87518ffbc935.html</a></p><h1 id="查看win10下linux系统的版本信息"><a href="#查看win10下linux系统的版本信息" class="headerlink" title="查看win10下linux系统的版本信息"></a>查看win10下linux系统的版本信息</h1><p><img src="/images/win10bash_1_1.png" alt></p><h1 id="win10系统与linux子系统的文件共享"><a href="#win10系统与linux子系统的文件共享" class="headerlink" title="win10系统与linux子系统的文件共享"></a>win10系统与linux子系统的文件共享</h1><p>在linux子系统中通过<code>/mnt/[盘符]/[目录]</code>的方式访问Windows目录中的文件。</p><h1 id="win10-linux子系统的使用"><a href="#win10-linux子系统的使用" class="headerlink" title="win10 linux子系统的使用"></a>win10 linux子系统的使用</h1><p>在命令提示符中输入bash，即可进入linux子系统；在linux子系统的bash shell中输入exit，即可退出linux子系统，进入命令提示符中。</p><p>备注：最好使用管理员身份运行命令提示符哦，如ping命令就需要以管理员身份运行cmd.exe，然后再进入bash子系统才可以使用ping命令，否则会提示没有icmp的权限而使用不了ping工具。默认以管理员身份运行cmd的方法参见<a href="https://jingyan.baidu.com/article/d2b1d102a391af5c7f37d44a.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/d2b1d102a391af5c7f37d44a.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在windowns中如何默认以管理员身份运行指定程序</title>
      <link href="/2018/02/04/%E5%9C%A8windowns%E4%B8%AD%E5%A6%82%E4%BD%95%E9%BB%98%E8%AE%A4%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E8%BA%AB%E4%BB%BD%E8%BF%90%E8%A1%8C%E6%8C%87%E5%AE%9A%E7%A8%8B%E5%BA%8F/"/>
      <url>/2018/02/04/%E5%9C%A8windowns%E4%B8%AD%E5%A6%82%E4%BD%95%E9%BB%98%E8%AE%A4%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E8%BA%AB%E4%BB%BD%E8%BF%90%E8%A1%8C%E6%8C%87%E5%AE%9A%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>在windows中如何默认以管理员身份运行指定程序，操作方法如下：</p><p>1.在应用程序快捷方式上右键，点击属性</p><p><img src="/images/windows_1_1.png" alt></p><p>2.点击“高级”按钮，勾选“用管理员身份运行”</p><p><img src="/images/windows_1_2.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中iftop/iotop的使用</title>
      <link href="/2018/02/04/Linux%E4%B8%ADiftop-iotop%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/04/Linux%E4%B8%ADiftop-iotop%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="iftop简介"><a href="#iftop简介" class="headerlink" title="iftop简介"></a>iftop简介</h1><p>iftop能显示指定网卡流量的topN，使用<code>yum install iftop</code>即可安装。例如使用命令<code>iftop -n -i eth0</code>输出结果如下：</p><p><img src="/images/iftop_1_1.png" alt></p><p>备注：<br>中间的&lt;=或=&gt;这两个左右箭头，表示的是流量的方向；TX表示发送流量 ；RX表示接收流量； TOTAL表示总流量； cum表示运行iftop到目前时间的总流量 ；peak表示流量的峰值 ；rates表示过去2s/10s/40s的平均流量.</p><p>iftop的主要选项有：</p><pre><code>-n           —— 不显示IP，不解析主机名-i interface —— 指定的网卡接口</code></pre><h1 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h1><p>iotop能显示磁盘IO（即读写磁盘）进程的topN，使用<code>yum install iotop</code>即可安装。iotop和top命令显示类似，不详细展开了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dmesg命令使用</title>
      <link href="/2018/02/04/dmesg%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/04/dmesg%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h1><p>kernel会将开机信息存储在ring buffer中，另外，也会保存在/var/log/dmesg的磁盘文件中。dmesg命令用于打印Linux系统开机启动信息，dmesg是从kernel ring buffer中读取开启启动信息，并不是从/var/log/dmesg文件中读取哦。</p><p>备注：/var/log/dmesg好像不是syslogd写入的。</p><h1 id="dmesg常见的用法"><a href="#dmesg常见的用法" class="headerlink" title="dmesg常见的用法"></a>dmesg常见的用法</h1><p>（1）查看看机信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg</span><br></pre></td></tr></table></figure><p>（2）清除kernel ring buffer中的开机信息，并打印到控制台上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg -c</span><br></pre></td></tr></table></figure><p>备注：使用<code>dmesg -c</code>只会清除kernel ring buffer中的内容，并不会清除/var/log/dmesg，所以我们还是可以通过查看/var/log/dmesg文件来获取系统启动信息。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下run-parts命令</title>
      <link href="/2018/02/04/Linux%E4%B8%8Brun-parts%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/02/04/Linux%E4%B8%8Brun-parts%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="run-parts"><a href="#run-parts" class="headerlink" title="run-parts"></a>run-parts</h1><p>在Centos5下，run-parts命令工具的绝对路径是/usr/bin/run-parts，内容是很简单的一个shell脚本，就是遍历目标文件夹，执行第一层目录下的可执行权限的文件，其他非可执行文件和子目录下的文件不会被执行。举例来说：<code>run-parts /home/wahaha</code>。</p><p>在ubuntu下，该文件位于/bin/run-parts，是个二进制文件，功能更为强大，支持–test等命令参数。</p><h1 id="run-parts的应用场景"><a href="#run-parts的应用场景" class="headerlink" title="run-parts的应用场景"></a>run-parts的应用场景</h1><p>我们可以直接使用run-parts工具来执行某个目录中的所有可执行文件，但通常run-parts被用到crontab中。以Centos来说，系统中有/etc/cron.hourly，/etc/cron.daily，/etc/cron.weekly以及/etc/cron.monthly等目录，我们可以在/etc/crontab中通过配置<code>01 * * * * root run-parts /etc/cron.hourly</code>，来达到每小时执行一次/etc/cron.hourly目录中的可执行文件的效果。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下logger命令的使用</title>
      <link href="/2018/02/04/Linux%E4%B8%8Blogger%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/04/Linux%E4%B8%8Blogger%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h1><p>logger命令可以和系统的syslog模块交互，也就是logger命令产生的日志会通过syslog服务来记录。</p><h1 id="logger命令的使用"><a href="#logger命令的使用" class="headerlink" title="logger命令的使用"></a>logger命令的使用</h1><p>格式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger [options] message</span><br></pre></td></tr></table></figure></p><p>重要参数如下：</p><pre><code>-p facility.level  #制定这条日志的facility和等级，syslogd可以依据此来记录这条日志，缺省的是user.notice</code></pre><h1 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger this is <span class="built_in">test</span> <span class="built_in">log</span></span><br><span class="line">logger -p user.info this is <span class="built_in">test</span> <span class="built_in">log</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux日志滚动或日志切割工具logrotate</title>
      <link href="/2018/02/04/Linux%E6%97%A5%E5%BF%97%E6%BB%9A%E5%8A%A8%E6%88%96%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%B7%A5%E5%85%B7logrotate/"/>
      <url>/2018/02/04/Linux%E6%97%A5%E5%BF%97%E6%BB%9A%E5%8A%A8%E6%88%96%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%B7%A5%E5%85%B7logrotate/</url>
      
        <content type="html"><![CDATA[<h1 id="logrotate简介"><a href="#logrotate简介" class="headerlink" title="logrotate简介"></a>logrotate简介</h1><p>logrotate程序是一个日志文件管理工具，用于分割日志文件，删除旧的日志文件，并创建新的日志文件，起到“转储”作用。可以节省磁盘空间。日志切割的过程是，比如以系统日志/var/log/messages做切割来简单说明下：</p><pre><code>第一次执行完rotate之后，原本的messages会变成messages.1，而且会制造一个空的messages给系统来储存日志；第二次执行之后，messages.1会变成messages.2，而messages会变成messages.1，又造成一个空的messages来储存日志；如果仅设定保留三个日志（即轮转3次）的话，那么执行第三次时，则messages.3这个档案就会被删除，并由后面的较新的保存日志所取代，也就是会保存最新的几个日志。</code></pre><p>logrotate不是一个常驻内存的后台服务，而是依赖crontab来执行，/etc/cron.daily/logrotate中配置了<code>/usr/sbin/logrotate /etc/logrotate.conf</code>，所有logrotate是有crontab来调度执行的。当然我们也可以通过<code>logrotate /etc/logrotate.conf</code>命令来手动执行。</p><p>logrotate命令常用的选项有：</p><pre><code>-d —— 调试模式，logrotate会打印执行过程，但不会真正去切割日志。另外，-d隐含了-v参数-v —— 打印logrotate详细执行过程-f —— 比如logrotate.conf中配置某个日志按周切割，现在还没有一周，此时当我们手动执行logrotate时，因为时间条件不满足，是不会切割日志的。当加上-f参数后，就会去强制切割日志</code></pre><p>logrotate命令使用举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logrotate /etc/logrotate.conf</span><br><span class="line">logrotate -d /etc/logrotate.conf</span><br><span class="line">logrotate -v /etc/logrotate.conf</span><br><span class="line">logrotate -vf /etc/logrotate.conf</span><br></pre></td></tr></table></figure><h1 id="logrotate的配置"><a href="#logrotate的配置" class="headerlink" title="logrotate的配置"></a>logrotate的配置</h1><p>logrotate是linux系统默认安装的工具，logrotate的配置文件是<code>/etc/logrotate.conf</code>和<code>/etc/logrotate.d/*</code>，其中<code>/etc/logrotate.con</code>是logrotate的主要的配置文件，<code>/etc/logrotate.d/</code>是一个目录，该目录里的所有文件都会被include指令加入<code>/etc/logrotate.conf</code>中。<code>/etc/logrotate.d/</code>目录可以放入一些我们针对某些日志单独配置的切割配置。<code>/etc/logrotate.d/</code>中会以<code>/etc/logrotate.conf</code>中配置作为默认值，另外，<code>/etc/logrotate.d/</code>中配置会覆盖<code>/etc/logrotate.conf</code>的配置。</p><p>如下为logrotate.conf的一些重要配置指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">compress                  <span class="comment"># 通过gzip压缩转储以后的日志</span></span><br><span class="line">nocompress                <span class="comment"># 不做gzip压缩处理</span></span><br><span class="line">copytruncate              <span class="comment"># 用于还在打开中的日志文件，把当前日志备份并截断；是先拷贝再清空的方式，拷贝和清空之间有一个时间差，可能会丢失部分日志数据</span></span><br><span class="line">nocopytruncate            <span class="comment"># 备份日志文件不过不截断</span></span><br><span class="line">create mode owner group   <span class="comment"># 轮转时指定创建新文件的属性，如create 0777 nobody nobody</span></span><br><span class="line">nocreate                  <span class="comment"># 不建立新的日志文件</span></span><br><span class="line">delaycompress             <span class="comment"># 和compress一起使用时，转储的日志文件到下一次转储时才压缩</span></span><br><span class="line">nodelaycompress           <span class="comment"># 覆盖 delaycompress 选项，转储同时压缩。</span></span><br><span class="line">missingok                 <span class="comment"># 如果日志丢失，不报错继续滚动下一个日志</span></span><br><span class="line">errors address            <span class="comment"># 专储时的错误信息发送到指定的Email 地址</span></span><br><span class="line">ifempty                   <span class="comment"># 即使日志文件为空文件也做轮转，这个是logrotate的缺省选项。</span></span><br><span class="line">notifempty                <span class="comment"># 当日志文件为空时，不进行轮转</span></span><br><span class="line">mail address              <span class="comment"># 把转储的日志文件发送到指定的E-mail 地址</span></span><br><span class="line">nomail                    <span class="comment"># 转储时不发送日志文件</span></span><br><span class="line">olddir directory          <span class="comment"># 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统</span></span><br><span class="line">noolddir                  <span class="comment"># 转储后的日志文件和当前日志文件放在同一个目录下</span></span><br><span class="line">sharedscripts             <span class="comment"># 运行postrotate脚本，作用是在所有日志都轮转后统一执行一次脚本。如果没有配置这个，那么每个日志轮转后都会执行一次脚本</span></span><br><span class="line">prerotate                 <span class="comment"># 在logrotate转储之前需要执行的指令，例如修改文件的属性等动作；必须独立成行</span></span><br><span class="line">postrotate                <span class="comment"># 在logrotate转储之后需要执行的指令，例如重新启动 (kill -HUP) 某个服务！必须独立成行</span></span><br><span class="line">daily                     <span class="comment"># 指定转储周期为每天</span></span><br><span class="line">weekly                    <span class="comment"># 指定转储周期为每周</span></span><br><span class="line">monthly                   <span class="comment"># 指定转储周期为每月</span></span><br><span class="line">rotate count              <span class="comment"># 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份</span></span><br><span class="line">dateext                   <span class="comment"># 使用当期日期作为命名格式</span></span><br></pre></td></tr></table></figure><p>如下举例来说明logrotate的配置方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@master-server ~]<span class="comment"># vim /etc/logrotate.d/nginx</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx/logs/*.<span class="built_in">log</span> &#123;</span><br><span class="line">daily</span><br><span class="line">rotate 7</span><br><span class="line">missingok</span><br><span class="line">notifempty</span><br><span class="line">dateext</span><br><span class="line">sharedscripts</span><br><span class="line">postrotate</span><br><span class="line">    <span class="keyword">if</span> [ -f /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">kill</span> -USR1 `cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid`</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="logrotate切割日志的原理"><a href="#logrotate切割日志的原理" class="headerlink" title="logrotate切割日志的原理"></a>logrotate切割日志的原理</h1><p>logrotate的日志切割方式有两种：</p><p>（1）create模式</p><p>即“先move再touch”的过程。首先先将当前日志文件重命名为一个新的文件，然后再touch出一个新的文件。例如/var/log/messages，先将messages文件move为messages.1，然后再touch出一个新的messages文件。值得注意的是，进程读写文件是通过inode，所以move走原始日志文件后，进程还是会向该文件输出日志。所以必须让进程重新打开日志，最简单粗暴的方式就是重启进程。</p><p>备注：使用create指令就是使用该种方式rotate日志</p><p>（2）copytruncate模式</p><p>即“先copy再truncate”的过程。首先先将当前日志文件copy，然后再置空当前日志文件。例如/var/log/messages，先用messges拷贝出一个新的文件messages.1，然后把messages置空。这样程序会继续往/var/log/messages中打印日志。值得注意是，该种方式下，在拷贝和置空的间隙可能会丢失一少部分日志。</p><p>备注：使用copytruncate指令就是使用该种方式rotate日志，配置了copytruncate指令后，create指令就会失效，二者是互斥的。</p><h1 id="logrotate的最佳实践"><a href="#logrotate的最佳实践" class="headerlink" title="logrotate的最佳实践"></a>logrotate的最佳实践</h1><p>（1）一般来说，我们不把日志轮替的规则全部配置在/etc/logrotate.conf中，而是配置到/etc/logrotate.d/下某个文件中，然后在/etc/logrotate.conf中通过include指令将配置文件引入进来即可。</p><p>学习资料参考于：<br><a href="http://www.cnblogs.com/kevingrace/p/6307298.html" target="_blank" rel="noopener">http://www.cnblogs.com/kevingrace/p/6307298.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下install命令</title>
      <link href="/2018/02/04/Linux%E4%B8%8Binstall%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/02/04/Linux%E4%B8%8Binstall%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="install命令"><a href="#install命令" class="headerlink" title="install命令"></a>install命令</h1><p>install和cp类似，都可以将文件/目录拷贝到指定的地点。但是，install允许你控制目标文件的属性。install通常用于程序的makefile（在RPM的spec里面也经常用到），使用它来将程序拷贝到目标（安装）目录。</p><h1 id="install命令的使用"><a href="#install命令的使用" class="headerlink" title="install命令的使用"></a>install命令的使用</h1><p>install的使用格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">install [OPTION] [-T] SOURCE DEST</span><br><span class="line">install [OPTION] SOURCE DIRECTORY</span><br><span class="line">install [OPTION] -t DIRECTORY SOURCE</span><br><span class="line">install [OPTION] -d DIRECTORY</span><br></pre></td></tr></table></figure><p>install命令常用选项：</p><pre><code>-p —— 安装文件时，保留原来的文件的时间戳属性-m —— 自行设置权限，而不是默认的rwxr-xr-x-D —— 创建目的地前的所有目录，然后将来源复制到目的地</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下chattr和lsattr命令的使用小结</title>
      <link href="/2018/02/04/Linux%E4%B8%8Bchattr%E5%92%8Clsattr%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/02/04/Linux%E4%B8%8Bchattr%E5%92%8Clsattr%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="chattr-lsattr简介"><a href="#chattr-lsattr简介" class="headerlink" title="chattr/lsattr简介"></a>chattr/lsattr简介</h1><p>chattr命令的作用很大，其中一些功能是由Linux内核版本来支持的，不过现在生产绝大部分跑的linux系统都是2.6以上内核了。通过chattr命令修改属性能够提高系统的安全性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录。lsattr命令是显示chattr命令设置的文件属性。</p><p>这两个命令是用来查看和改变文件、目录属性的，与chmod这个命令相比，chmod只是改变文件的读写、执行权限，更底层的属性控制是由chattr来改变的。</p><h1 id="chattr的使用"><a href="#chattr的使用" class="headerlink" title="chattr的使用"></a>chattr的使用</h1><p>命令使用格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr [ -RVf ] [ -v version ] [ mode ] files…</span><br></pre></td></tr></table></figure><p>备注：最关键的是在[mode]部分，[mode]部分是由+-=和[acdeijstuADST]这些字符组合的，这部分是用来控制文件的 属性。</p><h1 id="chattr-lsattr可查看和设置的一些属性"><a href="#chattr-lsattr可查看和设置的一些属性" class="headerlink" title="chattr/lsattr可查看和设置的一些属性"></a>chattr/lsattr可查看和设置的一些属性</h1><pre><code>i —— 设定该属性后，文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。i参数对于文件 系统的安全设置有很大帮助a —— 即append，设定该属性后，只能向文件中添加数据，而不能删除，多用于服务器日志文件安全，只有root才能设定这个属性</code></pre><h1 id="chattr-lsattr命令使用举例"><a href="#chattr-lsattr命令使用举例" class="headerlink" title="chattr/lsattr命令使用举例"></a>chattr/lsattr命令使用举例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chattr +i file1  <span class="comment">#给file1增加i属性</span></span><br><span class="line">chattr -i file1  <span class="comment">#去掉file1的i属性</span></span><br><span class="line">chattr +a file1  <span class="comment">#给file1增加a属性</span></span><br><span class="line">chattr -a file1  <span class="comment">#去掉file1的a属性</span></span><br><span class="line">lsattr file1</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://www.ha97.com/5172.html" target="_blank" rel="noopener">http://www.ha97.com/5172.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的限制用户资源使用的配置工具ulimit使用</title>
      <link href="/2018/02/04/Linux%E4%B8%AD%E7%9A%84%E9%99%90%E5%88%B6%E7%94%A8%E6%88%B7%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7ulimit%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/04/Linux%E4%B8%AD%E7%9A%84%E9%99%90%E5%88%B6%E7%94%A8%E6%88%B7%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7ulimit%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h1><p>ulimit是一种简单并且有效的实现资源限制的方式。</p><p>ulimit用于限制shell启动进程所占用的资源，支持以下各种类型的限制：所创建的内核文件的大小、进程数据块的大小、Shell进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU时间、单个用户的最大线程数、Shell进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。</p><p>作为临时限制，ulimit可以作用于通过使用其命令登录的shell会话，在会话终止时便结束限制，并不影响于其他shell会话。而对于长期的固定限制，ulimit命令语句又可以被添加到由登录shell读取的文件中，作用于特定的shell用户。</p><h1 id="ulimit命令格式及常用选项"><a href="#ulimit命令格式及常用选项" class="headerlink" title="ulimit命令格式及常用选项"></a>ulimit命令格式及常用选项</h1><p>命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> [options] parameter</span><br></pre></td></tr></table></figure><p>命令常用的参数有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-H  <span class="comment">#设置硬资源限制，即是一定不会超过配额值</span></span><br><span class="line">-S  <span class="comment">#设置软资源限制，即可以超过配额值，但若超过配额值会有警告信息</span></span><br><span class="line">-a  <span class="comment">#显示当前所有的limit信息</span></span><br><span class="line">-c  <span class="comment">#最大的core文件的大小， 以blocks为单位</span></span><br><span class="line">-d  <span class="comment">#进程最大的数据段的大小，以Kbytes为单位</span></span><br><span class="line">-f  <span class="comment">#进程可以创建文件的最大值，以blocks为单位</span></span><br><span class="line">-l  <span class="comment">#最大可加锁内存大小，以Kbytes为单位</span></span><br><span class="line">-m  <span class="comment">#最大内存大小，以Kbytes为单位</span></span><br><span class="line">-n  <span class="comment">#可以打开最大文件描述符的数量</span></span><br><span class="line">-p  <span class="comment">#管道缓冲区的大小，以Kbytes为单位</span></span><br><span class="line">-s  <span class="comment">#线程栈大小，以Kbytes为单位</span></span><br><span class="line">-t  <span class="comment">#最大的CPU占用时间，以秒为单位</span></span><br><span class="line">-u  <span class="comment">#用户最大可用的进程数</span></span><br><span class="line">-v  <span class="comment">#进程最大可用的虚拟内存，以Kbytes为单位</span></span><br></pre></td></tr></table></figure><p>备注：我们可以通过<code>ulimit -a</code>命令的输出结果，来对应出每个配置项的参数</p><h1 id="ulimit命令使用举例"><a href="#ulimit命令使用举例" class="headerlink" title="ulimit命令使用举例"></a>ulimit命令使用举例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> –Hs 64         <span class="comment">#限制硬资源，线程栈大小为64K</span></span><br><span class="line"><span class="built_in">ulimit</span> –Sn 32         <span class="comment">#限制软资源，32个文件描述符</span></span><br><span class="line"><span class="built_in">ulimit</span> -a             <span class="comment">#显示当前所有的limit信息</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited   <span class="comment">#对生成的core文件的大小不进行限制</span></span><br><span class="line"><span class="built_in">ulimit</span> -f 2048        <span class="comment">#限制进程可以创建的最大文件大小为2048blocks</span></span><br></pre></td></tr></table></figure><h1 id="ulimit的使用方式"><a href="#ulimit的使用方式" class="headerlink" title="ulimit的使用方式"></a>ulimit的使用方式</h1><p>（1）在命令行执行<code>ulimit [options] parameter</code><br>在命令执行<code>ulimit [options] parameter</code>进行资源限制，是有其作用范围的。这种情况下，ulimit限制的是当前shell进程以及其派生的子进程。举例来说，如果用户同时运行了两个shell终端进程，只在其中一个环境中执行了<code>ulimit -s 100</code>，则该shell进程里创建文件的大小收到相应的限制，而同时另一个shell终端包括其上运行的子程序都不会受其影响。</p><p>备注：当然，退出终端，会话结束，bash退出，ulimit设定的限制也就不存在了。</p><p>（2）修改系统的<code>/etc/security/limits.conf</code>和<code>/etc/security/limits.d/*</code>配置文件</p><p><code>/etc/security/limits</code>和<code>/etc/security/limits.d/*</code>文件是linux PAM（插入式认证模块，Pluggable Authentication Modules）中pam_limits.so的配置文件。pam_limits.so先加载<code>/etc/security/limits.conf</code>，如果<code>/etc/security/limits.d/</code>目录下还有配置文件的话，也会被加载一起分析。这就意味<code>/etc/security/limits.d/</code>里面的文件里面的配置会覆盖<code>/etc/security/limits.conf</code>的配置。通过修改<code>/etc/security/limits.conf</code>和<code>/etc/security/limits.d/*</code>文件不仅能限制指定用户的资源使用，还能限制指定组的资源使用。该文件的每一行都是对限定的一个描述，格式如下：</p><pre><code>&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt;</code></pre><p>其中domain表示用户或者组的名字，还可以使用<code>*</code>作为通配符。type可以有两个值，soft和hard。item则表示需要限定的资源，可以有很多候选值，如stack，cpu，nofile等等，分别表示最大的堆栈大小，占用的cpu时间，以及打开的文件数。通过添加对应的一行描述，则可以产生相应的限制。例如：</p><pre><code>* hard noflle 100       #该行配置语句限定了任意用户所能创建的最大文件数是100apache hard noflle 100  #限定了apache用户所能创建的最大文件数是100</code></pre><p>备注：修改了/etc/security/limits.conf配置文件后，配置会直接生效，不用重启系统哦。</p><h1 id="ulimit与sysctl"><a href="#ulimit与sysctl" class="headerlink" title="ulimit与sysctl"></a>ulimit与sysctl</h1><p>使用ulimit只是对某个用户或用户组所使用系统资源进行限制。有时候，我们需要对整个系统或内核上的进行资源限制，这时我们可以选择借助systrl工具修改内核参数来达到这个目的，举例来说，内核参数<code>fs.file-max</code>代表系统范围内所有进程可打开的文件句柄的数量限制，内核参数<code>fs.nr_open</code>表示单个进程打开文件句柄数上限。</p><p>学习资料参考于：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pgrep和pkill命令的使用</title>
      <link href="/2018/02/04/pgrep%E5%92%8Cpkill%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/04/pgrep%E5%92%8Cpkill%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pgrep与pkill"><a href="#pgrep与pkill" class="headerlink" title="pgrep与pkill"></a>pgrep与pkill</h1><p>pgrep和pkill是类似的，pgrep是通过进程的名称或其他属性查找进程，将满足条件的所有进程的PID列出来。pkill除了可以完成pgrep的功能，还能向匹配到的进程发送信号。</p><h1 id="pgrep和pkill命令使用举例"><a href="#pgrep和pkill命令使用举例" class="headerlink" title="pgrep和pkill命令使用举例"></a>pgrep和pkill命令使用举例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pgrep named           <span class="comment">#列出名称为named的所有进程的进程号</span></span><br><span class="line">pgrep -u root sshd    <span class="comment">#列出所有进程名为sshd，且属于root用户的进程的进程号</span></span><br><span class="line">pgrep -u root,daemon  <span class="comment">#列出所有属于root或daemon用户的进程的进程号</span></span><br><span class="line">pkill -HUP syslog     <span class="comment">#向名称为syslog的所有进程发送SIGHUP信号</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中表格化的格式输出工具column</title>
      <link href="/2018/02/04/Linux%E4%B8%AD%E8%A1%A8%E6%A0%BC%E5%8C%96%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E5%B7%A5%E5%85%B7column/"/>
      <url>/2018/02/04/Linux%E4%B8%AD%E8%A1%A8%E6%A0%BC%E5%8C%96%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E5%B7%A5%E5%85%B7column/</url>
      
        <content type="html"><![CDATA[<h1 id="column命令"><a href="#column命令" class="headerlink" title="column命令"></a>column命令</h1><p>linux有些命令的输出，因为字符串过度拥挤导致输出内容难以识别，例如mount命令。而column命令可以将一些命令的输出内容以表格的形式显示出来。</p><p>column命名默认以空格符来作为表格字段拆分，当然可以通过-s参数显式地指定分割符。</p><h1 id="column命令使用举例"><a href="#column命令使用举例" class="headerlink" title="column命令使用举例"></a>column命令使用举例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount | column -t                  <span class="comment">#将mount命令的输出用表格的形式打印出来</span></span><br><span class="line">cat /etc/passwd | column -t -s :   <span class="comment">#将文件/etc/passwd中的每行内容以冒号(:)分割开来，并以表格的方式打印出来</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中交互输入yes命令</title>
      <link href="/2018/02/04/Linux%E4%B8%AD%E4%BA%A4%E4%BA%92%E8%BE%93%E5%85%A5yes%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/02/04/Linux%E4%B8%AD%E4%BA%A4%E4%BA%92%E8%BE%93%E5%85%A5yes%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="yes命令"><a href="#yes命令" class="headerlink" title="yes命令"></a>yes命令</h1><p>yes命令可以重复输出指定的字符串到终端，直到被终止。默认会输出字符y。使用yes命令可以更加自动化地执行一些命令。举例来说，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yes | rm testfile           <span class="comment">#直接删除testfile，不用手动确认，相当于为rm命令加上了-f参数</span></span><br><span class="line">yes | yum install iftop     <span class="comment">#这样在安装iftop时，就不需要用户手动键入yes确认</span></span><br><span class="line">yes no | yum install iftop  <span class="comment">#这样在安装iftop时，提示用户确认安装时，自动输入no字符串，而导致安装终止</span></span><br><span class="line">yes YAMAHA                  <span class="comment">#在终端屏幕上循环打印YAMAHA字符串</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的小工具hping3 | fping | arping</title>
      <link href="/2018/02/03/Linux%E4%B8%8B%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7hping3-fping-arping/"/>
      <url>/2018/02/03/Linux%E4%B8%8B%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7hping3-fping-arping/</url>
      
        <content type="html"><![CDATA[<h1 id="hping3"><a href="#hping3" class="headerlink" title="hping3"></a>hping3</h1><p>（1）hping3简介</p><p>hping是用于生成和解析TCP/IP协议数据包的开源工具。创作者是Salvatore Sanfilippo。目前最新版是hping3。hping优势在于能够定制数据包的各个部分，因此用户可以灵活对目标机进行细致地探测。</p><p>（2）hping3命令的使用格式及重要选项</p><pre><code>-c count  #发出数据包的数量-S        #发送的TCP数据包，置位为SYN，即发出SYN TCP-p        #指定端口</code></pre><p>（3）hping3使用举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 4 -S -p 80 www.baidu.com   <span class="comment">#向www.baidu.com的80端口，发送4个SYN数据包</span></span><br></pre></td></tr></table></figure><p>备注：用的就不是ICMP协议了</p><p>学习资料参考于：<br><a href="http://man.linuxde.net/hping3" target="_blank" rel="noopener">http://man.linuxde.net/hping3</a></p><h1 id="fping"><a href="#fping" class="headerlink" title="fping"></a>fping</h1><p>fping程序类似于ping。fping与ping不同的地方在于，fping可以在命令行中指定多个探测主机，也可以指定含有要ping的主机列表文件。与ping要等待某一主机连接超时或发回反馈信息不同，fping给一个主机发送完数据包后，马上给下一个主机发送数据包，实现多主机同时ping。如果某一主机ping通，则此主机将被打上标记，并从等待列表中移除，如果没ping通，说明主机无法到达，主机仍然留在等待列表中，等待后续操作。fping命令的使用举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fping -f hostlist.txt       <span class="comment">#从hostlist.txt中读取机器列表，进行ping存活检测</span></span><br><span class="line">fping -c 3 -f hostlist.txt  <span class="comment">#从hostlist.txt中读取机器列表，并且每个目标机器被ping 3次</span></span><br><span class="line">fping -g 192.168.1.0/24     <span class="comment">#对某一个网段中的机器进行ping存活检测</span></span><br></pre></td></tr></table></figure><h1 id="arping"><a href="#arping" class="headerlink" title="arping"></a>arping</h1><p>向局域网中的机器发起arp解析，获取目标主机的MAC地址。</p><p>arping命令使用格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arping [options] [-c count] [-w deadline] [-s <span class="built_in">source</span>] -I interface destination</span><br></pre></td></tr></table></figure><p>arping命令使用举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arping 10.16.31.249        <span class="comment">#请求IP地址为10.16.31.249的主机MAC地址</span></span><br><span class="line">arping -I eth0 10.16.54.3  <span class="comment">#从网卡eth0发起主机10.16.54.3的MAC地址询问</span></span><br></pre></td></tr></table></figure><p>备注：arping用的就不是ICMP协议了</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中关于进程组|会话|控制终端的一点知识</title>
      <link href="/2018/02/03/Linux%E4%B8%AD%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%BB%84-%E4%BC%9A%E8%AF%9D-%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF%E7%9A%84%E4%B8%80%E7%82%B9%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/02/03/Linux%E4%B8%AD%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%BB%84-%E4%BC%9A%E8%AF%9D-%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF%E7%9A%84%E4%B8%80%E7%82%B9%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux中关于进程的几个概念"><a href="#Linux中关于进程的几个概念" class="headerlink" title="Linux中关于进程的几个概念"></a>Linux中关于进程的几个概念</h1><p>（1）进程组</p><p>进程组是一个或多个进程的集合，进程组方便了对多个进程的控制，在进程数较多的情况下，向进程组发送信号就行了。进程组ID是由它的组长进程的进程ID决定。组长进程创建了进程组，但它并不能决定进程组的存活时间，只要进程组内还有一个进程存在，进程组就存在，与组长进程是否已终止无关。</p><p>（2）会话</p><p>会话(session)是一个或多个进程组的集合，它开始于用户登陆终端，结束于用户退出登陆。其义如其名，就是指用户与系统的一次对话的全程。会话包括控制进程（与终端建立连接的领头进程），一个前台进程组和任意后台进程组。一个会话只能有一个控制终端，通常是登录到其上的终端设备或伪终端设备，产生在控制终端上的输入和信号将发送给会话的前台进程组中的所有进程。</p><p>（3）控制终端</p><p>每当我们使用终端工具打开一个本地或远程shell，我们便打开了一个控制终端。</p><p>备注：说白了，终端控制，就是我们登录Linux系统后得到的TTY，如物理终端机tty1-tty6、或伪终端机pts/n之类的。</p><p>如下为进程组与会话的关系：</p><p><img src="/images/linuxsession_1_1.png" alt></p><h1 id="终端机退出及进程存活问题"><a href="#终端机退出及进程存活问题" class="headerlink" title="终端机退出及进程存活问题"></a>终端机退出及进程存活问题</h1><p>我们每次在终端窗口执行命令的时候，进程总会一直占用着终端，直到进程结束，这段时间内，我们在终端的输入是没有用的。而且，当终端窗口关闭或网络连接失败后，再次打开终端，会发现进程已经中断了。这是因为用户注销或者网络断开时，SIGHUP信号会被发送到会话所属的子进程，而此SIGHUP的默认处理方式是终止收到该信号的进程。所以若程序中没有捕捉该信号，当终端关闭后，会话所属进程就会退出。</p><p>在Linux中终端退出，仍能保证进程执行可以有如下几种方式：</p><p>（1）nohup</p><p>nohup是一个我们常用的命令了，它的作用如其字面意思，使进程不受SIGHUP信号的影响。但我们在使用nohup php test.php后会发现，进程还会一直占用前台终端，但即使终端被关闭或连接断开了，程序还是会执行，另外我们会发现在当前文件夹下多了个名为nohup.out的文件。这是因为nohup的功能仅仅是让进程不受SIGHUP信号的影响，并不会让出前台终端，而且它还会在命令执行目录下建立nohup.out用以存储进程的输出。如果进程不需要输出，且不想让nohup创建文件，可以将标准输出和标准错误输出重定向。 我们常将nohup和&amp;搭配到一块使用，执行命令如下<code>nohup command &gt; /dev/null 2&gt;&amp;1 &amp;</code>这样，就可以放心的等待进程运行结果了。</p><p>（2）setsid</p><p>setsid是另一个让进程在后台执行的命令，它的作用是让进程打开一个新的会话并运行进程，使用方式为<code>setsid command</code>。根据上面的概念我们得知终端关闭后进程退出是因为会话首进程向进程发送了SIGHUP信号，setsid就厉害了，它直接打开一个新的会话来执行命令，那么原会话的终端的状态就再也不会影响到此进程了。</p><p>（3）一些终端复用工具</p><p>如screen，tmux等。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>系统日志服务[r]syslog[{d-ng}]技术调研</title>
      <link href="/2018/02/03/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1-r-syslog-d-ng-%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/02/03/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1-r-syslog-d-ng-%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<p>对于日志管理，老版本的Linux缺省使用syslog，虽然syslog中规中矩，但是随着时间的推移，无论是功能还是性能，它都显得捉襟见肘，于是出现了rsyslog和syslog-ng，它们不仅涵盖了sysLog的基本功能，而且在功能和性能上更为出色。目前多数Linux发行版均选择了rsyslog。下面一一介绍syslog、syslog-ng以及rsyslog。</p><h1 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h1><p>（1）syslog简介</p><p>syslog日志记录器由两个守护进程klogd/syslogd和一个配置文件/etc/syslog.conf组成。klogd不使用配置文件，它负责截获内核消息，它既可以独立使用也可以作为syslogd的客户端运行，也就是klogd可以将捕获的内核日志直接记录到文件中，也可以转发给syslogd。syslogd默认使用/etc/syslog.conf作为配置文件，它负责截获应用程序消息，还可以截获klogd向其转发的内核消息。Linux系统启动时，/etc/init.d/syslogd脚本会同时启动syslogd和klogd.</p><p>备注：其实syslog还有一个配置文件/etc/sysconfig/syslog，这个文件用来配置syslog在启动syslogd和klogd时的一些启动参数，例如如果想让syslogd作为日志服务器来接受其他syslog发过来的日志，就需要修改/etc/sysconfig/syslog的配置。</p><p>（2）syslogd的配置</p><p>syslog.conf是syslogd进程的配置文件，将在程序启动时读取，默认位置是/etc/syslog.conf 。它指定了一系列日志记录规则。规则的格式如下：</p><pre><code>facility.level    action</code></pre><p>这个配置文件中的空白行和以”#”开头的行将被忽略。”facility.level”部分也被称为选择符(seletor)。seletor和action之间使用一个或多个空白分隔。</p><p>A）facility</p><p>选择符由facility和level两部分组成，之间用一个句点(.)连接。facility指定了产生日志的子系统，可以是下面的关键字之一：</p><pre><code>auth      #由pam_pwdb报告的认证活动authpriv  #包括私有信息(如用户名)在内的认证活动cron      #与cron和at有关的信息daemon    #与inetd守护进程有关的信息ftp       #与FTP有关的信息kern      #内核信息，首先通过klogd传递lpr       #与打印服务有关的信息mail      #与电子邮件有关的信息mark      #syslog内部功能用于生成时间戳news      #来自新闻服务器的信息syslog    #由syslog生成的信息user      #由用户程序生成的信息uucp      #由uucp生成的信息local0 ~ local7  #由自定义程序使用，例如使用local5做为ssh功能*                #通配符代表除了mark以外的所有facility</code></pre><p>备注：在大多数情况下，任何程序都可以通过任何facility发送日志消息，但是一般都遵守约定俗成的规则。比如，只有内核才能使用”kern” facility.</p><p>B）level</p><p>level指定了消息的优先级，可以是下面的关键字之一(降序排列，严重性越来越低)：</p><pre><code>emerg   #系统不可用alert   #需要立即被修改的条件crit    #阻止某些工具或子系统功能实现的错误条件err     #阻止工具或某些子系统部分功能实现的错误条件warning #预警信息notice  #具有重要性的普通条件info    #提供信息的消息debug   #不包含函数条件或问题的其他信息none    #没有优先级，通常用于排错*       #除了none之外的所有级别</code></pre><p>备注：facility部分可以是用逗号(,)分隔的多个子系统，而多个seletor之间也可以通过分号(;)组合在一起。需要注意的是，多个组合在一起的选择符，后面的会覆盖前面的，这样就允许从模式中排除一些优先级。</p><p>C）动作action</p><p>这个字段定义了对符合条件的消息进行何种操作，可以选择下列操作之一：</p><ul><li><p>普通文件，将消息记录到这个文件中，必须使用绝对路径。如果在文件名之前加上减号(-)，则表示不将日志信息同步刷新到磁盘上(使用写入缓存)，这样可以提高日志写入性能，但是增加了系统崩溃后丢失日志的风险。</p></li><li><p>命名管道，在绝对路径表示的FIFO文件（使用mkfifo命令创建）前加上管道符号(|)即可。通常用于调试。比如：|/usr/adm/debug。</p></li><li><p>终端或者控制台，比如/dev/tty1或/dev/console。</p></li><li><p>远程主机，syslogd能够将消息发送到远程主机或从远程主机接收消息，不过默认并不转发接收到的消息。要将消息发送到远程主机，可以在主机名前加一个”@”即可。</p></li><li><p>逗号分隔的用户名列表，critical级别的消息除了记录到日志之外，通常还转发到root用户。</p></li><li><p>所有当前登录的用户，如果写上一个星号(*)则表示向当前所有登录的用户显示这条消息。</p></li></ul><p>备注： syslogd默认从Unix domain socket读取本地日志消息，而klogd默认首选从/proc/kmsg中获取内核消息。</p><p>（3）syslogd和klogd启动参数的配置</p><p>/etc/sysconfig/syslog文件可以用来配置syslogd和klogd的启动参数，在该文件中有SYSLOGD_OPTIONS和KLOGD_OPTIONS两个属性，分别用来控制syslogd和klogd启动时的命令行参数。具体配置选项有：</p><pre><code>-r —— 打开接受外来日志消息的功能，其监控514 UDP端口-x —— 关闭自动解析对方日志服务器的FQDN信息，这能避免DNS不完整所带来的麻烦-m —— 修改syslog的内部mark消息写入间隔时间（0为关闭），例如240为每隔240分钟写入一次“--MARK--”信息-h —— 默认情况下，syslog不会发送从远端接受过来的消息到其他主机，而使用该选项，则把该开关打开，所有接受到的信息都可根据syslog.conf中定义的@主机转发过去</code></pre><p>（4）用户程序使用syslog记录日志信息</p><p>Linux C中提供一套系统日记写入接口，包括三个函数：openlog，syslog和closelog。举例来说：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;   </span><br><span class="line">    openlog(<span class="string">"testsyslog"</span>, LOG_CONS | LOG_PID, <span class="number">0</span>);   </span><br><span class="line">    syslog(LOG_USER | LOG_INFO, <span class="string">"syslog test message generated in program %s \n"</span>, argv[<span class="number">0</span>]);   </span><br><span class="line">    closelog();   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成可执行文件后，每运行一次，程序将往/var/log/messages添加一条如下的记录。</p><p>备注：其中LOG_USER是指定往syslog的哪个facility中写入日志，LOG_INFO表示这条日志的等级。</p><p>（5）一些常见的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/var/log/messages   #包含整个系统的信息，包括系统启动期间被记录的日志。mail, cron, daemon, kern, auth等相关的日志信息在这里记录</span><br><span class="line">/var/log/dmesg      #系统的启动日志信息</span><br><span class="line">/var/log/auth.log   #包括系统的授权信息，包括用户登陆和使用的权限机制等</span><br><span class="line">/var/log/boot.log   #包含系统启动时记录的日志</span><br><span class="line">/var/log/daemon.log #包括多种后台守护进程的日志信息</span><br><span class="line">/var/log/dpkg.log   #包括使用dpkg命令安装或删除包时记录的信息</span><br><span class="line">/var/log/kern.log   #内核记录的信息。可以帮助定位定制内核的问题(注：在ArchLinux中为kernel.log)</span><br><span class="line">/var/log/lastlog    #最近所有用户的登陆信息，这不是一个ascii文件，应该使用lastlog命令来查看文件信息</span><br><span class="line">/var/log/maillog /var/log/mail.log #包含系统中运行的邮件服务的日志。例如sendmail的日志信息都会在这里被记录</span><br><span class="line">/var/log/user.log    #包括所有用户等级的日志</span><br><span class="line">/var/log/Xorg.x.log  #X系统的日志信息</span><br><span class="line">/var/log/alternatives.log  #关于更新替代的信息，Ubuntu中，不同的默认命令，会有不同的符号链接到对应的文件（？）On Ubuntu, update-alternatives maintains symbolic links determining default commands.</span><br><span class="line">/var/log/btmp         #包含尝试登陆失败的信息，使用last 命令查看，例如 “last -f /var/log/btmp | more”</span><br><span class="line">/var/log/cups         #所有的打印机和打印相关的</span><br><span class="line">/var/log/anaconda.log #存储安装相关的信息</span><br><span class="line">/var/log/yum.log      #使用yum安装包时的相关信息</span><br><span class="line">/var/log/cron         #每当cron守护进程（或anacron）开始cron定时操作时，都会将日志信息记录再这里</span><br><span class="line">/var/log/secure       #包含认证和授权相关的信息。例如sshd登陆记录的所有信息，包括失败的信息</span><br><span class="line">/var/log/wtmp 或 /var/log/utmp  #包含登陆记录。使用wtmp可以查出都有谁登陆过系统，非ASCII文件。who命令通过这个文件来显示信息。（wtmp 编程）</span><br><span class="line">/var/log/faillog      #包含用户的失败登陆尝试，使用faillog命令显示文件内容。非ASCII文件</span><br></pre></td></tr></table></figure><p>除了以上的日志文件，/var/log目录也包含一些子目录，这取决于你系统上运行的应用，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/var/<span class="built_in">log</span>/httpd/ 或 /var/<span class="built_in">log</span>/apache2  <span class="comment">#包括apache web服务器的access_log和error_log信息</span></span><br><span class="line">/var/<span class="built_in">log</span>/lighttpd/                   <span class="comment">#包含lighthttpd的access_log和error_log信息</span></span><br><span class="line">/var/<span class="built_in">log</span>/conman/                     <span class="comment">#ConMan客户端的日志文件（ConMan是一个console manager，需要有conmand守护进程运行）</span></span><br><span class="line">/var/<span class="built_in">log</span>/mail/                       <span class="comment">#包含邮件服务的额外日志。例如，sendmain会收集邮件的统计信息保存在/var/log/mail/statistics文件中</span></span><br><span class="line">/var/<span class="built_in">log</span>/prelink/           <span class="comment">#预链接（prelink program）修改（modifies?）已共享的库文件以及已链接的二进制文件来加速启动新的进程。/var/log/prelink/prelink.log 包含被prelink修改过的.so文件的信息</span></span><br><span class="line">/var/<span class="built_in">log</span>/audit/             <span class="comment">#包含Linux audit daemon (auditd).存储的信息（？）</span></span><br><span class="line">/var/<span class="built_in">log</span>/setroubleshoot/    <span class="comment">#SELinux使用setroubleshootd (SE Trouble Shoot Daemon) 来通告关于文件的安全上下文问题，这里存储其日志信息</span></span><br><span class="line">/var/<span class="built_in">log</span>/samba/   <span class="comment">#Samba的日志信息, Samba用来能使Windows连接到Linux的共享内容</span></span><br><span class="line">/var/<span class="built_in">log</span>/sa/      <span class="comment">#包含sysstat软件包收集的每天的sar文件</span></span><br><span class="line">/var/<span class="built_in">log</span>/sssd/    <span class="comment">#系统安全服务守护进程的相关日志。它用来管理远端目录的访问和授权</span></span><br></pre></td></tr></table></figure><h1 id="syslog-ng"><a href="#syslog-ng" class="headerlink" title="syslog-ng"></a>syslog-ng</h1><p>（1）syslog-ng的简介</p><p>syslog-ng(syslog next generation)是syslog的升级版，是由Balabit IT Security Ltd.公司维护的一套开源的Unix和类Unix系统的日志服务套件。它是一个灵活的、可伸缩的系统日志记录程序。syslog-ng有两个版本，一个是收费的，一个是开源的。 作为syslog的下一代产品，Syslog-ng主要特性有：</p><pre><code>支持SSL/TSL协议支持将日志写入数据库中,支持的数据库有MySQL, Microsoft SQL (MSSQL),Oracle, PostgreSQL, and SQLite.支持标准的syslog协议支持filter、parse以及rewrite支持更多的平台更高的负载能力</code></pre><p>syslog-ng的工作原理结构图如下：</p><p><img src="/images/syslogd_1_1.png" alt></p><p>（2）syslog-ng的配置</p><p>syslog-ng的配置文件在syslog-ng的安装目录下的${SYSLOG-NG_HOME}/etc/syslog-ng.conf中。 syslog-ng.conf文件里的内容有以下几个部分组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 全局选项,多个选项时用分好&quot;;&quot;隔开</span><br><span class="line">options &#123; .... &#125;;</span><br><span class="line"># 定义日志源,</span><br><span class="line">source s_name &#123; ... &#125;;</span><br><span class="line"># 定义过滤规则，规则可以使用正则表达式来定义,这里是可选的,不定义也没关系</span><br><span class="line">filter f_name &#123; ... &#125;;</span><br><span class="line"># 定义目标</span><br><span class="line">destination d_name &#123; ... &#125;;</span><br><span class="line"># 定义消息链可以将多个源,多个过滤规则及多个目标定义为一条链</span><br><span class="line">log &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>syslog-ng的学习资料参考于：<br><a href="http://cyr520.blog.51cto.com/714067/1245650" target="_blank" rel="noopener">http://cyr520.blog.51cto.com/714067/1245650</a><br><a href="http://ant595.blog.51cto.com/5074217/1080922" target="_blank" rel="noopener">http://ant595.blog.51cto.com/5074217/1080922</a></p><h1 id="rsyslog"><a href="#rsyslog" class="headerlink" title="rsyslog"></a>rsyslog</h1><p>（1）rsyslog简介</p><p>在CentOS 6中，日志是使用rsyslogd守护进程进行管理的，该进程是syslog的升级版，对原有的日志系统进行了功能的扩展，提供了诸如过滤器，日志加密保护，各种配置选项，输入输出模块，支持通过TCP或者UDP协议进行传输等。如下为官方的rsyslog的架构：</p><p><img src="/images/syslogd_1_2.png" alt></p><p>rsyslog的消息流是从<code>输入模块-&gt;预处理模块-&gt;主队列-&gt;过滤模块-&gt;执行队列-&gt;输出模块</code>。 在rsyslog的架构图中，输入、输出、过滤三个部分称为module。输入模块有imklg/imsock/imfile等，输出模块有omudp/omtcp/omfile/omprog/ommysql/omruleset等，过滤模块有mmnormalize等。其中输入模块以im为前缀，输出模块以om为前缀。</p><p>如下为rsyslog官网上发布的所支持的数据源和输出设备：</p><p><img src="/images/syslogd_1_3.png" alt></p><p>（2）rsyslog的配置</p><p>rsyslog的配置文件有/etc/rsyslog.conf、/etc/rsyslog.d/<em>.conf以及/etc/sysconfig/rsyslog。其中/etc/rsyslog.d/</em>.conf会被包含Include到/etc/rsyslog.conf中，/etc/sysconfig/rsyslog是用来配置rsyslog启动时的命令行参数。</p><p>rsyslog的学习资料参考于：<br><a href="http://www.rsyslog.com" target="_blank" rel="noopener">http://www.rsyslog.com</a><br><a href="http://www.cnblogs.com/tobeseeker/archive/2013/03/10/2953250.html" target="_blank" rel="noopener">http://www.cnblogs.com/tobeseeker/archive/2013/03/10/2953250.html</a><br><a href="http://blog.csdn.net/wangjianno2/article/details/50199639" target="_blank" rel="noopener">http://blog.csdn.net/wangjianno2/article/details/50199639</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSL开源套件技术调研</title>
      <link href="/2018/02/03/OpenSSL%E5%BC%80%E6%BA%90%E5%A5%97%E4%BB%B6%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/02/03/OpenSSL%E5%BC%80%E6%BA%90%E5%A5%97%E4%BB%B6%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenSSL开源套件简介"><a href="#OpenSSL开源套件简介" class="headerlink" title="OpenSSL开源套件简介"></a>OpenSSL开源套件简介</h1><p>OpenSSL是一个开源程序的套件，这个套件有三个部分组成，如下：</p><p>（1）libcryto</p><p>libcryto是一个具有通用功能的加密库，里面实现了众多的加密库；</p><p>（2）libssl</p><p>libssl是实现SSL机制的，它是用于实现TLS/SSL的功能；</p><p>（3）openssl</p><p>openssl是个多功能命令行工具，它可以实现加密解密，甚至还可以当CA来用，可以让你创建证书、吊销证书。</p><h1 id="openssl工具常用命令"><a href="#openssl工具常用命令" class="headerlink" title="openssl工具常用命令"></a>openssl工具常用命令</h1><p>openssl工具命令支持的功能丰富，包括生成公私钥、生成X.509证书以及SSL/TLS客户端/服务端模拟等等。如下为几个常用的openssl子命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">openssl ca       <span class="comment">#给CSR签名，从而颁发证书相关</span></span><br><span class="line">openssl genrsa   <span class="comment">#生成RSA加密算法的私钥</span></span><br><span class="line">openssl rsa      <span class="comment">#RSA加密算法的密钥管理，例如生成RSA的公钥</span></span><br><span class="line">openssl gendsa   <span class="comment">#生成DSA加密算法的私钥</span></span><br><span class="line">openssl dsa      <span class="comment">#DSA加密算法的密钥管理，例如生成DSA的公钥</span></span><br><span class="line">openssl req      <span class="comment">#CSR文件管理，包括生成CSR文件并管理等其他操作</span></span><br><span class="line">openssl x509     <span class="comment">#x.509标准格式的证书管理</span></span><br></pre></td></tr></table></figure><p>如下为openssl常用的命令举例：</p><p>（1）查看openssl版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl version</span><br><span class="line">openssl version -a</span><br></pre></td></tr></table></figure><p>（2）生成私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out rsa_private_key.pem 1024  <span class="comment">#生成RSA加密算法的私钥，是1024Bit的</span></span><br></pre></td></tr></table></figure><p>（3）生成公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> rsa_private_key.pem -pubout -out rsa_public_key.pem  <span class="comment">#指定私钥，来生成公钥</span></span><br></pre></td></tr></table></figure><p>（4）生成CSR文件（即未签名的SSL证书）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key rsa_private_key.pem -out wahaha.csr  <span class="comment">#生成CSR文件wahaha.csr</span></span><br></pre></td></tr></table></figure><p>（5）使用私钥给CSR文件签名，从而生成证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#–signkey ca-key.pem参数指定的是用来签名的私钥，这个私钥正常来说是CA的私钥。在本例子中，使用的自己的私钥rsa_private_key.pem来签名的，因此这是一张自签名的证书。一般来说，顶级证书或根证书都是自签名的证书。</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> wahaha.csr -out wahaha.pem -signkey rsa_private_key.pem -days 3650</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS双向认证过程及配置</title>
      <link href="/2018/02/03/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/02/03/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTPS双向认证简介"><a href="#HTTPS双向认证简介" class="headerlink" title="HTTPS双向认证简介"></a>HTTPS双向认证简介</h1><p>SSL双向认证就是，客户端要获取服务端的证书，检查下服务端是不是我可以信任的主机，否则我就认为那个站点的内容不可信任，不应该去访问你（浏览器会告诉你）。同时服务端也要检查客户端的证书，客户端如果不是服务端所信任的，那服务端也会认为，你不是我的合法用户，我拒绝给你提供服务。所以，要让HTTPS的双向认证顺利完成，就要在服务端给定一个证书，这个证书是浏览器可信任的，同时客户端（浏览器）也要发送给服务端一个证书，服务器端也要信任这个证书。</p><h1 id="HTTPS双向认证配置步骤"><a href="#HTTPS双向认证配置步骤" class="headerlink" title="HTTPS双向认证配置步骤"></a>HTTPS双向认证配置步骤</h1><p>一、自建CA根证书</p><p>（1）生成根证书的私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out ca-key.pem 2048</span><br></pre></td></tr></table></figure><p><img src="/images/https_1_1.png" alt></p><p>（2）生成根证书的CSR文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key ca-key.pem -out ca-req.csr -days 3650</span><br></pre></td></tr></table></figure><p><img src="/images/https_1_2.png" alt></p><p>（3）使用自己的私钥签名CSR文件，生成自签名的根证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> ca-req.csr -out ca-cert.pem -signkey ca-key.pem -days 3650</span><br></pre></td></tr></table></figure><p><img src="/images/https_1_3.png" alt></p><p>（4）将pem的CA证书转换为DER格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> ca-cert.pem -out ca.der -outform DER</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/images/https_1_4.png" alt></p><p>在windows上打开证书的效果如下：</p><p><img src="/images/https_1_5.png" alt></p><p>二、用自建CA颁发客户端证书</p><p>（1）生成客户端证书的私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out wzjtest-key.pem 2048</span><br></pre></td></tr></table></figure><p><img src="/images/https_1_6.png" alt></p><p>（2）生成客户端证书的CSR文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key wzjtest-key.pem -out wzjtest-req.csr -days 3650</span><br></pre></td></tr></table></figure><p><img src="/images/https_1_7.png" alt></p><p>（3）使用自建的CA为客户端证书签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> wzjtest-req.csr -out wzjtest-cert.pem -days 3650 -CA ../ca/ca-cert.pem -CAkey ../ca/ca-key.pem -CAcreateserial</span><br></pre></td></tr></table></figure><p><img src="/images/https_1_8.png" alt></p><p>（4）将客户端证书的格式从pem转换为der</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> wzjtest-cert.pem -out wzjtest.der -outform DER</span><br></pre></td></tr></table></figure><p><img src="/images/https_1_9.png" alt></p><p>在windows下打开客户端证书效果如下：</p><p><img src="/images/https_1_10.png" alt></p><p><img src="/images/https_1_11.png" alt></p><p>（5）将客户端证书格式转换成PKCS #12格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -<span class="built_in">export</span> -clcerts -<span class="keyword">in</span> wzjtest-cert.pem -inkey wzjtest-key.pem -out wzjtest.p12</span><br></pre></td></tr></table></figure><p><img src="/images/https_1_12.png" alt></p><p>三、在原有的https服务端上开启客户端证书验证</p><p>一般来说，我们的https都是单向验证的，下面是开启了双向认证的nginx配置：</p><p><img src="/images/https_1_13.png" alt></p><p>四、测试验证</p><p>（1）使用浏览器测试</p><p>可以在浏览器中先导入自己签发的私钥，然后再访问需要双向认证的站点。</p><p>（2）使用openssl工具测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_client -quiet -servername wahaha.sohuno.com -connect 10.16.57.158:443</span><br></pre></td></tr></table></figure><p><img src="/images/https_1_14.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_client -quiet -servername wahaha.sohuno.com -connect 10.16.57.158:443 -cert lv2/<span class="built_in">test</span>-lv2-cert.pem -key lv2/<span class="built_in">test</span>-lv2-key.pem</span><br></pre></td></tr></table></figure><p><img src="/images/https_1_15.png" alt></p><p>学习资料参考于：<br><a href="http://itindex.net/detail/52620-nginx-https-%E8%AE%A4%E8%AF%81" target="_blank" rel="noopener">http://itindex.net/detail/52620-nginx-https-%E8%AE%A4%E8%AF%81</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSL数字证书标准(X.509)及编码格式(PEM|DER)</title>
      <link href="/2018/02/03/SSL%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E6%A0%87%E5%87%86-X-509-%E5%8F%8A%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F-PEM-DER/"/>
      <url>/2018/02/03/SSL%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E6%A0%87%E5%87%86-X-509-%E5%8F%8A%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F-PEM-DER/</url>
      
        <content type="html"><![CDATA[<h1 id="SSL数字证书标准X-509"><a href="#SSL数字证书标准X-509" class="headerlink" title="SSL数字证书标准X.509"></a>SSL数字证书标准X.509</h1><p>SSL数字证书没有单一的全球标准，不过现在使用的大多数SSL证书都以一种标准格式——X.509 v3来存储它们的信息。X.509数字证书标准，定义证书文件的结构和内容，详情参考RFC5280。SSL数字证书通常采用这种标准，一般由用户公共密钥和用户标识符组成，此外还包括版本号、证书序列号、CA标识符、签名算法标识、签发者名称、证书有效期等信息。X.509 v3证书提供了一种标准的方式，将证书信息规范至一些可解析字段中。尽管不同类型的证书有不同的字段值，但大部分都遵循X.509 v3结构。如下为X.509 v3证书中的一些字段信息：</p><p><img src="/images/x.509_1_1.png" alt></p><h1 id="数字证书的编码格式"><a href="#数字证书的编码格式" class="headerlink" title="数字证书的编码格式"></a>数字证书的编码格式</h1><p>X.509标准的证书文件具有不同的编码格式，一般包括PEM和DER两种：</p><p>（1）PEM</p><p>PEM，是Privacy Enhanced Mail的缩写，以文本的方式进行存储。它的文件结构以<code>-----BEGIN XXX-----</code>开头，并以<code>-----END XXX-----</code>为结尾，中间Body内容为Base64编码过的数据。以PEM格式存储的证书结构大概如下：</p><pre><code>-----BEGIN CERTIFICATE-----Base64编码过的证书数据-----END CERTIFICATE-----</code></pre><p>它也可以用来编码存储公钥（RSA PUBLIC KEY）、私钥（RSA PRIVATE KEY）、证书签名请求（CERTIFICATE REQUEST）等数据。一般Apache和Nginx服务器应用偏向于使用PEM这种编码格式。</p><p>（2）DER</p><p>DER，是Distinguished Encoding Rules的缩写，以二进制方式进行存储，文件结构无法直接预览，同样可以通过如下OpenSSL命令查看其证书内容。一般Java和Windows服务器应用偏向于使用DER这种编码格式。当然同一X.509证书的不同编码之间可以互相转换。</p><h1 id="证书相关的一些扩展名"><a href="#证书相关的一些扩展名" class="headerlink" title="证书相关的一些扩展名"></a>证书相关的一些扩展名</h1><p>如上所述，对于X.509标准的证书两种不同编码格式，一般采用PEM编码就以.pem作为文件扩展名，若采用DER编码，就应以.der作为扩展名。但常见的证书扩展名还包括.crt、.cer、.p12等，他们采用的编码格式可能不同，内容也有所差别，但大多数都能互相转换，现总结如下：</p><p>（1）.pem</p><p>采用PEM编码格式的X.509证书的文件扩展名。</p><p>（2）.der</p><p>采用DER编码格式的X.509证书的文件扩展名。</p><p>（3）.crt</p><p>即certificate的缩写，常见于类UNIX系统，有可能是PEM编码，也有可能是DER编码，但绝大多数情况下此格式证书都是采用PEM编码。</p><p>（4）.cer</p><p>也是certificate的缩写，常见于Windows系统，同样地，可能是PEM编码，也可能是DER编码，但绝大多数情况下此格式证书都是采用DER编码。</p><p>（5）.p12</p><p>也写作.pfx，全称为PKCS #12，是公钥加密标准（Public Key Cryptography Standards，PKCS）系列的一种，它定义了描述个人信息交换语法（Personal Information Exchange Syntax）的标准，可以用来将包含了公钥的X.509证书和证书对应的私钥以及其他相关信息打包，进行交换。简单理解为·<code>一份.p12文件 = X.509证书 + 私钥</code>。</p><p>（6）.csr</p><p>Certificate Signing Request的缩写，即证书签名请求，它并不是证书的格式，而是用于向权威证书颁发机构（Certificate Authority, CA）获得签名证书的申请，其核心内容包含一个RSA公钥和其他附带信息，在生成这个.csr申请的时候，同时也会生成一个配对RSA私钥，私钥通常需要严格保存于服务端，不能外泄。</p><p>（7）.key</p><p>通常用来存放一个RSA公钥或者私钥，它并非X.509证书格式，编码同样可能是PEM，也可能是DER。</p><p>备注：各种证书格式之间是可以相互转换的哦。</p><p>学习资料参考于：<br><a href="http://www.cnblogs.com/guogangj/p/4118605.html" target="_blank" rel="noopener">http://www.cnblogs.com/guogangj/p/4118605.html</a><br><a href="https://kangzubin.com/certificate-format/" target="_blank" rel="noopener">https://kangzubin.com/certificate-format/</a><br><a href="https://www.chinassl.net/faq/n509.html" target="_blank" rel="noopener">https://www.chinassl.net/faq/n509.html</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shadowsocks简介及使用</title>
      <link href="/2018/02/03/Shadowsocks%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/03/Shadowsocks%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="GFW的来临"><a href="#GFW的来临" class="headerlink" title="GFW的来临"></a>GFW的来临</h1><p>这个文章来源于一个朋友在科学上网的过程中，搞不清楚Shadowsocks的配置问题，在这里我想按照我对Shadowsocks 的理解简单梳理一下，以便一些非专业人士也能了解。</p><p>在很久很久以前，我们访问各种网站都是简单而直接的，用户的请求通过互联网发送到服务提供方，服务提供方直接将信息反馈给用户。</p><p><img src="/images/shadowsocks_1_1.png" alt> </p><p>然后有一天，GFW 就出现了，他像一个收过路费的强盗一样夹在了在用户和服务之间，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容。</p><p><img src="/images/shadowsocks_1_2.png" alt> </p><h1 id="ssh-tunnel"><a href="#ssh-tunnel" class="headerlink" title="ssh tunnel"></a>ssh tunnel</h1><p>聪明的人们想到了利用境外服务器代理的方法来绕过GFW的过滤，其中包含了各种HTTP代理服务、Socks服务、VPN服务。其中以ssh tunnel的方法比较有代表性。</p><p>1）首先用户和境外服务器基于ssh建立起一条加密的通道<br>2-3）用户通过建立起的隧道进行代理，通过ssh server向真实的服务发起请求<br>4-5）服务通过ssh server，再通过创建好的隧道返回给用户</p><p><img src="/images/shadowsocks_1_3.png" alt></p><p>由于ssh本身就是基于RSA加密技术，所以GFW无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，ssh本身的特征是明显的，所以GFW一度通过分析连接的特征进行干扰，导致ssh存在被定向进行干扰的问题。</p><h1 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h1><p>简单来说，shadowsocks是将原来ssh创建的Socks5协议拆开成server端和client端，所以下面这个原理图基本上和利用ssh tunnel大致类似。</p><p>1,6）客户端发出的请求基于Socks5协议跟ss-local端进行通讯，由于这个ss-local一般是本机或路由器或局域网的其他机器，不经过GFW，所以解决了上面被GFW通过特征分析进行干扰的问题</p><p>2,5）ss-local和ss-server两端通过多种可选的加密方法进行通讯，经过GFW的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密</p><p>3,4）ss-server将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回 </p><p><img src="/images/shadowsocks_1_4.png" alt></p><p>备注：<br>简单来说，有香港或国外服务器的话，用shadowsocks客户端在本地代理，在香港或国外服务器运行<code>ssserver -p 8388 -k 密码 -m aes-256-cfb -d start</code>，Google Chrome里面装个代理插件（例如SwitchyOmega）就可以翻墙了。</p><p>学习资料参考于：<br><a href="https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/" target="_blank" rel="noopener">https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/</a></p>]]></content>
      
      
      <categories>
          
          <category> GFW </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Proxy SwitchySharp+goagent小结</title>
      <link href="/2018/02/03/%E4%BD%BF%E7%94%A8Proxy-SwitchySharp-goagent%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/02/03/%E4%BD%BF%E7%94%A8Proxy-SwitchySharp-goagent%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Proxy-SwitchySharp和goagent简介"><a href="#Proxy-SwitchySharp和goagent简介" class="headerlink" title="Proxy SwitchySharp和goagent简介"></a>Proxy SwitchySharp和goagent简介</h1><p>Proxy SwitchySharp只是一个chrome浏览器的一个插件，该插件是一个代理配置管理的插件，就类似与IE里面的Internet选项的中的代理设置的功能一样，不过Proxy SwitchySharp的功能更强大。</p><p>goagent是Google公司开发的一个翻墙软件，说白了，我们利用goagent架设了一个自己的代理服务器。goagent包括server端和local端，server端要上传部署到Google App Engine（所以我们要在GAE上创建appid）上。local端就在本地计算机。注意，当goagent配置成功后，以后当我们想要翻墙的时候，要先在本机上运行<code>*/local/goagent.exe</code>程序。</p><p>当在Proxy SwitchySharp设置代理方式是<code>127.0.0.1:8087</code>就表示，我们使用了自己搭建的goagent代理服务器。</p><p>备注：<br>Proxy SwitchySharp不是必备的东东哦，当我们搞定goagent的配置后，我们可以再chrome的自己的代理设置出填上<code>127.0.0.1:8087</code>就可以上网了。如果使用IE浏览器的话，我们在Internet局域网配置中配置代理为<code>127.0.0.1:8087</code>后也就可以翻墙了。</p><h1 id="使用goagent的原理结构图"><a href="#使用goagent的原理结构图" class="headerlink" title="使用goagent的原理结构图"></a>使用goagent的原理结构图</h1><p><img src="/images/gfw_1_1.png" alt></p><p>学习资料参考于：<br><a href="https://code.google.com/p/goagent/" target="_blank" rel="noopener">https://code.google.com/p/goagent/</a></p>]]></content>
      
      
      <categories>
          
          <category> GFW </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>穿越火线技巧</title>
      <link href="/2018/02/03/%E7%A9%BF%E8%B6%8A%E7%81%AB%E7%BA%BF%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/02/03/%E7%A9%BF%E8%B6%8A%E7%81%AB%E7%BA%BF%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="穿越GFW方法"><a href="#穿越GFW方法" class="headerlink" title="穿越GFW方法"></a>穿越GFW方法</h1><p>（1）自由门</p><p>自由门（英语：Freegate）是动态网公司开发的一种破网软件，一般用来突破中国大陆政府创建的防火长城以浏览被当局屏蔽的网站或收发邮件。由于防火长城不断加强封锁，所以该软件也不断升级以突破防火长城。除了中国大陆，在伊朗、叙利亚、阿联酋等含有互联网审查的国家中也有很多用户使用该软件访问被其政府屏蔽的网站。</p><p>动态网官网地址为：<a href="http://dongtaiwang.com" target="_blank" rel="noopener">http://dongtaiwang.com</a></p><p>（2）无界网络</p><p>（3）赛风Psiphon</p><p>（4）蓝灯Lantern</p><p>（5）影梭Shadowsocks</p><p>（6）VPN</p><p>（7）GoAgent</p><p>（8）……</p><p>备注：今年（2017年）有很多的VPN服务商，由于大陆政策的原因， 被迫下线，停止提供服务。</p>]]></content>
      
      
      <categories>
          
          <category> GFW </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器远程管理工具IMM|iDRAC|iLO简介</title>
      <link href="/2018/02/03/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7IMM-iDRAC-iLO%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/02/03/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7IMM-iDRAC-iLO%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="IMM"><a href="#IMM" class="headerlink" title="IMM"></a>IMM</h1><p>IBM服务器，IMM，全称为Integrated Management Module。IMM是IBM服务器的新一代集成管理模块，该模块是独立于服务器系统，可以通过一个单独的ip使用web和虚拟端口方式直接启动、停止和管理远程服务器，即使主板、处理器或者内存故障导致主机无法启动，也依然可以远程管理服务器，可以远程直接操作启动画面和服务器工作界面。</p><h1 id="iDRAC"><a href="#iDRAC" class="headerlink" title="iDRAC"></a>iDRAC</h1><p>DELL服务器，iDRAC，全称为Integrated Dell Remote Access Controller。iDRAC是DELL为DELL服务器研发的远程访问管理技术。</p><h1 id="iLO"><a href="#iLO" class="headerlink" title="iLO"></a>iLO</h1><p>iLO是Intergrated Light-Out的缩写，是惠普特有的远程管理功能，目前最新的版本是iLO2。通过iLO2可以实现硬件级别的服务器远程管理，包括开关机、重启、服务器状态的监控、虚拟KVM等。目前在惠普3、5、7系列服务器以及刀片服务器上一般都集成了iLO2控制芯片，管理员可以通过Web方式远程进行管理，配置过程和管理过程都非常简便，管理员可以从环境恶劣的机房中解放出来，管理过程轻松简洁，也降低了企业TCO成本</p>]]></content>
      
      
      <categories>
          
          <category> HardWare </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用GPG工具来了解加密解密以及签名认证过程</title>
      <link href="/2018/02/03/%E4%BD%BF%E7%94%A8GPG%E5%B7%A5%E5%85%B7%E6%9D%A5%E4%BA%86%E8%A7%A3%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E4%BB%A5%E5%8F%8A%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/02/03/%E4%BD%BF%E7%94%A8GPG%E5%B7%A5%E5%85%B7%E6%9D%A5%E4%BA%86%E8%A7%A3%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E4%BB%A5%E5%8F%8A%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="gpg简介"><a href="#gpg简介" class="headerlink" title="gpg简介"></a>gpg简介</h1><p>1991年，程序员Phil Zimmermann为了避开政府监视，开发了加密软件PGP。这个软件非常好用，迅速流传开来，成了许多程序员的必备工具。但是，它是商业软件，不能自由使用。所以，自由软件基金会决定，开发一个PGP的替代品，取名为GnuPG。这就是GPG的由来。</p><h1 id="gpg的安装"><a href="#gpg的安装" class="headerlink" title="gpg的安装"></a>gpg的安装</h1><p>使用源码或rpm包的方式安装即可。</p><h1 id="gpg工具的使用"><a href="#gpg工具的使用" class="headerlink" title="gpg工具的使用"></a>gpg工具的使用</h1><p>（1）使用gpg工具生成秘钥对</p><p>执行命令<code>gpg --gen-key</code>然后按照屏幕的提示来输入交互信息即可，主要有如下的一些确认信息：</p><p><img src="/images/gpg_1_1.png" alt></p><p>之后还需要为秘钥设置密码，即passphrase，用来保护私钥的安全，避免私钥泄露后的安全问题。</p><p>最终生成成功界面如下：</p><p><img src="/images/gpg_1_2.png" alt></p><p>（2）关于生成的秘钥的一些常用操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gpg --list-keys             <span class="comment">#列出系统中已有的密钥对</span></span><br><span class="line">gpg --delete-key [用户ID]   <span class="comment">#删除某个密钥对</span></span><br><span class="line">gpg --armor --output public-key.txt --<span class="built_in">export</span> [用户ID]      <span class="comment">#公钥文件（.gnupg/pubring.gpg）以二进制形式储存，armor参数可以将其转换为ASCII码显示</span></span><br><span class="line">gpg --armor --output private-key.txt --<span class="built_in">export</span>-secret-keys  <span class="comment">#将私钥文件转换成文本格式的</span></span><br><span class="line">gpg --send-keys [用户ID] --keyserver hkp://subkeys.pgp.net  <span class="comment">#钥服务器是网络上专门储存用户公钥的服务器。send-keys参数可以将公钥上传到服务器</span></span><br><span class="line">gpg --fingerprint [用户ID]  <span class="comment">#为公钥生成指纹fingerprint，当用户拿到公钥后，可以check下指纹是否正确</span></span><br><span class="line">gpg --import [密钥文件]     <span class="comment">#作为用户端，导入其他的公钥到本系统中</span></span><br></pre></td></tr></table></figure><p>备注：我们可以使用–export参数导出公钥，然后给用户使用即可</p><p>（3）加密和解密操作</p><p>A）加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --recipient [用户ID] --output demo.en.txt --encrypt demo.txt</span><br></pre></td></tr></table></figure><p>recipient参数指定公钥，output参数指定加密后的文件名，encrypt参数指明加密。运行上面的命令后，demo.en.txt就是已加密的文件，可以把它发给对方。</p><p>B）解密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --decrypt demo.en.txt --output demo.de.txt</span><br></pre></td></tr></table></figure><p>decrypt参数指定需要解密，output参数指定解密后生成的文件。运行上面的命令，demo.de.txt就是解密后的文件。</p><p>（4）签名和认证操作</p><p>A）签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --sign demo.txt</span><br></pre></td></tr></table></figure><p>运行上面的命令后，当前目录下生成demo.txt.gpg文件，这就是签名后的文件。demo.txt.gpg默认采用二进制储存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --clearsign demo.txt</span><br></pre></td></tr></table></figure><p>同上，只是生成的签名文件是ASCII文本格式的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --detach-sign demo.txt</span><br></pre></td></tr></table></figure><p>在当前目录下生成一个单独的签名文件demo.txt.sig，达到签名文件与文件内容分开存放的效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --armor --detach-sign demo.txt</span><br></pre></td></tr></table></figure><p>同上，只是生成的签名文件是ASCII文本格式的。</p><p>B）认证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --verify demo.txt.asc demo.txt</span><br></pre></td></tr></table></figure><p>收到别人签名后的文件，需要用对方的公钥验证签名是否为真。verify参数用来验证。</p><p>学习资料参考于：<br><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/07/gpg.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于进程的虚拟内存VIRT|物理内存RES|共享内存SHR</title>
      <link href="/2018/02/03/%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98VIRT-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98RES-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98SHR/"/>
      <url>/2018/02/03/%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98VIRT-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98RES-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98SHR/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟内存Virtual-Memory"><a href="#虚拟内存Virtual-Memory" class="headerlink" title="虚拟内存Virtual Memory"></a>虚拟内存Virtual Memory</h1><p>这里的虚拟内存，并不是SWAP的虚拟内存概念哦。虚拟内存是操作系统内核为了对进程地址空间进行管理而精心设计的一个逻辑意义上的内存空间概念。我们程序中的指针其实都是这个虚拟内存空间中的地址。比如我们在写完一段C++程序之后都需要采用g++进行编译，这时候编译器采用的地址其实就是虚拟内存空间的地址。因为这时候程序还没有运行，何谈物理内存空间地址。凡是程序运行过程中可能需要用到的指令或者数据都必须在虚拟内存空间中。既然说虚拟内存是一个逻辑意义上的内存空间，为了能够让程序在物理机器上运行，那么必须有一套机制可以让这些假象的虚拟内存空间映射到物理内存空间（实实在在的RAM内存条上的空间）。这其实就是操作系统中页映射表（page table）所做的事情了。内核会为系统中每一个进程维护一份相互独立的页映射表。页映射表的基本原理是将程序运行过程中需要访问的一段虚拟内存空间通过页映射表映射到一段物理内存空间上，这样CPU访问对应虚拟内存地址的时候就可以通过这种查找页映射表的机制访问物理内存上的某个对应的地址。其中“页page”是虚拟内存空间向物理内存空间映射的基本单元。</p><h1 id="驻留内存Resident-Memory"><a href="#驻留内存Resident-Memory" class="headerlink" title="驻留内存Resident Memory"></a>驻留内存Resident Memory</h1><p>驻留内存，顾名思义是指那些被映射到进程虚拟内存空间的物理内存。</p><h1 id="共享内存Share-Memory"><a href="#共享内存Share-Memory" class="headerlink" title="共享内存Share Memory"></a>共享内存Share Memory</h1><p>我们写的程序会依赖于很多外部的动态库（.so），比如libc.so、libld.so等等。这些动态库在内存中仅仅会保存/映射一份，如果某个进程运行时需要这个动态库，那么动态加载器会将这块内存映射到对应进程的虚拟内存空间中。多个进展之间通过共享内存的方式相互通信也会出现这样的情况。这么一来，就会出现不同进程的虚拟内存空间会映射到相同的物理内存空间。这部分物理内存空间其实是被多个进程所共享的，所以我们将他们称为共享内存，用SHR来表示。</p><p>下图清晰的展示了虚拟内存、驻留内存以及共享内存的关系。如下：</p><p><img src="/images/osproc_1_1.png" alt></p><p>学习资料参考于：<br><a href="http://www.cnblogs.com/bravery/archive/2012/06/27/2560611.html" target="_blank" rel="noopener">http://www.cnblogs.com/bravery/archive/2012/06/27/2560611.html</a></p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Python的批处理工具parallel-ssh</title>
      <link href="/2018/02/03/%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7parallel-ssh/"/>
      <url>/2018/02/03/%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7parallel-ssh/</url>
      
        <content type="html"><![CDATA[<h1 id="parallel-ssh"><a href="#parallel-ssh" class="headerlink" title="parallel-ssh"></a>parallel-ssh</h1><p>pssh是一个Python编写可以在多台服务器上执行命令的工具，同时支持拷贝文件，是同类工具中很出色的。为方便操作，使用前请在各个服务器上配置好密钥认证访问。parallel-ssh有pssh/pscp/pslurp/pnuke/prsync几个命令行工具。</p><p>项目地址: <a href="https://code.google.com/p/parallel-ssh/" target="_blank" rel="noopener">parallel-ssh</a></p><h1 id="parallel-ssh安装"><a href="#parallel-ssh安装" class="headerlink" title="parallel-ssh安装"></a>parallel-ssh安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://parallel-ssh.googlecode.com/files/pssh-2.3.1.tar.gz</span><br><span class="line">tar zxvf pssh-2.3.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> pssh-2.3.1/</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><h1 id="命令使用举例"><a href="#命令使用举例" class="headerlink" title="命令使用举例"></a>命令使用举例</h1><p>（1）pssh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#其中-h host.txt是从文件中读取机器列表，-i输出远程机器执行命令的输出结果</span></span><br><span class="line">pssh -h host.txt -i <span class="string">"pwd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#直接在命令行参数中指明目标机器</span></span><br><span class="line">pssh -H 10.16.20.22 -H 10.16.20.30 -i <span class="string">'pwd'</span></span><br></pre></td></tr></table></figure><p>（2）pscp</p><p>pscp传输文件到多个hosts，类似scp。命令使用举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将本地当前目录中的foo.txt文件，远程拷贝到目标主机的/home/work/目录下</span></span><br><span class="line">pscp -h hosts.txt foo.txt /home/work/foo.txt</span><br><span class="line">pscp -h hosts.txt -l root foo.txt /home/work/foo.txt <span class="comment">#指定root用户</span></span><br></pre></td></tr></table></figure><p>（3）pslurp</p><p>pslurp从多台远程机器拷贝文件到本地。</p><p>（4）pnuke</p><p>pnuke并行在远程主机杀进程 。命令使用举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnuke -h hosts.txt -l irb2 java</span><br></pre></td></tr></table></figure><p>（5）prsync</p><p>prsync使用rsync协议从本地计算机同步到远程主机 。命令使用举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prsync -r -h hosts.txt -l irb2 foo /home/irb2/foo</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://kumu-linux.github.io/blog/2013/08/12/pssh/" target="_blank" rel="noopener">http://kumu-linux.github.io/blog/2013/08/12/pssh/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP地址库小结</title>
      <link href="/2018/02/03/IP%E5%9C%B0%E5%9D%80%E5%BA%93%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/02/03/IP%E5%9C%B0%E5%9D%80%E5%BA%93%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="IP库"><a href="#IP库" class="headerlink" title="IP库"></a>IP库</h1><p>IP库（也叫IP地址数据库），是由专业技术人员经过长时间通过多种技术手段收集而来的，并且长期有专业人员进行更新、维护、补充。IP库里面存放了大量的IP地址，方便用户查询，比如，你知道了某个IP，就可以查到这个电脑在哪个省那个市哪条街甚至哪个网吧 反之，你知道了一个地方，也可以查看这个地方有哪些IP段。</p><h1 id="IP库的种类"><a href="#IP库的种类" class="headerlink" title="IP库的种类"></a>IP库的种类</h1><p>（1）IP市级库</p><p>可以查询到所有国内的IP段，精确到县级市（部分固定IP精确到区县）。</p><p>（2）IP国家库</p><p>可以查询到国际上各个国家的IP段，精确到具体的国家，不能查到更深层的省市。</p><p>（3）IP省级库（无ISP）</p><p>可以查询到国内的IP段，精确到省（有个别数据只能确定是在国内，不能定位到省，含港澳台地区）。</p><p>（4）IP省级库（含ISP）</p><p>在省级IP库的基础上，可以进一步查询到该IP所属的ISP信息（只能查询到省，部分IP的ISP信息无法确定）。</p><p>（5）省级定制IP库</p><p>可以查询国内某个省份的IP段，精确到地级市。每个省为一个单位，按省销售（可以查询到这些IP的ISP信息）。</p><p>（6）ISP定制IP库</p><p>可以查询某个ISP所辖IP段。每个ISP为一个单位，按ISP销售，不能查到省市信息。</p><p>（7）国内范围IP库(大陆地区)</p><p>可以查询到所有国内的IP段，不能精确到更深层的省市及ISP信息。不包含港澳台地区。</p><h1 id="IP库地址库产品"><a href="#IP库地址库产品" class="headerlink" title="IP库地址库产品"></a>IP库地址库产品</h1><p>各个运营商提供的IP地址库最准确，称为“官方库”，但是由于各个运营商独立，很难提供一个跨运营商的IP地址库。而民间通过一定的技术手段也有很多的IP地址库产品，称为“民间库”。如下为IP地址民间库的一些产品：</p><p>（1）腾讯腾讯IP分享计划</p><p>（2）新浪</p><p>（3）百度Web服务Geocoding API-百度地图</p><p>（4）淘宝IP地址库</p><p>（5）Geoip MaxMind</p><p>IP地理定位和在线欺诈预防。Geoip存在商业版跟免费版，免费版就不多说了，就使用情况来看，存在市的误差，不过相对其他的，Geoip的好处在于返回字段多，包含有经纬度等，具体看官网。商业版是我们目前用过的ip中最准的。</p><p>（6）纯真</p><p><a href="http://www.cz88.net/" target="_blank" rel="noopener">http://www.cz88.net/</a></p><p>（7）17mon </p><p>IP归属地数据库。</p>]]></content>
      
      
      <categories>
          
          <category> 杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂货铺 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome浏览器的一些使用小技巧</title>
      <link href="/2018/02/02/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/02/02/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Google-Smart-Lock保存网页表单密码"><a href="#使用Google-Smart-Lock保存网页表单密码" class="headerlink" title="使用Google Smart Lock保存网页表单密码"></a>使用Google Smart Lock保存网页表单密码</h1><p>打开Chrome浏览器选择<code>设置 -&gt; 显示高级设置 -&gt; 密码和表单 -&gt; 管理密码</code>，即可修改密码、添加密码等。当下次打开了这些被保存了密码的WEB页面时，Chrome会自动填充表单。打开Google Smart Lock的密码保存页面如下：</p><p><img src="/images/chrome_1_1.png" alt></p><h1 id="Google-Chrome提供的接口工具"><a href="#Google-Chrome提供的接口工具" class="headerlink" title="Google Chrome提供的接口工具"></a>Google Chrome提供的接口工具</h1><pre><code>chrome://dns/                 #查看chrome缓存的DNS信息 chrome://net-internals/#dns   #清除chrome的DNS缓存chrome://version/             #查看chrome的详细版本信息</code></pre><h1 id="Provisional-headers-are-shown"><a href="#Provisional-headers-are-shown" class="headerlink" title="Provisional headers are shown"></a>Provisional headers are shown</h1><p>使用Chrome的开发者工具，有时会发现一些HTTP请求的请求头为Provisional headers are shown，截图如下：</p><p><img src="/images/chrome_1_2.png" alt></p><p>一般来说，如果看到HTTP请求头为Provisional headers are shown，说明这个请求实际上根本没有产生，对应的请求头当然也不应该存在。但对于这样的请求，Google Chrome也会显示部分请求头信息，并给出「CAUTION:Provisional headers are shown」这样的提示。具体原因有多种，比如：</p><p>（1）请求被某些扩展如Adblock给拦截了</p><p>（2）走本地缓存（memory cache OR disk cache），举例来说，如下资源是直接从disk cache或memory cache中获取的，因此浏览器并没有向网络服务器发送HTTP请求，因此它的HTTP请求头就显示为Provisional headers are shown。</p><p><img src="/images/chrome_1_3.png" alt></p><h1 id="Chrome模拟移动终端设置"><a href="#Chrome模拟移动终端设置" class="headerlink" title="Chrome模拟移动终端设置"></a>Chrome模拟移动终端设置</h1><p>使用Google Chrome可以模拟移动终端设备，例如IPad、IPhone、Galaxy、Nexus等等。打开Chrome开发者工具，点击左上角的移动设备切换开发即可，如下所示：</p><p><img src="/images/chrome_1_4.png" alt></p><p>然后就可以选择要模拟的终端设备即可。</p><p><img src="/images/chrome_1_5.png" alt></p><h1 id="使用Chrome模拟弱网环境"><a href="#使用Chrome模拟弱网环境" class="headerlink" title="使用Chrome模拟弱网环境"></a>使用Chrome模拟弱网环境</h1><p>打开Google Chrome开发者工具，选择Network面板如下所示，即可选择不同的弱网环境：</p><p><img src="/images/chrome_1_6.png" alt></p><h1 id="Google-Chrome开发者工具Network面板的一些小Tips"><a href="#Google-Chrome开发者工具Network面板的一些小Tips" class="headerlink" title="Google Chrome开发者工具Network面板的一些小Tips"></a>Google Chrome开发者工具Network面板的一些小Tips</h1><p>使用Disable cache，可以禁止Chrome从本地cache中获取资源，而是直接发起HTTP请求到服务端获取资源，这样浏览器就直接忽略本地缓存（Cache-Control/Expires等）。使用Preserve log可以避免Network面板中历史的资源请求记录被清除。这样的一个好处是，如果我们在浏览器中请求的是A资源，但是A资源被30X到B资源，可是我们在Network面板中看不到从资源A 30X到资源B的这个处理过程，这时勾选上Preserve log功能就好了。</p><p><img src="/images/chrome_1_7.png" alt></p><h1 id="删除Chrome地址栏中推荐的不需要的网址"><a href="#删除Chrome地址栏中推荐的不需要的网址" class="headerlink" title="删除Chrome地址栏中推荐的不需要的网址"></a>删除Chrome地址栏中推荐的不需要的网址</h1><p>Chrome的地址栏自动补齐功能提供了非常方便的地址预测功能，浏览器可以通过用户当前输入的字符来与用户的访问历史与书签匹配，然后在下拉栏中为用户提供准确的补齐方案推荐，提高用户访问效率。在大部分情况下，这个功能是非常好用的。但是有时，出于某些原因，用户需要移除某个记录（例如网址无法访问、网址更换域名等）。因此我们按照如下步骤删除访问地址推荐：</p><p>（1）在地址栏中输入所需删除网址的完整URL或部分关键字</p><p>（2）使用↑键或↓键移动蓝色高亮选框，使用Page Up或Page Down移动蓝色高亮选框到首项或末项</p><p>（3）使用Shift+Delete来删除选中记录</p><p>（4）再次输入关键字，补齐方案中已没有了已删除的记录</p><p>备注：已加入书签的URL会在左侧显示☆号，这部分记录必须在书签中删除。</p><h1 id="TTFB"><a href="#TTFB" class="headerlink" title="TTFB"></a>TTFB</h1><p>TTFB，全称为Time To First Byte，是最初的网络请求被发起到从服务器接收到第一个字节这段时间，它包含了TCP连接时间，发送HTTP请求时间和获得响应消息第一个字节的时间。</p><p><img src="/images/chrome_1_8.png" alt></p><h1 id="chrome的chrome-功能"><a href="#chrome的chrome-功能" class="headerlink" title="chrome的chrome://***功能"></a>chrome的<code>chrome://***</code>功能</h1><p>在Chrome地址栏中输入chrome://chrome-urls/，即可以看到各种<code>chrome://***</code>，例如：</p><p><img src="/images/chrome_1_9.png" alt></p><h1 id="chrome查看单页面大小"><a href="#chrome查看单页面大小" class="headerlink" title="chrome查看单页面大小"></a>chrome查看单页面大小</h1><p>在network标签页下面，可以看到总请求数以及请求内容总大小等信息。</p><p><img src="/images/chrome_1_10.png" alt></p><h1 id="chrome关闭HTTP-2"><a href="#chrome关闭HTTP-2" class="headerlink" title="chrome关闭HTTP/2"></a>chrome关闭HTTP/2</h1><p>新版本的Chrome是默认开启HTTP/2，只要服务端支持HTTP/2，那么通信将使用HTTP/2。但有时我们测试的时候，期望Chrome关闭HTTP/2，而是使用HTTP/1.1。在MAC环境下，在终端中执行如下命令：</p><p><code>/Applications/Google Chrome.app/Contents/MacOS/Google Chrome -disable-http2</code></p><p>记得先要将已经运行的Chrome浏览器进程关闭干净。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIND|smbind技术调研</title>
      <link href="/2018/02/02/BIND-smbind%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/02/02/BIND-smbind%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="Bind简介"><a href="#Bind简介" class="headerlink" title="Bind简介"></a>Bind简介</h1><p>BIND，Berkeley Internet Name Daemon，是现今互联网上最常使用的DNS服务器软件，使用BIND作为服务器软件的DNS服务器约占所有DNS服务器的九成。BIND现在由互联网系统协会（Internet Systems Consortium）负责开发与维护。20世纪80年代，柏克莱加州大学计算机系统研究小组的四个研究生Douglas B Terry、Mark Painter、David W. Riggle和周松年（Songnian Zhou）一同编写了BIND的第一个版本，并随4.3BSD发布。</p><h1 id="Bind的安装和启动"><a href="#Bind的安装和启动" class="headerlink" title="Bind的安装和启动"></a>Bind的安装和启动</h1><p>（1）Bind的安装</p><ul><li><p>源码安装<br>在Bind官网<code>https://www.isc.org/downloads/bind/</code>中下载源码，然后编译安装。需要注意的是，源码安装Bind需要很多前置Lib环境的安装。</p></li><li><p>通过包管理工具安装bind</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install bind bindchroot  #RedHat系</span><br><span class="line">sudo apt-get install bind9   #Debian系</span><br></pre></td></tr></table></figure></li></ul><p>（2）Bind的启动</p><p>named的启动命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/sbin/named -u named -t /var/named/chroot -c /etc/named/named.conf</span><br></pre></td></tr></table></figure><p>其中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-u username     #指定用什么账户名来启动named</span><br><span class="line">-t directory    #chroot到指定目录，chroot是在加载配置文件之前，也就是配置文件路径还是从系统原先的根路径开始，等named服务启动后，那就是以-t后的directory目录作为根路径</span><br><span class="line">-c config-file  #指定named加载的配置文件路径。若没有该选项，则默认加载/etc/named.conf</span><br></pre></td></tr></table></figure><h1 id="Bind的配置文件"><a href="#Bind的配置文件" class="headerlink" title="Bind的配置文件"></a>Bind的配置文件</h1><p>BIND服务的进程名为named，主要的配置文件有：</p><p>（1）named.conf</p><p>bind的主配置文件，用来对bind服务的基本配置、zonefile的位置、权限等设置、zone和zonefile的对应关系等。bind主配置文件named.conf的基本格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 全局配置段</span><br><span class="line">options &#123; ... &#125;;</span><br><span class="line">// 日志配置段</span><br><span class="line">logging &#123; ... &#125;;</span><br><span class="line">// 区域配置段</span><br><span class="line">zone &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>named.conf options全局配置段中一些重要配置参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen-on port 53 &#123; 127.0.0.1; 192.168.1.108; &#125;;    //定义DNS监听在哪个IP的特定端口上</span><br><span class="line">directory      &quot;/var/named&quot;;    //指定DNS zone文件存放目录</span><br><span class="line">allow-query    &#123; localhost; 192.168.1.100; &#125;;    //定义允许哪些主机可以查询该DNS服务</span><br><span class="line">recursion yes;    //定义是否允许DNS服务器做递归查询</span><br><span class="line">notify yes;    //DNS服务器采用主从模式时，定义是否当主服务器zone文件发生改变，通知从服务器更新</span><br></pre></td></tr></table></figure><p>（2）zone file</p><p>包括域名正解配置文件、ip反解配置文件。是域名解析的关键文件。举例说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zone &quot;.&quot; IN &#123;     //根域的zone文件属性配置</span><br><span class="line">    type hint;    //定义此区域文件的类型为hint</span><br><span class="line">    file &quot;named.ca&quot;;    //相对directory &quot;/var/named/&quot;目录的文件，为根域的zone文件</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone &quot;example1.com&quot; &#123;</span><br><span class="line">    type master;     //说明该DNS对于example1.com域是Master</span><br><span class="line">    file &quot;db/example1.com.zone&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在zone中类型type可以是hint、master、slave以及forward。特殊符号<code>@</code>是DNS配置中的保留关键字，表示当前域的名称，在上述的例子<code>db/example1.com.zone</code>配置中，可以使用<code>@</code>表示<code>example1.com</code>。在zone file中还有一些特殊参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@TTL    #设置zone file中每一条记录的TTL值</span><br><span class="line">@ORIGIN #重新定义zone的名称，如上述例子中db/example1.com.zone文件中代表的域是example1.com，但当我们使用@ORIGIN bb.example1.com就表示当前域是bb.example1.com</span><br></pre></td></tr></table></figure><p>备注：为保持主配置文件简洁，可以将部分配置信息存放于其他文件，然后再主配置文件named.conf中通过include指令进行引入，如include “/etc/named.rfc1912.zones”。</p><h1 id="DNS的master-slave架构及配置同步问题"><a href="#DNS的master-slave架构及配置同步问题" class="headerlink" title="DNS的master/slave架构及配置同步问题"></a>DNS的master/slave架构及配置同步问题</h1><p>（1）master/slave架构简介</p><p>Bind的架构是Master/Slave架构模式，即一主多从的结构。在生产环境中一般有2台以上的DNS服务器，其中一台作为master dns，其他的作为slave dns。master dns用来提供域名解析的修改，不提供对外DNS解析服务。各个slave dns自动从master dns上同步配置文件，且他们真正对外提供DNS解析服务。</p><p>（2）master和slave dns的关键配置</p><p>master和slave dns的配置文件基本是一样的，但有如下的一些差异：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// master dns配置如下</span><br><span class="line">zone &quot;example.com&quot; IN &#123;</span><br><span class="line">    type master;                       #指明dns的类型，这里是master dns</span><br><span class="line">    file &quot;named.example.com&quot;;          #指明zone file</span><br><span class="line">    allow-transfer &#123;192.168.100.10;&#125;;  #这里配置的是slave ip列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// slave dns配置如下</span><br><span class="line">zone &quot;example.com&quot; IN &#123;</span><br><span class="line">    type slave;                 #指明dns的类型，这里是slave dns</span><br><span class="line">    file &quot;named.example.com&quot;;   #指明zone file</span><br><span class="line">    masters &#123;192.168.100.122;&#125;; #这里配置master dns的ip</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）master和slave的同步机制</p><p>master和slave dns之间的同步有两种策略：</p><p>a）master主动告知，当master修改了正反解配置文件，会主动通知slave进行更新</p><p>b）slave定期地比较本地配置文件的序号（或称为版本号）与master dns的不同。如果发现master的序号比本地要大，那么就会去同步master dns的配置文件。</p><p>备注：dns的配置文件有序号或版本号的概念，每次修改dns的配置文件，则序号会递增一个。另外，master和slave间的配置同步是有bind自身来支持的，不是由rsync这样的工具来控制的哦。</p><h1 id="cache-only-DNS服务器与forwarding-DNS服务器"><a href="#cache-only-DNS服务器与forwarding-DNS服务器" class="headerlink" title="cache-only DNS服务器与forwarding DNS服务器"></a>cache-only DNS服务器与forwarding DNS服务器</h1><p>（1）cache-only DNS服务器</p><p>如果某个DNS服务器只有<code>.</code>这个zone file（root dns），我们称这种没有自己公共的DNS数据库的服务器称为cache-only DNS服务器。也就是这种DNS服务器只有缓存查找的功能，它自身并没有任何域名和IP正反解的配置文件。</p><p>cache-only DNS的配置举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># named.conf主要的文件内容</span><br><span class="line">zone &quot;.&quot; &#123;</span><br><span class="line">  type hint;</span><br><span class="line">  file &quot;named.root&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># named.root文件的内容</span><br><span class="line">.                       446466  IN      NS      g.root-servers.net.</span><br><span class="line">.                       446466  IN      NS      k.root-servers.net.</span><br><span class="line">.                       446466  IN      NS      f.root-servers.net.</span><br><span class="line">.                       446466  IN      NS      a.root-servers.net.</span><br><span class="line">.                       446466  IN      NS      c.root-servers.net.</span><br><span class="line">.                       446466  IN      NS      d.root-servers.net.</span><br><span class="line">.                       446466  IN      NS      j.root-servers.net.</span><br><span class="line">.                       446466  IN      NS      l.root-servers.net.</span><br><span class="line">.                       446466  IN      NS      e.root-servers.net.</span><br><span class="line">.                       446466  IN      NS      i.root-servers.net.</span><br><span class="line">.                       446466  IN      NS      b.root-servers.net.</span><br><span class="line">.                       446466  IN      NS      m.root-servers.net.</span><br><span class="line">.                       446466  IN      NS      h.root-servers.net.</span><br><span class="line"></span><br><span class="line">a.root-servers.net.     447955  IN      A       198.41.0.4</span><br><span class="line">a.root-servers.net.     447958  IN      AAAA    2001:503:ba3e::2:30</span><br><span class="line">b.root-servers.net.     447955  IN      A       192.228.79.201</span><br><span class="line">b.root-servers.net.     447958  IN      AAAA    2001:500:84::b</span><br><span class="line">c.root-servers.net.     447955  IN      A       192.33.4.12</span><br><span class="line">c.root-servers.net.     447968  IN      AAAA    2001:500:2::c</span><br><span class="line">d.root-servers.net.     447955  IN      A       199.7.91.13</span><br><span class="line">d.root-servers.net.     447968  IN      AAAA    2001:500:2d::d</span><br><span class="line">e.root-servers.net.     447955  IN      A       192.203.230.10</span><br><span class="line">f.root-servers.net.     447955  IN      A       192.5.5.241</span><br><span class="line">f.root-servers.net.     447968  IN      AAAA    2001:500:2f::f</span><br><span class="line">g.root-servers.net.     447955  IN      A       192.112.36.4</span><br><span class="line">h.root-servers.net.     447968  IN      A       128.63.2.53</span><br><span class="line">h.root-servers.net.     447968  IN      AAAA    2001:500:1::803f:235</span><br><span class="line">i.root-servers.net.     447968  IN      A       192.36.148.17</span><br><span class="line">i.root-servers.net.     447968  IN      AAAA    2001:7fe::53</span><br><span class="line">j.root-servers.net.     447968  IN      A       192.58.128.30</span><br><span class="line">j.root-servers.net.     447968  IN      AAAA    2001:503:c27::2:30</span><br><span class="line">k.root-servers.net.     447968  IN      A       193.0.14.129</span><br><span class="line">k.root-servers.net.     447968  IN      AAAA    2001:7fd::1</span><br><span class="line">l.root-servers.net.     447968  IN      A       199.7.83.42</span><br><span class="line">l.root-servers.net.     447968  IN      AAAA    2001:500:3::42</span><br><span class="line">m.root-servers.net.     447968  IN      A       202.12.27.33</span><br><span class="line">m.root-servers.net.     447968  IN      AAAA    2001:dc3::35</span><br></pre></td></tr></table></figure><p>（2）forwarding DNS服务器</p><p>有些DNS服务器可能连<code>.</code>这个zone file都没有，而是通过forwarding配置将域名解析请求转发给其他的DNS服务器，我们称这种DNS服务器为forwarding DNS服务器。</p><p>forwarding DNS服务器的配置举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">zone &quot;example1.com&quot; &#123;</span><br><span class="line">  type forward;</span><br><span class="line">  forward only;</span><br><span class="line">  forwarders &#123; 10.28.21.70; 10.28.21.71; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone &quot;example2.com&quot; &#123;</span><br><span class="line">  type forward;</span><br><span class="line">  forward only;</span><br><span class="line">  forwarders &#123; 10.38.21.70; 10.38.21.71; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>备注：forwarding这个特性通常用来做DNS劫持吧，如某公司有内部域名<code>example-inc.com</code>需要解析到内部IP地址，此时在公司机房的Local DNS上针对<code>example-inc.com</code>这个zone配置forwarding，将DNS请求转发到一套内部的DNS集群，然后由这个内部的DNS集群负责解析<code>example-inc.com</code>这个zone。因此<code>example-inc.com</code>这个域名，就不需要向外部的<code>.com</code>域上申请授权啦。</p><p>（3）权威DNS服务器<br>自己的理解是，所谓权威DNS服务是相对于cache-only DNS和forwards DNS来说的，cache-only DNS和forwards DNS本身并不提供相关域名的解析（若自身缓存中有解析记录则可以返回给dns客户端，但这不叫自身的解析）。而权威服务器是自身就能够解析域名，即zone file中配置了域名和IP的映射关系（也有CNAME或MX等记录）。</p><p>备注：其实在实际生产环境中，有些DNS服务器具有.这个zone file，同时通过forwading配置将某些域名的解析请求转发给其他的DNS服务器。</p><h1 id="Bind中的zone-ACL-view概念"><a href="#Bind中的zone-ACL-view概念" class="headerlink" title="Bind中的zone/ACL/view概念"></a>Bind中的zone/ACL/view概念</h1><p>Bind中zone是指一个解析域，例如dns.baidu.com域名服务器中就有baidu.com、iqiyi.com等zone，zone里面会具体配置A记录、CNAME记录以及NS记录等等。</p><p>Bind可以配置很多的ACL，每一个ACL包含了一个网络地址的集合，例如北京电信ACL，河南移动ACL，广州联通ACL等等。通过ACL就可以知道一个用户IP来源于哪个运营商网络。</p><p>Bind中的view是匹配某个ACL的解析集合。</p><p>如下是一个包含了view/acl/zone概念的Bind配置举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">view beijing-cu &#123; </span><br><span class="line">    match-clients      &#123;beijing_cu.acl; &#125;;  #属于北京电信的用户才会被DNS从这个view中解析IP地址</span><br><span class="line">    recursion no;  #不允许外部网络用户进行递归查询（我们不是免费的公共dns）</span><br><span class="line"></span><br><span class="line">    zone &quot;lustlost.com&quot; IN &#123; </span><br><span class="line">            type master; </span><br><span class="line">            file &quot;lustlost.com.out&quot;; </span><br><span class="line">            allow-transfer &#123; none; &#125;; </span><br><span class="line">            allow-update &#123; none; &#125;; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="DNS-AXFR"><a href="#DNS-AXFR" class="headerlink" title="DNS AXFR"></a>DNS AXFR</h1><p>DNS Zone Transfer Protocol，简称AXFR，是多台DNS服务器之间同步解析规则的协议。因此可以通过AXFR，查到指定DNS服务器的所有解析记录。可以使用dig命令查看AXFR的威力，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig AXFR baidu.com @ns2.baidu.com    <span class="comment">#查询ns2.baidu.com</span></span><br></pre></td></tr></table></figure><p>DNS服务器上baidu.com这个zone下的所有域名，当然一般来说，DNS服务器会限制外部使用AXFR功能，可以自己搭建一个DNS服务，然后到dns服务器上执行<code>dig AXFR example.com @localhost</code>或<code>dig AXFR example.com @127.0.0.1</code>。</p><h1 id="Bind的开源可视化管理界面"><a href="#Bind的开源可视化管理界面" class="headerlink" title="Bind的开源可视化管理界面"></a>Bind的开源可视化管理界面</h1><p>Bind有非常非常多的WEB管理工具，例如webbind/smbind/DNS control/ProBIND/Binder/myWebDNS等等，具体参加页面<a href="http://www.ti6.net/internet/1490.html" target="_blank" rel="noopener">http://www.ti6.net/internet/1490.html</a></p><p>其中smbind，全称为Simple Management for BIND.</p><h1 id="智能DNS"><a href="#智能DNS" class="headerlink" title="智能DNS"></a>智能DNS</h1><p>像上面使用了view的概念后，就是智能DNS的配置。可以根据用户的来源IP所属的区域运营商，来返回一个离用户比较近的服务端IP给用户。值得注意的是，原始的DNS协议是无法获取到用户的来源IP，后来由Google起草的EDNS，EDNS是一个DNS扩展协议，改进部分很简单，就是在DNS协议中加入用户原始IP，这样DNS就知道用户的来源网络，为其指定一个离他较近的IP来访问。</p><p>智能DNS需要用到的IP库可以从如下地址下载：<br><a href="http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest" target="_blank" rel="noopener">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</a></p><p>备注：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig www.zhxfei.com @172.16.130.129 +subnet=120.0.0.1/24</span><br></pre></td></tr></table></figure></p><p>如上命令中，dig工具需要安装支持edns的版本，+subnet指定客户端所属的子网，@server指定Local DNS，假设172.16.130.129支持了edns，那么她会依照+subnet来解析出一个离客户端比较近的IP，而不是根据Local DNS来解析出较近的IP。这种情况下，DNS的GLSB负载均衡将会更准确。</p><h1 id="Bind的递归配置"><a href="#Bind的递归配置" class="headerlink" title="Bind的递归配置"></a>Bind的递归配置</h1><p>在named.conf中options区域通过<code>recursion {yes | no}</code>来设置，默认是<code>recursion yes</code>配置，即默认是开启递归的。若开启了递归，那么bind dns服务会依据客户端的dns请求，不管是通过“自己本地解析”或“cache缓存”或者“查询其他dns服务器”，最终一定要得到客户端需要的终极结果返回给客户端。就不用客户端再去查询了。若关闭了递归，那么bind dns在收到客户端的请求后，如果本地不能解析或本地缓存中也不存在，那就会返回和dns请求相关的信息，如返回一条NS记录，告诉客户端再去其他的DNS上去查询结果。</p><p>BIND9默认打开递归查询和关闭转发功能。</p><h1 id="Bind提供的一些辅助工具"><a href="#Bind提供的一些辅助工具" class="headerlink" title="Bind提供的一些辅助工具"></a>Bind提供的一些辅助工具</h1><ul><li>named-checkconf</li><li>named-checkzone</li><li>named-compilezone</li><li>rndc</li></ul><h1 id="Bind的负载均衡"><a href="#Bind的负载均衡" class="headerlink" title="Bind的负载均衡"></a>Bind的负载均衡</h1><p>假设域名<code>www.bat.com</code>有多条A记录，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.bat.com  A  10.0.0.1</span><br><span class="line">www.bat.com  A  10.0.0.2</span><br><span class="line">www.bat.com  A  10.0.0.3</span><br></pre></td></tr></table></figure></p><p>那么当客户端请求dns服务器解析<code>www.bat.com</code>时，dns服务器会随机的返回<code>1,2,3</code>、<code>2,1,3</code>、<code>3,1,2</code>等这样的顺序，一般来说客户端会使用第一条记录，那么所有的A记录的对应的服务的DNS请求数几乎是一样的。</p><h1 id="Bind能处理的类unix平台的信号"><a href="#Bind能处理的类unix平台的信号" class="headerlink" title="Bind能处理的类unix平台的信号"></a>Bind能处理的类unix平台的信号</h1><p>Bind能处理的类unix平台的信号有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SIGHUP   #会触发bind重新加载named.conf配置</span><br><span class="line">SIGTERM  #会触发bind退出</span><br><span class="line">SIGINT   #会触发bind退出</span><br></pre></td></tr></table></figure><h1 id="DNSPOD"><a href="#DNSPOD" class="headerlink" title="DNSPOD"></a>DNSPOD</h1><p>DNSPod建立于2006年3月份，是一款免费智能DNS产品。DNSPod是中国第一大DNS解析服务提供商、第一大域名托管商。DNSPod可以为同时有电信、联通、教育网服务器的网站提供智能的解析，让电信用户访问电信的服务器，联通的用户访问联通的服务器，教育网的用户访问教育网的服务器，达到互联互通的效果。</p><p>说白了，DNSPOD对外提供了一个公共的DNS服务，帮助其用户解析域名，这样其用户就不需要搭建自己的DNS服务器了。注意和Public DNS，例如和8.8.8.8，114.114.114.114是有区别的，Public DNS是用来帮助用户的浏览器解析域名的，而不会帮忙搭建DNS域名解析服务。</p><p>DNSPod目前是腾讯旗下的公司。</p><h1 id="Bind的闲杂知识点"><a href="#Bind的闲杂知识点" class="headerlink" title="Bind的闲杂知识点"></a>Bind的闲杂知识点</h1><p>（1）bind配置的序列号serial num问题</p><p>序列号的上限是2147483647(2ˆ31-1)，超过这个值之后，需要重置才能生效。如下为官方手册的说明：</p><p><img src="/images/smbind_1_1.png" alt></p><p>备注：先用当前序列号加上2147483647，并让bind reload配置，待各slaves更新完配置；在将序列号设定为自己想要的值，并再让bind reload配置即可。</p><p>学习资料参考于：<br><a href="https://www.isc.org/downloads/bind/" target="_blank" rel="noopener">https://www.isc.org/downloads/bind/</a><br><a href="https://www.isc.org/downloads/bind/doc/" target="_blank" rel="noopener">https://www.isc.org/downloads/bind/doc/</a></p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正向HTTP/HTTPS/FTP代理软件squid技术调研</title>
      <link href="/2018/02/02/%E6%AD%A3%E5%90%91HTTP-HTTPS-FTP%E4%BB%A3%E7%90%86%E8%BD%AF%E4%BB%B6squid%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/02/02/%E6%AD%A3%E5%90%91HTTP-HTTPS-FTP%E4%BB%A3%E7%90%86%E8%BD%AF%E4%BB%B6squid%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="squid简介"><a href="#squid简介" class="headerlink" title="squid简介"></a>squid简介</h1><p>Squid是HTTP代理服务器和缓存软件，支持HTTP/HTTPS/FTP协议的请求的代理。可以使用squid在一台科学上网的机器上（例如香港或美国的机器）搭建一个squid，然后就可以利用它来科学上网了哦。另外，squid不仅可以做代理，而且它可以缓存源站的内容哦，类似于Nginx的缓存功能。</p><h1 id="squid的安装"><a href="#squid的安装" class="headerlink" title="squid的安装"></a>squid的安装</h1><p>在RedHat系上我们可以使用yum来安装squid，即<code>yum install squid</code>。squid安装后核心的目录文件结构有：</p><pre><code>/usr/sbin/squid        #squid的主程序/etc/squid/squid.conf  #squid的主配置文件/var/spool/squid       #squid的默认的缓存文件的存储目录</code></pre><h1 id="squid的配置"><a href="#squid的配置" class="headerlink" title="squid的配置"></a>squid的配置</h1><p>squid的配置文件为/etc/squid/squid.conf，该配置文件主要有如下几个部分：</p><p>（1）acl的配置</p><p>包括本地、外网、以及服务端口等，举例来说：</p><pre><code>acl localhost src 127.0.0.1/32 ::1  #表示来源ip为本地acl localnet src 10.0.0.0/8         #表示来源ip为本地私网的一些机器acl Safe_ports port 80              #表示请求的端口是80</code></pre><p>备注：其实本部分可以理解为定义满足一定特征的一些请求，供（2）来对这些类别的请求进行权限控制</p><p>（2）访问权限的控制</p><pre><code>http_access allow localnet   #允许来自（1）中定义的localnet特征的请求http_access allow localhost  #允许来自（1）中定义的localhost特征的请求http_access deny !Safe_ports #拒绝（1）中没有被定义为Safe_ports的端口的请求</code></pre><p>备注：上面的访问控制是有先后顺序的。</p><p>（3）squid网络参数的配置</p><p>例如监听的端口，默认情况下，squid监听的是3128端口</p><p>（4）磁盘与缓存相关的配置</p><p>（5）其他的一些日志类的配置</p><h1 id="squid层级配置"><a href="#squid层级配置" class="headerlink" title="squid层级配置"></a>squid层级配置</h1><p>在负责的网络环境中，我们可能要使用多个squid服务器构建一个squid集群，squid集群中可以有父子关系、兄弟关系。使用squid层级时，我们还可以定义squid A将某些流量转发给squid B，某些流量直接转发到目标服务器，或者所有流量都由squid B转发。这些主要用到squid的cache_peer、cache_peer_access、always_direct等配置指令。</p><p><img src="/images/squid_1_2.png" alt></p><h1 id="squid的access日志格式"><a href="#squid的access日志格式" class="headerlink" title="squid的access日志格式"></a>squid的access日志格式</h1><p><img src="/images/squid_1_1.png" alt></p><h1 id="squid的access-log的状态码"><a href="#squid的access-log的状态码" class="headerlink" title="squid的access.log的状态码"></a>squid的access.log的状态码</h1><p><strong><em>使用TCP协议的状态码枚举</em></strong></p><p>（1）TCP_HIT</p><p>Squid发现请求资源的貌似新鲜的拷贝，并将其立即发送到客户端。</p><p>（2）TCP_MISS</p><p>Squid没有请求资源的cache拷贝。</p><p>（3）TCP_REFERSH_HIT</p><p>Squid发现请求资源的貌似陈旧的拷贝，并发送确认请求到原始服务器.原始服务器返回304（未修改）响应，指示squid的拷贝仍旧是新鲜的。</p><p>（4）TCP_REF_FAIL_HIT</p><p>Squid发现请求资源的貌似陈旧的拷贝，并发送确认请求到原始服务器。然而，原始服务器响应失败，或者返回的响应Squid不能理解。在此情形下，squid发送现有cache拷贝（很可能是陈旧的）到客户端。</p><p>（5）TCP_REFRESH_MISS</p><p>Squid发现请求资源的貌似陈旧的拷贝，并发送确认请求到原始服务器。原始服务器响应新的内容，指示这个cache拷贝确实是陈旧的。</p><p>（6）TCP_CLIENT_REFRESH_MISS</p><p>Squid发现了请求资源的拷贝，但客户端的请求包含了Cache-Control: no-cache指令。Squid转发客户端的请求到原始服务器，强迫cache确认。</p><p>（7）TCP_IMS_HIT</p><p>客户端发送确认请求，Squid发现更近来的、貌似新鲜的请求资源的拷贝。Squid发送更新的内容到客户端，而不联系原始服务器。</p><p>（8）TCP_SWAPFAIL_MISS</p><p>Squid发现请求资源的有效拷贝，但从磁盘装载它失败。这时squid发送请求到原始服务器，就如同这是个cache丢失一样。</p><p>（9）TCP_NEGATIVE_HIT</p><p>在对原始服务器的请求导致HTTP错误时，Squid也会cache这个响应。在短时间内对这些资源的重复请求，导致了否命中。negative_ttl指令控制这些错误被cache的时间数量。请注意这些错误只在内存cache，不会写往磁盘。下列HTTP状态码可能导致否定cache（也遵循于其他约束）： 204, 305, 400, 403, 404, 405, 414, 500, 501, 502, 503, 504.</p><p>（10）TCP_MEM_HIT</p><p>Squid在内存cache里发现请求资源的有效拷贝，并将其立即发送到客户端。注意这点并非精确的呈现了所有从内存服务的响应。例如，某些cache在内存里，但要求确认的响应，会以TCP_REFRESH_HIT、TCP_REFRESH_MISS等形式记录。</p><p>（11）TCP_DENIED</p><p>因为http_access或http_reply_access规则，客户端的请求被拒绝了。注意被http_access拒绝的请求在第9域的值是NONE/-，然而被http_reply_access拒绝的请求，在相应地方有一个有效值。</p><p>（12）TCP_OFFLINE_HIT</p><p>当offline_mode激活时，Squid对任何cache响应返回cache命中，而不用考虑它的新鲜程度。</p><p>（13）TCP_REDIRECT</p><p>重定向程序告诉Squid产生一个HTTP重定向到新的URI（见11.1节）。正常的，Squid不会记录这些重定向。假如要这样做，必须在编译squid前，手工定义LOG_TCP_REDIRECTS预处理指令。</p><p>（14）NONE</p><p>无分类的结果用于特定错误，例如无效主机名。</p><p><strong><em>使用UDP协议的状态码枚举</em></strong></p><p>（1）UDP_HIT</p><p>Squid在cache里发现请求资源的貌似新鲜的拷贝。</p><p>（2）UDP_MISS</p><p>Squid没有在cache里发现请求资源的貌似新鲜的拷贝。假如同一目标通过HTTP请求，就可能是个cache丢失，请对比UDP_MISS_NOFETCH。</p><p>（3）UDP_MISS_NOFETCH<br>跟UDP_MISS类似，不同的是这里也指示了Squid不愿去处理相应的HTTP请求。假如使用了-Y命令行选项，Squid在启动并编译其内存索引时，会返回这个标签而不是UDP_MISS。</p><p>（4）UDP_DENIED</p><p>因为icp_access规则，ICP查询被拒绝。假如超过95%的到某客户端的ICP响应是UDP_DENIED，并且客户端数据库激活了（见附录A），Squid在1小时内，停止发送任何ICP响应到该客户端。若这点发生，你也可在cache.log里见到一个警告。</p><p>（5）UDP_INVALID</p><p>Squid接受到无效查询（例如截断的消息、无效协议版本、URI里的空格等）。Squid发送UDP_INVALID响应到客户端。</p><h1 id="使用squid代理的客户端机器的配置"><a href="#使用squid代理的客户端机器的配置" class="headerlink" title="使用squid代理的客户端机器的配置"></a>使用squid代理的客户端机器的配置</h1><p>客户端机器要使用squid代理，需要本地配置一些代理相关的环境，例如：</p><pre><code># vi /etc/profilehttp_proxy=192.168.10.91:3128  #分别指定http/https/ftp协议使用的代理服务器地址https_proxy=192.168.10.91:3128ftp_proxy=192.168.10.91:3128no_proxy=192.168.10.0.  #访问局域网地址（192.168.20.0/24网段）时不使用代理，可以用逗号分隔多个地址export http_proxy https_proxy ftp_proxy no_proxy</code></pre><p>备注：向curl/wget会使用http_proxy类环境变量，但是有些程序不会使用http_proxy变量，那么就需要按照该程序的说明文档单独地配置即可。</p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BKM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议版本演进及SPDY|QUIC</title>
      <link href="/2018/02/02/HTTP%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC%E6%BC%94%E8%BF%9B%E5%8F%8ASPDY-QUIC/"/>
      <url>/2018/02/02/HTTP%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC%E6%BC%94%E8%BF%9B%E5%8F%8ASPDY-QUIC/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议版本演进"><a href="#HTTP协议版本演进" class="headerlink" title="HTTP协议版本演进"></a>HTTP协议版本演进</h1><p>（1）HTTP/0.9</p><p>1991年HTTP/0.9提出，是HTTP的原型版本。但是HTTP/0.9的设计有严重的缺陷，它很快被HTTP/1.0取代了。</p><p>（2）HTTP/1.0</p><p>HTTP/1.0是第一个得到广泛使用的HTTP版本。HTTP/1.0添加了版本号、各种HTTP首部、一些额外的方法，以及对多媒体对象的处理，它集合了一系列的最佳实践。</p><p>（3）HTTP/1.0+</p><p>在20世纪90年代中叶，HTTP协议增加了很多的特性，例如持久的keep-alive连接、虚拟主机支持，以及代理连接等等，这些特性成为了非官方的事实标准。这种非正式的HTTP扩展版本通常称为HTTP/1.0+</p><p>（4）HTTP/1.1</p><p>HTTP/1.1重点关注的是校正HTTP设计中的结构性缺陷，明确语义，引入重要的性能优化措施，并提出了一些不好的特性。HTTP/1.1是当前使用的HTTP版本。</p><p>（5）HTTP/2.0（又名为HTTP-NG）</p><p>HTTP-NG是HTTP/1.1后继结构的原型建议，它重点关注的是性能的大幅优化，以及更强大的服务逻辑远程执行框架。HTTP-NG的研究工作终止于1988年，但目前HTTP-NG还处在没有被推广实施的阶段。</p><h1 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h1><p>SPDY，一种开放的网络传输协议，由Google开发，用来发送网页内容。基于传输控制协议TCP的应用层协议。Google最早是在Chromium中提出的SPDY协议。被用于Google Chrome浏览器中来访问Google的SSL加密服务。SPDY并不是首字母缩略字，而仅仅是”speedy”的缩写。SPDY现为Google的商标。HTTP/2的关键功能主要来自SPDY技术，换言之，SPDY的成果被采纳而最终演变为HTTP/2。</p><p>SPDY并不是一个标准协议，但SPDY的开发组推动SPDY成为正式标准，而成为了互联网草案。后来SPDY未能单独成为正式标准，不过SPDY开发组的成员全程参与了HTTP/2的制定过程。Google Chrome、Mozilla Firefox、Safari、Opera、Internet Explorer等主要浏览器均已经或曾经支持SPDY协议。SPDY协议类似于HTTP，但旨在缩短网页的加载时间和提高安全性。SPDY协议通过压缩、多路复用和优先级来缩短加载时间。HTTP/2协议完成之后，Google认为SPDY可以功成身退了，于是最终Google Chrome淘汰对SPDY的支持，全面改为采用HTTP/2。</p><h1 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h1><p>QUIC是快速UDP网络连接（英文全称为Quick UDP Internet Connections）的缩写，这是一种实验性的传输层网络传输协议，由Google公司开发，在2013年实现。Google希望使用这个协议来取代TCP协议，使网页传输速度加快，计划将QUIC提交至互联网工程任务小组（IETF），让它成为下一代的正式网络规范。</p><p>目前来说，HTTP的数据传输都基于TCP协议。TCP协议在创建连接之前需要进行三次握手，如果需要提高数据交互的安全性，既增加传输层安全协议（TLS），还会增加更多的握手次数。而QUIC协议可以在1到2个数据包（取决于连接的服务器是新的还是已知的）内，完成连接的创建（包括TLS）。</p><p>QUIC协议内置了TLS栈，实现了自己的传输加密层，而没有使用现有的TLS1.2。同时QUIC还包含了部分HTTP/2的实现。如下为使用了QUIC协议和传统的HTTP的协议栈的对比图：</p><p><img src="/images/http_proto_1_1.png" alt></p><p>备注：QUIC协议是Google使用QUIC+UDP来取代TCP，来优化WEB服务器和浏览器间数据传输。也就是说Google让HTTP通信底层使用了UDP协议。</p><p>学习资料参考于：<br><a href="http://www.infoq.com/cn/articles/quic-google-protocol-web-platform-from-tcp-to-udp" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/quic-google-protocol-web-platform-from-tcp-to-udp</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BKM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘驱动器RAID查看与配置工具</title>
      <link href="/2018/02/02/%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8RAID%E6%9F%A5%E7%9C%8B%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/02/02/%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8RAID%E6%9F%A5%E7%9C%8B%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘阵列卡"><a href="#磁盘阵列卡" class="headerlink" title="磁盘阵列卡"></a>磁盘阵列卡</h1><p>RAID有软RAID和硬RAID两种，其中硬RAID是通过磁盘阵列卡（一块专门的芯片）来完成RAID功能。通常来说，我们使用的DELL/HP/IBM三家的机架式PC级服务器磁盘阵列卡是由LSI公司生产的。DELL和IBM两家对LSI的磁盘阵列卡没有做太多封装，可以用原厂LSI提供的阵列卡工具进行配置和管理。而HP则对LSI的磁盘阵列卡做了很多的封装，因此需要使用自身特有的工具来配置和管理。</p><p>如下为一些常见的磁盘阵列卡产品：</p><p>（1）DELL SAS 6/iR卡</p><p>全称LSI Logic SAS1068E，只支持RAID 0, RAID 1, RAID 1+0, 不支持RAID 5等高级RAID特性，不支持阵列卡电池。</p><p>（2）DELL PERC PERC H700卡</p><p>全称LSI Logic MegaRAID SAS 2108，支持各种RAID级别及高级特性，可选配阵列卡电池。</p><p>（3）DELL PERC H310 Mini卡</p><p>全称LSI Logic / Symbios Logic MegaRAID SAS 2008，支持常见RAID级别，不支持高级RAID特性，不支持阵列卡电池。</p><p>（4）IBM ServeRAID M5014 SAS/SATA Controller卡</p><p>全称LSI Logic / Symbios Logic MegaRAID SAS 2108，支持各种RAID级别及高级特性，可选配阵列卡电池。</p><p>（5）IBM ServeRAID-MR10i SAS/SATA Controller卡</p><p>全称LSI Logic / Symbios Logic MegaRAID SAS 1078，支持常见RAID级别，不支持高级RAID特性，可选配阵列卡电池，这个卡其实和DELL的PERC 6/i卡是一样的，都是基于LSI MegaRAID SAS 1078基础上OEM出来的。</p><p>（6）等等</p><h1 id="磁盘阵列卡的管理工具"><a href="#磁盘阵列卡的管理工具" class="headerlink" title="磁盘阵列卡的管理工具"></a>磁盘阵列卡的管理工具</h1><p>一般来说，支持RAID 5的磁盘阵列卡，都可以使用LSI官方提供的MegaCli工具来管理。而不支持RAID 5的磁盘阵列卡，我们称其为SAS卡，使用lsiutil工具来管理。HP的服务器使用其特有的hpacucli工具来管理。</p><h1 id="MegaCli工具的常用用法"><a href="#MegaCli工具的常用用法" class="headerlink" title="MegaCli工具的常用用法"></a>MegaCli工具的常用用法</h1><p>新版本的MegaCli-1.01.24-0.i386.rpm会把程序默认安装到/opt目录下，当然也可以自定义安装目录，例如下叙命令表示将MegaCli安装到/usr/bin目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --relocate /opt/=/usr/sbin/ -i MegaCli-1.01.24-0.i386.rpm</span><br></pre></td></tr></table></figure><p>如下为MegaCli工具的一些常用命令：</p><p>（1）查看阵列卡信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MegaCli -adpallinfo -aall</span><br></pre></td></tr></table></figure><p>备注：如下为一台做了两个RAID（RAID1+RAID5）的机器的信息，其中虚拟磁盘驱动器有2个，也即经过做RAID后有/dev/sda, /dev/sdb两个磁盘设备。物理磁盘有16，当前在线的有14个（其中1个有故障），另外2个磁盘已彻底故障且离线。</p><p><img src="/images/hardware_raid_1_1.png" alt></p><p>（2）查看阵列卡配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MegaCli -cfgdsply -aall</span><br></pre></td></tr></table></figure><p>备注：通通过RAID Level可以得知磁盘阵列的等级，规则如下：</p><p><img src="/images/hardware_raid_1_2.png" alt></p><p>（3）查看阵列卡日志，关注里面的error/fail/warn等多个关键字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MegaCli -fwtermlog -dsply -aALL</span><br></pre></td></tr></table></figure><p>（4）查看所有物理磁盘信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MegaCli -PDList -aALL</span><br></pre></td></tr></table></figure><p>备注：这个能够查看机器上所有物理磁盘的信息</p><p>（5）查看磁盘缓存策略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MegaCli -LDGetProp -Cache -L0 -a0</span><br></pre></td></tr></table></figure><p>（6）创建一个RAID 5的阵列，由物理盘 2,3,4 构成，该阵列的热备盘是物理盘5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MegaCli -CfgLdAdd -r5 [1:2,1:3,1:4] WB Direct -Hsp[1:5] -a0</span><br></pre></td></tr></table></figure><p>（7）删除一个RAID阵列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MegaCli -CfgLdDel -L1 -a0</span><br></pre></td></tr></table></figure><h1 id="lsiutil工具的常见用法"><a href="#lsiutil工具的常见用法" class="headerlink" title="lsiutil工具的常见用法"></a>lsiutil工具的常见用法</h1><p>（1）查看硬盘计数器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsiutil -p 1 -a 20,12,0,0</span><br></pre></td></tr></table></figure><p>（2）查看逻辑卷状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsiutil -p 1 -a 21,1,0,0,0</span><br></pre></td></tr></table></figure><p>（3）查看物理硬盘状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsiutil -p 1 -a 21,2,0,0,0</span><br></pre></td></tr></table></figure><h1 id="hpacucli工具的常见用法"><a href="#hpacucli工具的常见用法" class="headerlink" title="hpacucli工具的常见用法"></a>hpacucli工具的常见用法</h1><p>hpacucli工具查看阵列、硬盘、电池信息，其实就只要一条指令。</p><p>（1）查看阵列详细信息、配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hpacucli ctrl all show config detail</span><br></pre></td></tr></table></figure><h1 id="其他闲杂"><a href="#其他闲杂" class="headerlink" title="其他闲杂"></a>其他闲杂</h1><p>假如有2块物理磁盘，做了RAID 1，那么在Linux系统上看，只有一个设备，例如/dev/sda，经过分区后，就会多出几个名称为/dev/sda*的设备。</p><p>学习资料参考于：<br><a href="http://imysql.com/tag/megacli" target="_blank" rel="noopener">http://imysql.com/tag/megacli</a><br><a href="http://imysql.cn/2008_06_13_megacli_usage" target="_blank" rel="noopener">http://imysql.cn/2008_06_13_megacli_usage</a></p>]]></content>
      
      
      <categories>
          
          <category> HardWare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正向代理 | 反向代理 | 透明代理</title>
      <link href="/2018/02/02/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/"/>
      <url>/2018/02/02/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>正向代理，英文名为Forward Proxy。一般情况下，如果没有特别说明，代理技术默认说的是正向代理技术。 正向代理是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p><p>正向代理的架构图如下：</p><p><img src="/images/proxy_1_1.png" alt></p><p>使用正向代理的原因或优势有：</p><p>（1）通过代理服务器可以访问本来无法访问的资源</p><p>（2）访问加速</p><p>（3）缓存cache</p><p>（4）隐藏访问者的行踪</p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>反向代理，中文名为Reverse Proxy。反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理发送普通请求，但是反向代理上并没有需要的资源，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。</p><p>反向代理的架构图如下：</p><p><img src="/images/proxy_1_2.png" alt></p><p>使用反向代理的原因或优势有：</p><p>（1）保护和隐藏原始资源服务器</p><p>（2）负载均衡</p><h1 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h1><p>透明代理是相当于正向代理而言，透明代理的意思是客户端根本不需要知道有代理服务器的存在。如下为一个生产环境中使用透明代理的例子：</p><p><img src="/images/proxy_1_3.png" alt></p><p>用户A和用户B并不知道行为管理设备充当透明代理行为，当用户A或用户B向服务器A或服务器B提交请求的时候，透明代理设备根据自身策略拦截并修改用户A或B的报文，并作为实际的请求方，向服务器A或B发送请求，当接收信息回传，透明代理再根据自身的设置把允许的报文发回至用户A或B，如上图，如果透明代理设置不允许访问服务器B，那么用户A或者用户B就不会得到服务器B的数据。</p><h1 id="以Nginx的正向代理和反向代理的配置"><a href="#以Nginx的正向代理和反向代理的配置" class="headerlink" title="以Nginx的正向代理和反向代理的配置"></a>以Nginx的正向代理和反向代理的配置</h1><p>（1）nginx正向代理的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    resolver_timeout 30s;</span><br><span class="line">    listen 80;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://$http_host$request_uri;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_buffers 256 4k;</span><br><span class="line">        proxy_max_temp_file_size 0;</span><br><span class="line">        proxy_connect_timeout 30;</span><br><span class="line">        proxy_cache_valid 200 302 10m;</span><br><span class="line">        proxy_cache_valid 301 1h;</span><br><span class="line">        proxy_cache_valid any 1m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有resolver配置，即DNS服务器的配置。通过<code>proxy_pass http://$http_host$request_uri;</code>可以知道，代理服务器直接将代替客户将原始请求转发给真正的服务端。简单来看，代理服务器发出的http请求头和客户端发出的http请求头基本是一样的。</p><p>（2）nginx反向代理的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    #省略了前面一般的配置，直接从负载均衡这里开始</span><br><span class="line">    upstream http_server_pool &#123;</span><br><span class="line">        server 192.168.1.2:8080 weight=2 max_fails=2 fail_timeout=30s;</span><br><span class="line">        server 192.168.1.3:8080 weight=3 max_fails=2 fail_timeout=30s;</span><br><span class="line">        server 192.168.1.4:8080 weight=4 max_fails=2 fail_timeout=30s;</span><br><span class="line">    &#125;</span><br><span class="line">    #配置一个虚机，用来反向代理http_server_pool这组服务器</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;  </span><br><span class="line">        server_name www.test.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;</span><br><span class="line">            proxy_pass http://http_server_pool;</span><br><span class="line">            proxy_set_header Host www.test.com;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line">        access_log logs/www.test.com.access.log  combined;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：简单来看，反向代理服务发出的http请求的请求头是变化的，例如请求url。</p><p>学习资料参考于：<br><a href="http://z00w00.blog.51cto.com/515114/1031287" target="_blank" rel="noopener">http://z00w00.blog.51cto.com/515114/1031287</a></p>]]></content>
      
      
      <categories>
          
          <category> SRE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python应用中的一些小技巧</title>
      <link href="/2018/02/02/Python%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/02/02/Python%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="定位Python程序的性能"><a href="#定位Python程序的性能" class="headerlink" title="定位Python程序的性能"></a>定位Python程序的性能</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m cProfile xxx.py</span><br><span class="line">python -m profile xxx.py</span><br></pre></td></tr></table></figure><p>备注：建议使用cProfile就好了，cProfile会更高效，因为它是用C开发的。</p><h1 id="使用pdb调试Python程序"><a href="#使用pdb调试Python程序" class="headerlink" title="使用pdb调试Python程序"></a>使用pdb调试Python程序</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pdb xxx.py</span><br></pre></td></tr></table></figure><p>详细内容参见<a href="https://wangjianno1.github.io/2019/02/26/Python%E4%B8%ADDEBUG%E8%B0%83%E8%AF%95%E6%A8%A1%E5%9D%97PDB%E4%BD%BF%E7%94%A8/">《Python中DEBUG调试模块PDB使用》</a></p><h1 id="使用Python快速启动HTTP服务器"><a href="#使用Python快速启动HTTP服务器" class="headerlink" title="使用Python快速启动HTTP服务器"></a>使用Python快速启动HTTP服务器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure><h1 id="使用Python快速搭建FTP服务器"><a href="#使用Python快速搭建FTP服务器" class="headerlink" title="使用Python快速搭建FTP服务器"></a>使用Python快速搭建FTP服务器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install pyftpdlib</span><br><span class="line">python -m pyftpdlib  <span class="comment">#启动一个可以匿名登录的FTP服务器</span></span><br><span class="line">python -m pyftpdlib -u wahaha -P <span class="built_in">test</span>  <span class="comment">#启动一个需要使用账号wahaha，密码test登录的FTP服务器</span></span><br></pre></td></tr></table></figure><h1 id="使用Python格式化输出json数据"><a href="#使用Python格式化输出json数据" class="headerlink" title="使用Python格式化输出json数据"></a>使用Python格式化输出json数据</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat data.json | python -m json.tool</span><br><span class="line">python -m json.tool data.json</span><br></pre></td></tr></table></figure><h1 id="查看Python解释器的目录"><a href="#查看Python解释器的目录" class="headerlink" title="查看Python解释器的目录"></a>查看Python解释器的目录</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis python</span><br><span class="line"><span class="built_in">which</span> python</span><br></pre></td></tr></table></figure><h1 id="查看Python的安装目录"><a href="#查看Python的安装目录" class="headerlink" title="查看Python的安装目录"></a>查看Python的安装目录</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">print</span> sys.prefix</span><br></pre></td></tr></table></figure><h1 id="快速启动一个Python进程"><a href="#快速启动一个Python进程" class="headerlink" title="快速启动一个Python进程"></a>快速启动一个Python进程</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'while True: pass'</span> | python &amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uWSGI | uwgsi | WSGI区别和联系</title>
      <link href="/2018/02/02/uWSGI-uwsgi-WSGI%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/"/>
      <url>/2018/02/02/uWSGI-uwsgi-WSGI%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="uWSGI-WSGI-uwsgi三者的区别"><a href="#uWSGI-WSGI-uwsgi三者的区别" class="headerlink" title="uWSGI | WSGI | uwsgi三者的区别"></a>uWSGI | WSGI | uwsgi三者的区别</h1><h2 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h2><p>WSGI，全称为Web Server Gateway Interface，是Python语言中专有的接口协议，WSGI是一种类似于CGI/FastCGI等的通信协议。</p><p>下面以一个例子来说明WSGI协议，</p><p>（1）编写一个支持WSGI协议的web服务器</p><p>server.py使用支持WSGI协议的wsgiref服务器，并关联了用户程序application，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#server.py</span></span><br><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server <span class="comment">#从wsgiref模块导入</span></span><br><span class="line"><span class="keyword">from</span> hello <span class="keyword">import</span> application                 <span class="comment">#导入我们自己编写的application函数</span></span><br><span class="line"></span><br><span class="line">httpd = make_server(<span class="string">''</span>, <span class="number">8000</span>, application)    <span class="comment">#创建一个服务器，IP地址为空，端口是8000，处理函数是application</span></span><br><span class="line">print(<span class="string">'Serving HTTP on port 8000...'</span>)</span><br><span class="line">httpd.serve_forever()                         <span class="comment">#开始监听HTTP请求</span></span><br></pre></td></tr></table></figure><p>（2）编写用于生成动态网页的用户程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#hello.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</span>]</span><br></pre></td></tr></table></figure><p>其中environ用来接收web服务传递过来的HTTP请求协议头内容。start_response构造HTTP返回头。return返回的是html的body。如上就简单的实现了一个遵循WSGI规范的web服务器和用户程序，它们都严格遵循WSGI协议。</p><p>（3）测试</p><p>在浏览器中输入<code>http://localhost:8080/</code>即可访问测试了。</p><p>备注：在Python中，为了让程序员更关注业务处理逻辑，可以使用web框架，让解析http请求头中的路由信息交由框架来完成，Python的web框架有上百个，比如web2py，Bottle等等，同时html也有模板，比如jinja2等等。</p><h2 id="uwsgi"><a href="#uwsgi" class="headerlink" title="uwsgi"></a>uwsgi</h2><p>uwsgi与WSGI类似，也是一种通信协议，它是uWSGI服务器自有的协议，它用于定义传输信息的类型（type of information），每一个uwsgi packet前4byte为传输信息类型描述。与WSGI协议是两种东西，据说该协议是fcgi协议的10倍快。</p><h2 id="uWSGI"><a href="#uWSGI" class="headerlink" title="uWSGI"></a>uWSGI</h2><p>uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。</p><h1 id="Nginx对uwsgi协议的支持"><a href="#Nginx对uwsgi协议的支持" class="headerlink" title="Nginx对uwsgi协议的支持"></a>Nginx对uwsgi协议的支持</h1><p>Nginx中ngx_http_uwsgi_module模块就是对uwsgi协议的支持。通过该模块，我们可以部署分布式的服务。</p><p><img src="/images/uwsgi_1_1.png" alt></p><h1 id="使用uWSGI服务器部署Python-WSGI应用"><a href="#使用uWSGI服务器部署Python-WSGI应用" class="headerlink" title="使用uWSGI服务器部署Python WSGI应用"></a>使用uWSGI服务器部署Python WSGI应用</h1><p>架构图如下：</p><p><img src="/images/uwsgi_1_2.png" alt></p><p>其中APP是支持WSGI协议的APP，例如django应用。</p><p>学习资料参考于：<br><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432012393132788f71e0edad4676a3f76ac7776f3a16000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432012393132788f71e0edad4676a3f76ac7776f3a16000</a><br><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432012745805707cb9f00a484d968c72dbb7cfc90b91000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432012745805707cb9f00a484d968c72dbb7cfc90b91000</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫框架Scrapy学习</title>
      <link href="/2018/02/02/Python%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6Scrapy%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/02/02/Python%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6Scrapy%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Scrapy简介"><a href="#Scrapy简介" class="headerlink" title="Scrapy简介"></a>Scrapy简介</h1><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。其最初是为了页面抓取（更确切来说，网络抓取）所设计的， 也可以应用在获取API所返回的数据（例如Amazon Associates Web Services）或者通用的网络爬虫。Scrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持。</p><p>Scrapy的原理结构图如下：</p><p><img src="/images/scrapy_1_1.png" alt></p><p><img src="/images/scrapy_1_2.png" alt></p><p>从上图中，我们可以看到scrapy主要包括如下这些组件：</p><p>（1）引擎Scrapy</p><p>用来处理整个系统的数据流处理，触发事务（框架核心）。</p><p>（2）调度器Scheduler</p><p>用来接受引擎发过来的请求，压入队列中，并在引擎再次请求的时候返回。可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列，由它来决定下一个要抓取的网址是什么，同时去除重复的网址。</p><p>（3）下载器Downloader</p><p>用于下载网页内容，并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)</p><p>（4）爬虫Spiders</p><p>爬虫是主要干活的，用于从特定的网页中提取自己需要的信息，即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面。</p><p>（5）项目管道Pipeline</p><p>负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。</p><p>（6）下载器中间件Downloader Middlewares</p><p>位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。</p><p>（7）爬虫中间件Spider Middlewares</p><p>介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。</p><p>（8）调度中间件Scheduler Middewares</p><p>介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。</p><p>Scrapy运行流程大概如下：</p><p>（1）引擎从调度器中取出一个链接(URL)用于接下来的抓取</p><p>（2）引擎把URL封装成一个请求(Request)传给下载器，下载器把资源下载下来，并封装成应答包(Response)</p><p>（3）爬虫解析Response</p><p>若是解析出实体（Item），则交给实体管道进行进一步的处理。若是解析出的是链接（URL），则把URL交给Scheduler等待抓取。</p><h1 id="Scrapy的安装与配置"><a href="#Scrapy的安装与配置" class="headerlink" title="Scrapy的安装与配置"></a>Scrapy的安装与配置</h1><p>安装依赖和Scrapy列表如下（其实直接执行<code>pip install scrapy</code>命令，提示有依赖缺失后，在逐一解决即可）：</p><p><img src="/images/scrapy_1_3.png" alt></p><h1 id="使用scrapy框架生成爬虫工程目录结构"><a href="#使用scrapy框架生成爬虫工程目录结构" class="headerlink" title="使用scrapy框架生成爬虫工程目录结构"></a>使用scrapy框架生成爬虫工程目录结构</h1><p>执行<code>scrapy startproject testscrapy</code>命令即可创建爬虫工程的基本目录结构，如下：</p><p><img src="/images/scrapy_1_4.png" alt></p><p>其中，</p><pre><code>scrapy.cfg   #项目的配置信息，主要为Scrapy命令行工具提供一个基础的配置信息。（真正爬虫相关的配置信息在settings.py文件中）items.py     #设置数据存储模板，用于结构化数据，如：Django的Modelpipelines    #数据处理行为，如：一般结构化的数据持久化settings.py  #配置文件，如：递归的层数、并发数，延迟下载等spiders      #爬虫目录，如：创建文件，编写爬虫规则</code></pre><h1 id="基于Scrapy编写自己的爬虫"><a href="#基于Scrapy编写自己的爬虫" class="headerlink" title="基于Scrapy编写自己的爬虫"></a>基于Scrapy编写自己的爬虫</h1><p>前提声明，以爬取某XXOO网站为例说明：</p><p>（1）新建Item，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JianDanItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    image_urls = scrapy.Field()</span><br><span class="line">    images = scrapy.Field()</span><br><span class="line">    dom_title = scrapy.Field()</span><br></pre></td></tr></table></figure><p>（2）在spiders目录新建一个xxxspider.py文件，定义一个继承自scrapy.Spider的类，代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> jiandan_spider.items <span class="keyword">import</span> JianDanItem</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JianDanSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'jiandan'</span></span><br><span class="line">    allowed_domains = []</span><br><span class="line">    start_urls = [<span class="string">"http://jiandan.net/ooxx/"</span>;]   <span class="comment">#定义爬虫起始url列表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = JianDanItem()</span><br><span class="line">        item[<span class="string">'image_urls'</span>] = response.xpath(<span class="string">'//img//@src'</span>).extract()   <span class="comment">#解析页面上所有的img元素中图片链接地址</span></span><br><span class="line">        <span class="keyword">yield</span> item    <span class="comment">#交给scrapy engine，然后scrapy engine会交由Pipeline来处理</span></span><br><span class="line"></span><br><span class="line">        new_url =  response.xpath(<span class="string">'//a//@href'</span>).extract()[<span class="number">-2</span>]   <span class="comment">#抽取页面下一页的链接地址</span></span><br><span class="line">        <span class="comment">#创建Request对象且回调为self.parse，scrapy engine收到后，会将其交给调度器Scheduler模块，等待被抓取</span></span><br><span class="line">        <span class="keyword">if</span> new_url: <span class="keyword">yield</span> scrapy.Request(new_url,callback=self.parse)</span><br></pre></td></tr></table></figure><p>（3）编写pipeline用来保存图片</p><p>编写一个继承自ImagesPipeline的自定义图片保存的Pipeline，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JianDanImagesPipeline</span><span class="params">(ImagesPipeline)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_media_requests</span><span class="params">(self, item, info)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> image_url <span class="keyword">in</span> item[<span class="string">'image_urls'</span>]:</span><br><span class="line">            <span class="keyword">if</span> image_url.startswith(<span class="string">'//'</span>): image_url = <span class="string">'http:'</span> + image_url</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(image_url, meta=&#123;<span class="string">'dom_title'</span>: item[<span class="string">'dom_title'</span>]&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">file_path</span><span class="params">(self, request, response=None, info=None)</span>:</span></span><br><span class="line">        <span class="string">"""修改图片的默认保存路径</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dom_title = request.meta[<span class="string">'dom_title'</span>].encode(<span class="string">'utf-8'</span>)</span><br><span class="line">        image_guid = request.url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">        relative_path = <span class="string">'full/&#123;&#125;/&#123;&#125;'</span>.format(dom_title, image_guid)</span><br><span class="line">        <span class="keyword">return</span> relative_path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">item_completed</span><span class="params">(self, results, item, info)</span>:</span></span><br><span class="line">        image_paths = [x[<span class="string">'path'</span>] <span class="keyword">for</span> ok, x <span class="keyword">in</span> results <span class="keyword">if</span> ok]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> image_paths:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">"Item contains no images"</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p>（4）在settings.py中做一些基本的配置</p><p>常用的配置有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ROBOTSTXT_OBEY = False     //是否遵循robot.txt协议</span><br><span class="line">ITEM_PIPELINES = &#123;         //设置Pipeline</span><br><span class="line">    &apos;jiandan_spider.pipelines.JianDanImagesPipeline&apos;: 300,</span><br><span class="line">&#125;</span><br><span class="line">IMAGES_STORE = &apos;images&apos;    //设置图片的保存位置</span><br><span class="line">IMAGES_THUMBS = &#123;          //设置图片缩略图的大小，可不配置</span><br><span class="line">    &apos;small&apos;: (50, 50),</span><br><span class="line">    &apos;big&apos;: (270, 270),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）在项目目录执行<code>scrapy crawl &quot;爬虫名&quot;</code>命令即可启动爬虫。</p><h1 id="TODOLIST"><a href="#TODOLIST" class="headerlink" title="TODOLIST"></a>TODOLIST</h1><p>（1）使用Scrapy搭建分布式爬虫集群？</p><p>学习文档参考于：<br><a href="http://blog.csdn.net/u012150179/article/category/2345511" target="_blank" rel="noopener">http://blog.csdn.net/u012150179/article/category/2345511</a><br><a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/tutorial.html" target="_blank" rel="noopener">http://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/tutorial.html</a><br>Scrapy中文文档：<a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/index.html" target="_blank" rel="noopener">http://scrapy-chs.readthedocs.io/zh_CN/0.24/index.html</a><br><a href="http://www.cnblogs.com/qiyeboy/p/5449266.html" target="_blank" rel="noopener">http://www.cnblogs.com/qiyeboy/p/5449266.html</a><br>xpath教程：<a href="http://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/xpath/index.asp</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python网页爬虫（requests | BeautifulSoup）学习</title>
      <link href="/2018/02/02/Python%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB%EF%BC%88requests-BeautifulSoup%EF%BC%89%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/02/02/Python%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB%EF%BC%88requests-BeautifulSoup%EF%BC%89%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="网页抓取器"><a href="#网页抓取器" class="headerlink" title="网页抓取器"></a>网页抓取器</h1><p>（1）Python官方支持库</p><p>Python原生的http库，如urllib，urllib2，urllib3等。需要注意的是，urllib和urllib2是相互独立的模块，不是升级版的意思。如下为urllib/urllib2的简单使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">urllib.urlencode(&#123;<span class="string">'param1'</span>: <span class="string">'hello'</span>, <span class="string">'param2'</span>: <span class="string">'world'</span>&#125;)</span><br><span class="line">response = urllib2.urlopen(url)</span><br></pre></td></tr></table></figure><p>（2）第三方库requests</p><p>requests是非常好用的第三方http请求库，其API设计的比较简单易用，建议后面就使用requests库就好了。如下为requests库的简单使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get()</span><br><span class="line"><span class="comment">#response = requests.post()</span></span><br><span class="line"><span class="comment">#response = requests.delete()</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">response.headers   <span class="comment">#获取响应头</span></span><br><span class="line">response.text      <span class="comment">#获取响应内容的文本格式</span></span><br><span class="line">response.content   <span class="comment">#获取响应内容的二进制形式，若要获取图片、音乐之类的元素，需要使用response.content哦</span></span><br><span class="line">response.json      <span class="comment">#直接获取json格式的响应内容</span></span><br><span class="line">response.status_ok <span class="comment">#获取响应状态码</span></span><br><span class="line">response.reason    <span class="comment">#获取响应请求状态码的含义</span></span><br></pre></td></tr></table></figure><h1 id="网页解析器"><a href="#网页解析器" class="headerlink" title="网页解析器"></a>网页解析器</h1><p>网页解析有如下几种解决方案：</p><p>（1）字符串处理-正则匹配</p><p>（2）Python官方自带库html.parser</p><p>（3）第三方网页解析库BeautifulSoup</p><p>（4）第三方网页解析库lxml</p><p>学习资料参考于：<br><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">http://docs.python-requests.org/zh_CN/latest/user/quickstart.html</a><br><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python网页截屏（selenium+PhantomJS）</title>
      <link href="/2018/02/02/Python%E7%BD%91%E9%A1%B5%E6%88%AA%E5%B1%8F%EF%BC%88selenium-PhantomJS%EF%BC%89/"/>
      <url>/2018/02/02/Python%E7%BD%91%E9%A1%B5%E6%88%AA%E5%B1%8F%EF%BC%88selenium-PhantomJS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="selenium-PhantomJS简介"><a href="#selenium-PhantomJS简介" class="headerlink" title="selenium | PhantomJS简介"></a>selenium | PhantomJS简介</h1><p>PhantomJS是一个基于webkit的没有界面的浏览器，也就是它可以像浏览器解析网页，功能非常强大。selenium是一个web的自动测试工具，可以模拟人的操作，支持市面上几乎所有的主流浏览器（Chrome/FireFox等），同时也支持PhantomJS这种无界面浏览器。</p><p>正是有了PhantomJS这种无界面的浏览器，所以我们可以在Linux字符界面下，截取网页内容并生成图片。</p><h1 id="Linux下使用selenium-PhantomJS截取网页"><a href="#Linux下使用selenium-PhantomJS截取网页" class="headerlink" title="Linux下使用selenium+PhantomJS截取网页"></a>Linux下使用selenium+PhantomJS截取网页</h1><p>（1）安装PhantomJS</p><p>到<code>https://bitbucket.org/ariya/phantomjs/downloads/</code>页面上下载linux下二进制PhantomJS程序，放入/usr/local/bin或配置到环境变量中。</p><p>若是Windows平台，则需要下载windows下的二进制文件，并配置到系统环境变量PATH中。</p><p>备注：在linux平台上不要到<code>http://phantomjs.org</code>上下载，下载下来的二进制文件在执行时会报缺少so库的错误。</p><p>（2）安装selenium</p><p>直接使用<code>pip install selenium</code>安装selenium即可。</p><p>（3）编写截屏程序</p><p>代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.PhantomJS()</span><br><span class="line"><span class="comment">#driver.set_window_size(1024, 768)</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://www.sohu.com'</span>;</span><br><span class="line">driver.get(url)</span><br><span class="line">title = driver.title     <span class="comment">#获取html页面的标题</span></span><br><span class="line">driver.save_screenshot(title + <span class="string">'.png'</span>)  <span class="comment">#将截屏生成为本地png文件</span></span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="https://www.jianshu.com/p/520749be7377" target="_blank" rel="noopener">https://www.jianshu.com/p/520749be7377</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库的一些操作技巧</title>
      <link href="/2018/02/02/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/02/02/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="表记录删除"><a href="#表记录删除" class="headerlink" title="表记录删除"></a>表记录删除</h1><p>在生产环境中，一般来说是不会物理删除数据库表中的一些的记录的，而是进行逻辑删除。比如在表中增加一个tag字段。若<code>tag=1</code>则表示已删除；若<code>tag!=1</code>表示没有被删除。</p><h1 id="mysql中使用-G格式化输出"><a href="#mysql中使用-G格式化输出" class="headerlink" title="mysql中使用\G格式化输出"></a>mysql中使用\G格式化输出</h1><p>使用mysql的client工具，如<code>select * from user_msg limit 2\G;</code>，可以以如下的格式输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user_msg limit 2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">         uid: 1</span><br><span class="line">   today_msg: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">         uid: 2</span><br><span class="line">   today_msg: 0</span><br><span class="line">2 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure><h1 id="MySQL的auto-rehash功能"><a href="#MySQL的auto-rehash功能" class="headerlink" title="MySQL的auto-rehash功能"></a>MySQL的auto-rehash功能</h1><p>MySQL配置文件中有个auto-rehash的选项，auto-rehash是自动补全的意思，当我们在MySQL的命令行中输入SQL语句时，按TAB键就会帮我们自动补全表名或字段名。这个功能就像我们在Linux命令行里输入命令的时候，使用TAB键补全命令就好了。</p><p>但是，这个功能在有些情况下会出现一些弊端，当我们打开数据库，即<code>use 数据库名;</code>时，会预读数据库信息。有时候由于数据库太大或者表数量太多，预读数据库信息将非常慢，很容易就卡住。在进入数据库时加<code>-A</code>选项可以解决这个问题，即执行<code>mysql -u root -p -A</code>命令即可。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL管理员操作手册</title>
      <link href="/2018/02/02/MySQL%E7%AE%A1%E7%90%86%E5%91%98%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
      <url>/2018/02/02/MySQL%E7%AE%A1%E7%90%86%E5%91%98%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL登录"><a href="#MySQL登录" class="headerlink" title="MySQL登录"></a>MySQL登录</h1><p>（1）利用TCP/IP连接，客户端和服务端可以在不同的机器上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -h12.45.23.41 -uwahaha -p</span><br><span class="line">mysql -h12.45.23.41 -P3345 -uwahaha -p   <span class="comment">#非标准的3306端口</span></span><br></pre></td></tr></table></figure><p>然后输入用户密码，若无密码，直接回车即可。</p><p>（2）利用Unix域套接字来连接，客户端和服务端要在同一台机器上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -S /var/lib/mysql/mysql.sock -uroot -p</span><br></pre></td></tr></table></figure><h1 id="查看基础信息"><a href="#查看基础信息" class="headerlink" title="查看基础信息"></a>查看基础信息</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;                         <span class="comment">/*查看所有数据库*/</span></span><br><span class="line"><span class="keyword">use</span> db_name;                            <span class="comment">/*切换到数据库db_name*/</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;                            <span class="comment">/*查看某个数据库包含哪些数据库表*/</span></span><br><span class="line">desc table_name;                        <span class="comment">/*查看数据库表table_name的字段信息*/</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> table_name;           <span class="comment">/*同desc table_name*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> table_name;        <span class="comment">/*查询指定表中总共有多少条记录*/</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table_name;             <span class="comment">/*查看指定表的index信息*/</span></span><br><span class="line"><span class="keyword">select</span> host, <span class="keyword">user</span>, <span class="keyword">password</span> <span class="keyword">from</span> <span class="keyword">user</span>;  <span class="comment">/*查看mysql中所有的用户信息*/</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;                       <span class="comment">/*当我们修改完mysql的用户及授权信息后，一般需要执行该命令。执行后mysql会重新载入授权表，从而生效最新的权限变更*/</span></span><br></pre></td></tr></table></figure><h1 id="查看MySQL的版本信息"><a href="#查看MySQL的版本信息" class="headerlink" title="查看MySQL的版本信息"></a>查看MySQL的版本信息</h1><p>有如下几种方法：</p><p>（1）直接执行<code>mysql -V</code></p><p>（2）执行<code>mysqladmin -V</code></p><p>（3）登录MySQL后，在命令提示符上执行<code>status</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; status;</span><br></pre></td></tr></table></figure><p>（4）在MySQL的命令提示符中使用version函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select version();</span><br></pre></td></tr></table></figure><h1 id="获取数据库元数据"><a href="#获取数据库元数据" class="headerlink" title="获取数据库元数据"></a>获取数据库元数据</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">version</span>();                     <span class="comment">/*获取mysql服务器版本信息*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">database</span>();                    <span class="comment">/*查看当前使用的数据库*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>();                        <span class="comment">/*查看当前登录账户*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">current_user</span>();                <span class="comment">/*查看当前登录账户*/</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span>;                          <span class="comment">/*查看mysql服务器的状态*/</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span>;                       <span class="comment">/*查看mysql服务器的配置变量*/</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%sql_log_bin%'</span>;  <span class="comment">/*查看mysql服务器中包含了某关键字的变量*/</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">warnings</span>;                        <span class="comment">/*查看mysql中执行sql时的错误信息*/</span></span><br></pre></td></tr></table></figure><h1 id="一些常用的操作命令"><a href="#一些常用的操作命令" class="headerlink" title="一些常用的操作命令"></a>一些常用的操作命令</h1><p>（1）数据库的定义和删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="string">`some_database`</span>;            <span class="comment">/*删除some_database数据库*/</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> <span class="string">`some_database`</span>;  <span class="comment">/*若some_database存在，则删除some_database数据库*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="string">`some_database`</span>;          <span class="comment">/*创建some_database数据库*/</span></span><br></pre></td></tr></table></figure><p>（2）数据表的定义和删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="string">`some_table`</span>;                  <span class="comment">/*删除指定表*/</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> <span class="string">`some_table`</span>;        <span class="comment">/*若指定表存在，则删除之*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="string">`some_table`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`author`</span> <span class="built_in">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`date_t`</span> <span class="built_in">DATE</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> ( <span class="string">`id`</span> )</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;     <span class="comment">/*创建表结构*/</span></span><br></pre></td></tr></table></figure><p>（3）数据表的名称或字段修改（alter）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> testalter_tbl <span class="keyword">drop</span> age;                  <span class="comment">/*删除字段age*/</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> testalter_tbl <span class="keyword">add</span> age <span class="built_in">INT</span>;               <span class="comment">/*增加字段age，数据类型为整型*/</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> testalter_tbl <span class="keyword">modify</span> <span class="keyword">name</span> <span class="built_in">CHAR</span>(<span class="number">10</span>);      <span class="comment">/*修改字段name的数据类型为char(10)*/</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> testalter_tbl <span class="keyword">change</span> age age_fd <span class="built_in">BIGINT</span>;  <span class="comment">/*将字段名age修改为age_fd*/</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> testalter_tbl <span class="keyword">alter</span> age <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="number">29</span>;  <span class="comment">/*修改字段age的默认值为29*/</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> testalter_tbl <span class="keyword">ENGINE</span> = MYISAM;           <span class="comment">/*修改数据库表的存储引擎*/</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> testalter_tbl <span class="keyword">rename</span> <span class="keyword">to</span> alter_tbl;       <span class="comment">/*修改数据库表的名称*/</span></span><br></pre></td></tr></table></figure><p>（4）插入记录（insert）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> runoob_tbl (title, author, date_t) <span class="keyword">values</span> (<span class="string">"学习MySQL"</span>, <span class="string">"wahaha"</span>, <span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure><p>（5）数据查询（select）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> some_table;                              <span class="comment">/*查询数据库表中所有内容*/</span></span><br><span class="line"><span class="keyword">select</span> column_name_1, column_name_2 <span class="keyword">from</span> some_table;   <span class="comment">/*查询数据库表中指定列*/</span></span><br><span class="line"><span class="keyword">select</span> a.runoob_id, a.runoob_author, b.runoob_count <span class="keyword">from</span> runoob_tbl a, tcount_tbl b <span class="keyword">where</span> a.runoob_author = b.runoob_author;   <span class="comment">/*多表查询*/</span></span><br></pre></td></tr></table></figure><p>（6）更新记录（update）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> some_table <span class="keyword">set</span> title=<span class="string">'学习MySQL'</span> <span class="keyword">where</span> author=<span class="string">'wahaha'</span>;</span><br></pre></td></tr></table></figure><p>（7）删除记录（delete）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> some_table <span class="keyword">where</span> author=<span class="string">'wahaha'</span>; <span class="comment">/*按条件删除记录*/</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> some_table;     <span class="comment">/*删除表中所有记录*/</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> some_table;  <span class="comment">/*删除表中所有记录*/</span></span><br></pre></td></tr></table></figure><p>delete和truncate语句都可以删除表中记录。delete配合where子句可以删除符合条件的记录，但是truncate只能删除表中所有的记录。delete删除记录的操作是可回滚的，而truncate删除的记录是不可以回滚的。truncate删除记录的效率要高于delete语句。delete和truncate语句都不删除表的定义，但是drop table语句会删除表的定义。</p><p>如果一个表中有自增字段，使用<code>truncate table some_table</code>和没有where子句的<code>delete from some_table</code>删除所有记录后，这个自增字段将起始值恢复成1。如果你不想这样做的话，可以在delete语句中加上永真的where子句，如<code>where 1</code>或<code>where true</code>。</p><p>（8）where子句</p><p>where子句用于有条件地从表中选取数据。where子句也可以运用于SQL的select/delete/update命令。另外可以使用and或or关键字指定一个或多个条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> some_table <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">'12'</span> <span class="keyword">and</span> author=<span class="string">'wahaha'</span>;</span><br></pre></td></tr></table></figure><p>（9）where子句中嵌套like子句</p><p>SQL like子句中使用百分号<code>%</code>字符来表示任意字符，类似于UNIX或正则表达式中的星号<code>*</code>。 如果没有使用百分号<code>%</code>，like子句与等号<code>=</code>的效果是一样的。如下为查找author字段以haha为结尾的所有记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> some_table <span class="keyword">where</span> author <span class="keyword">like</span> <span class="string">'%haha'</span>;</span><br></pre></td></tr></table></figure><p>（10）对结果集排序order by子句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> some_table <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> some_table <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">asc</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> some_table <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>备注：asc表示将查询结果集按升序排列，desc表示将查询结果集按降序排列。如果order by子句不指明asc或desc，那默认的是asc，即升序排列。</p><p>（11）分组group by子句</p><p>mysql中可使用group by子句对记录行进行分组。select子句中的列名必须为分组列或列函数。列函数对于group by子句定义的每个组各返回一个结果。举例来说：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>，<span class="keyword">count</span>(*) <span class="keyword">from</span> employee_tbl <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br><span class="line"><span class="keyword">select</span> dept, <span class="keyword">max</span>(salary) <span class="keyword">as</span> maximum <span class="keyword">from</span> staff <span class="keyword">group</span> <span class="keyword">by</span> dept;</span><br></pre></td></tr></table></figure><p>（12）limit | offset子句</p><pre><code>select _column,_column from _table [where Clause] [limit N][offset M]</code></pre><p>说明如下：</p><pre><code>limit N表示返回前N条记录offset M表示跳过M条记录，从第M条记录开始limit N offset M表示从第M条记录开始, 返回N条记录limit M, N等价于limit N offset M</code></pre><p><code>limit | offset</code>一个重要用途就是实现MySQL查询分页功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> _table <span class="keyword">limit</span> (page_number<span class="number">-1</span>)*lines_perpage, lines_perpage;       //写法一</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> _table <span class="keyword">limit</span> lines_perpage <span class="keyword">offset</span> (page_number<span class="number">-1</span>)*lines_perpage; //写法二</span><br></pre></td></tr></table></figure><h1 id="MySQL-NULL值处理"><a href="#MySQL-NULL值处理" class="headerlink" title="MySQL NULL值处理"></a>MySQL NULL值处理</h1><p>mysql使用select命令及where子句来读取数据表中的数据，但是当提供的查询条件字段为NULL时，该命令可能就无法正常工作。 为了处理这种情况，mysql提供了两种运算符：</p><pre><code>IS NULL       #当列的值是NULL，此运算符返回trueIS NOT NULL   #当列的值不为NULL，此运算符返回true</code></pre><p>举例来说，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> runoob_test_tbl <span class="keyword">where</span> runoob_count <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> runoob_test_tbl <span class="keyword">where</span> runoob_count <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> runoob_test_tbl <span class="keyword">where</span> runoob_count = <span class="literal">NULL</span>;  <span class="comment">/*这种是没用的，需要使用IS NULL*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> runoob_test_tbl <span class="keyword">where</span> runoob_count != <span class="literal">NULL</span>; <span class="comment">/*这种是没用的，需要使用IS NOT NULL*/</span></span><br></pre></td></tr></table></figure><h1 id="MySQL中使用正则表达式"><a href="#MySQL中使用正则表达式" class="headerlink" title="MySQL中使用正则表达式"></a>MySQL中使用正则表达式</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> person_tbl <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'^st'</span>; <span class="comment">/*查询name字段以st开头的记录*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> person_tbl <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'ok$'</span>; <span class="comment">/*查询name字段以ok结尾的记录*/</span></span><br></pre></td></tr></table></figure><h1 id="SQL文件的执行方式"><a href="#SQL文件的执行方式" class="headerlink" title="SQL文件的执行方式"></a>SQL文件的执行方式</h1><p>可以将sql语句编写到<code>*.sql</code>文件中，执行方法有如下几种：</p><p>（1）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysql -h11.23.43.34 -uwahaha -phehe123 &lt; *.sql</span><br></pre></td></tr></table></figure><p>或直接将sql语句写入终端中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h11.23.43.34 -uwahaha -p -Ddatabase_name -e <span class="string">"select * from some_table"</span></span><br></pre></td></tr></table></figure><p>（2）客户端连接后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;source sql文件的绝对路径</span><br></pre></td></tr></table></figure><p>（3）客户端连接后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;/. sql文件的绝对路径</span><br></pre></td></tr></table></figure><h1 id="perror工具的使用"><a href="#perror工具的使用" class="headerlink" title="perror工具的使用"></a>perror工具的使用</h1><p>当使用mysql过程中出现错误，返回了错误码error_code，可以使用mysql安装的bin目录下perror工具来查看具体错误的含义。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[work@hostname bin]$ ./perror 111</span><br><span class="line">OS error code 111:  Connection refused</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从复制replication管理员手册</title>
      <link href="/2018/02/02/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6replication%E7%AE%A1%E7%90%86%E5%91%98%E6%89%8B%E5%86%8C/"/>
      <url>/2018/02/02/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6replication%E7%AE%A1%E7%90%86%E5%91%98%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="查看master库的binlog是否开启"><a href="#查看master库的binlog是否开启" class="headerlink" title="查看master库的binlog是否开启"></a>查看master库的binlog是否开启</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'log_%'</span>;</span><br></pre></td></tr></table></figure><h1 id="查看master的所有binlog文件的名称和大小"><a href="#查看master的所有binlog文件的名称和大小" class="headerlink" title="查看master的所有binlog文件的名称和大小"></a>查看master的所有binlog文件的名称和大小</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">logs</span>; </span><br><span class="line"><span class="keyword">show</span> <span class="built_in">binary</span> <span class="keyword">logs</span>;   <span class="comment">--同show master logs一样的效果</span></span><br></pre></td></tr></table></figure><p><img src="/images/mysqlrep_2_1.png" alt></p><h1 id="查看master状态，即最后-最新-一个binlog日志文件的文件名称，及其最后一个操作事件的End-Position值"><a href="#查看master状态，即最后-最新-一个binlog日志文件的文件名称，及其最后一个操作事件的End-Position值" class="headerlink" title="查看master状态，即最后(最新)一个binlog日志文件的文件名称，及其最后一个操作事件的End Position值"></a>查看master状态，即最后(最新)一个binlog日志文件的文件名称，及其最后一个操作事件的End Position值</h1><p>在主库上执行如下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/mysqlrep_2_2.png" alt></p><h1 id="查看主库master的所有从库"><a href="#查看主库master的所有从库" class="headerlink" title="查看主库master的所有从库"></a>查看主库master的所有从库</h1><p>在主库master上执行如下命令，可以查看master的所有从库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.processlist <span class="keyword">as</span> p <span class="keyword">where</span> p.command = <span class="string">'Binlog Dump'</span>;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">hosts</span>;</span><br></pre></td></tr></table></figure><h1 id="刷新binlog日志，自此刻开始产生一个新编号的binlog日志文件"><a href="#刷新binlog日志，自此刻开始产生一个新编号的binlog日志文件" class="headerlink" title="刷新binlog日志，自此刻开始产生一个新编号的binlog日志文件"></a>刷新binlog日志，自此刻开始产生一个新编号的binlog日志文件</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">logs</span>;</span><br></pre></td></tr></table></figure><h1 id="重置（清空）所有binlog日志"><a href="#重置（清空）所有binlog日志" class="headerlink" title="重置（清空）所有binlog日志"></a>重置（清空）所有binlog日志</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reset</span> <span class="keyword">master</span>;</span><br></pre></td></tr></table></figure><h1 id="查看当前有哪些线程在运行，排查有问题的操作动作"><a href="#查看当前有哪些线程在运行，排查有问题的操作动作" class="headerlink" title="查看当前有哪些线程在运行，排查有问题的操作动作"></a>查看当前有哪些线程在运行，排查有问题的操作动作</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">full</span> <span class="keyword">processlist</span>;   <span class="comment">--加上full选项后，可以在Info字段查看完成的sql语句，否则只显示前100个字符</span></span><br></pre></td></tr></table></figure><p><img src="/images/mysqlrep_2_3.png" alt></p><p>如下为各列的含义和用途：</p><pre><code>id       #一个标识，并非操作系统中的线程ID哦，你要kill一个语句的时候很有用user     #显示单前用户，如果不是root，这个命令就只显示你权限范围内的sql语句host     #显示这个语句是从哪个ip的哪个端口上发出的db       #显示这个进程目前连接的是哪个数据库command  #显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接 （connect）time     #此这个状态持续的时间，单位是秒state    #显示使用当前连接的sql语句的状态info     #显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据</code></pre><p>备注：我们可以执行命令<code>mysqladmin processlist</code>或直接查询<code>information_schema.processlist</code>表来查看同样的内容。</p><h1 id="使用show-binlog-events命令来读取并解析binlog日志"><a href="#使用show-binlog-events命令来读取并解析binlog日志" class="headerlink" title="使用show binlog events命令来读取并解析binlog日志"></a>使用show binlog events命令来读取并解析binlog日志</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span>\G;    <span class="comment">--查询并解析第一个(最早)的binlog日志内容</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">'mysql-bin.000021'</span>\G;    <span class="comment">--指定查询mysql-bin.000021这个binlog文件的内容</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">'mysql-bin.000021'</span> <span class="keyword">from</span> <span class="number">8224</span>\G; <span class="comment">--指定查询mysql-bin.000021这个binlog文件，从8224这个pos点开始查看</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">'mysql-bin.000021'</span> <span class="keyword">from</span> <span class="number">8224</span> <span class="keyword">limit</span> <span class="number">10</span>\G;   <span class="comment">--指定查询mysql-bin.000021这个binlog文件，从8224这个pos点开始查起，查询10条</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">'mysql-bin.000021'</span> <span class="keyword">from</span> <span class="number">8224</span> <span class="keyword">limit</span> <span class="number">2</span>,<span class="number">10</span>\G;    <span class="comment">--指定查询mysql-bin.000021这个binlog文件，从8224这个pos点开始查起，偏移2行，查询10条</span></span><br></pre></td></tr></table></figure><p>举例来说，</p><p><img src="/images/mysqlrep_2_4.png" alt></p><p>Pos:204,End_log_pos:365表示，该event是记录在mysql-bin.000001文件的第204字节和第365字节之间。</p><h1 id="使用mysqlbinlog-path-to-mysql-binlog-file工具来读取并解析binlog日志"><a href="#使用mysqlbinlog-path-to-mysql-binlog-file工具来读取并解析binlog日志" class="headerlink" title="使用mysqlbinlog /path/to/mysql-binlog-file工具来读取并解析binlog日志"></a>使用mysqlbinlog /path/to/mysql-binlog-file工具来读取并解析binlog日志</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog /var/lib/mysql/mysql-bin.000001</span><br></pre></td></tr></table></figure><h1 id="通过show-slave-status命令查看从库的同步状态"><a href="#通过show-slave-status命令查看从库的同步状态" class="headerlink" title="通过show slave status命令查看从库的同步状态"></a>通过show slave status命令查看从库的同步状态</h1><p>在slave节点上执行如下命令，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>\G;</span><br></pre></td></tr></table></figure><p><img src="/images/mysqlrep_2_5.png" alt></p><p>如下为各字段的含义：</p><pre><code>Slave_IO_State         #Slave IO线程的执行状态Master_User            #被用于连接主服务器的当前用户Master_Port            #当前的主服务器接口Connect_Retry          #--master-connect-retry选项的当前值Master_Log_File        #Slave I/O线程当前正在读取的主服务器二进制日志文件的名称Read_Master_Log_Pos    #在当前的主服务器二进制日志中，Slave I/O线程已经读取的位置Relay_Log_File         #Slave SQL线程当前正在读取和执行的中继日志relaylog文件的名称Relay_Log_Pos          #在当前的中继日志relaylog中，Slave SQL线程已读取和执行的位置Relay_Master_Log_File  #由SQL线程执行的包含多数近期事件的主服务器二进制日志文件的名称Slave_IO_Running       #Slave I/O线程是否被启动并成功地连接到主服务器上（状态信息为Yes/No）Slave_SQL_Running      #Slave SQL线程是否被启动（状态信息为Yes/No）Replicate_Do_DB        #使用--replicate-do-db选项指定的需要同步的数据库名称Replicate_Ignore_DB    #使用--replicate-ignore-db选项指定不需要同步的数据库名称Replicate_Do_Table,Replicate_Ignore_Table,Replicate_Wild_Do_Table,Replicate_Wild_Ignore_Table  #使用--replicate-do-table,--replicate-ignore-table,--replicate-wild-do-table和--replicate-wild-ignore_table选项指定的需要同步或不需要同步的数据库表名称Last_Errno,Last_Error  #被多数最近被执行的查询返回的错误数量和错误消息。错误数量为0并且消息为空字符串意味着“没有错误”。如果Last_Error值不是空值，它也会在从属服务器的错误日志中作为消息显示Relay_Log_Space        #所有原有的中继日志结合起来的总大小Seconds_Behind_Master  #本字段是Slave数据库实例“落后”Master数据库多少的一个指示（即延迟，单位为秒）</code></pre><p>备注：在日常MySQL数据运维中，我们需要判断主从复制的状态是否正常。通常来说，只需要Slave_IO_Running参数和Slave_SQL_Running参数都为Yes的情况下，并且Seconds_Behind_Master延迟小于一定数值的时候，我们就可以认定mysql主从是同步的。</p><p>另外，对于MySQL 5.7+及MariaDB来说，它们支持“多源复制”，也即是“多主库对应一个从库”的复制结构，那么对于slave库来说，同时会从多个主库上复制数据，也即有多个Slave IO线程和SQL线程，那么直接执行<code>show slave status</code>会返回为空，此时可以执行如下命令来查看slave的同步状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">all</span> slaves <span class="keyword">status</span> \G;      <span class="comment">--查看所有slave的复制状态，也是在Slave节点上执行</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="string">'xx_db'</span> <span class="keyword">status</span> \G;   <span class="comment">--仅查看某一个slave的复制状态，也是在Slave节点上执行</span></span><br></pre></td></tr></table></figure><h1 id="关闭或启动slave-IO线程或SQL线程"><a href="#关闭或启动slave-IO线程或SQL线程" class="headerlink" title="关闭或启动slave IO线程或SQL线程"></a>关闭或启动slave IO线程或SQL线程</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;          <span class="comment">--启动slave</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;           <span class="comment">--停止slave</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span> <span class="string">'xx_db'</span>;  <span class="comment">--对于mysql 5.7+及MariaDB来说，支持“多源复制”，可以启动指定Connection_name的slave</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span> <span class="string">'xx_db'</span>;   <span class="comment">--对于mysql 5.7+及MariaDB来说，支持“多源复制”，可以停止指定Connection_name的slave</span></span><br></pre></td></tr></table></figure><h1 id="删除主从配置的设置"><a href="#删除主从配置的设置" class="headerlink" title="删除主从配置的设置"></a>删除主从配置的设置</h1><p>我们使用<code>change master to</code>命令来配置主从同步关系，假设我们不仅想停止主从同步，而且想删除这种主从同步的关系。可以使用如下的操作的方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;       <span class="comment">--停掉slave的同步</span></span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">slave</span> <span class="keyword">all</span>;  <span class="comment">--删除主从同步的配置，然后执行show slave status将看不到这个同步任务</span></span><br></pre></td></tr></table></figure><p>备注：如果使用<code>reset slave</code>仅仅会重置主从同步的状态，并没有删除主从同步的配置。而<code>reset slave all</code>则会删除主从同步配置。</p><p>对于在MySQL 5.7+及MariaDB来说，支持“多源复制”，我们想停掉某一个slave的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span> <span class="string">'xx_db'</span>;</span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">slave</span> <span class="keyword">all</span> <span class="string">'xx_db'</span>;   <span class="comment">--如果是MariaDB，需要执行reset slave 'xx_db' all命令哦</span></span><br></pre></td></tr></table></figure><h1 id="其他闲杂知识"><a href="#其他闲杂知识" class="headerlink" title="其他闲杂知识"></a>其他闲杂知识</h1><p>在MySQL 5.7+中增加了很多的表，用来对主从同步复制进行管理，即在<code>performance_schema</code>数据库中以<code>replication_</code>开头的一些数据库表。</p><p>学习资料参考于：<br><a href="http://www.cnblogs.com/martinzhang/p/3454358.html" target="_blank" rel="noopener">http://www.cnblogs.com/martinzhang/p/3454358.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从复制replication原理及配置</title>
      <link href="/2018/02/02/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6replication%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/02/02/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6replication%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql二进制日志binlog简介"><a href="#mysql二进制日志binlog简介" class="headerlink" title="mysql二进制日志binlog简介"></a>mysql二进制日志binlog简介</h1><p>mysql二进制日志binlog可以说是MySQL最重要的日志了，它记录了所有的DDL和DML（除了数据查询语句）语句，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。一般来说开启二进制日志大概会有1%的性能损耗（参见MySQL官方中文手册5.1.24版）。</p><p>二进制有两个最重要的使用场景：</p><p>（1）mysql基于binlog的主从复制。</p><p>（2）数据恢复，通过使用mysqlbinlog工具来使恢复数据。</p><p>二进制日志binlog包括两类文件：</p><p>（1）二进制日志索引文件</p><p>文件名后缀为<code>.index</code>，用于记录所有的二进制文件。缺省路径为<code>/var/lib/mysql/mysql-bin.index</code>。</p><p>（2）二进制日志文件</p><p>文件名后缀为<code>.00000*</code>，记录数据库所有的DDL和DML（除了数据查询语句）语句事件。缺省路径为<code>/var/lib/mysql/mysql-bin.000001</code>。</p><h1 id="mysql-binlog日志格式"><a href="#mysql-binlog日志格式" class="headerlink" title="mysql binlog日志格式"></a>mysql binlog日志格式</h1><p>mysql中binlog是二进制日志，它有三种格式，</p><pre><code>STATEMENT格式，该格式是基于sql语句，就是将有变更的sql语句写入到binlog日志中ROW格式，该格式是基于行的，也就是将数据记录修改后的内容直接记录到binlog中MIXED格式，该格式是STATEMENT和ROW的混合使用</code></pre><p>MySQL默认使用基于语句的复制，当基于语句的复制会引发问题的时候就会使用基于行的复制，MySQL会自动进行选择。</p><p>备注：若一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于ROW的binlog日志则要记录一万行的内容，由此造成的开销比较大，且日志量也很大。而基于STATEMENT格式的binlog日志仅仅一条语句就可以了，因此往往基于STATEMENT格式的binlog日志量会比较小。</p><p>另外，可以使用mysqlbinlog工具查看binlog文件的内容，也可以使用编程语言按照binlog的格式去解析binlog数据。</p><h1 id="mysql主从复制的实现方式"><a href="#mysql主从复制的实现方式" class="headerlink" title="mysql主从复制的实现方式"></a>mysql主从复制的实现方式</h1><p>目前来说，mysql主从复制有两种实现方式：</p><p>（1）基于binlog的复制</p><p>针对这三种binlog日志格式，在主从复制或备份还原时，就有三种的复制方式，</p><pre><code>基于SQL语句的复制(statement-based replication, SBR)基于行的复制(row-based replication, RBR)混合模式复制(mixed-based replication, MBR)</code></pre><p>（2）基于事务（GTID）的复制（mysql5.6及以后版本才支持）</p><p>备注：本节如下内容都是基于binlog的复制方式来展开的。基于事务（GTID）的复制的方式以后再研究哦。</p><h1 id="基于binlog的主从复制的原理"><a href="#基于binlog的主从复制的原理" class="headerlink" title="基于binlog的主从复制的原理"></a>基于binlog的主从复制的原理</h1><p>主从同步的原理如下：</p><p><img src="/images/mysqlrep_1_1.png" alt></p><p>同步的过程为：</p><p>（1）主库中的每一个事务在操作数据后，主库会将该操作dump出来，写入到二进制文件binlog中，binlog其实就是一系列的数据库操作内容。</p><p>（2）从库的IO线程连接上主库，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容。</p><p>（3）主库接收到来自从库的IO线程的请求后，负责复制的IO线程会根据请求信息读取日志指定位置之后的日志信息，返回给从库的IO线程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到主库端的binlog文件的名称以及binlog的位置。</p><p>（4）从库的IO线程接收到信息后，将接收到的日志内容依次添加到从库的relay-log文件的最末端，并将读取到的主库的binlog的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉主库“我需要从某个binlog的哪个位置开始往后的日志内容，请发给我”。</p><p>（5）从库的SQL线程检测到relay-log中新增加了内容后，会马上解析relay-log的内容，并将其在从库中回放执行。</p><h1 id="基于binlog的mysql主从复制的配置"><a href="#基于binlog的mysql主从复制的配置" class="headerlink" title="基于binlog的mysql主从复制的配置"></a>基于binlog的mysql主从复制的配置</h1><p>（1）在master节点开启binlog日志，并配置server-id</p><p>在mysql主库的配置文件my.cnf添加如下内容：</p><pre><code>[mysqld]server-id = 1    //全局唯一server-id用来标示mysql主库在主从集群中的位置log_bin = /var/log/mysql/mysql-bin.log     //开启BinaryLog，binlog为/var/log/mysql/mysql-bin.log</code></pre><p>（2）在master端建立复制用户（该用户是slave用来读取master的binlog日志所使用的账户），命令范例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'dba'</span>@<span class="string">'192.168.3.%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'dba'</span>@<span class="string">'192.168.3.%'</span>;</span><br></pre></td></tr></table></figure><p>（3）给slave节点配置server-id</p><p>在mysql从库的配置文件my.cnf添加如下内容：</p><pre><code>[mysqld]server-id = 2    //全局唯一server-id用来标示mysql从库在主从集群中的位置</code></pre><p>备注：从库一般不需要开启记录binlog日志，但是当有其他mysql数据库以该库作为主库来实现主从同步时，那么该库也就需要打开binlog日志。</p><p>（4）配置slave，连接到master</p><p>在master和slave都配置好后，只需要把slave指向master即可。需要在从库上执行<code>change master to</code>命令，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'10.1.6.159'</span>, master_port=<span class="number">3306</span>, master_user=<span class="string">'dba'</span>, master_password=<span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure><p>备注：master_host指定的是master库所在的机器ip，master_user和master_password是第（2）步中在master端建立的复制用户和密码。</p><p>另外，在执行<code>change master to</code>命令时，可以通过配置master_log_file和master_log_pos两个参数，使slave节点从master节点的指定位置开始同步，命令类似如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'192.168.3.100'</span>, master_port=<span class="number">3306</span>, master_user=<span class="string">'dba'</span>, master_password=<span class="string">'123456'</span>, master_log_file=<span class="string">'mysql-bin.000004'</span>, master_log_pos=<span class="number">1687</span>;</span><br></pre></td></tr></table></figure><p>对于Mysql 5.7+及MariaDB来说，支持“多源复制”架构，在从库上使用<code>change master to</code>命令时，需要明确每个Slave IO的名称，执行命令范例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="string">'xx_db'</span> <span class="keyword">to</span> master_host=<span class="string">'10.27.102.202'</span>, master_user=<span class="string">'dba'</span>, master_password=<span class="string">'123456'</span>, master_log_file=<span class="string">'mysql.000006'</span>, master_log_pos=<span class="number">238976927</span>;    <span class="comment">--其中xx_db是“多源复制”中某一个slave IO线程，也就是slave上有多个Slave IO线程，对应多个master，这是给每个slave IO线程起一个名字</span></span><br></pre></td></tr></table></figure><p>（5）启动Slave，也即启动从库的IO线程和SQL线程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure><p>（6）校验复制状态</p><p>在Slave节点上执行<code>show slave status</code>命令查看复制状态。一般情况下，当Slave_IO_Running和Salve_SQL_Running都为YES时，我们才认为主从复制的状态是正常的。</p><h1 id="基于binlog的Mysql主从复制的部分复制配置"><a href="#基于binlog的Mysql主从复制的部分复制配置" class="headerlink" title="基于binlog的Mysql主从复制的部分复制配置"></a>基于binlog的Mysql主从复制的部分复制配置</h1><p>Mysql的主从之间的复制可以对整个数据库实例进行复制，也可以对数据库实例中的某个库或某个表进行复制。部分复制可以通过如下选项参数来控制：</p><p>master端的控制参数有<code>--binlog-do-db/--binlog-ignore-db</code></p><p>slave端的控制参数有<code>--replicate-do-db/--replicate-ignore-db/--replicate-do-table/--replicate-ignore-table/--replicate-wild-do-table/--replicate-wild-ignore-table</code></p><h1 id="MySQL多源复制"><a href="#MySQL多源复制" class="headerlink" title="MySQL多源复制"></a>MySQL多源复制</h1><p>多源复制也就是多mater复制，允许一个slave对应多个master。在MySQL5.7以前，主从复制集群都是“一主多从”的结构，即一个slave只有一个master，一个master可以有多个slave。而在MySQL5.7及以后的版本中，支持一个slave对应多个master的结构。如下为多源复制的应用场景之一：</p><p>当我们需要将跨数据库实例来查询数据时，往往在效率和用户程序实现上比较难，但有了多源复制之后，我们可以将多个mysql数据库中数据同步复制到同一个Slave中，这样通过对Salve数据库实例操作，来达到跨数据库实例操作的目的。</p><h1 id="目前基于主从复制机制中binlog的实时获取和解析来实现数据库“变更抓取”系统的开源项目有："><a href="#目前基于主从复制机制中binlog的实时获取和解析来实现数据库“变更抓取”系统的开源项目有：" class="headerlink" title="目前基于主从复制机制中binlog的实时获取和解析来实现数据库“变更抓取”系统的开源项目有："></a>目前基于主从复制机制中binlog的实时获取和解析来实现数据库“变更抓取”系统的开源项目有：</h1><p>（1）LinkedIn的DataBus项目</p><p>（2）Alibaba的canal项目</p><p>（3）Baidu的Fountain DAS项目（未开源）</p><h1 id="mysql主从复制的闲杂知识"><a href="#mysql主从复制的闲杂知识" class="headerlink" title="mysql主从复制的闲杂知识"></a>mysql主从复制的闲杂知识</h1><p>（1）在MySQL主从复制架构中，读操作可以在所有的服务器上面进行，而写操作只能在主服务器上面进行。主从复制架构虽然给读操作提供了扩展，可如果写操作也比较多的话（多台从服务器还要从主服务器上面同步数据），单主模型的复制中主服务器势必会成为性能瓶颈。</p><p>（2）多线程复制，是指将slave端的复制线程配置成多线程的，这样可以提高主从同步复制数据的效率。</p><p>学习资料参考：<br><a href="http://www.cnblogs.com/fxjwind/archive/2013/03/05/2944864.html" target="_blank" rel="noopener">http://www.cnblogs.com/fxjwind/archive/2013/03/05/2944864.html</a><br><a href="http://highscalability.com/blog/2012/3/19/linkedin-creating-a-low-latency-change-data-capture-system-w.html" target="_blank" rel="noopener">http://highscalability.com/blog/2012/3/19/linkedin-creating-a-low-latency-change-data-capture-system-w.html</a><br><a href="http://www.csdn.net/article/1970-01-01/2814280" target="_blank" rel="noopener">http://www.csdn.net/article/1970-01-01/2814280</a><br><a href="http://blog.csdn.net/mycwq/article/details/17136001" target="_blank" rel="noopener">http://blog.csdn.net/mycwq/article/details/17136001</a><br><a href="http://pangge.blog.51cto.com/6013757/1299028" target="_blank" rel="noopener">http://pangge.blog.51cto.com/6013757/1299028</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的用户和权限控制</title>
      <link href="/2018/02/02/MySQL%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2018/02/02/MySQL%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL的用户管理和权限管理，都体现在如下的六张表中"><a href="#MySQL的用户管理和权限管理，都体现在如下的六张表中" class="headerlink" title="MySQL的用户管理和权限管理，都体现在如下的六张表中"></a>MySQL的用户管理和权限管理，都体现在如下的六张表中</h1><pre><code>mysql.usermysql.dbmysql.hostmysql.tables_privmysql.columns_privmysql.procs_priv</code></pre><h1 id="各种权限表"><a href="#各种权限表" class="headerlink" title="各种权限表"></a>各种权限表</h1><p>（1）user表</p><p>user表是MySQL中最重要的一个权限表，记录允许连接到服务器的账号信息，里面的权限是全局级的。user表的信息有用户列、权限列、安全列和资源控制列。这个表中有Host、User、Password三个字段，如下：</p><pre><code>Host表示远程主机，即MySQL客户端的ip，表示从该Host上用指定的User和Password才可以登录数据库User表示用户名Password表示用户密码</code></pre><p>备注：在不同的Host上使用同一个User来登录数据库，对应的登录密码可以是不一样的。因此，可以认为Host+User唯一对应一个用户哦。</p><p>（2）db表</p><p>db表中存储了用户对某个数据库的操作权限，决定用户能从哪个主机存取哪个数据库。主要反映的是用户对Mysql中哪些db有操作权限。</p><p>（3）host表</p><p>host表中存储了某个主机对某个数据库有什么操作权限。</p><h1 id="创建mysql新用户"><a href="#创建mysql新用户" class="headerlink" title="创建mysql新用户"></a>创建mysql新用户</h1><p>前提声明，如下命令中，10.12.21.23代表的mysql客户端所在的机器，wahaha是用户名，guest123是用户密码。</p><p>新增mysql用户有如下几种方法：</p><p>（1）直接在mysql库中user表中添加记录来创建新用户并授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(host, <span class="keyword">user</span>, <span class="keyword">password</span>, select_priv, insert_priv, update_priv) <span class="keyword">VALUES</span>(<span class="string">'10.12.21.23'</span>, <span class="string">'wahaha'</span>, <span class="keyword">PASSWORD</span>(<span class="string">'guest123'</span>), <span class="string">'Y'</span>, <span class="string">'Y'</span>, <span class="string">'Y'</span>);</span><br></pre></td></tr></table></figure><p>（2）使用grant命令创建新用户并授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'wahaha'</span>@<span class="string">'10.12.21.23'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'guest123'</span>;</span><br></pre></td></tr></table></figure><p>或如下授予部分权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">insert</span>, <span class="keyword">update</span>, <span class="keyword">delete</span>, <span class="keyword">create</span>, <span class="keyword">drop</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'wahaha'</span>@<span class="string">'10.12.21.23'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'guest123'</span>;</span><br></pre></td></tr></table></figure><p>（3）使用create user命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> wahaha <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'guest123'</span>;</span><br></pre></td></tr></table></figure><p>备注：使用<code>create user</code>命令创建用户后，还需要对用户进行授权。</p><h1 id="修改MySQL中用户名密码"><a href="#修改MySQL中用户名密码" class="headerlink" title="修改MySQL中用户名密码"></a>修改MySQL中用户名密码</h1><p>mysql安装后，root账户的密码默认是空，即不需要密码就可以登录。我们可以通过如下几种方法来修改指定用户的登录密码（前提申明，如下命令中，10.12.21.23代表的mysql客户端所在的机器，wahaha是用户名，guest123是用户密码）：</p><p>（1）使用mysqladmin工具（不会用这个）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root password <span class="string">"guest123"</span>;</span><br></pre></td></tr></table></figure><p>上述命令表示将root的密码修改成guest123。</p><p>（2）直接修改MySQL中系统db mysql中user表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mysql -uroot -p</span><br><span class="line">Enter password: 【输入原来的密码】</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user set password=PASSWORD(&quot;guest123&quot;) where user=&apos;wahaha&apos;;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure><p>备注：其中PASSWORD()是mysql的一个内置函数，用来将明文密码转换成暗文。</p><p>（3）使用set命令（这个很赞哦）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> <span class="string">'wahaha'</span>@<span class="string">'10.12.21.23'</span> = <span class="keyword">PASSWORD</span>(<span class="string">'guest123'</span>);</span><br></pre></td></tr></table></figure><h1 id="mysql中常见问题处理"><a href="#mysql中常见问题处理" class="headerlink" title="mysql中常见问题处理"></a>mysql中常见问题处理</h1><p>（1）客户端授权问题</p><p>如果远程主机上client连接MySQL提示“ #1130 - Host ‘localhost’ is not allowed to connect to this MySQL server”表示不允许从当前机器上连接mysql服务器，需要使用GRANT授权，命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> . <span class="keyword">to</span> <span class="string">'wahaha'</span>@<span class="string">'%'</span>;  <span class="comment">--该句中的%表示允许从所有主机上用wahaha用户去连接mysql服务器</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> . <span class="keyword">to</span> <span class="string">'wahaha'</span>@<span class="string">'10.12.21.23'</span>; <span class="comment">--该句表示授权从10.12.21.23主机上使用wahaha用户去连接mysql服务器</span></span><br></pre></td></tr></table></figure><p>备注：</p><p>A）使用grant语句后，记得使用<code>flush privileges</code>命令让其生效</p><p>B）当使用上面的语句授权时，发现wahaha账号的密码被重置了。是不是从不同机器上客户端用同一个账号连接Mysql服务器，使用的密码是不一样的。</p><p>C）部署phpMyAdmin时，需要为部署phpMyAdmin的服务器授权客户端来源权限。</p><p>备注：当修改完mysql的用户及授权信息后，一般需要执行<code>flush privileges</code>命令。执行后mysql会重新载入授权表，从而使最新的权限变更生效。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的备份和还原</title>
      <link href="/2018/02/02/MySQL%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/"/>
      <url>/2018/02/02/MySQL%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h1><p>（1）备份命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -pwahaha --all-database=TRUE &gt; ./all_database.sql    <span class="comment">#导出所有数据库的定义和数据</span></span><br><span class="line">mysqldump -uroot -pwahaha some_database &gt; ./some_database.sql         <span class="comment">#导出指定数据库的定义和数据</span></span><br><span class="line">mysqldump -uroot -pwahaha some_database some_table &gt; ./some_table.sql <span class="comment">#导出指定数据库表的定义和数据</span></span><br></pre></td></tr></table></figure><p>（2）还原命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -pwahaha &lt; ./all_database.sql                 <span class="comment">#还原所有数据库的定义和数据</span></span><br><span class="line">mysql -uroot -pwahaha some_database &lt; ./some_database.sql  <span class="comment">#还原指定数据库的定义和数据</span></span><br><span class="line">mysql -uroot -pwahaha some_database &lt; ./some_table.sql     <span class="comment">#还原指定数据库表的定义和数据</span></span><br></pre></td></tr></table></figure><h1 id="只导出数据库的表结构，不导出数据，可以利用这个复制一个没有数据的空数据库"><a href="#只导出数据库的表结构，不导出数据，可以利用这个复制一个没有数据的空数据库" class="headerlink" title="只导出数据库的表结构，不导出数据，可以利用这个复制一个没有数据的空数据库"></a>只导出数据库的表结构，不导出数据，可以利用这个复制一个没有数据的空数据库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -pwahaha --all-database=TRUE -d &gt; ./all_database.sql    <span class="comment">#只导出所有数据库的定义</span></span><br><span class="line">mysqldump -uroot -pwahaha some_database -d &gt; ./some_database.sql         <span class="comment">#只导出指定数据库的定义</span></span><br><span class="line">mysqldump -uroot -pwahaha some_database some_table -d &gt; ./some_table.sql <span class="comment">#只导出指定数据库表的定义</span></span><br></pre></td></tr></table></figure><p>备注：-d参数表示只dump表结构，不dump数据记录哦。这个很好用哦。</p><h1 id="使用into-outfile子句"><a href="#使用into-outfile子句" class="headerlink" title="使用into outfile子句"></a>使用into outfile子句</h1><p>使用into outfile子句，可以将查询结果，写入到一个文本文件中，文件的格式也可以自定义。然后可以使用脚本语言来处理这个文件哦。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> websites <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'/tmp/output'</span>;</span><br></pre></td></tr></table></figure><p>另外，也可以使用如下方式将查询结果存入文本文件，效果同into outfile，且不需要登录数据库哦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p -Ddbname -e <span class="string">"select * from websites limit 4"</span> &gt; /tmp/output</span><br><span class="line">mysql -uroot -p -e <span class="string">"show databases"</span> &gt; /tmp/output</span><br><span class="line">mysql -uroot -p -Ddbname -e <span class="string">"show tables"</span> &gt; /tmp/output</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL复制表的使用</title>
      <link href="/2018/02/02/MySQL%E5%A4%8D%E5%88%B6%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/02/MySQL%E5%A4%8D%E5%88%B6%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL复制表"><a href="#MySQL复制表" class="headerlink" title="MySQL复制表"></a>MySQL复制表</h1><p>假设数据库中已经有数据库表some_table，现在想要复制出一张新的表，表的结构和some_table一样。如果需要的话，还希望将some_table中的数据拷贝到新数据库表中。我们知道使用mysqldump工具可以将整个数据库导出，但是满足不了上面以表为单位的操作。</p><h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><p>假设现在已经有数据库表websites，现在要复制出名称为websites2的数据表，操作步骤如下：</p><p>（1）复制表的结构</p><p>执行<code>show create table websites \G</code>可以查看已有表的创建命令，如下：</p><p><img src="/images/mysqlreptable_1_1.png" alt></p><p>复制上述命令，修改表名为website2，然后执行该命令，即可以创建出和websites表结构一样的websites2，如下：</p><p><img src="/images/mysqlreptable_1_2.png" alt></p><p>（2）复制表的数据记录</p><p>执行如下命令，将websites中的数据记录复制到表websites2中，如下：</p><p><img src="/images/mysqlreptable_1_3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL临时表的使用</title>
      <link href="/2018/02/02/MySQL%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/02/MySQL%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL临时表"><a href="#MySQL临时表" class="headerlink" title="MySQL临时表"></a>MySQL临时表</h1><p>MySQL临时表在需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。 MySQL临时表是在MySQL 3.23及以后版本中才有的功能，若使用的MySQL版本低于3.23，则无法使用MySQL临时表。</p><h1 id="MySQL临时表的具体使用"><a href="#MySQL临时表的具体使用" class="headerlink" title="MySQL临时表的具体使用"></a>MySQL临时表的具体使用</h1><p>（1）创建临时表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> some_table (</span><br><span class="line">  product_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  total_sales <span class="built_in">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0.00</span>,</span><br><span class="line">  avg_unit_price <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0.00</span>,</span><br><span class="line">  total_units_sold <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>（2）往临时表中插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> info some_table (product_name, total_sales, avg_unit_price, total_units_sold) <span class="keyword">values</span> (<span class="string">'cucumber'</span>, <span class="number">100.25</span>, <span class="number">90</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>（3）从临时表中查询数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> some_table;</span><br></pre></td></tr></table></figure><p>备注：如果退出了当前MySQL会话，再使用select命令来读取原先创建的临时表数据，那会发现数据库中该表已经不存在了，因为在退出MySQL会话时，该临时表已经被销毁了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引index的使用</title>
      <link href="/2018/02/02/MySQL%E7%B4%A2%E5%BC%95index%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/02/MySQL%E7%B4%A2%E5%BC%95index%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>MySQL索引的建立对于mysql的高效运行是很重要的，索引可以大大提高MySQL的检索速度。索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</p><p>需要注意的是，过多的使用索引将会造成滥用，虽然索引能大大提高查询速度，但是却会降低更新表的速度（如对表进行insert、update和delete）。因为更新表时，MySQL不仅要保存数据，还要更新一下索引文件。</p><h1 id="索引的创建、删除及查看"><a href="#索引的创建、删除及查看" class="headerlink" title="索引的创建、删除及查看"></a>索引的创建、删除及查看</h1><p>创建索引的方法有：</p><p>（1）创建普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> some_table(column_name);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> some_table <span class="keyword">add</span> <span class="keyword">index</span> index_name(column_name);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> some_table (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </span><br><span class="line">  username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">  <span class="keyword">index</span> index_name(column_name) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>（2）创建唯一索引</p><p>与普通索引类似，不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> some_table(column_name);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> some_table <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name(column_name);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> some_table (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </span><br><span class="line">  username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">  <span class="keyword">unique</span> <span class="keyword">index</span> index_name(column_name) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>（3）删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> some_index <span class="keyword">on</span> some_table;</span><br></pre></td></tr></table></figure><p>（4）查看指定数据库表上的所有索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> some_table;</span><br></pre></td></tr></table></figure><h1 id="创建索引注意事项"><a href="#创建索引注意事项" class="headerlink" title="创建索引注意事项"></a>创建索引注意事项</h1><p>（1）对where，on，group by，order by等字句中出现的字段上创建索引</p><p>（2）对较小的数据列使用索引，这样会使索引文件更小，同时内存中也可以装载更多的索引键。</p><p>（3）为较长的字符串使用前缀索引。</p><p>（4）不要过多创建索引，除了增加额外的磁盘空间外，对于DML操作的速度影响很大，因为其每增删改一次就得从新建立索引。</p><h1 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h1><p>聚集索引是指数据库表行中数据的物理存储顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相比，聚集索引有着更快的检索速度。</p><p>InnoDB支持聚集索引，而MyISAM不支持聚集索引。MySQL数据表中的自增id字段上就是聚集索引哦。</p><p>学习资料参考于：<br><a href="http://www.runoob.com/mysql/mysql-index.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-index.html</a><br><a href="https://mp.weixin.qq.com/s/tvfieCo_W_pLQwpLofwT9A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/tvfieCo_W_pLQwpLofwT9A</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL变量学习小结</title>
      <link href="/2018/02/02/MySQL%E5%8F%98%E9%87%8F%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/02/02/MySQL%E5%8F%98%E9%87%8F%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL变量简介"><a href="#MySQL变量简介" class="headerlink" title="MySQL变量简介"></a>MySQL变量简介</h1><p>变量实际上用于控制数据库的一些行为和方式的参数。比如我们启动数据库的时候设定多大的内存，使用什么样的隔离级别，日志文件的大小，存放位置等等一系列的东东。当然我们数据库系统启动后，有些变量(参数)也可以通过动态修改来及时调整数据库。这个变量在Oracle里边是通过pfile或者spfile来控制，称之为参数，是一个意思。关于变量几个要点如下：</p><p>（1）变量取值</p><p>有些变量具有默认值，可以在启动时及启动后修改。</p><p>（2）设置范围</p><p>全局与回话级别，全局级别需要super权限，会话级别只影响自身会话。</p><p>（3）设置方法</p><p>启动前可以通过配置文件以及启动选项来修改，启动后通过SET子句来设置。</p><h1 id="MySQL变量的类型"><a href="#MySQL变量的类型" class="headerlink" title="MySQL变量的类型"></a>MySQL变量的类型</h1><p>（1）用户变量</p><p>以”@”开始，形式为”@变量名”。用户变量跟mysql客户端是绑定的，设置的变量，只对当前用户使用的客户端生效。</p><p>（2）全局变量</p><p>定义时，以如下两种形式出现，<code>set GLOBAL 变量名</code>或者<code>set @@global.变量名</code>，对所有客户端生效。只有具有super权限才可以设置全局变量。</p><p>（3）会话变量</p><p>只对连接的客户端有效。</p><p>（4）局部变量</p><p>作用范围在begin到end语句块之间。在该语句块里设置的变量。declare语句专门用于定义局部变量。set语句是设置不同类型的变量，包括会话变量和全局变量。</p><h1 id="MySQL变量的查看和配置"><a href="#MySQL变量的查看和配置" class="headerlink" title="MySQL变量的查看和配置"></a>MySQL变量的查看和配置</h1><p>（1）查看一个全局变量的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@global.sort_buffer_size;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'sort_buffer_size'</span>;</span><br></pre></td></tr></table></figure><p>（2）查看一个session变量的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@sort_buffer_size;</span><br><span class="line"><span class="keyword">select</span> @@session.sort_buffer_size;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">session</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'sort_buffer_size'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'sort_buffer_size'</span>;    <span class="comment">--show variables缺省显示的是session变量</span></span><br></pre></td></tr></table></figure><p>（3）设置一个全局变量的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> sort_buffer_size=<span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">set</span> @@global.sort_buffer_size=<span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p>（4）设置一个session变量的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> sort_buffer_size=<span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">set</span> @@session.sort_buffer_size=<span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">set</span> sort_buffer_size=<span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><h1 id="MySQL变量操作命令举例"><a href="#MySQL变量操作命令举例" class="headerlink" title="MySQL变量操作命令举例"></a>MySQL变量操作命令举例</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%isolation%'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">session</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%isolation%'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%isolation%'</span>;</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://blog.csdn.net/leshami/article/details/39585253" target="_blank" rel="noopener">http://blog.csdn.net/leshami/article/details/39585253</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的基本数据类型</title>
      <link href="/2018/02/02/MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/02/02/MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>MySQL的数据类型有：</p><p>（1）整型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TINYINT   <span class="comment">#占用1Byte</span></span><br><span class="line">SMALLINT  <span class="comment">#占用2Bytes</span></span><br><span class="line">MEDIUMINT <span class="comment">#占用3Bytes</span></span><br><span class="line">INT       <span class="comment">#占用4Bytes</span></span><br><span class="line">BIGINT    <span class="comment">#占用8Bytes</span></span><br></pre></td></tr></table></figure><p>（2）浮点数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FLOAT    <span class="comment">#占用4Bytes</span></span><br><span class="line">DOUBLE   <span class="comment">#占用8Bytes</span></span><br><span class="line">DECIMAL</span><br></pre></td></tr></table></figure><p>（3）字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VARCHAR  <span class="comment">#可变长度的字符串的存储</span></span><br><span class="line">CHAR     <span class="comment">#固定长度的字符串的存储</span></span><br><span class="line">TEXT     <span class="comment">#包括TINYTEXT/TEXT/MEDIUMTEXT/LONGTEXT四种类型</span></span><br><span class="line">BLOB     <span class="comment">#包括TINYBLOB/BLOB/MEDIUMBLOB/LONGBLOB四种类型</span></span><br></pre></td></tr></table></figure><p>备注：VARCHAR存储可变长度的字符串，如VARCHAR(100)，虽然是100，但会根据字符串的实际大小来分配空间。CHAR是存储固定长度字符串的，如CHAR(100)，不管字符串的长度多长，都分配100个Byte。</p><p>（4）日期</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DATETIME   <span class="comment">#占用8Bytes</span></span><br><span class="line">TIMESTAMP  <span class="comment">#占用4Bytes</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的配置</title>
      <link href="/2018/02/02/MySQL%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/02/02/MySQL%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL的配置文件my-cnf"><a href="#MySQL的配置文件my-cnf" class="headerlink" title="MySQL的配置文件my.cnf"></a>MySQL的配置文件my.cnf</h1><p>mysql的配置文件有：</p><pre><code>/etc/my.cnf</code></pre><p>或</p><pre><code>~/.my.cnf</code></pre><p>或</p><pre><code>${mysql安装目录}/etc/my.cnf</code></pre><p>在.cnf配置文件中，分为几个配置组，例如[client]， [mysqld]，[mysqld_safe]等等，分别的作用如下：</p><pre><code>[client]是客户端去加载的。 [mysqld]是mysqld服务器程序加载的[mysqld_safe]是mysqld_safe是启动脚本加载的......</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的安装及启动</title>
      <link href="/2018/02/02/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E5%90%AF%E5%8A%A8/"/>
      <url>/2018/02/02/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><p>安装环境前提声明：</p><pre><code>系统发行版本：Red Hat Enterprise Linux Server release 5.4内核版本：2.6.18数据库版本：mysql-5.6.35cmake版本：cmake-2.8.8</code></pre><p>完整的安装步骤如下：</p><p>（1）下载RPM格式的源码包</p><p>下载地址为：<a href="https://dev.mysql.com/get/Downloads/MySQL-5.6/MySQL-5.6.35-1.rhel5.src.rpm" target="_blank" rel="noopener">MySQL-5.6</a></p><p>（2）解压源码包</p><p>使用<code>rpm -ivh MySQL-5.6.35-1.rhel5.src.rpm</code>解压，解压后的源码tar.gz文件在/usr/src/redhat/SOURCES/目录中。然后将tar.gz文件copy出来，解压到某个用户目录就行了。</p><p>（3）安装cmake工具</p><p>到<code>http://www.cmake.org</code>官网上下载cmake工具，然后使用<code>./configure &amp;&amp; make &amp;&amp; make install</code>安装到系统中</p><p>（4）生成MySQL的makefile文件</p><p>执行如下cmake命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/home/jianzai/mysql \</span><br><span class="line"> -DMYSQL_UNIX_ADDR=/tmp/mysql.sock \</span><br><span class="line"> -DDEFAULT_CHARSET=utf8 \</span><br><span class="line"> -DDEFAULT_COLLATION=utf8_general_ci \</span><br><span class="line"> -DWITH_EXTRA_CHARSETS:STRING=utf8,gbk \</span><br><span class="line"> -DWITH_MYISAM_STORAGE_ENGINE=1 \</span><br><span class="line"> -DWITH_INNOBASE_STORAGE_ENGINE=1 \</span><br><span class="line"> -DWITH_READLINE=1 \</span><br><span class="line"> -DENABLED_LOCAL_INFILE=1 \</span><br><span class="line"> -DMYSQL_DATADIR=/home/jianzai/mysql/data</span><br></pre></td></tr></table></figure><p>其中DCMAKE_INSTALL_PREFIX参数指定mysql的安装位置。</p><p>（5）编译链接安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>（6）使用mysql_install_db脚本初始化数据库<br>执行<code>cd /home/jianzai/mysql &amp;&amp; ./scripts/mysql_install_db</code>命令即可。需要说明mysql_install_db做了如下初始化工作：</p><p>a）用来初始化MySQL的数据目录（data directory）和创建系统表（当data directory和系统表不存在的时候）</p><p>b）用来初始化innodb引擎管理使用的系统表空间（system tablespace）和数据结构（data structure）</p><p>c）在目录中生成Mysql的配置文件my.cnf</p><p>备注：关于mysql_install_db脚本的说明参见<a href="http://blog.chinaunix.net/uid-23284114-id-5520029.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-23284114-id-5520029.html</a><br>mysql_install_db后面也可以带上<code>--user=mysql</code>参数，用来表示使用linux系统中mysql账户来启动mysqld服务进程。</p><p>（7）启动mysql</p><p>a）直接启动方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libexec/mysqld --defaults-file=etc/my.cnf --user=mysql &amp;</span><br></pre></td></tr></table></figure><p>2）安全启动方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/mysqld_safe --defaults-file=etc/my.cnf --user=mysql &amp;</span><br></pre></td></tr></table></figure><p>备注：这里面的user指的是操作系统的账户，表示使用账户名mysql启动mysql daemon进程。不是mysql账户哦。</p><p>（8）使用MySQL客户端登录验证</p><p>值得注意的是，刚安装的MySQL数据库的超级账号root是没有密码的，因此可以直接使用<code>./bin/mysql -h127.0.0.1 -uroot</code>来登录。如果需要从远程主机上登录，则需要授权后才可以。</p><h1 id="YUM安装"><a href="#YUM安装" class="headerlink" title="YUM安装"></a>YUM安装</h1><p>（1）安装</p><p>直接执行命令<code>yum install mysql-server</code>或<code>apt-get install mysql-server</code>即可。</p><p>（2）启动</p><p>直接执行命令<code>/etc/init.d/mysqld start</code>或<code>service mysqld start</code>即可。</p><p>备注：<code>yum install mysql-server</code>不仅会安装mysql服务器，而且会安装mysql客户端等工具。若只想安装mysql客户端而已，可以执行<code>yum install mysql</code>命令即可。另外，在centos7之后，在yum源里面就没有mysql的资源了，可以使用mariadb来代替，即执行<code>yum install mariadb-server mariadb</code>即可。若确实需要在centos7之后版本上安装MySQL，可以改变系统的YUM源（包含了MySQL的）就可以啦。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ELK的日志收集系统业界实践</title>
      <link href="/2018/02/02/%E5%9F%BA%E4%BA%8EELK%E7%9A%84%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F%E4%B8%9A%E7%95%8C%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/02/02/%E5%9F%BA%E4%BA%8EELK%E7%9A%84%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F%E4%B8%9A%E7%95%8C%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="ELK通用架构"><a href="#ELK通用架构" class="headerlink" title="ELK通用架构"></a>ELK通用架构</h1><p><img src="/images/elkpractice_1_1.png" alt></p><h1 id="携程网架构"><a href="#携程网架构" class="headerlink" title="携程网架构"></a>携程网架构</h1><p><img src="/images/elkpractice_1_2.png" alt></p><p>学习资料参考于：<br><a href="http://tech.meituan.com/mt-log-system-arch.html" target="_blank" rel="noopener">http://tech.meituan.com/mt-log-system-arch.html</a><br><a href="http://www.dahouduan.com/2016/10/17/bigdata-filebeat-elasticsearch-kibana-elk/" target="_blank" rel="noopener">http://www.dahouduan.com/2016/10/17/bigdata-filebeat-elasticsearch-kibana-elk/</a></p>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elk实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lucene技术调研</title>
      <link href="/2018/02/02/Lucene%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/02/02/Lucene%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="Lucene简介"><a href="#Lucene简介" class="headerlink" title="Lucene简介"></a>Lucene简介</h1><p>Lucene是一个基于Java的全文信息检索工具包，它不是一个完整的搜索应用程序，而是为你的应用程序提供索引和搜索功能。Lucene目前是Apache Jakarta家族中的一个开源项目。也是目前最为流行的基于Java开源全文检索工具包。</p><p>Lucene最初是由Doug Cutting所撰写的，他是一位资深的全文索引及检索专家，曾经是V-Twin搜索引擎的主要开发者，后来在Excite担任高级系统架构设计师，目前从事于一些互联网底层架构的研究。他贡献出Lucene的目标是为各种中小型应用程序加入全文检索功能。</p><p>备注：综合来说，Lucene工具包完成了索引Index和搜索Search两个功能。</p><h1 id="Lucene工具包的使用"><a href="#Lucene工具包的使用" class="headerlink" title="Lucene工具包的使用"></a>Lucene工具包的使用</h1><p>Lucene能够为文本类型的数据建立索引，所以你只要能把你要索引的数据格式转换为文本格式的，Lucene就能对你的文档进行索引和搜索。比如你要对一些HTML文档、PDF文档进行索引的话你就首先需要把HTML文档和PDF文档转化成文本格式的，然后将转化后的内容交给Lucene进行索引，然后把创建好的索引文件保存到磁盘或者内存中，最后根据用户输入的查询条件在索引文件上进行查询。</p><p>如下为应用程序和Lucene工具包的关系图：</p><p><img src="/images/lucene_1_1.png" alt></p><h1 id="Lucene索引原理"><a href="#Lucene索引原理" class="headerlink" title="Lucene索引原理"></a>Lucene索引原理</h1><p>Lucene建索引时，使用的是倒排索引（inverted index）的结构。倒排索引维护了一个词/短语表，对于这个表中的每个词/短语，都有一个链表描述了有哪些文档包含了这个词/短语。这样在用户输入查询条件的时候，就能非常快的得到搜索结果。</p><h1 id="Lucene开发包介绍"><a href="#Lucene开发包介绍" class="headerlink" title="Lucene开发包介绍"></a>Lucene开发包介绍</h1><p>Lucene软件包的发布形式是一个JAR文件，如下为这个JAR文件中主要的package：</p><p>（1）Package: org.apache.lucene.document</p><p>这个包提供了一些为封装要索引的文档所需要的类，比如Document、Field等。这样，每一个文档最终被封装成了一个Document对象。</p><p>（2）Package: org.apache.lucene.analysis</p><p>这个包主要功能是对文档进行分词，因为文档在建立索引之前必须要进行分词，所以这个包的作用可以看成是为建立索引做准备工作。</p><p>（3）Package: org.apache.lucene.index</p><p>这个包提供了一些类来协助创建索引以及对创建好的索引进行更新。这里面有两个基础的类：IndexWriter和IndexReader，其中IndexWriter是用来创建索引并添加文档到索引中的，IndexReader是用来删除索引中的文档的。</p><p>（4）Package: org.apache.lucene.search</p><p>这个包提供了对在建立好的索引上进行搜索所需要的类。比如IndexSearcher和Hits，IndexSearcher定义了在指定的索引上进行搜索的方法，Hits用来保存搜索得到的结果。</p><h1 id="基于Lucene工具包的开发DEMO"><a href="#基于Lucene工具包的开发DEMO" class="headerlink" title="基于Lucene工具包的开发DEMO"></a>基于Lucene工具包的开发DEMO</h1><p>（1）为计算机中指定的磁盘目录中的所有文件建立索引，然后将新建的索引文件写到磁盘上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TestLucene;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Analyzer;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.analysis.standard.StandardAnalyzer;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This class demonstrate the process of creating index with Lucene</span></span><br><span class="line"><span class="comment">* for text files</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxtFileIndexer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//indexDir is the directory that hosts Lucene's index files</span></span><br><span class="line">        File indexDir = <span class="keyword">new</span> File(<span class="string">"D:\\luceneIndex"</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//dataDir is the directory that hosts the text files that to be indexed</span></span><br><span class="line">        File dataDir = <span class="keyword">new</span> File(<span class="string">"D:\\luceneData"</span>);</span><br><span class="line">        Analyzer luceneAnalyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line">        File[] dataFiles = dataDir.listFiles();</span><br><span class="line">        IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(indexDir, luceneAnalyzer, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">long</span> startTime = <span class="keyword">new</span> Date().getTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataFiles.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dataFiles[i].isFile() &amp;&amp; dataFiles[i].getName().endsWith(<span class="string">".txt"</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Indexing file "</span> + dataFiles[i].getCanonicalPath());</span><br><span class="line">                Document document = <span class="keyword">new</span> Document();</span><br><span class="line">                Reader txtReader = <span class="keyword">new</span> FileReader(dataFiles[i]);</span><br><span class="line">                document.add(Field.Text(<span class="string">"path"</span>, dataFiles[i].getCanonicalPath()));</span><br><span class="line">                document.add(Field.Text(<span class="string">"contents"</span>, txtReader));</span><br><span class="line">                indexWriter.addDocument(document);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        indexWriter.optimize();</span><br><span class="line">        indexWriter.close();</span><br><span class="line">        <span class="keyword">long</span> endTime = <span class="keyword">new</span> Date().getTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"It takes "</span> + (endTime - startTime)</span><br><span class="line">            + <span class="string">" milliseconds to create index for the files in directory "</span></span><br><span class="line">            + dataDir.getPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）基于（1）中建立的索引，来搜索包含指定关键词的文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TestLucene;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.Term;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.Hits;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.TermQuery;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.store.FSDirectory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This class is used to demonstrate the</span></span><br><span class="line"><span class="comment">* process of searching on an existing</span></span><br><span class="line"><span class="comment">* Lucene index</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxtFileSearcher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String queryStr = <span class="string">"lucene"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//This is the directory that hosts the Lucene index</span></span><br><span class="line">        File indexDir = <span class="keyword">new</span> File(<span class="string">"D:\\luceneIndex"</span>);</span><br><span class="line">        FSDirectory directory = FSDirectory.getDirectory(indexDir, <span class="keyword">false</span>);</span><br><span class="line">        IndexSearcher searcher = <span class="keyword">new</span> IndexSearcher(directory);</span><br><span class="line">        <span class="keyword">if</span>(!indexDir.exists()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"The Lucene index is not exist"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Term term = <span class="keyword">new</span> Term(<span class="string">"contents"</span>, queryStr.toLowerCase());</span><br><span class="line">        TermQuery luceneQuery = <span class="keyword">new</span> TermQuery(term);</span><br><span class="line">        Hits hits = searcher.search(luceneQuery);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hits.length(); i++) &#123;</span><br><span class="line">            Document document = hits.doc(i);</span><br><span class="line">            System.out.println(<span class="string">"File: "</span> + document.get(<span class="string">"path"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-lucene1/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-lucene1/</a></p>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lucene </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kibana技术调研</title>
      <link href="/2018/02/02/Kibana%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/02/02/Kibana%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="Kibana简介"><a href="#Kibana简介" class="headerlink" title="Kibana简介"></a>Kibana简介</h1><p>Kibana自带Node.js Web服务器，无需额外代码或额外基础设施。</p><h1 id="Kibana的查询"><a href="#Kibana的查询" class="headerlink" title="Kibana的查询"></a>Kibana的查询</h1><p>在Discover页提交一个搜索，你就可以搜索匹配当前索引模式的索引数据了。可以有两种查询方式：</p><p>（1）直接输入简单的请求字符串，也就是用 Lucene query syntax</p><p>（2）用完整的基于JSON的Elasticsearch Query DSL</p><h1 id="Kibana的配置和安装"><a href="#Kibana的配置和安装" class="headerlink" title="Kibana的配置和安装"></a>Kibana的配置和安装</h1><p>前提声明：本次部署测试使用的是kibana-5.3.0</p><p>（1）在官网上下载二进制部署包，并解压缩</p><p>（2）配置Kibana</p><p>在${KIBANA_HOME}/config/kibana.yml中修改配置，主要配置Kibana要连接的ES集群。Kibana的配置比较简单，参考配置的说明文字修改即可。</p><p>（3）启动Kibana</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./bin/kibana &amp;</span><br></pre></td></tr></table></figure><p>（4）测试Kibana</p><p>使用浏览器打开<a href="http://hostname:5601" target="_blank" rel="noopener">http://hostname:5601</a></p><h1 id="Kibana的常见配置"><a href="#Kibana的常见配置" class="headerlink" title="Kibana的常见配置"></a>Kibana的常见配置</h1><p>（1）elasticsearch.requestTimeout</p><p>设置kibana请求ES的超时时间，超过这个值后kibana直接向用户返回查询超时。默认为30s.</p><h1 id="Kibana搜索实践"><a href="#Kibana搜索实践" class="headerlink" title="Kibana搜索实践"></a>Kibana搜索实践</h1><p>Kibana的搜索框中支持如下格式的搜索语句</p><p>（1）全文搜索</p><p>直接输入关键字：如upstreams或no live upstreams，但是如果有多个关键字，那么会被切词。</p><p>（2）多关键字搜索</p><p>例如，no AND live AND upstreams，这样只有同时包含no、live以及upstreams的关键字的文档才会被搜索到。</p><p>（3）按字段查找</p><p>例如server:mp.i.sohu.com，表示只匹配server字段为mp.i.sohu.com的文档。</p><p>（4）其他的复合查询</p><p>type:http AND http.code:302</p><p>更多Kibana搜索用法参见<a href="https://segmentfault.com/a/1190000002972420" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002972420</a></p>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kibana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch系列（5）_ES集群运维工具</title>
      <link href="/2018/02/02/ElasticSearch%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89-ES%E9%9B%86%E7%BE%A4%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/02/02/ElasticSearch%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89-ES%E9%9B%86%E7%BE%A4%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="ElasticSearch集群管理工具"><a href="#ElasticSearch集群管理工具" class="headerlink" title="ElasticSearch集群管理工具"></a>ElasticSearch集群管理工具</h1><h2 id="elasticsearch-kopf"><a href="#elasticsearch-kopf" class="headerlink" title="elasticsearch-kopf"></a>elasticsearch-kopf</h2><p>elasticsearch-kopf是一个简单的ElasticSearch集群管理工具，使用JavaScript、AngularJS、jQuery以及Bootstrap编写。它是一个开源工具，不是官方ELK Stack中的组件。目前elasticsearch-kopf已经维护，由新的项目cerebro来代替。</p><p>elasticsearch-kopf Github：<a href="https://github.com/lmenezes/elasticsearch-kopf" target="_blank" rel="noopener">https://github.com/lmenezes/elasticsearch-kopf</a></p><h2 id="cerebro"><a href="#cerebro" class="headerlink" title="cerebro"></a>cerebro</h2><p>cerebro是一个ElasticSearch集群管理工具，其不仅实现了elasticsearch-kopf的功能，而且还新增了一些功能。cerebro使用Scala、Play Framework、AngularJS以及Bootstrap编写。cerebro需要JAVA 1.8版本以上的环境运行。</p><p>cerebro Github：<a href="https://github.com/lmenezes/cerebro" target="_blank" rel="noopener">https://github.com/lmenezes/cerebro</a></p><p>cerebro的安装非常简单，步骤如下：</p><p>（1）下载cerebro安装包，并解压</p><p>从<code>https://github.com/lmenezes/cerebro/releases</code>上下载cerebro的安装包，这里下载的是v0.6.5版本，用来管理ElasticSearch 5.3集群。</p><p>（2）配置文件</p><p>在${cerebro_HOME}/conf/application.conf中，可以配置要监控的集群，以及集群名。另外，还可以为cerebro平台配置登录账号密码。</p><p>（3）启动cerebro</p><p>执行<code>nohup ./bin/cerebro &amp;</code>， 默认启动的端口是9000</p><p>（4）测试cerebro</p><p>使用浏览器打开<code>http://hostname:9000</code>，效果图如下：</p><p><img src="/images/elasticsearch_5_1.png" alt></p><h2 id="elasticsearch-head"><a href="#elasticsearch-head" class="headerlink" title="elasticsearch-head"></a>elasticsearch-head</h2><p>elasticsearch-head是ElasticSearch的一个插件工具，用来管理ElasticSearch集群。</p><p>elasticsearch-head Github： <a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a></p><h2 id="bigdesk"><a href="#bigdesk" class="headerlink" title="bigdesk"></a>bigdesk</h2><p>bigdesk插件是一个ElasticSearch的集群监控工具，可以通过它来查看集群的各种状态，如CPU、内存使用情况、索引数据、搜索情况、http连接数等。bigdesk的作者为lukas-vlcek，但是从Elasticsearch 1.4版本开始就不再更新了，也就是说最新的ES集群，bigdesk是不支持。不过，国内有用户fork出来继续维护到支持ES 5.0版本（<a href="https://github.com/hlstudio/bigdesk" target="_blank" rel="noopener">https://github.com/hlstudio/bigdesk</a> ），配置方法如下：</p><p>（1）到github下载项目文件</p><p>（2）修改ES集群的某一个节点的elasticsearch.yml文件，增加如下内容：</p><pre><code>http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;</code></pre><p>（3）启动webserver</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> bigdesk/_site &amp;&amp; python -m SimpleHTTPServer   <span class="comment">## 默认开启了8000端口的web服务</span></span><br></pre></td></tr></table></figure><p>（4）测试</p><p>打开浏览器输入<code>http://host:8000</code>，然后在页面上配置连接修改了cors的ES节点即可.</p><p><a href="https://github.com/lukas-vlcek/bigdesk" target="_blank" rel="noopener">bigdesk原作品Github地址（不支持最新的ES版本）</a></p><p><a href="https://github.com/hlstudio/bigdesk" target="_blank" rel="noopener">bigdesk GitHub（支持最新的ES版本，本例子中使用）</a></p><h2 id="Marvel"><a href="#Marvel" class="headerlink" title="Marvel"></a>Marvel</h2><p>Marvel是ElasticSearch的一个集群监控工具，集Head和Bigdesk有点于一身，但是Marvel插件不是免费的。Marvel是ElasticSearch官方开发的一个插件。</p><h1 id="ElasticSearch集群压测工具"><a href="#ElasticSearch集群压测工具" class="headerlink" title="ElasticSearch集群压测工具"></a>ElasticSearch集群压测工具</h1><p><a href="https://github.com/elastic/rally" target="_blank" rel="noopener">esrally压测工具</a></p><h1 id="集群权限控制"><a href="#集群权限控制" class="headerlink" title="集群权限控制"></a>集群权限控制</h1><p>searchguard</p>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch系列（4）_Shard Allocation策略</title>
      <link href="/2018/02/02/ElasticSearch%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89-Shard-Allocation%E7%AD%96%E7%95%A5/"/>
      <url>/2018/02/02/ElasticSearch%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89-Shard-Allocation%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="ES的Shard-Allocation策略简介"><a href="#ES的Shard-Allocation策略简介" class="headerlink" title="ES的Shard Allocation策略简介"></a>ES的Shard Allocation策略简介</h1><p>某个shard分配在哪个节点上，一般来说，是由ES集群自动决定的。以下几种情况会触发分配动作：</p><pre><code>新索引生成索引的删除新增副本分片节点增减引发的数据均衡</code></pre><p>ES提供了一系列参数详细控制这部分逻辑，如下：</p><p>（1）cluster.routing.allocation.enable</p><p>该参数用来控制允许分配哪种分片。默认是all。可选项还包括primaries和new_primaries。none则彻底拒绝分片。</p><p>（2）cluster.routing.allocation.allow_rebalance</p><p>该参数用来控制什么时候允许数据均衡。默认是indices_all_active，即要求所有分片都正常启动成功以后，才可以进行数据均衡操作，否则的话，在集群重启阶段，会浪费太多流量了。</p><p>（3）cluster.routing.allocation.cluster_concurrent_rebalance</p><p>该参数用来控制集群内同时运行的数据均衡任务个数。默认是2个。如果有节点增减，且集群负载压力不高的时候，可以适当加大。</p><p>（4）cluster.routing.allocation.node_initial_primaries_recoveries</p><p>该参数用来控制节点重启时，允许同时恢复几个主分片。默认是4个。如果节点是多磁盘，且IO压力不大，可以适当加大。</p><p>（5）cluster.routing.allocation.node_concurrent_recoveries</p><p>该参数用来控制节点除了主分片重启恢复以外其他情况下，允许同时运行的数据恢复任务。默认是2个。所以，节点重启时，可以看到主分片迅速恢复完成，副本分片的恢复却很慢。除了副本分片本身数据要通过网络复制以外，并发线程本身也减少了一半。当然，这种设置也是有道理的——主分片一定是本地恢复，副本分片却需要走网络，带宽是有限的。从ES 1.6开始，冷索引的副本分片可以本地恢复，这个参数也就是可以适当加大了。</p><p>（6）indices.recovery.concurrent_streams</p><p>该参数用来控制节点从网络复制恢复副本分片时的数据流个数。默认是3个。可以配合上一条配置一起加大。</p><p>（7）indices.recovery.max_bytes_per_sec</p><p>该参数用来控制节点恢复时的速率。默认是40MB。显然是比较小的，建议加大。</p><h1 id="ES支持的一些特殊的Shard-Allocation策略"><a href="#ES支持的一些特殊的Shard-Allocation策略" class="headerlink" title="ES支持的一些特殊的Shard Allocation策略"></a>ES支持的一些特殊的Shard Allocation策略</h1><p>ES还有一些其他的分片分配控制策略，比如以tag和rack_id作为区分等。一般来说，ElasticStack场景中使用不多，在ES集群运维中会常常使用到。</p><p>（1）基于磁盘空间的Shard Allocation</p><p>为了保护节点数据安全，ES会定时（cluster.info.update.interval，默认30 秒）检查一下各节点的数据目录磁盘使用情况。在达到cluster.routing.allocation.disk.watermark.low（默认 85%）的时候，新索引分片就不会再分配到这个节点上了。在达到cluster.routing.allocation.disk.watermark.high （默认 90%）的时候，就会触发该节点现存分片的数据均衡，把数据挪到其他节点上去。这两个值不但可以写百分比，还可以写具体的字节数。</p><p>备注：这个可以解决ES集群中各节点的磁盘空间不一致的问题哦。</p><p>具体参见官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.3/disk-allocator.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/5.3/disk-allocator.html</a></p><p>（2）解决热索引分片不均的问题</p><p>略。</p><h1 id="手动Shard-Allocation"><a href="#手动Shard-Allocation" class="headerlink" title="手动Shard Allocation"></a>手动Shard Allocation</h1><p>上面说的各种配置，都是从ES集群自身的策略层面来控制分片分配的规则。在必要的时候，还可以通过ES的reroute接口，手动完成对分片的分配选择的控制。reroute接口支持五种指令allocate_replica, allocate_stale_primary, allocate_empty_primary, move和cancel。</p><p>学习资料参考于：<br><a href="https://github.com/chenryn/ELKstack-guide-cn/blob/master/elasticsearch/principle/shard-allocate.md" target="_blank" rel="noopener">https://github.com/chenryn/ELKstack-guide-cn/blob/master/elasticsearch/principle/shard-allocate.md</a></p>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch系列（3）_ES API技术</title>
      <link href="/2018/02/02/ElasticSearch%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89-ES-API%E6%8A%80%E6%9C%AF/"/>
      <url>/2018/02/02/ElasticSearch%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89-ES-API%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="ElasticSearch对外API"><a href="#ElasticSearch对外API" class="headerlink" title="ElasticSearch对外API"></a>ElasticSearch对外API</h1><p>ElasticSearch对外暴露两种形式的API，一种是JAVA API，另一种是HTTP Restful API。具体说明如下：</p><p>（1）JAVA API</p><p>JAVA API又分为Node Client和Transport Client两种，两种Java客户端都通过9300端口与集群交互，使用ElasticSearch传输协议(Elasticsearch Transport Protocol)进行通信。集群中的节点之间也通过9300端口进行通信。如果此端口未开放，你的节点将不能组成集群。另种JAVA API具体说明如下：</p><p>A）节点客户端Node Client</p><p>节点客户端以无数据节点(none data node)身份加入集群，换言之，它自己不存储任何数据，但是它知道数据在集群中的具体位置，并且能够直接转发请求到对应的节点上。</p><p>B）传输客户端Transport Client</p><p>这个更轻量的传输客户端能够发送请求到远程集群。它自己不加入集群，只是简单转发请求给集群中的节点。</p><p>（2）HTTP Restful API</p><p>基于HTTP协议，以JSON为数据交互格式的RESTful API，通过9200端口的与Elasticsearch进行通信。ElasticSearch提供的一些HTTP RESTful API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_cat API    —— 格式化输出API</span><br><span class="line">_bulk API   —— 批量操作API</span><br><span class="line">_search API —— 搜索API</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h1 id="ElasticSearch的一些常见操作"><a href="#ElasticSearch的一些常见操作" class="headerlink" title="ElasticSearch的一些常见操作"></a>ElasticSearch的一些常见操作</h1><p>使用申明：v参数表示打印详细输出；pretty参数表示格式化的样式输出，输出结果更直观。</p><p>（1）查看集群的健康状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_cat/health?v</span><br></pre></td></tr></table></figure><p>备注：ElasticSearch集群有三种健康状态，分别是green，yellow以及red，如下：</p><pre><code>green表示集群中所有的主分片和副本都是正常的，处于活动状态。yellow表示集群现中所有的主分片是正常的，处于活动状态。但不是所有的replica处在活动状态。red表示集群中不是所有的主分片是正常的，处于活动状态</code></pre><p>（2）查看集群的所有节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_cat/nodes?v</span><br></pre></td></tr></table></figure><p>（3）查看所有的索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_cat/indices?v</span><br></pre></td></tr></table></figure><p>（4）在索引bank的account类型中，查找id为1的文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://192.168.65.239:9200/bank/account/1?pretty</span><br></pre></td></tr></table></figure><p>（5）查找一个索引指定类型的所有的文档信息，默认显示10个，加载size参数可以指定返回大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET http://192.168.65.239:9200/bank/account/_search?pretty</span><br><span class="line">GET /bank/account/_search?size=100&amp;pretty</span><br></pre></td></tr></table></figure><p>（6）查看last_name属性为Smith的账户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/account/_search?q=last_name:Smith</span><br></pre></td></tr></table></figure><p>（7）使用DSL方式查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/account/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"match"</span> : &#123;</span><br><span class="line">            <span class="string">"last_name"</span> : <span class="string">"Smith"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（8）删除索引中某一个文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /bank/account/1</span><br></pre></td></tr></table></figure><p>（9）删除一个索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /bank</span><br></pre></td></tr></table></figure><h1 id="ElasticSearch-HTTP-REST-API的使用"><a href="#ElasticSearch-HTTP-REST-API的使用" class="headerlink" title="ElasticSearch HTTP REST API的使用"></a>ElasticSearch HTTP REST API的使用</h1><p>ElasticSearch REST API的使用形式有两种，一种是将查询参数拼接到url里面，另一种是将查询参数放到-d选项中。</p><p>（1）请求参数方式（Query String）</p><p>举例来说，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/bank/_search?q=*&amp;pretty'</span></span><br></pre></td></tr></table></figure><p>（2）请求体方式（Query DSL）</p><p>举例来说，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">'localhost:9200/bank/_search?pretty'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "query": &#123; "match_all": &#123;&#125; &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><p>（3）查询中的term与match</p><p>term表示精确匹配，即我们的搜索词不会被切词。举例来说，如果我们搜索的关键词是“中国北京”，那么ES建立的倒排索引的term中，必须有“中国北京 ”的文档才会被检索出来。</p><p>而如果我们使用match来搜索时，会先对搜索词进行切词。举例来说，如果我们搜索的关键词是“中国北京”，那么先会被切分为“中国”和“北京”两个词，当匹配到其中任何一个的文档都会被检索出来。</p><p>学习资料参考于：<a href="http://www.cnblogs.com/muniaofeiyu/p/5616316.html" target="_blank" rel="noopener">http://www.cnblogs.com/muniaofeiyu/p/5616316.html</a></p><p>（4）search API输出查询结果的数据结构</p><p><img src="/images/elasticsearch_3_1.png" alt></p><p>主要字段说明如下：</p><pre><code>took      ## 是查询花费的时间，毫秒单位time_out  ## 标识查询是否超时_shards   ## 描述了查询分片的信息，查询了多少个分片、成功的分片数量、失败的分片数量等hits      ## 搜索的结果，total是全部的满足的文档数目，hits是返回的实际数目（默认是10）_score    ## 文档的分数信息，与排名相关度有关 </code></pre><h1 id="ElasticSearch中的映射Mapping"><a href="#ElasticSearch中的映射Mapping" class="headerlink" title="ElasticSearch中的映射Mapping"></a>ElasticSearch中的映射Mapping</h1><p>在ES中，索引具有一定的数据结构，称为映射(mapping)或者模式定义(schema definition)。一个映射定义了索引有哪些字段，每个字段的数据类型以及字段被Elasticsearch处理的方式等。</p><p>（1）ES支持的字段数据类型</p><pre><code>字符串类：string整型类：byte、short、integer、long浮点类：float、double布尔类：boolean日期类：date</code></pre><p>（2）ES的动态映射</p><p>当我们向ES插入文档时，当文档中包含一个之前不存在的字段，Elasticsearch将使用动态映射猜测字段类型，动态映射的规则如下：</p><p><img src="/images/elasticsearch_3_2.png" alt></p><p>（3）ES字段分词相关的配置</p><p>当我们定义mapping时，可以为某个字段指定index和analyzer属性。</p><p>A）index<br>index可以被设置为如下三个字段（缺省为analyzed）：</p><pre><code>analyzed：表示该字段会被分词，然后被索引。例如某个字段的值是“中国”，那么会被分为“中”、“国”。我们可以通过“中国”、“中”、“国”都可以搜索到该文档not_analyzed：表示该字段不会被分词，例如“中国”，只能通过关键字“中国”搜索到no：表示不为该字段建索引，也就是说该字段不能根据关键词被搜索到</code></pre><p>备注：其他简单类型（long、double、date等）也接受index参数，但相应的值只能是no和not_analyzed，它们的值不能被分析。</p><p>B）analyzer</p><p>使用analyzer参数用来指定使用哪一种分析器来分词。默认的Elasticsearch使用standard分析器，但可以通过指定一个内建的分析器来更改它，例如whitespace、simple或english。</p><p>（4）查看某个索引的指定类型的mapping</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'http://10.19.120.93:9200/log-error-2017.06.05/_mapping/log-error?pretty'</span></span><br></pre></td></tr></table></figure><h1 id="ElasticSearch中的创建索引以及索引初始化"><a href="#ElasticSearch中的创建索引以及索引初始化" class="headerlink" title="ElasticSearch中的创建索引以及索引初始化"></a>ElasticSearch中的创建索引以及索引初始化</h1><p>当我们往ElasticSearch集群中一个还不存在的索引中添加一个文档时，API会自动创建一个索引，该索引使用默认设置，且字段属性通过动态映射来决定的。在ES中通过设置<code>action.auto_create_index: false</code>来禁止自动创建索引。</p><p>其实，我们可以通过API手动的创建索引，并配置索引的Mapping，命令的格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123; ... any settings ... &#125;,</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"type_one"</span>: &#123; ... any mappings ... &#125;,</span><br><span class="line">        <span class="string">"type_two"</span>: &#123; ... any mappings ... &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Python的ES-API第三方库"><a href="#Python的ES-API第三方库" class="headerlink" title="Python的ES API第三方库"></a>Python的ES API第三方库</h1><p>Python封装好的API有两个库，一个是elasticsearch-py，一个是elasticsearch-dsl-py。其中elasticsearch-py是低级库，和HTTP REST API的形式类似，而elasticsearch-dsl-py是基于elasticsearch-py，对api做了更好的封装。<br>备注：elasticsearch-dsl-py的开发文档有点晦涩，暂时就使用elasticsearch-py低级python库了。</p>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch系列（2）_ES安装及配置</title>
      <link href="/2018/02/02/ElasticSearch%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89-ES%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/02/02/ElasticSearch%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89-ES%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="ElasticSearch的配置和安装"><a href="#ElasticSearch的配置和安装" class="headerlink" title="ElasticSearch的配置和安装"></a>ElasticSearch的配置和安装</h1><p>前提申明：本次部署测试用的是elasticsearch-5.3.0，依赖1.8或1.8以上的JDK版本</p><p>（1）安装Java JDK并配置CLASSPATH,PATH,JAVA_HOME环境变量</p><p>（2）到ES官网<code>https://www.elastic.co/downloads/elasticsearch</code>上下载ES的zip包，解压即可。</p><p>（3）启动</p><p>执行<code>./bin/elasticsearch</code>即可在前台启动ES，或者执行<code>./bin/elasticsearch -d</code>在后台启动ES</p><p>（4）测试</p><p>在浏览器中输入<code>http://x.x.x.x:9200</code>，即可看到：</p><p><img src="/images/elasticsearch_2_1.png" alt></p><p>备注：如果在远程主机上访问<code>http://x.x.x.x:9200</code>，需要在${ES_HOME}/config/elasticsearch.yml中将network.host的配置打开，且将后面ip修改为0.0.0.0</p><h1 id="ElasticSearch的常见配置项"><a href="#ElasticSearch的常见配置项" class="headerlink" title="ElasticSearch的常见配置项"></a>ElasticSearch的常见配置项</h1><p>ElasticSearch的配置文件为${ES_HOME}/config/elasticsearch.yml，一般来说，ElasteSearch集群不需要配置太多东西，使用缺省的配置就可以了。</p><p>（1）cluster.name</p><p>集群的名称。如果没有配置，默认为elasticserach.  cluster.name相同的elasticsearch节点，会自动组成一个名称为cluster.name的配置值的ElasticSearch集群</p><p>（2）node.name</p><p>节点的名称。如果没有配置，ElasticSearch会在你的节点启动的时候随机给它指定一个名字。ElasticSearch节点每次启动时，都会得到一个新的名字。这会使日志变得很混乱，因为所有节点的名称都是不断变化的。因此我们需要在配置文件中人为定义一个有意义的节点名称。</p><p>（3）path.data</p><p>指定es节点的数据存放路径，可以通过path.data: /path/to/data1,/path/to/data2的形式指定多个目录，当然也可以只指定一个目录。默认是存储在${ES_HOME}/data</p><p>（4）path.logs</p><p>指定es节点的运行日志存放路径。默认存储在${ES_HOME}/logs</p><p>（5）path.plugins</p><p>指定es的插件存放路径。默认是放到${ES_HOME}/plugins</p><p>（6）transport.tcp.port</p><p>设置节点间的交互的tcp端口，默认是9300</p><p>（7）http.port</p><p>设置集群对外服务的http端口，默认为9200</p><p>（8）node.master</p><p>指定该节点是否有资格被选举成为master节点，默认是true.  es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举master</p><p>（9）node.data</p><p>指定该节点是否存储索引数据，默认为true.</p><p>（10）index.number_of_shards</p><p>设置默认索引分片个数，默认为5片</p><p>（11）index.number_of_replicas</p><p>设置默认索引副本replica个数，默认为1个副本</p><p>（12）http.enabled</p><p>是否使用http协议对外提供服务，默认为true</p><p>（13）ElasticSearch重启恢复方面的配置</p><p>假设我们的集群有10个节点，现在我们要对10个节点进行升级并重启，假设5个节点先正常启动了，这五个节点会相互通信，选出一个 master，从而形成一个集群。 然后集群发现数据不再均匀分布，因为有5 个节点在集群中丢失了，所以他们之间会立即启动分片复制。这时，另外的5个节点启动完成了，这些节点会发现它们的数据正在被复制到其他节点，所以他们删除本地数据（因为这份数据要么是多余的，要么是过时的）。 然后整个集群重新进行平衡，因为集群的大小已经从5变成了10。对比有TB量级的ElasticSearch集群，这种来回地数据移动，无疑会大量消耗集群计算或网络资源。通常我们在通过配置如下的参数来缓解这种情况：</p><pre><code>gateway.recover_after_nodes: 8gateway.expected_nodes: 10gateway.recover_after_time: 5m</code></pre><p>上述参数表示，满足如下条件之一集群才开始进行数据恢复：一是集群在线的节点数为10个；二是集群在线的节点数至少为8个，且等待5分钟</p><p>（14）discovery.zen.minimum_master_nodes</p><p>ElasticSearch集群一旦建立起来以后，会选举出一个master，其他都为slave节点。当配置了discovery.zen.minimum_master_nodes参数后，当集群面临重新选主时，所有可能成为master的节点的集合（仲裁集）要大于等于discovery.zen.minimum_master_nodes。所以一般来说，<code>discovery.zen.minimum_master_nodes</code>设置为<code>(master_eligible_nodes / 2) + 1</code>，其中master_eligible_nodes表示<code>node.master=true</code>的节点数，因此可以避免一个ES集群出现脑裂的问题（所谓脑裂指的是，集群中某些节点脱离了集群后，自动组成一个新的集群。这样的话，原来的一个集群就变成了两个集群，会导致一些不确定的问题发生）。</p><p>比如我们集群有5个节点，我们需要配置discovery.zen.minimum_master_nodes=(5/2)+1=3，所以当这个集群中有2个节点断连脱离集群后，不会选主成功，当然也不会成为一个独立的集群。而另外3个节点可以选主成功，从而组成一个单独的集群。</p><p>备注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node.master=true  &amp; node.data=true  —— 表示节点既可以是master节点，也可以是data节点</span><br><span class="line">node.master=false &amp; node.data=true  —— 表示节点只可能是data节点，不可能成为master节点</span><br><span class="line">node.master=true  &amp; node.data=false —— 表示节点只可能成为master节点，不存储数据</span><br><span class="line">node.master=false &amp; node.data=false —— 表示节点不会成为master节点，也不存储数据。只能用来作为client节点</span><br></pre></td></tr></table></figure><h1 id="ElasticSearch的最佳实践"><a href="#ElasticSearch的最佳实践" class="headerlink" title="ElasticSearch的最佳实践"></a>ElasticSearch的最佳实践</h1><p>（1）部署ElasticSearch的机器，64GB内存的机器是非常理想的，但是32GB和16GB机器也是很常见的。少于8GB会适得其反（你最终需要很多很多的小机器），大于64GB的机器也会有问题。</p><p>（2）当ElasticSearch集群已经在生产环境中，如果这时需要修改集群的配置参数，可以有两种方式：一种是修改配置，然后重启ES实例；一种是使用ES的HTTP API直接修改内存中的配置，不需要重启。当然推荐第二种方式来修改集群参数。</p><p>（3）ElasticSearch中有索引有type的概念，建议一个index就配置一个type就好了。ES中type的概念逐渐弱化，到ES6.0时候，可能就没有type的概念了。</p><h1 id="ES安装与配置常见问题"><a href="#ES安装与配置常见问题" class="headerlink" title="ES安装与配置常见问题"></a>ES安装与配置常见问题</h1><p>（1）elasticsearch安装和配置问题</p><p>elasticsearch出于安全的考虑，不允许使用root账户启动，所以要为elasticsearch单独创建账户。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd elasticsearch</span><br><span class="line">chown -R elasticsearch:elasticsearch ~/prod/elasticsearch-2.4.0</span><br><span class="line">su elasticsearch &amp;&amp; ./bin/elasticsearch    #加上-d，将在后台启动</span><br></pre></td></tr></table></figure><p>（2）无法使用<code>http://192.168.65.239:9200/</code>来测试，需要修改config/elasticsearch.yml中network.host: 192.168.0.1，改成network.host: 0.0.0.0</p><p>（3）出现failed to resolve local host, fallback to loopback错误，因为hostname没有在/etc/hosts中，需要将机器名追加到/etc/hosts中127.0.0.1这一行的后面</p><p>（4）elasticsearch开启了9200和9300两个端口，9200是提供的http接口，9300是其他的非http接口。如果是用flume的sink往elasticsearch中写的话，需要使用9300端口</p><p>（5）<a href="http://www.jianshu.com/p/89f8099a6d09" target="_blank" rel="noopener">http://www.jianshu.com/p/89f8099a6d09</a></p><p>今天开工，在看ES时候发现前几天已经发布了5.2.0，就安装了一下，岂料安装完一直启动不了，可以说是一个bug。报错如下：</p><pre><code>[2017-05-09T13:19:18,665][INFO ][o.e.b.BootstrapChecks    ] [sgw-node-1] bound or publishing to a non-loopback or non-link-local address, enforcing bootstrap checksERROR: bootstrap checks failedmax file descriptors [65535] for elasticsearch process is too low, increase to at least [65536]max number of threads [1024] for user [elasticsearch] is too low, increase to at least [2048]max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk</code></pre><p>这是在因为Centos6不支持SecComp，而ES5.2.0默认<code>bootstrap.system_call_filter</code>为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。</p><p>在elasticsearch.yml中配置<code>bootstrap.system_call_filter</code>为false，注意要在Memory下面：</p><pre><code>bootstrap.memory_lock: falsebootstrap.system_call_filter: false</code></pre><p>对于<code>max file descriptors</code>和<code>max number of threads</code>的问题，可以修改<code>/etc/security/limits.conf</code>，配置如下：</p><pre><code>*                soft   nofile          65536*                hard   nofile          65536elasticsearch    soft   nproc           16384elasticsearch    hard   nproc           32768</code></pre><p>对于<code>vm.max_map_count</code>的问题，可以修改/etc/sysctl.conf，配置如下：</p><pre><code>vm.max_map_count=262144</code></pre><h1 id="ElasticSearch中的一些闲杂知识"><a href="#ElasticSearch中的一些闲杂知识" class="headerlink" title="ElasticSearch中的一些闲杂知识"></a>ElasticSearch中的一些闲杂知识</h1><p>（1）在ElasticSearch中一个文档有很多的字段Field，在ES中文档不仅包括数据本身，还包括一些元数据Metadata，例如_index/_type/_id. 其中_index表示文档所属索引名称，_type表示文档属于索引的哪个类型，_id表示文档的id，id可以自己指定，也可以由ES集群自动生成。在一个ElasticSearch集群中三元组（_index, _type, _id）唯一确定一个文档。</p><p>（2）ElasticSearch的一些内置字段</p><p><img src="/images/elasticsearch_2_2.png" alt></p><p>（3）关于ES heap设置，官方建议ES的内存不要超过系统可用内存的一半，并且不要超过32GB。<a href="https://elasticsearch.cn/article/32" target="_blank" rel="noopener">https://elasticsearch.cn/article/32</a></p><p>（4）在config/jvm.options中可以修改ElasticSearch JAVA应用的heap大小</p><h1 id="生产环境中ES集群全局配置修改方式"><a href="#生产环境中ES集群全局配置修改方式" class="headerlink" title="生产环境中ES集群全局配置修改方式"></a>生产环境中ES集群全局配置修改方式</h1><p>（1）修改配置文件并重启集群的每个节点</p><p>修改config/elasticsearch.yml静态文件，然后重启集群的每个节点。这个方式比较粗暴，生产环境中不建议使用。</p><p>（2）使用动态更新集群配置（Cluster Update Settings）API</p><p>使用动态更新就集群配置（Cluster Update Settings）API，又有两种，即一种是瞬时Transient生效，另一种是永久Persistent生效。</p><p>A）瞬时Transient</p><p>这些变更在集群重启之前一直会生效。一旦整个集群重启，这些配置就被清除。操作方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /_cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"transient"</span> : &#123;</span><br><span class="line">        <span class="string">"indices.recovery.max_bytes_per_sec"</span> : <span class="string">"20mb"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B）永久Persistent</p><p>这些变更会永久存在直到被显式修改。即使全集群重启它们也会存活下来，当和静态配置config/elasticsearch.yml有冲突时，会覆盖掉静态配置文件里的选项。操作方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /_cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"persistent"</span> : &#123;</span><br><span class="line">        <span class="string">"indices.recovery.max_bytes_per_sec"</span> : <span class="string">"50mb"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch系列（1）_ES简介及原理</title>
      <link href="/2018/01/31/ElasticSearch%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89-ES%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>/2018/01/31/ElasticSearch%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89-ES%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h1><p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</p><p>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><p>ElasticSearch不仅仅是Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：</p><p>（1）一个分布式的实时文档存储，每个字段可以被索引与搜索</p><p>（2）一个分布式实时分析搜索引擎</p><p>（3）能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</p><p>备注：Apache Solr项目和ElasticSearch的功能类似，Apache Solr也是基于Lucene库的开源搜索引擎。Apache Solr在2010年与Apache Lucene项目合并。</p><p>如下为ElasticSearch的架构图：</p><p><img src="/images/elasticsearch_1_1.png" alt></p><p>备注：Apache Lucene是一个单机版的全文索引和搜索的工具包，通过ElasticSearch的封装，可以让Apache lucene具有分布式的扩展能力。</p><h1 id="ElasticSearch中的一些概念"><a href="#ElasticSearch中的一些概念" class="headerlink" title="ElasticSearch中的一些概念"></a>ElasticSearch中的一些概念</h1><p>（1）集群和节点</p><p>节点(node)是一个运行着的ElasticSearch实例。集群(cluster)是一组具有相同cluster.name的节点集合，他们协同工作，共享数据并提供故障转移和扩展功能，当然一个节点也可以组成一个集群。</p><p>我们通过修改config/elasticsearch.yml文件，来修改cluster.name名称，然后重启ELasticsearch即可。cluster.name默认为elasticsearch，我们最好修改一个自定义的名称，这样可以防止一个新启动的节点加入到相同网络中的另一个同名的集群中。</p><p>另外，节点的名称可以通过node.name配置来修改。</p><p>（2）索引、类型、文档</p><p>和关系型数据库对比一下概念：</p><pre><code>Relational DB :: Databases -&gt; Tables -&gt; Rows      -&gt; ColumnsElasticSearch :: Indices   -&gt; Types  -&gt; Documents -&gt; Fields</code></pre><p><img src="/images/elasticsearch_1_2.png" alt></p><p>备注：<br>Elasticsearch集群可以包含多个索引(indices)（数据库），每一个索引可以包含多个类型(types)（表），每一个类型包含多个文档(documents)（行），然后每个文档包含多个字段(Fields)（列）</p><p>（3）索引</p><p>索引(index)这个词在Elasticsearch中有着不同的含义，所以有必要在此做一下区分：</p><p>A）索引（名词） </p><p>如上文所述，一个索引(index)就像是传统关系数据库中的数据库，它是相关文档存储的地方，index的复数是indices 或indexes。</p><p>B）索引（动词） </p><p>「索引一个文档」表示把一个文档存储到索引（名词）里，以便它可以被检索或者查询。这很像SQL中的INSERT关键字，差别是，如果文档已经存在，新的文档将覆盖旧的文档。</p><p>（4）分片和副本（Shards &amp; Replicas）</p><p>一个索引可能存储大量的数据，这个数据量可能超过一个单独节点的硬盘大小。比如说，十亿个文档的索引可能会占用1TB大小的磁盘空间，可能就不适合一个单独节点的磁盘，也可能会导致这个节点处理查询请求非常缓慢。 为了解决这个问题，ElasticSearch提供一种能力，这种能力可以把索引细分到多个称为分片的地方中去。当我们往ES中写入文档时，ES按照一定的hash策略<code>[ shard = hash(routing) % number_of_primary_shards ]</code>，将文档写入某一个分片中，所以一个索引的多个shard是同时工作的，而不是说一个shard写满之后，就不在写了，然后创建出一个新的shard。当你创建索引的时候，可以自定义分片的数量。每个分片对于它自己都是全功能和独立索引的。</p><p>在一个网络、云环境中，任何时候都有可能失败，万一 一个分片、节点以某种方式下线或者消失，有一个故障恢复机制是非常有用并被建议的。ElasticSearch允许索引的分片有一个或多个副本，这个副本我们称为复制分片，或直接叫做副本。</p><p>备注：一个索引的shards的数量，是在创建shards时指定的，创建之后不可修改。而一个shard的replica数量是可以在索引创建之后根据需要修改的。</p><h1 id="ElasticSearch集群工作机制"><a href="#ElasticSearch集群工作机制" class="headerlink" title="ElasticSearch集群工作机制"></a>ElasticSearch集群工作机制</h1><p>（1）ElasticSearch集群基本概念</p><p>ElasticSearch集群中一个节点被选举为master节点，其他的节点则为slave节点。master节点负责集群整体状态的维护，例如创建或删除索引、增加或删除节点等等。对于用户，可以和集群中的任意节点进行通信，包括主节点。每个节点都知道某个文档的存放位置，并且能够将请求转发到持有所需数据的节点。用户直接通信的节点负责将需要的数据从各个节点收集起来，然后返回给用户。这个过程都是由ES透明地进行管理。</p><p>当我们创建索引时，ElasticSearch默认将这个索引配置5个shard和1个replica（也就是新索引有5个分片，每个分片又有一个副本）。</p><p>A）一个没有数据，且只有一个节点的空集群</p><p><img src="/images/elasticsearch_1_3.png" alt></p><p>该节点是集群中有一个节点，该节点为master节点</p><p>B） 在（A）的基础上，创建一个有3个shard，1个replica的索引</p><p><img src="/images/elasticsearch_1_4.png" alt></p><p>三个shard均被分配到NODE1上。由于只有一个节点，3个replica没有被分配，当前集群状态为yellow</p><p>C）在（B）的基础上，给ES集群增加一个节点NODE2</p><p><img src="/images/elasticsearch_1_5.png" alt></p><p>该索引的3个shard被复制到NODE2节点，因此在NODE2上有3个replica，至此集群状态为green（3个主分片和3个副本均正常）</p><p>D）在（C）的基础上再增加一个节点NODE3</p><p><img src="/images/elasticsearch_1_6.png" alt></p><p>ES集群的shards和replica将会在集群中重新分配，以达到一个比较均衡的状态。</p><p>E）在（D）的基础上将replica数量从1调整到2</p><p><img src="/images/elasticsearch_1_7.png" alt></p><p>F）在（E）的基础上干掉NODE1 master节点</p><p><img src="/images/elasticsearch_1_8.png" alt></p><p>master节点宕掉之后，第一件事是剩余的节点重新选主出master节点，图中NODE2被选举为新的master节点。由于P1和P2两个主分片在NODE1被干掉时丢失了，所以新的master节点将重新从replica中恢复主分片，图中将NODE2和NODE3中replica确定为主分片。此时集群的状态为yellow，因为该所有需要2个replica，目前只有1个replica.</p><p>（2）shard的路由机制</p><p>在ElasticSearch中，一个索引可能有多个shard，一个文档只能被存储到一个shard中。因此在索引文档的时候，需要有一个机制来决定文档被索引到哪一个shard上。在ES中，通过公式shard = hash(routing) % number_of_primary_shards来计算文档应该被分配到哪个shard中。而且在读取ES中某个文档时，也是通过该公式计算出该文档存储在哪个shard中。因此在ES中，shard数在创建文档时指定，后来就无法改变，因为如果改变索引的shard数，那么已经被索引的数据将会失效或找不到。而replica数目则是可以随时调整的。</p><p>备注：公式中routing可以是文档的_id，也可以是用户自定义的值。</p><p>（3）在ES集群中，每一个节点都维护了一套完整集群元数据，所有每个节点都知道某个文档的存储节点，以及能够将请求转发给相应的节点，因此ES集群中每一个节点都能响应客户端的所有请求，而不管它是master节点，还是slave节点。</p><p>（4）ElasticSearch基本操作工作流</p><p><strong><em>场景一：创建或删除一个文档</em></strong></p><p><img src="/images/elasticsearch_1_9.png" alt></p><p>A）NODE1收到用户发起的创建或删除文档请求</p><p>B）NODE1根据文档的_id计算（hash(routing) % number_of_primary_shards） 出该文档属于shard 0. 然后NODE1将请求转发给shard 0所在的节点NODE3</p><p>C）NODE3响应请求，完成P0的更新。然后将请求同时转发给给其副本所在的节点NODE1和NODE2。NODE1和NODE2更新完副本后，返回成功给主分片所在的节点NODE3。</p><p>D）NODE3返回成功给NODE1，NODE1返回成功给用户</p><p>备注：这个里面响应用户请求的是NODE1节点，其实这里其他的节点都可以直接响应用户的请求，请求工作流是类似的。</p><p><strong><em>场景二：读取一个文档</em></strong></p><p><img src="/images/elasticsearch_1_10.png" alt></p><p>A）NODE1收到用户的读取文档请求</p><p>B）NODE1根据文档的_id计算<code>hash(routing) % number_of_primary_shards</code>出该文档属于shard 0. NODE1发现在所有的节点上都有shard 0或shard 0的副本。在这种情况下，NODE1会按照Round Robin模式妆发请求，在上图的例子中，是转发给了NODE2</p><p>C）NODE2返回文档数据给NODE1，然后NODE1将文档数据返回给用户</p><p>备注：这个里面响应用户请求的是NODE1节点，其实这里其他的节点都可以直接响应用户的请求，请求工作流是类似的。</p><p><strong><em>场景三：更新一个文档</em></strong></p><p><img src="/images/elasticsearch_1_11.png" alt></p><p>A）NODE1收到用户的更新文档请求</p><p>B）NODE1计算出文档属于shard 0，并将请求转发给主分片shard 0所在的节点NODE3上。NODE3更新文档，并将请求转发给replica所在的NODE1和NODE2</p><p>C）NODE1和NODE2更新replica，并返回成功给NODE3。NODE3返回成功给NODE1，然后NODE1返回成功给用户</p><h1 id="ElasticSearch集群的自动发现机制"><a href="#ElasticSearch集群的自动发现机制" class="headerlink" title="ElasticSearch集群的自动发现机制"></a>ElasticSearch集群的自动发现机制</h1><p>分布式系统要解决的首要问题就是节点之间互相发现以及选主的机制。如果使用了Zookeeper/Etcd这样的成熟的服务发现工具，这两个问题都一并解决了。但ElasticSearch并没有依赖这样的工具，带来的好处是部署服务的成本和复杂度降低了，不用预先依赖一个服务发现的集群，缺点当然是将复杂度带入了ElasticSearch内部。ElasticSearch Discovery模块就是负责集群中节点的自动发现和Master节点选举的模块，详细介绍如下：</p><p>（1）自动发现</p><p>目前ElasticSearch的自动发现机制有四种选择，ES默认支持的是zen Discovery，详细介绍如下：</p><p>A）zen discovery</p><p>它是ElasticSearch默认支持的，有单播和多播两种方式。</p><p>多播时需要如下配置：</p><pre><code>discovery.zen.ping.multicast.group: 224.2.2.4  #组地址 discovery.zen.ping.multicast.port: 54328       #端口 discovery.zen.ping.multicast.ttl: 3            #广播消息TTLdiscovery.zen.ping.multicast.address: null     #绑定的地址，null表示绑定所有可用的网络接口 discovery.zen.ping.multicast.enabled: true     #多播自动发现禁用开关</code></pre><p>备注：在生产环境中，官方建议关闭多播模式，因为多播模式下，可能会有一些节点错误地加到ES集群中来</p><p>单播时需要如下配置：</p><pre><code>discovery.zen.ping.multicast.enabled: false        #多播自动发现禁用开关discovery.zen.ping.unicast.hosts: [&quot;192.168.11.192&quot;,&quot;192.168.11.193&quot;,&quot;192.168.11.194&quot;]  #unicast.hosts是集群中任意几个节点，而不用是所有ES中的所有节点。该节点会和unicast.hosts列表中机器进行通信，然后该节点和集群master节点通信，从而加入到集群中来</code></pre><p>B）Azure classic discovery</p><p>它以插件的形式被ES支持，只有多播方式</p><p>C） EC2 discovery</p><p>它以插件的形式被ES支持，只有多播方式</p><p>D）Google Compute Engine(GCE) discovery</p><p>它以插件的形式被ES支持，只有多播方式</p><p>（2）Master节点选举</p><p>和master选举相关的几个参数有node.master，discovery.zen.minimum_master_nodes等</p><p>（3）故障检测</p><p>ElasticSearch中的故障检测有两个机制，一个是master节点定期去ping检测所有的slave节点；一个是slave节点定期去ping检测master节点是否存活。有如下三个相关的配置参数：</p><pre><code>discovery.zen.fd.ping_interval #多长时间ping一次，默认是1sdiscovery.zen.fd.ping_timeout  #ping的返回最大容忍时间，默认是30s，也就是说超过30s，ping还没有返回，就认为超时了discovery.zen.fd.ping_retries  #如果ping超时，最大的重试次数，默认为3，也就是说重试了3次，一个节点还是ping不通，那么就认为该节点挂掉了</code></pre><h1 id="ElasticSearch中各种节点"><a href="#ElasticSearch中各种节点" class="headerlink" title="ElasticSearch中各种节点"></a>ElasticSearch中各种节点</h1><p>（1）master-eligible node（候选主节点）</p><p>node.master为true，缺省即为true，意味着该节点可以被选举为master。</p><p>（2）master node（主节点）</p><p>（3）data node（数据节点）</p><p>node.data为true，缺省即为true，它负责存储数据，执行数据相关的CRUD、搜索、聚合操作。</p><p>（4）Ingest node（提取节点）</p><p>node.ingest为true，缺省即为true，它能够在索引之前预处理文档，拦截文档的bulk和index请求，施加转换，然后再将文档传回给 bulk和index API。用户可以定义一个管道，指定一系列的预处理器，有点类似于logstash了哦。</p><p>（5）Tribe node（部落节点）</p><p>通过<code>tribe.*</code>配置，是一种特殊类型的协调节点，它连接多个集群，接受同事对多个集群的查询和操作。</p>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper技术调研</title>
      <link href="/2018/01/31/zookeeper%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/01/31/zookeeper%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="zookeeper简介"><a href="#zookeeper简介" class="headerlink" title="zookeeper简介"></a>zookeeper简介</h1><p>ZooKeeper是一个开放源码的分布式协调服务，由知名互联网公司雅虎创建，是Google Chubby的开源实现。ZooKeeper致力于提供一个高性能、高可用、且具有严格的顺序访问控制能力的分布式协调服务。分布式应用可以基于ZooKeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁以及分布式队列等功能。</p><h1 id="zookeeper的基本概念"><a href="#zookeeper的基本概念" class="headerlink" title="zookeeper的基本概念"></a>zookeeper的基本概念</h1><p>（1）节点角色</p><pre><code>Leader   —— 是整个zookeeper集群的核心Follower ——  Observer —— </code></pre><p>（2）会话Session</p><p>会话Session是指客户端和zookeeper服务器的连接，客户端与服务器建立一个TCP的长连接来维持一个Session。客户端启动时，会与服务器建立一个TCP连接。</p><p>（3）watcher</p><p>zookeeper允许用户在指定节点上注册一些watcher，当该数据节点发生变化时，zookeeper服务器会把这个变化通知给感兴趣的客户端。</p><p>（4）ACL权限控制</p><p>zookeeper采用ACL策略来进行权限控制，例如，</p><pre><code>CREATE    ## 创建子节点的权限READ      ## 获取节点数据和子节点列表的权限WRITE     ## 更新节点数据的权限DELETE    ## 删除子节点的权限ADMIN     ## 设置节点ACL的权限</code></pre><p>（5）snapshot</p><p>zookeeper集群中的所有节点以及数据都会存放到内存中，形成一棵树的数据结构。zookeeper集群会定期地把内存中的数据dump到本地磁盘上，称为快照snapshot。</p><p>（6）znode</p><p>zookeeper中每一个数据节点都称为一个zonde，注意这里的节点并非部署zookeeper的服务器节点哦，而是指zookeeper数据存储结构中节点啦。</p><p>（7）zxid</p><p>zookeeper状态的每一次改变，都对应着一个递增的Transaction id，该id就称为zxid。由于zxid的递增性质，如果zxid1小于zxid2，那么zxid1肯定先于zxid2发生。创建任意节点、更新任意节点的数据或者删除任意节点，都会导致zookeeper状态发生改变，从而导致zxid的值增加。</p><h1 id="zookeeper的znode节点类型"><a href="#zookeeper的znode节点类型" class="headerlink" title="zookeeper的znode节点类型"></a>zookeeper的znode节点类型</h1><p>（1）persistent节点</p><p>persistent节点不和特定的session绑定，不会随着创建该节点的session的结束而消失，而是一直存在，除非该节点被显式删除。</p><p>（2）ephemeral节点</p><p>ephemeral节点是临时性的，如果创建该节点的session结束了，该节点就会被自动删除。ephemeral节点不能拥有子节点。虽然ephemeral节点与创建它的session绑定，但只要该该节点没有被删除，其他session就可以读写该节点中关联的数据。使用-e参数指定创建ephemeral节点。</p><p>（3）sequence节点</p><p>严格的说，sequence并非节点类型中的一种。sequence节点既可以是ephemeral的，也可以是persistent的。创建sequence节点时，ZooKeeper server会在指定的节点名称后加上一个数字序列，该数字序列是递增的。因此可以多次创建相同的sequence节点，而得到不同的节点。使用-s参数指定创建sequence节点。</p><h1 id="zookeeper的数据结构模型"><a href="#zookeeper的数据结构模型" class="headerlink" title="zookeeper的数据结构模型"></a>zookeeper的数据结构模型</h1><p><img src="/images/zookeeper_1_1.png" alt></p><p>zookeeper的数据结构模型就形如上图，图中的每个节点称为一个znode，每个znode由3部分组成：</p><p>（1）stat</p><p>此为状态信息，描述该znode的版本，权限等信息。stat详细参数如下：</p><table><thead><tr><th>属性名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>czxid</td><td>节点创建时的zxid（Create）</td><td></td></tr><tr><td>mzxid</td><td>节点最新一次更新发生时的zxid（Mofify）</td><td>只表示本节点的修改，若子节点有修改，不会影响到mzxid</td></tr><tr><td>pzxid</td><td>是与该节点或其子节点的最近一次创建/删除时的zxid</td><td>只与本节点/该节点的子节点有关，与孙子节点无关</td></tr><tr><td>ctime</td><td>节点创建时的时间戳</td><td></td></tr><tr><td>mtime</td><td>节点最新一次更新发生时的时间戳</td><td></td></tr><tr><td>dataVersion</td><td>节点数据的更新次数</td><td></td></tr><tr><td>cversion</td><td>其子节点的更新次数</td><td></td></tr><tr><td>aclVersion</td><td>节点ACL（授权信息）的更新次数</td><td></td></tr><tr><td>ephemeralOwner</td><td>如果该节点为ephemeral节点，ephemeralOwner值表示与该节点绑定的session id；如果该节点不是ephemeral节点，ephemeralOwner值为0</td><td></td></tr><tr><td>dataLength</td><td>节点数据的字节数</td><td></td></tr><tr><td>numChildren</td><td>子节点个数</td><td></td></tr></tbody></table><p>（2）data</p><p>与该znode关联的数据。</p><p>（3）children</p><p>该znode下的子节点。</p><h1 id="zookeeper架构及读写过程"><a href="#zookeeper架构及读写过程" class="headerlink" title="zookeeper架构及读写过程"></a>zookeeper架构及读写过程</h1><p><img src="/images/zookeeper_1_2.png" alt></p><pre><code>（1）客户端提交请求（2）follower接受到请求，转发给leader（3，4）leader开始本地写，并且下发写操作到所有follower（5）某一个follower收到propose，开始写事务日志，此时并没有真正更新到内存中（6）写完日志后返回ack给leader，当leader收到加自己超过一半的机器的回复后，返回commit（7）所有follwer开始更新内存树。leader告诉发写请求的follower，follower再通知client写成功</code></pre><h1 id="zookeeper的应用场景"><a href="#zookeeper的应用场景" class="headerlink" title="zookeeper的应用场景"></a>zookeeper的应用场景</h1><pre><code>名字服务（Name Service）配置管理（Configuration Management）集群管理共享锁（Locks）队列管理</code></pre><h1 id="zookeeper集群的配置和搭建"><a href="#zookeeper集群的配置和搭建" class="headerlink" title="zookeeper集群的配置和搭建"></a>zookeeper集群的配置和搭建</h1><h2 id="搭建测试一：单节点zookeeper集群的配置和搭建"><a href="#搭建测试一：单节点zookeeper集群的配置和搭建" class="headerlink" title="搭建测试一：单节点zookeeper集群的配置和搭建"></a>搭建测试一：单节点zookeeper集群的配置和搭建</h2><p>（1）下载zookeeper二进制安装文件</p><p>在<code>http://zookeeper.apache.org/releases.html</code>页面下载zookeeper稳定的版本（本次部署测试用的是zookeeper-3.4.10）。然后解压即可。</p><p>（2）配置zookeeper</p><p>在${ZOOKEEPER_HOME}/conf目录中新建zoo.cfg配置文件，并增加如下内容：</p><pre><code>tickTime=2000dataDir=/var/lib/zookeeper    #存储zookeeper内存中数据的快照clientPort=2181               #zookeeper服务监听的端口</code></pre><p>zookeeper服务启动时，默认读取的是conf/zoo.cfg配置文件。</p><p>zookeeper中的数据在内存和本地磁盘中都存在，提供服务时，使用的是内存中的数据。同时zookeeper也会将内存中的快照存储到本地磁盘，当zookeeper重启或宕掉时，可以加载被持久化的快照来恢复服务。</p><p>（3）启动zookeeper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zkServer.sh start</span><br></pre></td></tr></table></figure><p>（4）测试连接zookeeper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zkCli.sh -server 192.168.65.239:2182</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.65.239 2182   <span class="comment">##连接上之后，执行stat命令查看zookeeper状态</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="built_in">stat</span> | nc 192.168.65.239 2182</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zkServer.sh status</span><br></pre></td></tr></table></figure><h2 id="搭建测试二：多节点的复制zookeeper集群的配置和搭建（伪集群）"><a href="#搭建测试二：多节点的复制zookeeper集群的配置和搭建（伪集群）" class="headerlink" title="搭建测试二：多节点的复制zookeeper集群的配置和搭建（伪集群）"></a>搭建测试二：多节点的复制zookeeper集群的配置和搭建（伪集群）</h2><p>（1）下载zookeeper二进制安装文件</p><p>在<code>http://zookeeper.apache.org/releases.html</code>页面下载zookeeper稳定的版本（本次部署测试用的是zookeeper-3.4.10）。解压之后，可以将目录名称命名为zookeeper-node-1。</p><p>（2）配置zookeeper zookeeper-node-1</p><p>在<code>${ZOOKEEPER_HOME}/conf</code>目录中新建zoo.cfg配置文件，并增加如下内容：</p><pre><code>tickTime=2000initLimit=10syncLimit=5dataDir=/root/prod/zookeeper-cluster/zookeeper-node-1/data    #存储zookeeper内存中数据的快照clientPort=2181    #zookeeper服务监听的端口# 配置zookeeper集群中的所有节点的ip和port信息server.1=192.168.65.239:2688:3688server.2=192.168.65.239:2788:3788server.3=192.168.65.239:2888:3888</code></pre><p>备注：</p><pre><code>server.id=host:port1:port2id    —— 是zookeeper集群中各节点的编号，id是阿拉伯数字host  —— host是主机的ip或机器名port1 —— 第一个port是follower节点和Leader节点的通信端口 port2 —— 第二个port是Leader重新选举时的投票通信端口</code></pre><p>（3）配置zookeeper节点的server.id</p><p>在<code>${ZOOKEEPER_HOME}/conf/zoo.cfg</code>中dataDir配置指定的目录（在本例中是/root/prod/zookeeper-cluster/zookeeper-node-1/data ）中，新建一个myid文件，写入一个阿拉伯数字，代表本zookeeper节点在zookeeper集群中的编号。假定此处设置为1。</p><p>（4）新建其他节点的程序环境</p><p>A）配置zookeeper-node-2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r zookeeper-node-1 zookeeper-node-2</span><br></pre></td></tr></table></figure><p>修改zookeeper-node-2/conf/zoo.cfg如下：</p><pre><code>dataDir=/root/prod/zookeeper-cluster/zookeeper-node-2/dataclientPort=2182</code></pre><p>修改/root/prod/zookeeper-cluster/zookeeper-node-2/data/myid，设置值为2。</p><p>B）配置zookeeper-node-3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r zookeeper-node-1 zookeeper-node-3</span><br></pre></td></tr></table></figure><p>修改zookeeper-node-3/conf/zoo.cfg如下：</p><pre><code>dataDir=/root/prod/zookeeper-cluster/zookeeper-node-3/dataclientPort=2183</code></pre><p>修改/root/prod/zookeeper-cluster/zookeeper-node-3/data/myid，设置值为3。</p><p>（5）启动zookeeper各个节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/prod/zookeeper-cluster/zookeeper-node-1 &amp;&amp; ./bin/zkServer.sh start</span><br><span class="line"><span class="built_in">cd</span> /root/prod/zookeeper-cluster/zookeeper-node-2 &amp;&amp; ./bin/zkServer.sh start</span><br><span class="line"><span class="built_in">cd</span> /root/prod/zookeeper-cluster/zookeeper-node-3 &amp;&amp; ./bin/zkServer.sh start</span><br></pre></td></tr></table></figure><p>（6）测试连接zookeeper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bin/zkCli.sh -server 192.168.65.239:2181</span><br><span class="line">./bin/zkCli.sh -server 192.168.65.239:2182</span><br><span class="line">./bin/zkCli.sh -server 192.168.65.239:2183</span><br></pre></td></tr></table></figure><p>备注：本次配置的伪zookeeper集群，如果有多台物理服务器，集群的配置方式和伪集群的配置差不多。</p><h1 id="zookeeper的客户端"><a href="#zookeeper的客户端" class="headerlink" title="zookeeper的客户端"></a>zookeeper的客户端</h1><p>ZooKeeper的客户端有如下几种：</p><p>（1）使用./bin/zkCli.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zkCli.sh -server ip:port</span><br></pre></td></tr></table></figure><p>常用的命令有ls/stat/get/create/set/get/delete/rmr。</p><p>（2）使用zookeeper JAVA api</p><p>使用zookeeper JAVA API来编程。</p><p>（3）开源客户端ZkClient</p><p>ZkClient是Github上一个开源的zookeeper客户端。ZkClient在zookeeper原生API接口之上进行了包装，是一个更加易用的zookeeper客户端。</p><p>（4）开源客户端Curator</p><p>Curator是Netflix公司开源的一套ZooKeeper客户端框架，Curator解决了很多的ZooKeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher等，实现了Fluent风格的API接口，目前已经成为Apache的顶级项目，是全世界范围内使用最广泛的ZooKeeper客户端之一。</p><h1 id="zookeeper的一些重要配置参数"><a href="#zookeeper的一些重要配置参数" class="headerlink" title="zookeeper的一些重要配置参数"></a>zookeeper的一些重要配置参数</h1><p>（1）tickTime</p><p>tickTime用于配置zookeeper中最小时间单元的长度，单位是毫秒ms。zookeeper中很多的时间配置都是用tickTime的倍数来表示，例如initLimit=5表示5倍的tickTime。</p><p>（2）initLimit</p><p>Follower节点在启动时，会与Leader节点建立连接，并同步Leader的数据，这个需要一定的时间。initLimit就是用来限制最大允许的同步时间。如果Follower节点从Leader同步数据的时间超过了initLimit设置的时间，那么就会同步失败。一般我们使用默认值就可以了，也就是initLimit=10。</p><p>（3）dataLogDir</p><p>用来配置存储zookeeper服务器的事务日志文件的路径位置。如果没有配置dataLogDir，zookeeper的事务日志文件默认和数据快照存在在一起（也就是dataDir配置的目录）。我们尽量将事务日志文件和数据快照存在在不同的地方，最好是存储到不同的磁盘上。</p><p>（4）electionAlg</p><p>用来配置zookeeper Leader选举的算法，但是从3.4.0，zookeeper只保留了fast-leader算法，因此这个参数没有什么作用了。</p><p>（5）syncLimit </p><p>用来设置Leader和Follower节点之间进行心跳检测的最大延迟时间。如果Leader节点在syncLimit设定的时间内没有收到Follower节点的心跳包，那么Leader节点会认为该Follower节点已经挂掉了。一般我们使用默认值就可以了，也就是syncLimit=5。</p><h1 id="zookeeper的4字命令"><a href="#zookeeper的4字命令" class="headerlink" title="zookeeper的4字命令"></a>zookeeper的4字命令</h1><p>zookeeper支持像conf/stat这样四个字母左右组成的命令，我们称之为“4字命令”。执行4字命令有两种方式：</p><p>（1）使用<code>telnet host port</code>登录zookeeper实例，然后执行stat/conf等这样的命令</p><p>（2）使用<code>echo stat | nc host port</code></p><p>下面列举一些常用的四字命令：</p><pre><code>stat —— 用于输出zookeeper集群的统计信息conf —— 列举出zookeeper的一些配置信息cons —— 列举出所有连接的客户端的详情crst —— 用于重置所有客户端的连接统计信息dump —— 用于输出当前集群所有会话信息ruok —— 用于输出当前zookeeper集群是否正在运行mntr —— 用于输出比stat更详细的统计信息</code></pre><p>还有其他的一些4字命令，不一一列出来。</p><h1 id="zookeeper监控平台的搭建和使用"><a href="#zookeeper监控平台的搭建和使用" class="headerlink" title="zookeeper监控平台的搭建和使用"></a>zookeeper监控平台的搭建和使用</h1><p>（1）exhibitor</p><p>netflix公司开发的，可以通过exhibitor来管理zookeeper集群，例如重启zookeeper节点、日志清除功能等。</p><p>（2）zabbix</p><p>用来监控zookeeper节点所在服务器的CPU/MEM/NET等信息。</p><p>（3）ambari监控zookeeper</p><h1 id="zookeeper集群的最佳实践"><a href="#zookeeper集群的最佳实践" class="headerlink" title="zookeeper集群的最佳实践"></a>zookeeper集群的最佳实践</h1><p>（1）一个具有3个节点的zookeeper集群可以支持12-13w QPS的压力</p><p>（2）zookeeper集群中，如果有超过一半节点是正常的，那么整个zookeeper集群就可以对外提供服务。否则集群停止对外服务。所以zookeeper集群最好使用奇数个节点，比如3，5，7个节点。比如一个集群有4个节点，因为超过半数才正常，所有该集群也只允许一个节点挂掉。</p><p>（3）使用jps命令可以查看zookeeper的进程名，进程名为QuorumPeerMain</p><p>学习资料参考于：<br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a><br><a href="http://coolxing.iteye.com/blog/1871328" target="_blank" rel="noopener">http://coolxing.iteye.com/blog/1871328</a></p>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka集群运维工具</title>
      <link href="/2018/01/31/Kafka%E9%9B%86%E7%BE%A4%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/01/31/Kafka%E9%9B%86%E7%BE%A4%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka集群的web管理工具"><a href="#Kafka集群的web管理工具" class="headerlink" title="Kafka集群的web管理工具"></a>Kafka集群的web管理工具</h1><p>Kafka集群的web管理工具有很多，例如：</p><p>（1）Kafka Web Conslole</p><p>（2）Kafka Manager</p><p>（3）KafkaOffsetMonitor</p><p>具体参见<a href="http://kaimingwan.com/post/kafka/kafka-managershi-yong-jiao-cheng" target="_blank" rel="noopener">http://kaimingwan.com/post/kafka/kafka-managershi-yong-jiao-cheng</a></p><p>（4）Kafka-monitor</p><p>具体参见项目地址：<a href="https://github.com/linkedin/kafka-monitor" target="_blank" rel="noopener">https://github.com/linkedin/kafka-monitor</a></p><p>（5）Kafka Eagle</p><h1 id="Kafka-Manager"><a href="#Kafka-Manager" class="headerlink" title="Kafka Manager"></a>Kafka Manager</h1><p>（1）Kafka Manager简介</p><p>Kafka Manager是Yahoo开源的Kafka集群管理工具，Kafka Manager主要支持以下几个功能：</p><pre><code>管理几个不同的集群很容易地检查集群的状态(topics, brokers, 副本的分布, 分区的分布)选择副本产生分区分配(Generate partition assignments)基于集群的当前状态重新分配分区。。。。</code></pre><p>（2）Kafka Manager的配置与安装</p><p>Kafka Manager的配置与安装步骤如下：</p><p>A）下载并安装构建工具sbt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install java-1.8.0-devel</span><br><span class="line">rpm -ivh sbt-0.13.15.rpm</span><br></pre></td></tr></table></figure><p>备注：sbt的安装依赖java1.8开发包</p><p>B）下载kafka-manager源文件，并解压</p><p>在Github地址：<code>https://github.com/yahoo/kafka-manager</code>上下载项目源码，假设为kafka-manager-master.zip，解压缩并将目录重命名为kafka-manager。</p><p>C）使用sbt构建kafka-manager源文件</p><p>执行<code>cd kafka-manager &amp;&amp; sbt clean dist</code>命令，命令执行完成后会在kafka-manager\target\universal目录下生成一个zip部署包。</p><p>备注：这个过程需要连接网络，可能执行的时间会比较长。</p><p>D）部署kafka-manager</p><p>将（3）中产生的部署包，分发到任意一台机器，并解压，修改配置文件kafka-manager/conf/application.conf，为kafka manager配置一个zookeeper实例，用来管理kafka manager自身的一些状态和配置信息（不是kafka集群连接的zookeeper哦，当然，这里可以复用kafka集群的zk哦 ），例如：</p><pre><code>kafka-manager.zkhosts=&quot;10.26.30.92:2181,10.26.30.94:2181,10.26.30.96:2181&quot;</code></pre><p>备注：部署机上不依赖sbt工具，所以我们可以在Windows上安装sbt，然后构建kafka-manager，最后将生成的部署包部署到linux服务器上也是可以的。</p><p>E）启动kafka-manager</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-manager   <span class="comment">#默认监听9000端口</span></span><br><span class="line">./bin/kafka-manager -Dconfig.file=/path/to/application.conf -Dhttp.port=8080 <span class="comment">#启动时，为kafka-manager指定配置文件和端口</span></span><br></pre></td></tr></table></figure><p>F）测试</p><p>使用浏览器打开<a href="http://hostname:9000" target="_blank" rel="noopener">http://hostname:9000</a></p><p>G）在Kafka-manager界面上添加集群，包括自定义Kafka集群的名称，Kafka集群使用到的zk集群，Kafka的版本等信息。</p><p><img src="/images/kafka_2_1.png" alt></p><p>备注：一个kafka-manager可以管理多个kafka集群</p><p>（3）开启kafka的JMX，让kafka-manager获取更细粒度的监控信息</p><p>A）修改<code>${KAFKA_HOME}/bin/kafka-run-class.sh</code>, 为KAFKA_JMX_OPTS变量增加java.rmi.server.hostname参数，这样避免远程连接JMX端口失败的问题，形式如下：</p><pre><code>KAFKA_JMX_OPTS=&quot;-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false  -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=10.26.30.96&quot;</code></pre><p>B）修改<code>${KAFKA_HOME}/bin/kafka-server-start.sh</code>中增加JMX_PORT环境变量，形式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$KAFKA_HEAP_OPTS</span>"</span> = <span class="string">"x"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">"-Xmx1G -Xms1G"</span></span><br><span class="line">    <span class="built_in">export</span> JMX_PORT=<span class="string">"8999"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>C）在kafka-manager中打开集群的JMX选项</p><p><img src="/images/kafka_2_2.png" alt></p><p>备注：我们也可以直接在Windows上使用jsconsole来连接JMX（hostname:port）来查看一个监控参数，界面如下：</p><p><img src="/images/kafka_2_3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka技术调研</title>
      <link href="/2018/01/31/Kafka%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/01/31/Kafka%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的消息队列Message-Queue，MQ"><a href="#常见的消息队列Message-Queue，MQ" class="headerlink" title="常见的消息队列Message Queue，MQ"></a>常见的消息队列Message Queue，MQ</h1><p>（1）RabbitMQ</p><p>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</p><p>（2）Redis</p><p>Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</p><p>（3）ZeroMQ</p><p>ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter的Storm 0.9.0以前的版本中默认使用ZeroMQ作为数据流的传输（Storm从0.9版本开始同时支持ZeroMQ和Netty作为传输模块）。</p><p>（4）ActiveMQ</p><p>ActiveMQ是Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。</p><p>（5）Kafka/Jafka<br>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</p><p>如下为Kafka、RabbitMQ以及RocketMQ的一点区别，权威性待验证。</p><p>Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。</p><p>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p><p>RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。</p><p><img src="/images/kafka_1_5.png" alt></p><h1 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h1><p>Kafka是由LinkedIn开发的一个分布式的消息系统，使用Scala编写（Scala程序是运行在JDK上的），它以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如Cloudera、Apache Storm、Spark都支持与Kafka集成。</p><p><img src="/images/kafka_1_1.png" alt></p><p>Kafka集群的组成部分有：</p><p>（1）Broker</p><p>Kafka集群包含一个或多个服务器，这种服务器被称为broker 。</p><p>（2）Topic</p><p>Topic是逻辑上的概念。每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处。如下为一个topic的解剖图：</p><p><img src="/images/kafka_1_2.png" alt></p><p>备注：这个topic有3个partition，每一个partition中的数据是按时间有序的。</p><p>（3）Partition</p><p>Parition是物理上的概念。每个Topic包含一个或多个Partition，每个partition又由一个一个消息组成，每个消息都被标识了一个递增序列号代表其进来的先后顺序，并按顺序存储在partition中。Partition是kafka消息队列组织的最小单位。对于某一个Partition来说，它只会存储在某个broker上（就是某台机器上），而不会分布在多台机器上，当然这个Partition有Replica的话，它的Replica是分布在其他的Broker上的。</p><p>（4）Producer</p><p>负责发布消息到Kafka broker 。</p><p>（5）Consumer</p><p>消息消费者，向Kafka broker读取消息的客户端。</p><p>（6）Consumer Group</p><p>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p><p>（7）Controller</p><p>每个Cluster当中会选举出一个Broker来担任Controller，负责处理Partition的Leader选举，协调Partition迁移等工作。</p><p>备注：Topic相当于pipe，Partition相当于pipelet。</p><h1 id="关于Consumer和Consumer-Group的一点补充"><a href="#关于Consumer和Consumer-Group的一点补充" class="headerlink" title="关于Consumer和Consumer Group的一点补充"></a>关于Consumer和Consumer Group的一点补充</h1><p>传统的消息队列的消息消费有两种模式：</p><p>（1）队列模式-Queue</p><p>在队列模式中，一条消息只能被某一个消费者消费，一条消息一旦被消费后，其他的消费者就获取不到这条消息了。</p><p>（2）发布/订阅模式-Topic</p><p>在发布/订阅模式中，消息可以被所有的消费者消费。</p><p>在Kafka中，通过使用Consumer Group的机制，Kafka集群就涵盖了上述两种的模式。每一个Consumer都存在于某个Consumer Group中。各个Consumer Group使用发布/订阅模式来消费数据，也就是说每个Consumer Group都可以消费消息队列中的所有消息。而对于单独的一个Consumer Group所包含的所有Consumer，则使用队列模式来消费消息，也就是Consumer Group订阅到的某一条消息，只能被该Group中的某一个Consumer消费。</p><p>如果Kafka中，所有Consumer Group都包含一个Consumer的话，那其实就相当于是发布/订阅模式。下图形象地说明了Kafka的消息消费方式：</p><p><img src="/images/kafka_1_3.png" alt></p><p>另外，属于同一个Consumer Group的多个Consumer在消费信息时，也有一定的balance策略。当Consumer和Partition的数量相同时，那么每个Consumer都会去消费一个Partition。当Consumer比Partition的数据要少时，那么有些Consumer就会去消费多个Partition。当Consumer比Partition的数据要多时，那么有些Consumer就不会从任何Partition中订阅数据。此部分内容可参见<a href="http://www.jasongj.com/2015/01/02/Kafka%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">《Kafka深度解析》</a>。</p><h1 id="Kafka集群配置和搭建"><a href="#Kafka集群配置和搭建" class="headerlink" title="Kafka集群配置和搭建"></a>Kafka集群配置和搭建</h1><p>前提声明：本次部署测试用的是kafka_2.12-0.10.2.0</p><p><strong><em>搭建测试一：单broker的Kafka集群搭建</em></strong></p><p>（1）下载kafka二进制包</p><p>（2）启动只有一个节点的应急的zookeeper集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><p>连接zookeeper集群并测试：<code>./bin/zookeeper-shell.sh 192.168.65.239:2181</code>（备注：zookeeper的默认端口是2181）</p><p>（3）启动一个kafka broker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure><p>（4）创建测试用的topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名称为wahaha的topic，有1个partition，复制因子为1（单副本，就是没有备份）</span></span><br><span class="line">./bin/kafka-topics.sh --create --zookeeper 192.168.65.239:2181 --replication-factor 1 --partitions 1 --topic wahaha</span><br></pre></td></tr></table></figure><p>查看集群中的所有topic信息：<code>./bin/kafka-topics.sh --list --zookeeper 192.168.65.239:2181</code></p><p>备注：也可以在broker配置，使其能够自动创建topic，而不需要手动去创建topic</p><p>（5）向Kafka集群中指定的topic写入一些消息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-producer.sh --broker-list 192.168.65.239:9092 --topic wahaha</span><br></pre></td></tr></table></figure><p>备注：使用Ctrl+D结束输入</p><p>（6）消费Kafka集群中指定topic的消息（如下两种方式都是可以的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-consumer.sh --bootstrap-server 192.168.65.239:9092 --topic wahaha --from-beginning</span><br><span class="line">./bin/kafka-console-consumer.sh --zookeeper 192.168.65.239:2181 --topic wahaha --from-beginning</span><br></pre></td></tr></table></figure><p><strong><em>搭建测试二：多broker的Kafka集群搭建</em></strong></p><p>前提：在同一台物理机上通过启动3个broker进程，来达到搭建有3个broker的Kafka集群，步骤如下：</p><p>（1）下载kafka二进制包</p><p>（2）启动只有一个节点的应急的zookeeper集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><p>连接zookeeper集群并测试：<code>./bin/zookeeper-shell.sh 192.168.65.239:2181</code>（备注：zookeeper的默认端口是2181）</p><p>（3）启动三个kafka broker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> config &amp;&amp; mv server.properties server-1.properties</span><br><span class="line"><span class="built_in">cd</span> config &amp;&amp; cp server-1.properties server-2.properties</span><br><span class="line"><span class="built_in">cd</span> config &amp;&amp; cp server-1.properties server-3.properties</span><br></pre></td></tr></table></figure><p>修改config/server-1.properties内容如下：</p><pre><code>broker.id=1listeners=PLAINTEXT://192.168.65.239:9092log.dir=/tmp/kafka-logs-1</code></pre><p>修改config/server-2.properties内容如下：</p><pre><code>broker.id=2listeners=PLAINTEXT://192.168.65.239:9093log.dir=/tmp/kafka-logs-2</code></pre><p>修改config/server-3.properties内容如下：</p><pre><code>broker.id=3listeners=PLAINTEXT://192.168.65.239:9094log.dir=/tmp/kafka-logs-3</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-server-start.sh [-daemon] config/server-1.properties   <span class="comment">#启动监听默认9092端口的broker</span></span><br><span class="line">./bin/kafka-server-start.sh [-daemon] config/server-2.properties   <span class="comment">#启动监听默认9093端口的broker</span></span><br><span class="line">./bin/kafka-server-start.sh [-daemon] config/server-3.properties   <span class="comment">#启动监听默认9094端口的broker</span></span><br></pre></td></tr></table></figure><p>备注：加上-daemon选项，将会在后台启动broker进程；另外，在实际部署kafka集群时，注意listens中的配置格式哦</p><p>（4）创建测试用的topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名称为wahaha-replicas的topic，有1个partition，复制因子为3（三副本）</span></span><br><span class="line">./bin/kafka-topics.sh --create --zookeeper 192.168.65.239:2181 --replication-factor 3 --partitions 1 --topic wahaha-replicas</span><br></pre></td></tr></table></figure><p>备注：也可以在broker配置，使其能够自动创建topic，而不需要手动去创建topic</p><p>（5）向Kafka集群中指定的topic写入一些消息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-producer.sh --broker-list 192.168.65.239:9093 --topic wahaha-replicas</span><br></pre></td></tr></table></figure><p>备注：broker的端口9092,9093,9094都可以用的。–broker-list只需要随便给下broker的ip:port，不用给全部，参见metadata.broker.list</p><p>（6）消费Kafka集群中指定topic的消息（如下两种方式都是可以的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-consumer.sh --bootstrap-server 192.168.65.239:9092 --topic wahaha-replicas --from-beginning</span><br><span class="line">./bin/kafka-console-consumer.sh --zookeeper 192.168.65.239:2181 --topic wahaha --from-beginning</span><br></pre></td></tr></table></figure><h1 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h1><p>AMQP，Advanced Message Queuing Protocol，中文译为高级消息队列协议。AMQP是一个标准开放的应用层的消息中间件（Message Oriented Middleware）协议。AMQP定义了通过网络发送的字节流的数据格式。因此兼容性非常好，任何实现AMQP协议的程序都可以和与AMQP协议兼容的其他程序交互，可以很容易做到跨语言，跨平台。 像ActiveMQ/RabbitMQ都按照AMQP协议来实现，而Kafka是仿照AMQP协议来实现的。</p><h1 id="Kafka集群搭建最佳实践"><a href="#Kafka集群搭建最佳实践" class="headerlink" title="Kafka集群搭建最佳实践"></a>Kafka集群搭建最佳实践</h1><p>（1）kafka集群最好部署在相同局域网的环境里，不要部署在不同的网络环境里。跨数据中心延迟大，大大影响kafka、zk写入效率以及分区复制效率。</p><p>（2）磁盘推荐使用RAID，但是SSD是非必需的。</p><p>（3）kafka集群的重要配置项</p><pre><code>zookeeper.connect # 必配参数，建议在kafka集群的每台机器都配置所有zkbroker.id         # 必配参数，集群节点的标示符，不得重复。取值范围0~nlog.dirs          # 配置broker存放数据的位置，不要使用默认的/tmp/kafka-logsnum.partitions    # 自动创建topic时默认partition数量。默认是1，为了获得更好的性能，建议修改为更大default.replication.factor # 自动创建topic的默认副本数量，官方建议修改为2，也就是在kafka集群中同一个消息有两份metadata.broker.list  # 给出一些broker地址，没必要将集群中所有的broker都添加到这个属性中，但是建议最少设置两个，以防止第一个broker不可用。Kafka会自己找到相应topic/partition的leader brokerlog.retention.hours   # kafka数据保留时间log.segment.bytes     # partition在磁盘的文件不能超过log.segment.bytes大小，如果超过该指，则重新写入一个新文件，即新的segment</code></pre><p>（4）在发布数据时，需要通过broker-list来指定broker的ip和port，这里其实不需要把集群中的所有broker都配置上去，因为发布端api可以通过一台broker获取到集群所有的metadata。而订阅数据时，只需要指定zookeeper地址即可。</p><h1 id="Kafka的HA设计"><a href="#Kafka的HA设计" class="headerlink" title="Kafka的HA设计"></a>Kafka的HA设计</h1><p>（1）Kafka中的HA设计</p><p>A）Kafka的Replication机制</p><p>Kafka在0.8以前的版本中，并不提供High Availablity机制，一旦一个或多个Broker宕机，则宕机期间其上所有Partition都无法继续提供服务。若该Broker永远不能再恢复，亦或磁盘故障，则其上数据将丢失。而Kafka的设计目标之一即是提供数据持久化，同时对于分布式系统来说，尤其当集群规模上升到一定程度后，一台或者多台机器宕机的可能性大大提高，对Failover要求非常高。因此，Kafka从0.8开始提供High Availability机制。</p><p>B）Kafka的Leader Election机制</p><p>引入Replication之后，同一个Partition可能会有多个Replica，而这时需要在这些Replication之间选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。 因为需要保证同一个Partition的多个Replica之间的数据一致性（其中一个宕机后其它Replica必须要能继续服务并且即不能造成数据重复也不能造成数据丢失）。如果没有一个Leader，所有Replica都可同时读/写数据，那就需要保证多个Replica之间互相（N×N条通路）同步数据，数据的一致性和有序性非常难保证，大大增加了Replication实现的复杂性，同时也增加了出现异常的几率。而引入Leader后，只有Leader负责数据读写，Follower只向Leader顺序Fetch数据（N条通路），系统更加简单且高效。如下为引入Replication机制后数据的同步过程图：</p><p><img src="/images/kafka_1_4.png" alt></p><p>（2）Kafka中replica的均衡分布算法</p><p>Kafka中同一个topic中多个partition，以及每个partition的多个replica，在Kafka集群中的分布算法如下：</p><pre><code>将所有Broker（假设共n个Broker）和待分配的Partition排序将第i个Partition分配到第（i mod n）个Broker上将第i个Partition的第j个Replica分配到第（(i + j) mode n）个Broker上</code></pre><p>（3）Kafka中partition的Leader Election选主算法</p><p>实际上，Leader Election算法非常多，比如ZooKeeper的Zab, Raft和Viewstamped Replication。而Kafka所使用的Leader Election算法更像微软的PacificA算法。</p><h1 id="Kafka中的一些常用操作"><a href="#Kafka中的一些常用操作" class="headerlink" title="Kafka中的一些常用操作"></a>Kafka中的一些常用操作</h1><p>（1）查看集群中的所有topic信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-topics.sh --list --zookeeper 192.168.65.239:2181</span><br></pre></td></tr></table></figure><p>（2）查看集群中指定topic的详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-topics.sh --describe --zookeeper 192.168.65.239:2181 --topic wahaha-replicas</span><br></pre></td></tr></table></figure><p>其中，leader负责给定分区中所有的读和写的任务，分区将随即选取一个节点作为leader； replicas列出了所有当前分区中的副本节点，不论这些节点是否是leader或者是否处于激活状态，都会被列出来；isr是表示“在同步中”的副本节点的列表，是replicas列表的一个子集，包含了当前处于激活状态的节点，并且leader节点开头。</p><p>（3）给一个topic增加partition</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-topics.sh --zookeeper 192.168.65.239:2181 --alter --topic wahaha-replicas --partitions 3</span><br></pre></td></tr></table></figure><p>备注：增加了分区或增加了broker节点，原有的数据并不会rebalance，可以使用Kafka自带的kafka-reassign-partitions.sh工具进行rebalance。</p><h1 id="Kafka中消息发送端Producer的可靠性保证"><a href="#Kafka中消息发送端Producer的可靠性保证" class="headerlink" title="Kafka中消息发送端Producer的可靠性保证"></a>Kafka中消息发送端Producer的可靠性保证</h1><p>发布端Producer可以通过acks参数来决定发布时的一些控制，具体如下：</p><pre><code>acks=0   #producer不等待broker的acks。发送的消息可能丢失，但永远不会重发acks=1   #leader不等待其他follower同步，leader直接写log然后发送acks给producer。这种情况下会有重发现象，可靠性比only once好点，但是仍然会丢消息。例如leader挂了了，但是其他replication还没同步完成acks=all #leader等待所有follower同步完成才返回acks。消息可靠不丢失（丢了会重发），没收到ack会重发</code></pre><p>备注：当acks=all的时候，就算你设置retries=0也依然会重发</p><h1 id="Kafka集群的压力测试"><a href="#Kafka集群的压力测试" class="headerlink" title="Kafka集群的压力测试"></a>Kafka集群的压力测试</h1><p>Kafka集群的压力测试，可以使用Kafka自带的kafka-producer-perf-test.sh和kafka-consumer-perf-test.sh工具，使用方法如下：</p><p>（1）发布压力测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-producer-perf-test.sh --topic <span class="built_in">test</span>-benchmark --num-records 100000000 --record-size 1024 --throughput 5000000 --producer-props bootstrap.servers=192.168.65.239:9092,192.168.65.239:9093 acks=all retries=2 linger.ms=1</span><br></pre></td></tr></table></figure><p>（2）订阅压力测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-consumer-perf-test.sh --topic wahaha-replicas --batch-size 10000 --num-fetch-threads 2 --threads 10 --show-detailed-stats --group kafka.benchmark --messages 100000000 --broker-list 192.168.65.239:9092,192.168.65.239:9093</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://www.infoq.com/cn/articles/kafka-analysis-part-1" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/kafka-analysis-part-1</a></p>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flume技术调研</title>
      <link href="/2018/01/31/Flume%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/01/31/Flume%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="Flume简介"><a href="#Flume简介" class="headerlink" title="Flume简介"></a>Flume简介</h1><p>Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，目前已经是Apache的一个子项目。在Flume中有一个event的概念，event就是Flume处理数据的最小单元。</p><p>Flume的内部是由Source、Channel以及Sink三个组件组成：</p><p><img src="/images/flume_1_1.png" alt></p><p>（1）Source</p><p>Source组件用来与要搜集的外部数据源做交互，Source支持很多的数据源，例如文件以及thrift等RPC数据。</p><p>（2）Sink</p><p>Sink组件用来与外部存储做交互，Sink支持向文件系统、数据库、hadoop存数据。</p><p>（3）Channel</p><p>Channel组件是用来连接Source和Sink的数据通道，当前有如下几个channel可供选择（比较常见的是前三种channel）：</p><p>A）Memory Channel</p><p>把event放到内存队列当中，使用这种channel的优点是速度最快的channel、容易配置 。缺点是当flume agent挂掉时会导致数据丢失。</p><p>B）File Channel</p><p>持久化event到磁盘 ，可靠性很好 ，但是速度慢。</p><p>C）JDBC Channel</p><p>event持久化存储到DB。现在仅支持嵌入式的derby ，可以防止丢数据了，而且还提供了一些数据管理 。但是持久化到DB仅支持derby，选择较少，速度没有memory channel快</p><p>D）Psuedo Transaction Channel </p><h1 id="Flume在生产环境中的应用"><a href="#Flume在生产环境中的应用" class="headerlink" title="Flume在生产环境中的应用"></a>Flume在生产环境中的应用</h1><p>Flume在生产环境的部署结构非常灵活，如下为一种部署架构的例子：</p><p><img src="/images/flume_1_2.png" alt></p><p>Flume具有如下的特性：</p><p>（1）Channel中的数据只有在Sink组件发送成功后才会被删除</p><p>（2）在整个数据的传输过程中流动的是event，event可以理解为是flume中数据传输的基本单位，event表现为一条条的数据，其事务保证是event级别</p><p>（3）flume支持多级flume的agent，支持扇入(fan-in)和扇出(fan-out)</p><h1 id="Flume的配置和安装"><a href="#Flume的配置和安装" class="headerlink" title="Flume的配置和安装"></a>Flume的配置和安装</h1><p>（1）Flume下载和安装</p><p>在<code>https://flume.apache.org/download.html</code>中下载Apache Flume二进制版本，解压到目标目录即可。</p><p>（2）Flume配置</p><p>A）JAVA环境变量配置，有两种方式</p><p>配置JDK环境变量（PATH，JAVA_HOME, CLASS_PATH），或者在${JAVA_HOME}/conf/flume-env.sh中增加<code>export JAVA_HOME=/root/prod/jdk1.7.0_80</code>即可。后者很好用，这样就不会对操作系统中已有的应用程序带来影响。</p><p>B）Flume自身的配置</p><p>在conf目录新建一个flume的配置文件，假设为flume-my.conf，配置举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># flume-my.conf: A single-node Flume configuration</span><br><span class="line"></span><br><span class="line"># agent1的名称可以自定义，定义了sources，sinks，channels三个组件</span><br><span class="line">agent1.sources = r1</span><br><span class="line">agent1.sinks = k1 elasticsearch  #这里配置两个sink，一个写入本地文件系统，一个写入ElasticSearch</span><br><span class="line">agent1.channels = c1</span><br><span class="line"></span><br><span class="line"># 配置sources</span><br><span class="line">agent1.sources.r1.type  =  TAILDIR</span><br><span class="line">agent1.sources.r1.positionFile  =  /root/prod/apache-flume-1.7.0-bin/var/progress/taildir_position.json</span><br><span class="line">agent1.sources.r1.filegroups  =  f1</span><br><span class="line">agent1.sources.r1.filegroups.f1  =  /root/prod/test-env/input-data/error.log</span><br><span class="line">agent1.sources.r1.headers.f1.headerKey1  =  value1</span><br><span class="line">agent1.sources.r1.fileHeader  =  true</span><br><span class="line"></span><br><span class="line"># 配置sink</span><br><span class="line">## 配置写入本地文件系统的sink</span><br><span class="line">agent1.sinks.k1.type = file_roll</span><br><span class="line">agent1.sinks.k1.sink.directory  =  /root/prod/test-env/output-data</span><br><span class="line">## 配置写入ElasticSearch的sink</span><br><span class="line">agent1.sinks.elasticsearch.type = org.apache.flume.sink.elasticsearch.ElasticSearchSink</span><br><span class="line">agent1.sinks.elasticsearch.hostNames = 10.168.65.239:9300</span><br><span class="line"></span><br><span class="line"># 配置channel</span><br><span class="line">agent1.channels.c1.type = memory</span><br><span class="line">agent1.channels.c1.capacity = 1000</span><br><span class="line">agent1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># 为source和sink绑定channel</span><br><span class="line">agent1.sources.r1.channels = c1</span><br><span class="line">agent1.sinks.k1.channel = c1</span><br><span class="line">agent1.sinks.elasticsearch.channel = c1</span><br></pre></td></tr></table></figure><p>备注：agent1是自定义的agent的名称</p><p>（3）启动flume命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/prod/apache-flume-1.7.0-bin/ &amp;&amp; ./bin/flume-ng agent --conf /root/prod/apache-flume-1.7.0-bin/conf/ --conf-file /root/prod/apache-flume-1.7.0-bin/conf/flume-my.conf --name agent1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><p>备注：</p><p>A）–name agent_name指定的flume agent名称要与flume配置文件中自定义的agent名称一致</p><p>B）-Dflume.root.logger=INFO,console中表示flume自身的日志输出到控制台中，如果是-Dflume.root.logger=INFO,LOGFILE表示将日志输出到文件中</p><h1 id="Flume中的拦截器Interceptor"><a href="#Flume中的拦截器Interceptor" class="headerlink" title="Flume中的拦截器Interceptor"></a>Flume中的拦截器Interceptor</h1><p>Flume中拦截器的作用就是对于event中header的部分可以按需塞入一些属性，当然你如果想要处理event的body内容，也是可以的，但是event的body内容是系统下游阶段真正处理的内容，如果让Flume来修饰body的内容的话，那就是强耦合了，这就违背了当初使用Flume来解耦的初衷了。</p><h1 id="Flume的闲杂知识"><a href="#Flume的闲杂知识" class="headerlink" title="Flume的闲杂知识"></a>Flume的闲杂知识</h1><p>在Flume中，event是流动的数据的最小单元，就是我们理解的一条日志。event包括event header和event body两部分。event body就是我们实际的数据，event header可以根据用户自定义配置，例如很多interceptor就是往event header中写入信息，供下游的flume组件来使用。从数据结构上来说，event由头<code>Map&lt;String, String&gt; headers</code>和身体<code>body</code>两部分组成：Headers部分是一个map，body部分可以是String或者byte[]等。其中body部分是真正存放数据的地方，headers部分用于interceptor特性等。</p><p><img src="/images/flume_1_3.png" alt></p><h1 id="Flume的最佳实践"><a href="#Flume的最佳实践" class="headerlink" title="Flume的最佳实践"></a>Flume的最佳实践</h1><p>（1）flume source文件正则的使用</p><p>在flume1.7.0的TAILDIR Source中通过正则来匹配数据源文件，例如<code>agent.sources.r2.filegroups.f1  =  /root/prod/test-env/input-data/messages(.*)?</code>，如果修改文件的文件名，flume也认为是一个新文件，从而导致数据被重复搜集的问题。有blog反馈这个问题是bug，如<code>https://kknews.cc/other/enx3mk4.html</code>，需要注意下这个问题。</p><p>（2）当我们使用<code>agent.sources.r2.filegroups.f1  =  /root/prod/test-env/input-data/messages</code>的绝对路径来匹配文件时，无论我们使用<code>move+touch</code>，或者<code>copy+置空</code>的方式来切割日志文件，flume都能正常收集messages文件中日志内容。</p><h1 id="Flume自定义Interceptor的开发"><a href="#Flume自定义Interceptor的开发" class="headerlink" title="Flume自定义Interceptor的开发"></a>Flume自定义Interceptor的开发</h1><p>待补充</p>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logstash技术调研</title>
      <link href="/2018/01/31/logstash%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/01/31/logstash%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="logstash简介"><a href="#logstash简介" class="headerlink" title="logstash简介"></a>logstash简介</h1><p>Logstash事件处理流水线有三个阶段：<code>输入-&gt;过滤器-&gt;输出</code>。输入生成事件，过滤器修改它们，并将其输出到其他地方。</p><p>（1）输入，logstash的输入包括有文件、syslogn、redis、beats等</p><p>（2）过滤器，logstash的过滤器有grok、mutate、drop、clone以及geoip等</p><p>（3）输出，logstash的输出有ElasticSearch、文件、graphite等</p><p><img src="/images/logstash_1_1.png" alt></p><p>Logstash拥有丰富的输入，过滤器，编解码器和输出插件，要会使用各种插件，例如用来从文件读取数据源的插件logstash-input-file，将数据写入ES的插件logstash-output-elasticsearch。如果要查看当前logstash拥有的插件，可以执行<code>./bin/logstash-plugin list</code>命令查看。</p><p><img src="/images/logstash_1_2.png" alt></p><h1 id="logstash的配置与安装"><a href="#logstash的配置与安装" class="headerlink" title="logstash的配置与安装"></a>logstash的配置与安装</h1><p>前提声明：本次部署测试使用的是logstash-5.3.0</p><p>（1）下载logstash二进制部署包，并解压缩</p><p>（2）配置logstash</p><p>这里的配置logstash，是指配置logstash的input/filter/output等信息，建议在${LOGSTASH_HOME}下新建conf目录，然后创建一个任意名称的文件，假设此处新建一个nginx-error.conf的文件。配置内容形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">        path =&gt; &quot;/root/prod/test-env/input-data/error.log.bak&quot;</span><br><span class="line">        type =&gt; &quot;nginx-error&quot;</span><br><span class="line">        start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）启动logstash</p><p>执行命令<code>./bin/logstash -f conf/nginx-error.conf</code>即可</p><h1 id="logstash的配置"><a href="#logstash的配置" class="headerlink" title="logstash的配置"></a>logstash的配置</h1><p>logstash配置格式有四个需要注意的地方，分别是区域、数据类型、条件判断、字段引用。</p><p>（1）区域</p><p>logstash中，是用花括号{}来定义区域的，区域内可以使用插件。一个区域内可以定义多个插件。</p><p>（2）数据类型</p><p>布尔类型boolean，举例来说<code>ssl_enable=&gt;true</code></p><p>字符串类型string，举例来说<code>name=&gt;&quot;Hello World&quot;</code></p><p>数组Array，举例来说<code>match=&gt;[&quot;datetime&quot;,&quot;UNIX&quot;,&quot;ISO8601&quot;]</code></p><p>哈希Hash，举例来说<code>options=&gt;{key1=&gt;&quot;value1&quot;,key2=&gt;&quot;value2&quot;}</code></p><p>（3）条件判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if EXPRESSION &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; else if EXPRESSION &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）字段引用</p><h1 id="logstash的插件"><a href="#logstash的插件" class="headerlink" title="logstash的插件"></a>logstash的插件</h1><p>logstash有四类插件，如下</p><pre><code>inputs  —— 输入的插件codecs  —— 解码的插件filters —— 过滤的插件outputs —— 输出的插件</code></pre><p>可以在<code>https://github.com/logstash-plugins</code>查看一些logstash的插件</p><h1 id="logstash各种插件的使用"><a href="#logstash各种插件的使用" class="headerlink" title="logstash各种插件的使用"></a>logstash各种插件的使用</h1><p>（1）grok插件</p><p>grok用于将任意的文本进行结构化处理。grok是目前logstash中将混乱的非结构日志数据，进行结构化的最好方式。 用这个工具来解析syslog日志，apache或其他webserver日志，mysql日志的效果非常好。grok的基本语法是%{SYNTAX:SEMANTIC}。</p><p>其中SANTAX是用于匹配目标文本的模式的名称，SEMANTIC是我们用来自定义这个被匹配文本的字段名称。例如，%{IP:client_ip}就能够匹配IP地址，并将该字段命名为client_ip.</p><p>grok有120多种默认的模式，可以到<code>https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns</code>上查看。当然了我们也可以自定义自己的模式，自定义模式有两种方式，一种是类似<code>(?&lt;field_name&gt;the pattern here)</code>，例如<code>(?&lt;queue_id&gt;[0-9A-F]{10,11})</code>，其中queue_id是自定义模式名，后面是正则匹配。另一种是在logstash的安装目录中创建一个patterns目录，然后在其中创建一些文件，文件内容类似于<code>POSTFIX_QUEUEID [0-9A-F]{10,11}</code>，然后在grok插件中可以使用该模式。</p><p>如果数据源的格式不统一，我们可以在grok中定义多个正则规则，举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">match =&gt; [</span><br><span class="line">    &quot;message&quot;, &quot;(?&lt;request_time&gt;\d+(?:\.\d+)?)&quot;,</span><br><span class="line">    &quot;message&quot;, &quot;%&#123;SYSLOGBASE&#125; %&#123;DATA:message&#125;&quot;,</span><br><span class="line">    &quot;message&quot;, &quot;(?m)%&#123;WORD&#125;&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>logstash 会按照这个定义次序依次尝试匹配，到匹配成功为止。</p><p>（2）ruby插件</p><p>如果你稍微懂那么一点点Ruby语法的话，filters/ruby 插件将会是一个非常有用的工具。 比如你需要稍微修改一下 LogStash::Event 对象，但是又不打算为此写一个完整的插件，用ruby插件绝对感觉良好。使用ruby插件可以对event执行ruby语句，举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">    ruby &#123;</span><br><span class="line">        init =&gt; &quot;@kname = [&apos;client&apos;,&apos;servername&apos;,&apos;url&apos;,&apos;status&apos;,&apos;time&apos;,&apos;size&apos;,&apos;upstream&apos;,&apos;upstreamstatus&apos;,&apos;upstreamtime&apos;,&apos;referer&apos;,&apos;xff&apos;,&apos;useragent&apos;]&quot;</span><br><span class="line">        code =&gt; &quot;</span><br><span class="line">            new_event = LogStash::Event.new(Hash[@kname.zip(event.get(&apos;message&apos;).split(&apos;|&apos;))])</span><br><span class="line">            new_event.remove(&apos;@timestamp&apos;)</span><br><span class="line">            event.append(new_event)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）mutate插件</p><p>mutate插件是Logstash的另一个重要插件。它提供了丰富的基础类型数据处理能力，包括类型转换、字符串处理和字段处理等。</p><h1 id="filter-mutate插件的使用"><a href="#filter-mutate插件的使用" class="headerlink" title="filter/mutate插件的使用"></a>filter/mutate插件的使用</h1><p>参见<a href="http://www.mobile-open.com/2016/940848.html" target="_blank" rel="noopener">http://www.mobile-open.com/2016/940848.html</a></p><h1 id="logstash的最佳实践"><a href="#logstash的最佳实践" class="headerlink" title="logstash的最佳实践"></a>logstash的最佳实践</h1><p>（1）<code>./bin/logstash -t -f ./conf/logstash.conf</code>  ##测试logstash的配置文件是否正确，不会直接启动logstash</p><p>（2）logstash是保存有发布进度状态的，当重启logstash，logstash会继续之前的进度继续发布数据，而不会丢失哦</p><h1 id="logstash闲杂知识点"><a href="#logstash闲杂知识点" class="headerlink" title="logstash闲杂知识点"></a>logstash闲杂知识点</h1><p>（1）最简单的logstash配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    stdout &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：表示从从标准输入中读取数据，然后从标准输出中输出数据</p><p>（2）logstash的helloworld</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/logstash -e <span class="string">"input&#123;stdin&#123;&#125;&#125; output&#123;stdout&#123;codec=&gt;rubydebug&#125;&#125;"</span></span><br><span class="line">./bin/logstash -e <span class="string">"input&#123;generator&#123;count=&gt;100000000000&#125;&#125; output&#123;stdout&#123;codec=&gt;dots&#125;&#125;"</span></span><br></pre></td></tr></table></figure><p>（3）清空logstash的传输进度是清空${LOGSTASH_HOME}/data目录中的内容即可？</p><p>（4）如果logstash的grok插件解析字段失败，输出的event中包含_grokparsefailure的tag，我们可以在kibana上搜索该字段，如果发现有_grokparsefailure关键词，那么说明有些日志解析失败了。</p>]]></content>
      
      
      <categories>
          
          <category> ELKStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logstash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA编程闲杂知识</title>
      <link href="/2018/01/31/JAVA%E7%BC%96%E7%A8%8B%E9%97%B2%E6%9D%82%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/01/31/JAVA%E7%BC%96%E7%A8%8B%E9%97%B2%E6%9D%82%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="省略花括号"><a href="#省略花括号" class="headerlink" title="省略花括号"></a>省略花括号</h1><p>当<code>if</code>或<code>for</code>控制语句的执行体，只有一行时，可以省略花括号。如下写法都是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) System.out.println(<span class="string">"aaaaa"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        System.out.println(<span class="string">"aaaaa"</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) System.out.println(<span class="string">"bbbbb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>)</span><br><span class="line">        System.out.println(<span class="string">"bbbbb"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java中字符串比较"><a href="#Java中字符串比较" class="headerlink" title="Java中字符串比较"></a>Java中字符串比较</h1><p>双等号<code>str1 == str2</code>表示比较两个字符串对象是否在内存中是同一个。<code>str1.equals(str2)</code>表示比较两个字符串的内容是否一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"Lee"</span>;</span><br><span class="line">String str2 = <span class="string">"Lee"</span>;</span><br><span class="line">str1 == str2        <span class="comment">// true，因为他们在内存中是同一个对象。正常来说，它们不相等才对的啊，实际上Java在对字符串常量初始化时，先看内存中是否已经有了字符串字面值常量，若已经有了，就直接将引入传给该字符串变量。在本例中，当定义字符串变量str2时，发现字符串字面值常量"Lee"在内存中已经存在了，因此将该引用直接赋值给str2啦，因此在JVM内存中，str1和str2其实是指向同一块内存</span></span><br><span class="line">str1.equals(str2)   <span class="comment">// true，因为str1和str2的字符串内容是一样的</span></span><br><span class="line"></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"Lee"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"Lee"</span>);</span><br><span class="line">str1 == str2        <span class="comment">// false，因为他们在内存中不是同一个对象</span></span><br><span class="line">str1.equals(str2)   <span class="comment">// true，因为str1和str2的字符串内容是一样的</span></span><br></pre></td></tr></table></figure><p>备注：<code>equals()</code>函数默认是用来比较两个对象的引用是否一样的，而在String类中应该是被覆写了，用来比较对象的内容是否一样啦。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA语言中类加载机制</title>
      <link href="/2018/01/31/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/01/31/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java类加载机制简介"><a href="#Java类加载机制简介" class="headerlink" title="Java类加载机制简介"></a>Java类加载机制简介</h1><p>当调用java命令运行某个java进程时，该命令将会启动一个Java虚拟机进程，不管该Java程序有多么复杂，该程序启动了多少个线程，它们都处于该Java虚拟机进程里。同一个JVM的所有线程、所有变量都处于同一个进程里，它们都使用该JVM进程的内存区。当系统出现以下几种情况时，JVM进程将被终止：</p><ul><li>程序运行到最后正常结束</li><li>程序运行到使用<code>System.exit()</code>或<code>Runtime.getRuntime().exit()</code>代码处结束程序</li><li>程序执行过程中遇到未捕获的异常或错误而结束</li><li>程序所在平台强制结束了JVM进程</li></ul><p>当程序主动使用某个类时，如果该类还未加载到内存中，则系统会通过加载、连接以及初始化三个步骤来对该类进行初始化。如果没有意外出现，JVM会将连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或类初始化。</p><p><img src="/images/java_classloader_1_1.png" alt></p><p>（1）类的加载</p><p>类加载指的是将类的class文件读入内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。类的加载是由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。通过使用不同的类加载器，可以从不同来源加载类二进制数据，通常有如下几种来源：</p><ul><li>从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式</li><li>从JAR包加载class文件，这种方式也是很常见的</li><li>通过网络加载class文件</li><li>把一个Java源文件动态编译，并执行加载</li></ul><p>值得注意的是，类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。</p><p>（2）类的连接</p><p>当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接有可分为如下三个阶段：</p><ul><li>验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致</li><li>准备：类准备阶段负责为类的类变量分配内存，并设置默认初始值</li><li>解析：将类的二进制数据中的符号引用替换成直接引用</li></ul><p>（3）类的初始化<br>在类的初始化阶段，虚拟机负责对类进行初始化，主要就是对类变量进行初始化。在Java类中对类变量指定初始值有两种方式：一是声明类变量时指定初始值；二是使用静态初始化块为类变量指定初始值。</p><h1 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h1><p>类加载器负责将.class文件（可能在磁盘上，也可能在网络上）加载到内存中，并为之生成对应的java.lang.Class对象。尽管在Java开发中无须过分关心类加载机制，但所有的编程人员都应该了解其工作机制。类加载器负责加载所有的类，并为所有的被载入内存中的类生成一个java.lang.Class实例。</p><p>正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在java中，一个类用其全限定类名（包括包名和类名）作为标识。但在JVM中，一个被加载到JVM的类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例k1负责加载，则该Person类对应的Class对象在JVM中被表示为<code>（Person、pg、k1）</code>。这意味着两个类加载器加载的同名类<code>（Person、pg、k1）</code>和<code>（Person、pg、k2）</code>在JVM中被认为是不同的类。</p><p>Java中的类加载器大致可以分成两类，一类是系统提供的，另一类则是由Java应用开发人员编写的。所以JAVA平台中的类加载器有如下几种：</p><p>（1）引导类加载器（bootstrap class loader）</p><p>它用来加载Java的核心库，一般来说就是<code>%JAVA_HOME%/jre/lib/rt.jar</code>中的各种类，如String、System等等。在Sun的JVM中，当执行java.exe命令时，使用-Xbootclasspath选项或使用-D选项指定sun.boot.class.path系统属性值可以指定加载附加的类。根类加载器非常特殊，它并不是java.lang.ClassLoader的子类，而是由JVM自身实现的。</p><p>（2）扩展类加载器（extensions class loader）</p><p>扩展类加载器负责加载JRE的扩展目录（<code>%JAVA_HOME%/jre/lib/ext</code>或由<code>java.ext.dirs</code>系统属性指定的目录）中JAR包的类。通过这种方式，就可以为Java扩展核心类以外的新功能，只要把自己开发的类打包成JAR文件，然后放入<code>%JAVA_HOME%/jre/lib/ext</code>路径即可。</p><p>（3）系统类加载器（system class loader）</p><p>系统类加载器负载在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性，或CLASSPATH环境变量所指定的JAR包和类路径。用户程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都是以系统类加载器作为父加载器。</p><p>（4）用户自定义的加载类</p><p>如下为各种类加载器的树状组织架构图：</p><p><img src="/images/java_syntax_17_1.png" alt></p><p>备注：类的加载器也是一个类，真正去加载其他类的是加载器ClassLoader的对象。</p><h1 id="类加载机制的方式"><a href="#类加载机制的方式" class="headerlink" title="类加载机制的方式"></a>类加载机制的方式</h1><p>JVM的类加载机制主要有三种：</p><p>（1）全盘负责</p><p>所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。</p><p>（2）父类委托</p><p>所有父类委托，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。</p><p>（3）缓存机制</p><p>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区中。所以在修改了Class后，需要重新启动JVM，程序所做的修改才会生效。</p><p>学习资料参考于：<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA虚拟机启动参数设置</title>
      <link href="/2018/01/31/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"/>
      <url>/2018/01/31/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM启动参数的简介"><a href="#JVM启动参数的简介" class="headerlink" title="JVM启动参数的简介"></a>JVM启动参数的简介</h1><p>Java JVM启动参数共分为三类：</p><p>（1）标准参数（-）</p><p>所有的JVM实现都必须实现这些参数的功能，而且向后兼容。</p><p>（2）非标准参数（-X）</p><p>非标准参数（-X）又称为扩展参数。默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容。</p><p>（3）非Stable参数（-XX）</p><p>此类参数各个JVM实现会有所不同，将来可能会随时取消，需要慎重使用。</p><h1 id="标准参数（-）"><a href="#标准参数（-）" class="headerlink" title="标准参数（-）"></a>标准参数（-）</h1><p>（1）-client</p><p>设置JVM使用client模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或者PC应用开发和调试。</p><p>（2）-server</p><p>设置JVM使server模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有64位能力的JDK环境下将默认启用该模式，而忽略-client参数。</p><p>（3）-classpath classpath 或 -cp classpath</p><p>告知JVM搜索目录名、jar文档名、zip文档名，之间用冒号(:)分隔；使用-classpath后JVM将不再使用CLASSPATH中的类搜索路径，如果-classpath和CLASSPATH都没有设置，则JVM使用当前路径(.)作为类搜索路径。</p><p>JVM搜索类的方式和顺序为：Bootstrap，Extension，User。</p><ul><li>Bootstrap中的路径是JVM自带的jar或zip文件，JVM首先搜索这些包文件，用<code>System.getProperty(&quot;sun.boot.class.path&quot;)</code>可得到搜索路径。</li><li>Extension是位于<code>%{JRE_HOME}/lib/ext</code>目录下的jar文件，JVM在搜索完Bootstrap后就搜索该目录下的jar文件，用<code>System.getProperty(&quot;java.ext.dirs&quot;)</code>可得到搜索路径。</li><li>User搜索顺序为当前路径.、CLASSPATH、-classpath，JVM最后搜索这些目录，用<code>System.getProperty(&quot;java.class.path&quot;)</code>可得到搜索路径。</li></ul><p>（4）-Dproperty=value</p><p>设置系统属性名/值对，运行在此JVM之上的应用程序可用<code>System.getProperty(&quot;property&quot;)</code>得到value的值。如果value中有空格，则需要用双引号将该值括起来，如<code>-Dname=&quot;space string&quot;</code>。该参数通常用于设置系统级全局变量值，如配置文件路径，以便该属性在程序中任何地方都可访问。</p><p>（5）-jar</p><p>指定以jar包的形式执行一个应用程序。要这样执行一个应用程序，必须让jar包的manifest文件中声明初始加载的Main-class，当然那Main-class必须有<code>public static void main(String[] args)</code>方法。</p><p>（6）-version</p><p>输出java的版本信息，比如jdk版本、vendor、model。</p><p>（7）-showversion</p><p>输出java版本信息（与-version相同）之后，继续输出java的标准参数列表及其描述。</p><h1 id="非标准参数（-X）"><a href="#非标准参数（-X）" class="headerlink" title="非标准参数（-X）"></a>非标准参数（-X）</h1><p>（1）<code>-Xms&lt;x&gt;</code></p><p>设置JVM初始堆内存为xMB ，例如-Xms256M</p><p>（2）<code>-Xmx&lt;x&gt;</code></p><p>设置JVM最大可用堆内存为xMB ，例如-Xmx1G</p><p>（3）<code>-Xss&lt;x&gt;</code></p><p>设置单个线程栈的大小，一般默认为512k。</p><p>备注：一般而言，-Xms和-Xmx配置的一样大，避免JVM动态分配内存。</p><h1 id="非Stable参数（-XX）"><a href="#非Stable参数（-XX）" class="headerlink" title="非Stable参数（-XX）"></a>非Stable参数（-XX）</h1><p>用-XX作为前缀的参数列表在JVM中可能是不健壮的，SUN也不推荐使用，后续可能会在没有通知的情况下就直接取消了。但是由于这些参数中的确有很多是对我们很有用的，比如我们经常会见到的-XX:PermSize、-XX:MaxPermSize等等。我们将Java HotSpot VM中-XX:的可配置参数列表分成三类：</p><ul><li>行为参数（Behavioral Options）：用于改变JVM的一些基础行为</li><li>性能调优（Performance Tuning）：用于JVM的性能调优</li><li>调试参数（Debugging Options）：一般用于打开跟踪、打印、输出等JVM参数，用于显示JVM更加详细的信息</li></ul><p>（1）行为参数举例</p><p><img src="/images/java_jvm_1_1.png" alt></p><p>备注：上面表格中黑体的三个参数代表着JVM中GC执行的三种方式，即 串行、并行、并发。串行 （SerialGC）是JVM的默认GC方式，一般适用于小型应用和单处理器，算法比较简单，GC效率也较高，但可能会给应用带来停顿； 并行 （ParallelGC）是指GC运行时，对应用程序运行没有影响，GC和app两者的线程在并发执行，这样可以最大限度不影响app的运行； 并发 （ConcMarkSweepGC）是指多个线程并发执行GC，一般适用于多处理器系统中，可以提高GC的效率，但算法复杂，系统消耗较大。</p><p>（2）性能调优参数举例</p><p><img src="/images/java_jvm_1_2.png" alt></p><p>（3）调试参数举例</p><p><img src="/images/java_jvm_1_3.png" alt></p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>如下为启动一个ElasticSearch java进程的虚拟机启动参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/work/jdk1.8.0_112/bin/java -Xms2g -Xmx2g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+DisableExplicitGC -XX:+AlwaysPreTouch -server -Xss1m -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djna.nosys=true -Djdk.io.permissionsUseCanonicalPath=true -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Dlog4j.skipJansi=true -XX:+HeapDumpOnOutOfMemoryError -Des.path.home=/home/work/elasticsearch -cp /home/work/elasticsearch/lib/elasticsearch-5.3.0.jar:/home/work/elasticsearch/lib/* org.elasticsearch.bootstrap.Elasticsearch -d</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="https://my.oschina.net/dodojava/blog/23640" target="_blank" rel="noopener">https://my.oschina.net/dodojava/blog/23640</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中JPA技术调研</title>
      <link href="/2018/01/31/JAVA%E4%B8%ADJPA%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2018/01/31/JAVA%E4%B8%ADJPA%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="JPA简介"><a href="#JPA简介" class="headerlink" title="JPA简介"></a>JPA简介</h1><p>JPA（Java Persistence API）是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。它的出现主要是为了简化现有的持久化开发工作和整合ORM技术，结束现在Hibernate，TopLink，JDO等ORM框架各自为营的局面。值得注意的是，JPA是在充分吸收了现有Hibernate，TopLink，JDO等ORM框架的基础上发展而来的，具有易于使用，伸缩性强等优点。JPA的总体思想和现有Hibernate，TopLink，JDO等ORM框架大体一致。</p><p>需要注意的是，虽然JPA最初打算用于关系/SQL型数据库，但是一些JPA实现已经扩展用于NoSQL数据存储，但JPA还主要是用于关系型数据库的场景。</p><p>总的来说，JPA包括以下3方面的技术：</p><p>（1）ORM映射元数据</p><p>JPA支持XML和JDK5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。</p><p>（2）Java持久化API</p><p>用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者可以从繁琐的JDBC和SQL代码中解脱出来。</p><p>（3）查询语言（JPQL）</p><p>这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。</p><p><strong>简单地说，JPA是Sun定义的一套规范，不是一套产品，而像Hibernate，TopLink以及JDO等才是遵循了JPA规范的产品</strong>。其实JPA规范的主要定义者是来自于Hibernate团队。JPA是一种规范不是产品，而Hibernate是一种ORM技术的产品。JPA有点像JDBC，为各种不同的ORM技术提供一个统一的接口，方便把应用移植到不同的ORM技术上。</p><p>另外，JPA定义了一系列的接口、注解等，它们在J2EE的javax.persistence包下，常用的举例来说有：</p><pre><code>javax.persistence.Entityjavax.persistence.Tablejavax.persistence.Columnjavax.persistence.Idjavax.persistence.GeneratedValuejavax.persistence.OneToOnejavax.persistence.ManyToOnejavax.persistence.OneToManyjavax.persistence.ManyToManyjavax.persistence.JoinColumnjavax.persistence.CascadeTypejavax.persistence.FetchTypejavax.persistence.Transient</code></pre><p>说白了，JPA是对象关系映射ORM框架的一套标准，所有的具体的ORM框架都要遵循这套标准去实现。</p><h1 id="JAVA-JPA技术整体组织结构"><a href="#JAVA-JPA技术整体组织结构" class="headerlink" title="JAVA JPA技术整体组织结构"></a>JAVA JPA技术整体组织结构</h1><p>JAVA JPA技术整体组织结构如下：</p><p><img src="/images/java_syntax_15_1.png" alt></p><h1 id="JPA的简单使用举例"><a href="#JPA的简单使用举例" class="headerlink" title="JPA的简单使用举例"></a>JPA的简单使用举例</h1><p>假设我们使用JPA产品Hibernate作为项目的持久层框架，一般来说我们会首先使用JAVA JPA规范的注解来定义实体类，举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义Student实例类</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"t_student"</span>) <span class="comment">//如果数据库中表名和实体类名相同的话，@Table注解可以省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span>  <span class="comment">//@Id表示主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span> <span class="comment">//@GeneratedValue自定义主键生成策略</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>) <span class="comment">//若字段名与数据库中表的列名相同，@Column注解可以省略</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"age"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@ManyToOne</span>(cascade = &#123; CascadeType.ALL &#125;, fetch = FetchType.EAGER)</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"class_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> ClassRoom classRoom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略getter和setter方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义ClassRoom实体类</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"t_classroom"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"class_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@OneToMany</span>(cascade = &#123; CascadeType.ALL &#125;, fetch = FetchType.EAGER)</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"class_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; student;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：一定要注意，这里面的注解使用的是javax.persistence包下注解，像Hibernate框架中也提供了这些注解。为了在ORM框架的移植性，我们一定是要javax.persistence包下注解。</p><p>定义了实体类后，我们要使用JPA实现框架的工具去初始化数据，然后使用JPA框架的接口实现数据库的增删改查等操作。</p><h1 id="JPA中EntityManager简介"><a href="#JPA中EntityManager简介" class="headerlink" title="JPA中EntityManager简介"></a>JPA中EntityManager简介</h1><p>JPA中要对数据库进行操作前，必须先取得EntityManager对象，这有点类似JDBC在对数据库操作之前，必须先取得Connection对象，EntityManager是JPA操作的基础，但它不是线程安全的。</p><p>EntityManager主要用来管理Entity对象生命周期，通过EntityManager可以对Entity对象进行操作，也就对应到对数据库进行增删改查等操作。</p><h1 id="EntityManager的获取方式"><a href="#EntityManager的获取方式" class="headerlink" title="EntityManager的获取方式"></a>EntityManager的获取方式</h1><p>（1）通过静态方法<code>EntityManagerFactory.createEntityManager()</code>来取得。</p><p>（2）若使用容器管理，则可以使用@PersistenceContext注入EntityManger。</p><p>（3）可以使用@PersistenceUnit注入EntityManagerFactory，再用它来建立EntityManager。</p><h1 id="使用EntityManager操作数据库的示例"><a href="#使用EntityManager操作数据库的示例" class="headerlink" title="使用EntityManager操作数据库的示例"></a>使用EntityManager操作数据库的示例</h1><p>如下是一些操作示例：</p><p>（1）要新增记录，可以使用EntityManager的persist()方法，这也会让Entity实例处于Managed状态，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">// 设定user相关属性</span></span><br><span class="line">entityManager.persist(user);</span><br></pre></td></tr></table></figure><p>（2）若要查找数据库中的记录，使用EntityManager的find()方法，指定主键和Entiry Class实例来取得对应的Entiry对象，查找回的记录会处于Managed的状态，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = entityManager.find(User<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br></pre></td></tr></table></figure><p>（3）若要修改数据库中已有的记录，可按如下的方式</p><p>若记录是在Managed状态，例如查找记录之后，直接更新记录，在提交确认之后，记录的更新就会反应至数据库之中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = entityManager.find(User<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">user.setName(<span class="string">"Justin Lin"</span>);</span><br></pre></td></tr></table></figure><p>（4）若要删除数库表中的记录，则记录必须是在Managed的状态，例如用EntityManager的find()方法查找记录，以查找到的记录配合remove()方法来移除，或是使用merge()方法将Entity处于Managed状态再用remove()移除，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = entityManager.find(User<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">entityManager.remove(user);</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="https://openhome.cc/Gossip/EJB3Gossip/EntityManager.html" target="_blank" rel="noopener">https://openhome.cc/Gossip/EJB3Gossip/EntityManager.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SSM/SSH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中日志记录模块</title>
      <link href="/2018/01/31/JAVA%E4%B8%AD%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/01/31/JAVA%E4%B8%AD%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA开发环境中日志相关库"><a href="#JAVA开发环境中日志相关库" class="headerlink" title="JAVA开发环境中日志相关库"></a>JAVA开发环境中日志相关库</h1><p><img src="/images/java_syntax_14_1.png" alt></p><p>备注：其中log4j，logback以及slf4j都是由一个人开发而成，他就是Ceki Gülcü.</p><p>学习资料参考于：<br><a href="http://mp.weixin.qq.com/s/Fxurcbgu061f6JM1JyvFIw" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/Fxurcbgu061f6JM1JyvFIw</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中抽象类与抽象方法</title>
      <link href="/2018/01/31/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
      <url>/2018/01/31/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h1><p>在Java语言中，abstract关键字修饰的方法称为抽象方法，抽象方法只包含一个方法名，而没有方法体。在书写上，一定要注意，抽象方法名后面直接跟一个分号，而不是花括号。</p><h1 id="抽象类的几个概念要点"><a href="#抽象类的几个概念要点" class="headerlink" title="抽象类的几个概念要点"></a>抽象类的几个概念要点</h1><p>（1）抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p><p>（2）抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><p>（3）抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p><p>（4）构造方法，类方法（用static修饰的方法）不能声明为抽象方法。</p><p>（5）抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p><h1 id="抽象类的定义和使用"><a href="#抽象类的定义和使用" class="headerlink" title="抽象类的定义和使用"></a>抽象类的定义和使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个抽象类Employee，该抽象类有一个抽象方法computePay</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">computePay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类实现抽象类Employee，该类实现了computePay抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary; <span class="comment">// Annual salary</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">computePay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Computing salary pay for "</span> + getName());</span><br><span class="line">        <span class="keyword">return</span> salary/<span class="number">52</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中泛型编程</title>
      <link href="/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型简介"><a href="#泛型简介" class="headerlink" title="泛型简介"></a>泛型简介</h1><p>JAVA泛型是JDK 5中引入的一个新特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>有许多原因促成了泛型的出现，而最引人注意的一个原因，就是为了创建容器类。</p><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<e>）。每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。举例来说：</e></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        Double[] doubleArray = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span> &#125;;</span><br><span class="line">        Character[] charArray = &#123; <span class="string">'H'</span>, <span class="string">'E'</span>, <span class="string">'L'</span>, <span class="string">'L'</span>, <span class="string">'O'</span> &#125;;</span><br><span class="line"></span><br><span class="line">        printArray(intArray);</span><br><span class="line">        printArray(doubleArray);</span><br><span class="line">        printArray(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] inputArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (E element : inputArray) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s "</span>, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：类型参数也可以是多个，具有多个类型参数的泛型方法形如：<code>public static &lt;E, F&gt; void printArray(E[] inputArray1, F[] inputArray2) {}</code></p><h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();</span><br><span class="line">        Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;String&gt;();</span><br><span class="line">     </span><br><span class="line">        integerBox.add(<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line">        stringBox.add(<span class="keyword">new</span> String(<span class="string">"菜鸟教程"</span>));</span><br><span class="line">     </span><br><span class="line">        System.out.printf(<span class="string">"整型值为 :%d\n\n"</span>, integerBox.get());</span><br><span class="line">        System.out.printf(<span class="string">"字符串为 :%s\n"</span>, stringBox.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：泛型类也可以使用多个类型参数，形如：<code>public class Box&lt;T, E&gt; {}</code></p><h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><p>首先定义一个泛型接口Generator，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再定义一个生成器类来实现这个接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="伪泛型-与-类型擦除"><a href="#伪泛型-与-类型擦除" class="headerlink" title="伪泛型 与 类型擦除"></a>伪泛型 与 类型擦除</h1><p>泛型的本质是参数化类型的应用，也就是说所操作的数据类型被指定为一个参数。泛型的概念在C++、C#以及JAVA中都有实现。但是实现的技术是不同的。</p><p>C#里面的泛型无论在程序源码中、编译后的IL中，或者是运行期的CLR中，都是切实存在的，<code>List&lt;int&gt;</code>和<code>List&lt;String&gt;</code>就是两个不同的类型，它们在系统运行时生成，有自己的虚方法表和类型数据，这种实现称为“类型膨胀”，在C#中基于这种方法实现的泛型称为“真实泛型”。JAVA语言中的泛型则不一样，它只在源码中存在，在编译后的字节码文件中就不存在了，而是在相应的地方插入了强制类型转化代码，因此，对于运行期的JAVA语言来说，<code>ArrayList&lt;int&gt;</code>与<code>ArrayList&lt;String&gt;</code>就是同一个类型，所以JAVA中泛型技术实际上是JAVA语言的一颗语法糖，JAVA语言中的泛型实现方法称为“类型擦除”，JAVA中基于这种方法实现的泛型称为“伪泛型”。</p><p>如下为使用JAVA泛型的一段源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    map.put(<span class="string">"how ary you?"</span>, <span class="string">"吃了吗"</span>);</span><br><span class="line">    System.out.println(map.get(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println(map.get(<span class="string">"how are you?"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上段JAVA代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，泛型类型都变回了原生类型，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    map.put(<span class="string">"how ary you?"</span>, <span class="string">"吃了吗"</span>);</span><br><span class="line">    System.out.println((String)map.get(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println((String)map.get(<span class="string">"how are you?"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一点闲杂"><a href="#一点闲杂" class="headerlink" title="一点闲杂"></a>一点闲杂</h1><p>不管是泛型类，泛型方法，还是泛型接口，在使用这些泛型时候，类型参数必须是抽象类型，不能是基本数据类型，如int/short，应该使用他们的封箱类Integer/Short等等。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中注解annotation技术</title>
      <link href="/2018/01/30/JAVA%E4%B8%AD%E6%B3%A8%E8%A7%A3annotation%E6%8A%80%E6%9C%AF/"/>
      <url>/2018/01/30/JAVA%E4%B8%AD%E6%B3%A8%E8%A7%A3annotation%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="annotation注解简介"><a href="#annotation注解简介" class="headerlink" title="annotation注解简介"></a>annotation注解简介</h1><p>注解是JDK1.5新增新技术。很多框架为了简化代码，都会提供一些注解。可以理解为插件，是代码级别的插件，在类的方法上写@XXX，就是在代码上插入了一个插件。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p><p>注解分为内置注解（也称为元注解，JDK自带注解）和自定义注解（各种框架自带的注解或用户自定义的注解）。</p><p>备注：需要注意的是，注解本身做不了任何事情，和XML一样，只起到配置的作用。而主要在于背后的处理器 ，也就是注解使用方的解析和处理逻辑。</p><h1 id="JAVA语言内置的元注解"><a href="#JAVA语言内置的元注解" class="headerlink" title="JAVA语言内置的元注解"></a>JAVA语言内置的元注解</h1><p>JAVA内置了三种标准注解和四种元注解。</p><p>三种标准注解如下：</p><p>（1）<code>@Override</code></p><p>表示当前的方法定义将覆盖超类中的方法。如果不小心拼写错误，或者方法签名对不上被覆盖的方法，编译器就会发出错误提示。</p><p>（2）<code>@Deprecated</code></p><p>如果程序员使用了被@Deprecated注解的元素，编译器会发出警告信息。</p><p>（3）<code>@SuppressWarnings</code></p><p>使用@SuppressWarnings可以关闭不当的编译器警告信息。举例来说：</p><ul><li>抑制单类型的警告，如<code>@SuppressWarnings(&quot;unchecked&quot;)</code>表示只抑制无检查的警告</li><li>抑制多类型的警告，如<code>@SuppressWarnings(value={&quot;unchecked&quot;, &quot;rawtypes&quot;})</code>表示抑制无检查和rawtypes的警告</li><li>抑制所有类型的警告，即使用<code>@SuppressWarnings(&quot;all&quot;)</code>表示抑制所有的告警</li></ul><p>备注：还有其他很多种的警告类型，如unused、restriction以及deprecation等等。</p><p>JAVA还提供了四种元注解，专门用来的负责创建新注解的注解。如下：</p><p>（1）<code>@Target</code></p><p>@Target表示该注解可以用于什么地方，可能的ElementType参数包括，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONSTRUCTOR：构造器的声明</span><br><span class="line">FIELD：域声明</span><br><span class="line">LOCAL_VARIABLE：局部变量声明</span><br><span class="line">METHOD：方法声明</span><br><span class="line">PACKAGE：包声明</span><br><span class="line">PARAMETER：参数声明</span><br><span class="line">TYPE：类、接口或enum声明</span><br></pre></td></tr></table></figure><p>（2）<code>@Retention</code></p><p>表示在什么级别下保存该注解信息，可选的RetentionType参数有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SOURCE：只在源代码阶段保存注解信息。代码编译时，注解会被编译器丢弃</span><br><span class="line">CLASS：在class字节码阶段依然保存注解信息。代码执行时，会被JVM丢弃</span><br><span class="line">RUNTIME：JVM在代码运行期也保留注解，因此可以通过反射机制读取注解的信息</span><br></pre></td></tr></table></figure><p>（3）<code>@Documented</code></p><p>将此注解包含在JAVA DOC文档中。</p><p>（4）<code>@Inherited</code></p><p>允许子类继承父类中的注解。</p><h1 id="annotation作用"><a href="#annotation作用" class="headerlink" title="annotation作用"></a>annotation作用</h1><p>（1）编译检查</p><p>具有“让编译器进行编译检查的作用”。例如，@SuppressWarnings，@Deprecated和@Override都具有编译检查作用。</p><p>（2）在反射中使用annotation</p><p>在反射的Class/Method/Field中的函数中，有许多关于annotation相关的接口。这也意味着，我们可以在反射中解析并使用annotation，这一块很重要，很多annotation的功能就通过反射来实现。</p><p>（3）根据annotation生成帮助文档</p><p>通过给annotation注解加上@Documented标签，能使该annotation标签出现在javadoc中。</p><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>如下定义了一个名称为WaHaHa的注解（使用@interface关键字）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WaHaHa &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA语言中异常处理机制</title>
      <link href="/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA的异常与错误"><a href="#JAVA的异常与错误" class="headerlink" title="JAVA的异常与错误"></a>JAVA的异常与错误</h1><p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</p><p>（1）错误Error</p><p>Error表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误 ，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。 Error类体系描述了Java运行系统中的内部错误以及资源耗尽的情形。假如出现这种错误，除了尽力使程序安全退出外，在其他方面是无能为力的。例如Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p><p>（2）检查性异常Exception</p><p>检查性异常也就是我们经常遇到的IO异常，以及SQL异常等。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。</p><p>（3）运行时异常Exception</p><p>出现运行时Exception时，总是由虚拟机接管。比如，我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。 出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了。运行时异常是Exception的子类，也有一般异常的特点，是可以被catch块处理的，只不过往往我们不对他处理罢了。也就是说，你如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。当然，如果需要，我们可以像检查性异常一样去对运行性异常进行catch并处理。</p><p>备注：简单来说，你的代码少了一个分号，那么运行出来的结果是提示java.lang.Error错误；如果你用System.out.println(11/0)，那么因为用0做了除数，会抛出 java.lang.ArithmeticException异常。值得注意的是，ERROR和Exception的一个重要区别是，ERROR是用户代码无法捕获并处理的问题；</p><p>而Exception，包括检查性异常和运行时异常。检查性异常必须被<code>try{}catch{}</code>语句块所捕获，或者在方法里通过throws子句声明，检查性异常命名为Checked Exception，是因为Java编译器要进行检查，Java虚拟机也要进行检查，以确保这个规则得到遵守，否则编译的时候就会报错。对于运行时异常，可以选择用try-catch捕获，或throws关键字抛出，当然也可以不做任何处理。</p><h1 id="JAVA的异常或错误的类层级图"><a href="#JAVA的异常或错误的类层级图" class="headerlink" title="JAVA的异常或错误的类层级图"></a>JAVA的异常或错误的类层级图</h1><p>JAVA的异常或错误的类层级图如下：</p><p><img src="/images/java_syntax_10_1.png" alt></p><p>备注：IOException和RuntimeException是Exception最主要的两个子类，Exception还有非常多的子类哦。</p><h1 id="JAVA中的异常处理"><a href="#JAVA中的异常处理" class="headerlink" title="JAVA中的异常处理"></a>JAVA中的异常处理</h1><p>（1）简单的try-catch结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(ExceptionName e1) &#123;</span><br><span class="line">    <span class="comment">//Catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）多重捕获块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）try-catch-finally块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>在Java中你可以自定义异常。编写自己的异常类时需要记住下面的几点：</p><p>（1）所有异常都必须是Throwable的子类</p><p>（2）如果希望写一个检查性异常类，则需要继承Exception类</p><p>（3）如果你想写一个运行时异常类，那么需要继承RuntimeException类</p><p>通常来说，我们可以按照如下格式来自定义异常类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用throws-throw关键字"><a href="#使用throws-throw关键字" class="headerlink" title="使用throws/throw关键字"></a>使用throws/throw关键字</h1><p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用throws关键字来声明。throws关键字放在方法签名的尾部。也可以使用throw关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="comment">// Method implementation</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中容器类或集合类</title>
      <link href="/2018/01/30/JAVA%E4%B8%AD%E5%AE%B9%E5%99%A8%E7%B1%BB%E6%88%96%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>/2018/01/30/JAVA%E4%B8%AD%E5%AE%B9%E5%99%A8%E7%B1%BB%E6%88%96%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h1><p>（1）枚举Enumeration</p><p>枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。</p><p>（2）位集合BitSet</p><p>位集合类实现了一组可以单独设置和清除的位或标志。该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</p><p>（3）向量Vector</p><p>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。和数组一样，Vector对象的元素也能通过索引访问。</p><p>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</p><p>（4）栈Stack</p><p>栈（Stack）实现了一个后进先出（LIFO）的数据结构。你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。</p><p>（5）字典Dictionary</p><p>字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。</p><p>（6）哈希表Hashtable</p><p>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。</p><p>（7）属性Properties<br>Properties继承于Hashtable。Properties类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。Properties类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</p><h1 id="集合类-容器类"><a href="#集合类-容器类" class="headerlink" title="集合类 | 容器类"></a>集合类 | 容器类</h1><p>在Java 2之前，Java是没有完整的集合框架的。它只有一些简单的可以自扩展的容器类，比如Vector，Stack，Hashtable等。这些容器类在使用的过程中由于效率问题饱受诟病，因此在Java 2中，Java设计者们进行了大刀阔斧的整改，重新设计，于是就有了现在的集合框架。需要注意的是，之前的那些容器类库并没有被弃用而是进行了保留，主要是为了向下兼容的目的，但我们在平时使用中还是应该尽量少用。</p><p>在Java2中集合框架中的接口或类，我们称之为“集合类”或“容器类”。</p><p>必须指出的是，虽然容器号称存储的是Java对象，但实际上并不会真正将Java对象放入容器中，只是在容器中保留这些对象的引用。也就是说，Java容器实际上包含的是引用变量，而这些引用变量指向了我们要实际保存的Java对象。</p><h1 id="容器类的框架图"><a href="#容器类的框架图" class="headerlink" title="容器类的框架图"></a>容器类的框架图</h1><p>容器类的框架图如下：</p><p><img src="/images/java_syntax_9_1.png" alt></p><p>备注：窄虚线框代表的是“接口”；宽虚线框代表的是实现了部分方法的“抽象类”；实线框代表的是“类”；粗实线框代表的是日常常用的“类”。</p><p>上图中有一点疑惑，水平的实心箭头的produces是什么含义？一个Collection的类可以产生一个Iterator的对象？</p><p><img src="/images/java_syntax_8_1.png" alt></p><p>如上是一个简化版的容器类关系图，图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了AbstractList，NavigableSet等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p><h1 id="JAVA常用集合类"><a href="#JAVA常用集合类" class="headerlink" title="JAVA常用集合类"></a>JAVA常用集合类</h1><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>有序、可重复。如ArrayList、LinkedList以及Vector等。</p><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p>无序、不能重复。如HashSet以及TreeSet等。</p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>大都是无序（有些LinkedHashMap是有序的），键值对、键唯一、值不唯一。如HashMap、Hashtable以及TreeMap等。</p><p>备注：有序，指的是遍历读取集合中元素的顺序，和集合中元素添加时的先后次序保持一样。</p><h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><p>（1）Queue</p><p>Queue队列接口。Deque是继承Queue的子接口，是一个双端队列（即两头都可以添加或删除元素）。</p><p>Queue定义了6个队列相关操作的方法，分别如下：</p><table><thead><tr><th style="text-align:left">接口</th><th style="text-align:left">抛uncheck异常</th><th style="text-align:left">返回null</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">入队列</td><td style="text-align:left">add(e)</td><td style="text-align:left">offer(e)</td><td style="text-align:left">都是从往队列中添加元素，只是当队列满时，add会抛异常，而offer返回null</td></tr><tr><td style="text-align:left">出队列</td><td style="text-align:left">remove(e)</td><td style="text-align:left">poll(e)</td><td style="text-align:left">都是从往队列中获取元素，只是当队列为空时，remove会抛异常，而poll返回null</td></tr><tr><td style="text-align:left">队头元素取出</td><td style="text-align:left">element(e)</td><td style="text-align:left">peek(e)</td><td style="text-align:left">从队列头部读取一个元素，但是不会删除队列中元素，只是当队列为空时，element会抛异常，而peek返回null。该方法通常用来判断队列中是否还有元素哦，不要使用isEmpty或size</td></tr></tbody></table><p>（2）Deque</p><p>Deque是一个双端队列接口，继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。Deque有三种用途：一是普通队列(一端进另一端出)；二是双端队列(两端都可进出)；三是堆栈。</p><p>如下是Deque中定义的一些作为双端队列的方法，如下：</p><p><img src="/images/java_collection_1_1.png" alt></p><p>Deque接口扩展（继承）了Queue接口。在将双端队列用作队列时，将得到FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从Queue接口继承的方法完全等效于Deque方法，如下表所示：</p><table><thead><tr><th style="text-align:left">继承自Queue的方法</th><th style="text-align:left">等效Deque方法</th></tr></thead><tbody><tr><td style="text-align:left">add(e)</td><td style="text-align:left">addLast(e)</td></tr><tr><td style="text-align:left">offer(e)</td><td style="text-align:left">offerLast(e)</td></tr><tr><td style="text-align:left">remove(e)</td><td style="text-align:left">removeLast(e)</td></tr><tr><td style="text-align:left">poll(e)</td><td style="text-align:left">pollLast(e)</td></tr><tr><td style="text-align:left">element(e)</td><td style="text-align:left">elementLast(e)</td></tr><tr><td style="text-align:left">peek(e)</td><td style="text-align:left">peekLast(e)</td></tr></tbody></table><p>双端队列也可用作LIFO（后进先出）堆栈。（实现了List接口的Stack类是专门用来做堆栈的，但是已经过时了，现在都建议使用Deque接口实现类来做堆栈会更好）。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于Deque方法，如下表所示：</p><table><thead><tr><th style="text-align:left">堆栈方法</th><th style="text-align:left">等效Deque方法</th></tr></thead><tbody><tr><td style="text-align:left">push(e)</td><td style="text-align:left">addFirst(e)</td></tr><tr><td style="text-align:left">pop(e)</td><td style="text-align:left">popFirst(e)</td></tr><tr><td style="text-align:left">peek(e)</td><td style="text-align:left">peekFirst(e)</td></tr></tbody></table><p>当作不同的数据结构来使用，就使用相对应的方法。如当栈使用，用<code>push/pop/peek</code>；若当队列使用，就使用<code>offer/poll/peek</code>等方法；若当双端队列使用，就用<code>offerFirst/pollFirst/peekFirst/offerLast/pollLast/peekLast</code>等。</p><p>备注：LinkedList内部使用的双向链表的数据结构，其实现了Queue/Deque接口，因此LinkedList即可以当作队列来使用，也可以当堆来使用，还可以当作双端队列来使用哦。</p><h1 id="集合类的遍历操作"><a href="#集合类的遍历操作" class="headerlink" title="集合类的遍历操作"></a>集合类的遍历操作</h1><p>集合类的遍历操作有如下几种方式：</p><ul><li>普通for循环，形如<code>for(int i=0; i&lt;arr.size(); i++) {…}</code></li><li>增强for循环foreach，形如<code>for(Object i : arr) {…}</code></li><li>迭代器Iterator，形如<code>Iterator it = arr.iterator(); while(it.hasNext()) { Object o =it.next(); …}</code></li></ul><p>List类型的集合类的遍历示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"aaa"</span>);</span><br><span class="line">list.add(<span class="string">"bbb"</span>);</span><br><span class="line">list.add(<span class="string">"ccc"</span>);</span><br><span class="line"><span class="comment">//使用for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index=<span class="number">0</span>; index&lt;list.size(); index++) &#123;</span><br><span class="line">    String elem = list.get(index);</span><br><span class="line">    System.out.println(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用增强for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (String elem : list) &#123;</span><br><span class="line">    System.out.println(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用迭代器Iterator遍历</span></span><br><span class="line">Iterator iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    Object obj = iter.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用forEach + Lambda表达式遍历（需要JDK1.8及以上版本）</span></span><br><span class="line">list.forEach(item -&gt; System.out.println(item));</span><br></pre></td></tr></table></figure><p>Map类型的集合类的遍历示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">map.put(<span class="string">"zhangsan"</span>, <span class="number">23</span>);</span><br><span class="line">map.put(<span class="string">"lisi"</span>, <span class="number">43</span>);</span><br><span class="line">map.put(<span class="string">"wangwu"</span>, <span class="number">32</span>);</span><br><span class="line"><span class="comment">//遍历Map的key值</span></span><br><span class="line"><span class="keyword">for</span> (Object key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历Map的value值</span></span><br><span class="line"><span class="keyword">for</span> (Object value : map.values()) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用key集合或者values集合的迭代器来遍历</span></span><br><span class="line"><span class="keyword">for</span> (Iterator it = map.keySet().iterator(); it.hasNext();) &#123;</span><br><span class="line">    Object obj = it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Map.Entry来遍历，Map.Entry是Map的内部接口，在HashMap会实现这个接口，而成为HashMap的内部类</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entity : map.entrySet()) &#123;</span><br><span class="line">    String key1 = entity.getKey();</span><br><span class="line">    Integer value1 = entity.getValue();</span><br><span class="line">    System.out.println(key1);</span><br><span class="line">    System.out.println(value1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用forEach + Lambda表达式遍历（需要JDK1.8及以上版本）</span></span><br><span class="line">map.forEach((k, v) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"key="</span> + k);</span><br><span class="line">        System.out.println(<span class="string">"value="</span> + v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Set类型的集合类的遍历示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">"beijing"</span>);</span><br><span class="line">set.add(<span class="string">"shanghai"</span>);</span><br><span class="line">set.add(<span class="string">"tianjin"</span>);</span><br><span class="line">set.add(<span class="string">"chongqing"</span>);</span><br><span class="line"><span class="comment">//使用增强for循环来遍历</span></span><br><span class="line"><span class="keyword">for</span> (Object obj : set) &#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用迭代器Iterator来遍历</span></span><br><span class="line">Iterator iter = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    Object obj = iter.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用forEach + Lambda表达式遍历（需要JDK1.8及以上版本）</span></span><br><span class="line">set.forEach(item -&gt; System.out.println(item));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中this/super用法</title>
      <link href="/2018/01/30/JAVA%E4%B8%ADthis-super%E7%94%A8%E6%B3%95/"/>
      <url>/2018/01/30/JAVA%E4%B8%ADthis-super%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="this的含义和用法"><a href="#this的含义和用法" class="headerlink" title="this的含义和用法"></a>this的含义和用法</h1><p>Java关键字this只能用于方法体内。当一个对象创建后，Java虚拟机（JVM）就会给这个对象分配一个引用自身的指针，这个指针的名字就是this。因此，this只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this。并且this只和特定的对象关联，而不和类关联，同一个类的不同对象有不同的this。</p><p>一些需要注意的地方如下：</p><p>（1）通过this调用本类中另一个构造方法，用法是this(参数列表)，这个仅仅在类的构造方法中可以用，并且只能放在类的构造方法的方法体的第一句。别的地方不能用。</p><p>（2）方法参数或者方法中的局部变量和成员变量同名的情况下，成员变量被屏蔽，此时要访问成员变量则需要用“this.变量名”的方式来引用变量。但是，在没有同名的情况，可以直接用成员变量的名字，而不用this，用了也是正确的（看起来更加的直观）。</p><p>（3）我们也可以是用“this.成员方法名”来调用对象的成员方法，不过没有必要这要做哦，直接调用“成员方法名”即可。</p><p>总之，this代表的是指向对象本身的一个指针。</p><h1 id="super的含义和用法"><a href="#super的含义和用法" class="headerlink" title="super的含义和用法"></a>super的含义和用法</h1><p>super和this作用类似，不过super是用在子类中，目的是访问直接父类中被屏蔽的成员，注意是直接父类（就是类之上最近的超类）。</p><p>一些需要注意的地方如下：</p><p>（1）在子类的构造方法中要调用父类的构造函数，用“super(参数列表)”的方式调用，参数不是必须的。注意“super(参数列表)”这条语句只能放在子类构造方法的方法体的第一句。</p><p>（2）当子类方法中的局部变量或者子类的成员变量与父类的成员变量同名时，也就是子类局部变量或者子类的成员变量覆盖了父类的成员变量时，用“super.成员变量”引用父类的成员变量。当然父类的成员变量没有覆盖，也可以用“super.成员变量名”来引用父类的成员变量，但是是不必要的。因为在调用这个方法的时候，会先去看一下这个类里面有没有这个方法，如果本类中没有这个方法，那么系统就会自动去这个类的父类里面查找是否有这个方法。</p><p>（3）如果子类重写了父类的某一个方法，也就是子类和父类有相同的方法定义，但是有不同的方法体。此时，我们需要通过“super.成员方法名”来调用父类里面的这个方法。</p><p>总之，super代表的是指向直接父类对象的一个指针。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA语言中接口的使用</title>
      <link href="/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h1><p>abstract关键字允许人们在类中创建一个或多个没有任何定义的方法，该方法只提供接口部分，但是没有提供任何相应的具体实现，这些实现由此类的继承者创建。而Java中有接口的概念，通过接口产生一个完全抽象的类，它根本就没有提供任何具体的实现。它允许创建者确定方法名、参数列表和返回类型，但是没有任何方法体。总之，接口只提供了形式，而未提供任何具体实现。</p><p>要想创建一个接口，需要用interface关键字来替代class关键字。接口的概念中有如下几个要点：</p><p>（1）接口中每一个方法也是隐式抽象的，接口中的方法会被隐式地指定为public abstract（只能是public abstract，其他修饰符都会报错）。</p><p>（2）接口中可以含有变量，但是接口中的变量会被隐式的指定为public static final变量（并且只能是public，用private修饰会报编译错误）。</p><p>（3）接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。（哎呀，JDK8之后，接口中有default关键字修饰的方法是有方法体的哦）。</p><h1 id="接口的定义和使用举例"><a href="#接口的定义和使用举例" class="headerlink" title="接口的定义和使用举例"></a>接口的定义和使用举例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Animal.java文件中定义Animal接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：接口还可以继承其他接口，如<code>public interface Animal extends Biology {}</code>，要注意的是这里是<code>extends</code>，而不是<code>implements</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在MammalInt.java文件中定义MammalInt类，实现Animal接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MammalInt</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mammal eats"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mammal travels"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">noOfLegs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        MammalInt m = <span class="keyword">new</span> MammalInt();</span><br><span class="line">        m.eat();</span><br><span class="line">        m.travel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，一个类可以实现implements多个接口，如<code>public class WaHaHa implements InterfaceA, InterfaceB {}</code></p><h1 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h1><p>关于接口的继承的两点。一是接口可以继承其他接口，和类的继承是一样的。二是接口可以多继承，即一个接口可以继承多个父接口（类的继承只能是单继承）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sports</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHomeTeam</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisitingTeam</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Sports</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfQuarter</span><span class="params">(<span class="keyword">int</span> quarter)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hockey</span> <span class="keyword">extends</span> <span class="title">Sports</span>, <span class="title">Event</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h1><p>（1）抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行</p><p>（2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的</p><p>（3）接口中不能含有静态代码块以及静态方法（用static修饰的方法），而抽象类是可以有静态代码块和静态方法</p><p>（4）一个类只能继承一个抽象类，而一个类却可以实现多个接口</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA语言中OOP概念相关</title>
      <link href="/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%ADOOP%E6%A6%82%E5%BF%B5%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%ADOOP%E6%A6%82%E5%BF%B5%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="OOP中一些基本概念"><a href="#OOP中一些基本概念" class="headerlink" title="OOP中一些基本概念"></a>OOP中一些基本概念</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">多态</span><br><span class="line">继承</span><br><span class="line">封装</span><br><span class="line">类</span><br><span class="line">对象</span><br><span class="line">成员变量/实例变量/成员属性</span><br><span class="line">类变量/静态变量</span><br><span class="line">成员方法/实例方法</span><br><span class="line">类方法/静态方法</span><br><span class="line">构造方法</span><br><span class="line">重载overload</span><br><span class="line">覆盖/覆写/重写override</span><br></pre></td></tr></table></figure><h1 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。举例来说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个构造器仅有一个参数：name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员变量-实例变量-成员属性"><a href="#成员变量-实例变量-成员属性" class="headerlink" title="成员变量/实例变量/成员属性"></a>成员变量/实例变量/成员属性</h2><p>成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</p><h2 id="类变量-静态变量"><a href="#类变量-静态变量" class="headerlink" title="类变量/静态变量"></a>类变量/静态变量</h2><p>类变量也声明在类中，方法体之外，但必须声明为static类型。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类Animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String myName, <span class="keyword">int</span> myid)</span> </span>&#123; </span><br><span class="line">        name = myName; </span><br><span class="line">        id = myid;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123; </span><br><span class="line">        System.out.println(name+<span class="string">"正在吃"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"正在睡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">introduction</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"大家好！我是"</span>         + id + <span class="string">"号"</span> + name + <span class="string">"."</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类企鹅类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Penguin</span><span class="params">(String myName, <span class="keyword">int</span> myid)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>(myName, myid); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类老鼠类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mouse</span><span class="params">(String myName, <span class="keyword">int</span> myid)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>(myName, myid); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于继承的一些知识点：</p><p>（1）继承可以使用extends关键字来实现继承，而且所有的类都是继承于java.lang.Object，当一个类没有extends关键字时，则默认继承Object（这个类在java.lang包中，所以不需要import）祖先类。Java Object类是所有类的父类，也就是说Java的所有类都继承了Object，子类可以使用Object的所有方法。Object类可以显式继承，也可以隐式继承，以下两种方式时一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在Java中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以extends只能继承一个类。</p><p>（3）final关键字声明的类是不能被继承的，即最终类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    <span class="comment">//类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>所谓多态，就是同一个接口，使用不同的实例执行相同的操作，而表现的内容结果是不一样的。</p><p><img src="/images/java_oop_1_1.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle.draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square.draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Triangle.draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>() </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape shape1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        shape.draw();</span><br><span class="line"></span><br><span class="line">        Shape shape2 = <span class="keyword">new</span> Square();</span><br><span class="line">        shape.draw();</span><br><span class="line"></span><br><span class="line">        Shape shape3 = <span class="keyword">new</span> Triangle();</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载-覆写"><a href="#重载-覆写" class="headerlink" title="重载/覆写"></a>重载/覆写</h2><p>（1）覆写</p><p>覆写（override）是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。</p><p>（2）重载</p><p>重载（overload）是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA语言中各种修饰符modifier</title>
      <link href="/2018/01/30/JAVA%E4%B8%AD%E5%90%84%E7%A7%8D%E4%BF%AE%E9%A5%B0%E7%AC%A6modifier/"/>
      <url>/2018/01/30/JAVA%E4%B8%AD%E5%90%84%E7%A7%8D%E4%BF%AE%E9%A5%B0%E7%AC%A6modifier/</url>
      
        <content type="html"><![CDATA[<h1 id="修饰符简介"><a href="#修饰符简介" class="headerlink" title="修饰符简介"></a>修饰符简介</h1><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。比如在Java类中定义方法：</p><p><img src="/images/java_syntax_5_1.png" alt></p><h1 id="JAVA中修饰符的类别"><a href="#JAVA中修饰符的类别" class="headerlink" title="JAVA中修饰符的类别"></a>JAVA中修饰符的类别</h1><p>主要有两类修饰符如下：</p><p>（1）访问控制修饰符</p><p>a）default</p><p>即缺省，什么也不写，在同一包内可见，不使用任何修饰符。修饰目标有类、接口、变量、方法。</p><p>b）public</p><p>对所有类可见，修饰目标有类、接口、变量、方法。</p><p>c）protected</p><p>对同一包内的类和所有子类可见，修饰目标有变量、方法。 但是不能修饰类（外部类）。</p><p>d）private</p><p>在同一类内可见，修饰目标有变量、方法。 但是不能修饰类（外部类）。</p><p>（2）非访问控制修饰符</p><p>a）static</p><p>修饰方法，使之成为类方法/静态方法；修饰变量，使之成为类变量/静态变量。</p><p>b）final</p><p>修饰变量，使之成为常量；修饰方法，使之XXX；修饰类，使之XXX</p><p>c）abstract</p><p>修饰类，使之成为抽象类；修饰方法，使之成为抽象方法</p><p>d）synchronized</p><p>e）transient</p><p>f）volatile</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA语言中数组的使用</title>
      <link href="/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数组变量的声明和初始化（分开）"><a href="#数组变量的声明和初始化（分开）" class="headerlink" title="数组变量的声明和初始化（分开）"></a>数组变量的声明和初始化（分开）</h1><p>（1）数据变量的声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;   <span class="comment">// 首选的方法</span></span><br><span class="line"></span><br><span class="line">dataType arrayRefVar[];   <span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure><p>（2）数组变量的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line"></span><br><span class="line">arrayRefVar = <span class="keyword">new</span> dataType[]&#123;var1, var2, var3, ....&#125;;</span><br><span class="line"><span class="comment">// arrayRefVar = new dataType[2]&#123;var1, var2&#125;; //这种写法不可以哦，注意</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arrayRefVar = &#123;var1, var2, var3, ....&#125;; //这种写法不可以哦，注意</span></span><br></pre></td></tr></table></figure><h1 id="数组变量的声明和初始化（合并）"><a href="#数组变量的声明和初始化（合并）" class="headerlink" title="数组变量的声明和初始化（合并）"></a>数组变量的声明和初始化（合并）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line">dataType arrayRefVar[] = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line"></span><br><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[] &#123; value0, value1, ..., valuek &#125;;</span><br><span class="line">dataType arrayRefVar[] = <span class="keyword">new</span> dataType[] &#123; value0, value1, ..., valuek &#125;;</span><br><span class="line"><span class="comment">// dataType[] arrayRefVar = new dataType[2] &#123; value0, value1 &#125;; //这种写法不可以哦，注意</span></span><br><span class="line"><span class="comment">// dataType arrayRefVar[] = new dataType[2] &#123; value0, value1 &#125;; //这种写法不可以哦，注意</span></span><br><span class="line"></span><br><span class="line">dataType[] arrayRefVar = &#123; value0, value1, ..., valuek &#125;;</span><br><span class="line">dataType arrayRefVar[] = &#123; value0, value1, ..., valuek &#125;;</span><br></pre></td></tr></table></figure><h1 id="举例来说"><a href="#举例来说" class="headerlink" title="举例来说"></a>举例来说</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">double</span>[] myArr = <span class="keyword">new</span> <span class="keyword">double</span>[size];</span><br><span class="line">myArr[<span class="number">0</span>] = <span class="number">5.6</span>;</span><br><span class="line">myArr[<span class="number">1</span>] = <span class="number">4.5</span>;</span><br><span class="line">myArr[<span class="number">2</span>] = <span class="number">3.3</span>;</span><br><span class="line"></span><br><span class="line">myArr.length;  <span class="comment">// 获取数组的长度</span></span><br></pre></td></tr></table></figure><h1 id="一点闲杂"><a href="#一点闲杂" class="headerlink" title="一点闲杂"></a>一点闲杂</h1><p>（1）java.util.Arrays提供了一些操纵数组的静态方法。举例来说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(Object[] array)  <span class="comment">// 排序数组</span></span><br><span class="line">Arrays.sort(Object[] array, <span class="keyword">int</span> from, <span class="keyword">int</span> to)  <span class="comment">// 对数组指定范围的元素进行排序</span></span><br><span class="line">Arrays.toString(Object[] array)  <span class="comment">// 返回数组的字符串形式</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt;<span class="title">asList</span><span class="params">(T... a)</span>  <span class="comment">// 用给定的数组构造一个List对象</span></span></span><br><span class="line"><span class="function"><span class="comment">// ...</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA语言中控制逻辑语句</title>
      <link href="/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序语句"><a href="#顺序语句" class="headerlink" title="顺序语句"></a>顺序语句</h1><h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><p>（1）if语句</p><p>结构一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expression) &#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expression) &#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式的值为true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式的值为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构三：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expression1) &#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式1的值为true执行代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(expression2) &#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式2的值为true执行代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果以上布尔表达式都不为true执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）switch语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> value:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> value:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">default</span>:   <span class="comment">//可选</span></span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当变量的值与case语句的值相等时，那么case语句之后的语句开始执行，直到break语句出现才会跳出switch语句。当遇到break语句时，switch语句终止，程序跳转到switch语句后面的语句执行。case语句不必须要包含break语句，如果没有break语句出现，程序会继续执行下一条case语句，直到出现break语句。代码举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="comment">//char grade = args[0].charAt(0);</span></span><br><span class="line">      <span class="keyword">char</span> grade = <span class="string">'C'</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">switch</span>(grade) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">'A'</span> :</span><br><span class="line">            System.out.println(<span class="string">"优秀"</span>); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">'B'</span> :</span><br><span class="line">         <span class="keyword">case</span> <span class="string">'C'</span> :</span><br><span class="line">            System.out.println(<span class="string">"良好"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">'D'</span> :</span><br><span class="line">            System.out.println(<span class="string">"及格"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">'F'</span> :</span><br><span class="line">            System.out.println(<span class="string">"你需要再努力努力"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span> :</span><br><span class="line">            System.out.println(<span class="string">"未知等级"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"你的等级是 "</span> + grade);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>（1）while循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(expression) &#123;</span><br><span class="line">    <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）do-while循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125; <span class="keyword">while</span>(expression);</span><br></pre></td></tr></table></figure><p>（3）for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化; 布尔表达式; 更新) &#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）增强for循环或foreach循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句 : 表达式) &#123;</span><br><span class="line">    <span class="comment">//代码句子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] fruits = &#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Watermelon"</span>, <span class="string">"Orange"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (String fruit : fruits) &#123;</span><br><span class="line">    System.out.println(fruit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h1><p>（1）break</p><p>结束整个循环体</p><p>（2）continue</p><p>结束本次循环，开始下一次循环</p><p>（3）return</p><p>回到方法调用处</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA语言中各种数据类型</title>
      <link href="/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">关键字</th><th style="text-align:left">占用空间(字节）</th><th style="text-align:left">包装类型</th></tr></thead><tbody><tr><td style="text-align:left">整型</td><td style="text-align:left">byte</td><td style="text-align:left">1</td><td style="text-align:left">Byte</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">char</td><td style="text-align:left">2</td><td style="text-align:left">Character</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">short</td><td style="text-align:left">2</td><td style="text-align:left">Short</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">int</td><td style="text-align:left">4</td><td style="text-align:left">Integer</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">long</td><td style="text-align:left">8</td><td style="text-align:left">Long</td></tr><tr><td style="text-align:left">浮点型</td><td style="text-align:left">float</td><td style="text-align:left">8</td><td style="text-align:left">Float</td></tr><tr><td style="text-align:left">浮点型</td><td style="text-align:left">double</td><td style="text-align:left">8</td><td style="text-align:left">Double</td></tr><tr><td style="text-align:left">布尔型</td><td style="text-align:left">boolean</td><td style="text-align:left">8</td><td style="text-align:left">Boolean</td></tr></tbody></table><p>备注：byte/char/short/int/long都是整型数据类型，因占用存储空间的不同，所能代表的取值范围也是不同的。char和short虽然都占2个字节，但是char是无符号的整型，而short是有符号的整型，因此char和short的取值范围也是不同的。</p><p><strong>在Java中，整数字面值常量默认的数据类型是int，小数字面值常量默认的数据类型是double。</strong></p><p>当声明<code>long a = 23</code>时，23是int类型，属于小类型往大类型转换，Java可以自动转换，但是当后字面值常量大于int的范围时，就会报错了，因此当声明long类型的变量时，在后面加上<code>L/l</code>，即<code>long a = 23L</code>，<code>23L</code>就是一个long类型的字面值常量，这样就不存在类型的自动转换了。</p><p>当声明<code>float a = 2.3</code>时，2.3是double类型，属于大类型往小类型转换，这就可能会造成精度丢失，编译时会直接报错，因此当声明float类型的变量时，在后面加上<code>F/f</code>，即<code>float a = 2.3F</code>，<code>2.3F</code>就是一个float类型的字面值常量，这样就不存在类型的自动转换了。</p><h1 id="抽象数据类型ADT"><a href="#抽象数据类型ADT" class="headerlink" title="抽象数据类型ADT"></a>抽象数据类型ADT</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类/对象</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA语言简介及技能图谱</title>
      <link href="/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"/>
      <url>/2018/01/30/JAVA%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA语言简介"><a href="#JAVA语言简介" class="headerlink" title="JAVA语言简介"></a>JAVA语言简介</h1><p>Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。Java分为三个体系：</p><p>（1）JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</p><p>（2）JavaEE（J2EE）（Java2 Platform Enterprise Edition，java平台企业版）</p><p>（3）JavaME（J2ME）(Java2 Platform Micro Edition，java平台微型版）</p><p>2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字”2”，J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。</p><h1 id="JAVA版本选择"><a href="#JAVA版本选择" class="headerlink" title="JAVA版本选择"></a>JAVA版本选择</h1><p>从大概2019年01月份开始，Oracle JDK开始对Java SE 8之后的版本开始进行商用收费，确切的说是8u201/202之后的版本。如果你用Java开发的功能如果是用作商业用途的，如果还不想花钱购买的话，能免费使用的最新版本是8u201/202。当然如果是个人客户端或者个人开发者可以免费试用Oracle JDK所有的版本。</p><p>在JDK 9发布之前，Oracle的发版策略是以特性驱动的，只有重大的特性改变才会发布大版本，比如JDK 7到JDK 8，中间会发多个更新版本。而从JDK 9开始变为以时间驱动的方式。发布周期为6个月一个大版本，比如JDK 9到JDK 10，3个月一次补丁版，3年一个LTS（长期支持版本）。</p><p><img src="/images/java_syntax_1_3.png" alt></p><p>备注：目前，开发者中还是大部分在使用JDK 8哦，主要原因是JDK 8是LTS，稳定可靠，另外JDK 8之后的版本用于商业用途是要收费的。</p><p>JDK 8的新特性主要有：</p><p>（1）Lambda表达式</p><p>Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</p><p>（2）方法引用</p><p>方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与 lambda 联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p><p>（3）默认方法</p><p>默认方法就是一个在接口里面有了一个实现的方法。</p><p>（4）新工具</p><p>新的编译工具，如：Nashorn引擎jjs、 类依赖分析器jdeps。</p><p>（5）Stream API</p><p>新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</p><p>（6）Date Time API</p><p>加强对日期与时间的处理。</p><p>（7）Optional类</p><p>Optional类已经成为Java 8类库的一部分，用来解决空指针异常。</p><h1 id="JAVA技术体系"><a href="#JAVA技术体系" class="headerlink" title="JAVA技术体系"></a>JAVA技术体系</h1><p>JAVA技术体系包括如下几个部分：</p><p>（1）JAVA程序设计语言</p><p>（2）JAVA虚拟机JVM</p><p>（3）JAVA API类库</p><p>（4）来自商业机构或开源社区的第三方JAVA类库</p><h1 id="JAVA语言的完整概念图"><a href="#JAVA语言的完整概念图" class="headerlink" title="JAVA语言的完整概念图"></a>JAVA语言的完整概念图</h1><p><img src="/images/java_syntax_1_1.png" alt></p><p>图片来源于：<a href="https://docs.oracle.com/javase/8/docs/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/</a></p><p>备注：可见JDK是JRE的超集。</p><h1 id="JDK与JRE区别"><a href="#JDK与JRE区别" class="headerlink" title="JDK与JRE区别"></a>JDK与JRE区别</h1><p>JRE，Java Runtime Environment，是Java运行时环境，包含了Java虚拟机以及Java基础类库等，是使用Java语言编写的程序运行所需要的软件环境，是提供给想运行Java程序的用户使用的。</p><p>JDK，Java Development Kit，是Java开发工具包，是程序员使用Java语言编写Java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译Java源码的编译器javac，还包含了很多Java程序调试和分析的工具，如jconsole，jvisualvm等工具软件，另外，还包含了Java程序编写所需文档和demo例子程序。</p><p>如果你需要运行Java程序，只需安装JRE就可以了。如果你需要编写Java程序，需要安装JDK。</p><h1 id="JAVA技术栈的技能图谱"><a href="#JAVA技术栈的技能图谱" class="headerlink" title="JAVA技术栈的技能图谱"></a>JAVA技术栈的技能图谱</h1><p><img src="/images/java_syntax_1_2.png" alt></p><h1 id="JAVA世界中的一些新闻"><a href="#JAVA世界中的一些新闻" class="headerlink" title="JAVA世界中的一些新闻"></a>JAVA世界中的一些新闻</h1><p>（1）2017年，Oracle向Eclipse基金会捐赠Java EE规范，Java EE将被改名为Jakarta EE，在Java EE 8版本之后就是Jakarta EE 9，包名的命名空间从<code>javax.*</code>也改成了<code>jakarta.*</code>。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环型数据库RRD及RRDtool工具</title>
      <link href="/2018/01/30/%E7%8E%AF%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93RRD%E5%8F%8ARRDtool%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/01/30/%E7%8E%AF%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93RRD%E5%8F%8ARRDtool%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="RRD"><a href="#RRD" class="headerlink" title="RRD"></a>RRD</h1><p>RRD全称是Round Robin Database，即「环型数据库」。顾名思义，它是一种循环使用存储空间的数据库，适用于存储和时间序列相关的数据。RRD数据库在被创建的时候就已经定义好了数据库的大小，当空间存储满了以后，又从头开始覆盖旧的数据，这样整个存储空间的大小就是一个固定的数值，所以和其他线性增长的数据库不同 。 可以把RRD 理解为一个有时间刻度的圆环，每个刻度上可以存储一个数值，同时有一个从圆心指向最新存储值的指针。</p><p>RRD的数据库文件是以.rrd为结尾的文件，当然也可以随便定义文件名，但是最好后缀是rrd.</p><h1 id="RRDtool"><a href="#RRDtool" class="headerlink" title="RRDtool"></a>RRDtool</h1><p>RRDtool是一个往RRD数据库中存放和读取数据的工具，同时RRDtool又可以读取RRD数据库中的数据来动态创建图表。所以RRDtool看起来既是后台工具，也是前端画图工具。举例来说：</p><p>（1）使用rrdtool create命令创建一个名为test.rrd的RRD数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rrdtool create test.rrd</span><br><span class="line">--step 300</span><br><span class="line">DS:miles:COUNTER:600:0:1024</span><br><span class="line">RRA:AVERAGE:0.5:2:8</span><br><span class="line">RRA:AVERAGE:0.5:4:7</span><br></pre></td></tr></table></figure><p>（2）使用rrdtool update命令存储监测值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rrdtool update test.rrd 920804700:12345 920805000:12357 920805300:12363</span><br></pre></td></tr></table></figure><p>备注：表示插入3条记录，时间点920804700时，被监测对象数值为12345 ；时间点920805000时，被监测对象数值为12357 ；时间点920805300时，被监测对象数值为12363.</p><p>（3）使用rrdtool graph输出一张png图片</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rrdtool graph myrouter-day.png --start -86400</span><br><span class="line">DEF:inoctets=myrouter.rrd:input:AVERAGE</span><br><span class="line">DEF:outoctets=myrouter.rrd:output:AVERAGE</span><br><span class="line">AREA:inoctets<span class="comment">#00FF00:"In traffic"</span></span><br><span class="line">LINE1:outoctets<span class="comment">#0000FF:"Out traffic"</span></span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://www.jianshu.com/p/b925b1584ab2" target="_blank" rel="noopener">http://www.jianshu.com/p/b925b1584ab2</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RRD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源监控解决方案OMD技术</title>
      <link href="/2018/01/30/%E5%BC%80%E6%BA%90%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88OMD%E6%8A%80%E6%9C%AF/"/>
      <url>/2018/01/30/%E5%BC%80%E6%BA%90%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88OMD%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="OMD简介"><a href="#OMD简介" class="headerlink" title="OMD简介"></a>OMD简介</h1><p>OMD，英文全称是The Open Monitoring Distribution，OMD支持当前Centos的主流版本，同时也兼容RHEL的版本。 OMD是一套开源的监控套件，包含了多种开源的工具。简单概括如下：</p><p>（1）以Nagios为核心，用于任务的调度。</p><p>（2）Check_MK是基于Nagios的一个强力的扩展程序，接替Nagios负责数据采集和web管理（Nagios只做任务调度），集成了众多的监控插件/模板并支持目前主流的操作系统（Windows、Centos、Debian、FreeBSD等）</p><p>（3）通过pnp4nagios和RDDtool进行监控项目的绘图</p><p>（4）通过Nagvis和Thruk进行设备和网络拓扑的展示</p><h1 id="omd的版本及包含的组件"><a href="#omd的版本及包含的组件" class="headerlink" title="omd的版本及包含的组件"></a>omd的版本及包含的组件</h1><p>omd有两个版本，分别是Check_MK Raw Edition和OMD Labs-Edition。Check_MK Raw Edition版本其实就是Check_MK，下载地址会链接到Check_MK的官网。而OMD Labs-Edition包含了非常多的组件，如下：</p><p><img src="/images/omd_1_1.png" alt></p><p>一般来说，我们使用Check_MK Raw Edition就好了。安装演示里面的OMD也是Check_MK Raw Edition。</p><p>备注：thruk仅仅是GUI，比nagios原生的GUI要好用一些，尤其在thruk做批量报警屏蔽灰常好用。</p><h1 id="omd的安装与配置"><a href="#omd的安装与配置" class="headerlink" title="omd的安装与配置"></a>omd的安装与配置</h1><p>前提，这里安装测试的环境是RedHat Linux 6.8 + omd-1.20.rhel6.x86_64 + check_mk-agent-1.2.4p5-1</p><p>（1）下载omd rpm包并在服务端安装</p><p>在<a href="http://files.omdistro.org/releases/centos_rhel/上下载omd的安装，然后执行rpm" target="_blank" rel="noopener">http://files.omdistro.org/releases/centos_rhel/上下载omd的安装，然后执行rpm</a> -ivh omd-*.rpm。之后会提示一些依赖包需要安装，直接执行命令yum install XXX即可（应该会提示安装httpd，直接yum install httpd即可）。</p><p>omd默认安装到/opt/omd目录中，其生成的目录结构为：</p><p><img src="/images/omd_1_2.png" alt></p><p>并且创建一个软链/omd，目标链接到/opt/omd.</p><p>其中apache目录只存放一个apache虚机host的配置文件；versions目录存放的是OMD的bin/lib/man文档等等；sites是使用omd create命令创建出来的site，里面会有该site的bin/conf/lib等等（bin是直接软链到versions目录下的bin）。</p><p>（2）使用omd命令生成站点并启动站点</p><p>使用omd create xxx命令来创建一个站点site，会生成/omd/sites/xxx站点：</p><p><img src="/images/omd_1_3.png" alt></p><p>使用omd start用来启动站点所有服务，包括apache，nagios等。</p><p>（3）下载check_mk agent rpm包并在客户端安装，修改配置并启动</p><p>在Check_MK的WATO配置中，找到Monitoring Agents，然后在面板中可以直接下载Check_mk agent。而对于老版本的Check_MK（例如1.2.4p5），在WATO界面中找不到Monitoring Agents选项，可以使用链接<a href="http://mathias-kettner.de/download/check_mk-agent-1.2.4p5-1.noarch.rpm下载check_mk-agent，并安装。check_mk" target="_blank" rel="noopener">http://mathias-kettner.de/download/check_mk-agent-1.2.4p5-1.noarch.rpm下载check_mk-agent，并安装。check_mk</a> agent是以xinitd的进程存在，agent监听的端口是6556。</p><p>（4）Web-GUI界面登录</p><p>访问地址<a href="http://HOSTNAME/my-omdsite-name/omd/即可访问，其中check_mk的缺省账号和密码分别为omdadmin和omd。" target="_blank" rel="noopener">http://HOSTNAME/my-omdsite-name/omd/即可访问，其中check_mk的缺省账号和密码分别为omdadmin和omd。</a></p><p>（5）在omd的check_mk界面WATO中添加主机和服务，并刷新WATO配置</p><p>若check_mk agent没有部署，那么为host添加service监控时，会报如下错误：</p><p><img src="/images/omd_1_4.png" alt></p><h1 id="omd的服务进程"><a href="#omd的服务进程" class="headerlink" title="omd的服务进程"></a>omd的服务进程</h1><p>默认情况下，执行omd start命令后，会启动如下的服务：</p><p><img src="/images/omd_1_5.png" alt></p><p>下面分别简单说明下：</p><p>（1）npcd，全称为Nagios-Perfdata-C-Daemon，是专门用来处理性能数据的。</p><p>（2）nagios</p><p>（3）rrdcached</p><p>rrdcached是一个常驻内存的进程，用来接收更新RRD数据的请求，如果请求积累到一定数据或超过一定的时间，rrdcached才会一次性的去更新RRD文件，这种方式主要是来缓存磁盘的IO压力。</p><p>（4）apache</p><p>（5）mkeventd</p><p>Event Console是由mkeventd后台进程来控制的。</p><h1 id="omd及check-mk的一些常用操作命令"><a href="#omd及check-mk的一些常用操作命令" class="headerlink" title="omd及check_mk的一些常用操作命令"></a>omd及check_mk的一些常用操作命令</h1><p>omd可以使用的命令有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">omd version   <span class="comment">#查看omd的版本</span></span><br><span class="line">omd sites     <span class="comment">#查看本机上所有omd创建的站点</span></span><br><span class="line">omd status    <span class="comment">#查看omd管理服务的状态</span></span><br><span class="line">omd restart   <span class="comment">#重启omd管理的服务</span></span><br><span class="line">omd create sitename  <span class="comment">#创建一个名称为sitename的omd站点</span></span><br><span class="line">omd start sitename    <span class="comment">#启动名称为sitename的omd站点，该命令会启动一系列命令，包括httpd、nagios、check_mk等等</span></span><br></pre></td></tr></table></figure><p>su - OMD-user &amp;&amp; cd /omd/sites/XXX，然后可以执行很多check_mk的命令，举例来说：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./bin/check_mk -l    <span class="comment">#查看check_mk中配置的所有主机host列表</span></span><br><span class="line">./bin/check_mk -L    <span class="comment">#可以查看check_mk支持的所有采集项</span></span><br><span class="line">./bin/check_mk -d HOSTNAME|IPADDRESS        <span class="comment">#输出指定check-mk agent的原始输出，每一项以&lt;&lt;&lt;XXX&gt;&gt;&gt;开头</span></span><br><span class="line">./bin/check_mk --checks=mem.used -I s1531   <span class="comment">#从check-mk agent s1531中获取filecount.temp采集项的值，并存储到check_mk服务端，注意并会将采集值打印到终端屏幕上</span></span><br><span class="line">./bin/check_mk -nv s1531   <span class="comment">#查看指定agent的所有hosts/services最新的监控状态，会将结果打印到终端屏幕上</span></span><br><span class="line">./bin/check_mk -p -v --checks=mem.used -I s1531  <span class="comment">#采集指定项目，并存储到check_mk服务端</span></span><br></pre></td></tr></table></figure><p>6.omd中一些重要的目录备注</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/omd/sites/XXX/local/share/check_mk/checks  #服务端用来解析客户端采集的数据</span><br><span class="line">/usr/lib/check_mk_agent/plugins             #check_mk agent端采集检测脚本</span><br><span class="line">/omd/sites/XXX/var/check_mk/precompiled     #这里面是预编译的脚本，check_mk向check_mk agent采集数据就是通过该目录下面的脚本来完成的。每一个host对应一个python脚本和二进制文件，当我们修改某个host的监控配置时，会自动重新编译该脚本。另外，若手动删除了某个host的脚本，那么将采集不到对应host的监控值，参见下图</span><br><span class="line">/omd/sites/XXX/lib/nagios/plugins           #是nagios各种插件的安装位置</span><br><span class="line">/omd/sites/XXX/etc/check_mk/conf.d/wato     #使用check_mk的WATO生成的配置所在的目录</span><br><span class="line">/omd/sites/XXX/var/pnp4nagios/perfdata/     #perf性能的rrd文件的存储路径</span><br><span class="line">/omd/sites/XXX/var/                         #各种监控数据存放的位置，灰常重要</span><br><span class="line">/omd/sites/XXX/tmp/nagios/status.dat        #omd中nagios组件界面的状态文件status.dat</span><br><span class="line">/omd/sites/XXX/tmp/check_mk/cache           #该目录存放的是从check_mk-agent获取到的最新的结果，每个host对应一个文件</span><br><span class="line">/omd/sites/XXX/local                        #目录存放的是用户自定义的一些脚本或配置，例如短信/微信报警、用户自定义的check_mk采集等等</span><br></pre></td></tr></table></figure><p>/omd/sites/XXX/var/check_mk/precompiled中预编译脚本的引用：</p><p><img src="/images/omd_1_6.png" alt></p><p>学习资料参考于：<br><a href="http://www.jianshu.com/p/11fb320816ab" target="_blank" rel="noopener">http://www.jianshu.com/p/11fb320816ab</a></p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OMD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>check_mk系列（7）_一些使用技巧</title>
      <link href="/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89-%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89-%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="check-mk的PNP4Nagios面板的小功能"><a href="#check-mk的PNP4Nagios面板的小功能" class="headerlink" title="check_mk的PNP4Nagios面板的小功能"></a>check_mk的PNP4Nagios面板的小功能</h1><p><img src="/images/check_mk_7_1.png" alt></p><p>功能1：可以查看对应时间段该host/service的所有告警信息，是超链接到nagios的历史告警报告页面上。<br>功能2：可以查看对应时间段该host/service的所有可用性数据，是超链接到nagios的Availablility报告页面上。<br>功能3：收藏视图到check_mk GUI的个人收藏夹中。<br>功能4：将pnp4nagios绘制的趋势图在单独的页面中显示，且可以灵活地调整时间范围，如下：</p><p><img src="/images/check_mk_7_2.png" alt></p><h1 id="check"><a href="#check" class="headerlink" title="check"></a>check</h1><p>在check_mk的面板中，有很多功能需要关注下，如下：</p><p><img src="/images/check_mk_7_3.png" alt></p><p>比如说，点击图标功能，可以在指定的对象，例如host、service等，执行特殊的操作。一个使用场景是，我们模拟各个采集项的结果，并触发报警。如下所示：</p><p><img src="/images/check_mk_7_4.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> check_mk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>check_mk系列（6）_分布式任务处理系统gearman以及在nagios应用</title>
      <link href="/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9Fgearman%E4%BB%A5%E5%8F%8A%E5%9C%A8nagios%E5%BA%94%E7%94%A8/"/>
      <url>/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9Fgearman%E4%BB%A5%E5%8F%8A%E5%9C%A8nagios%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="gearman简介"><a href="#gearman简介" class="headerlink" title="gearman简介"></a>gearman简介</h1><p>gearman是一个分布式任务处理系统，我们可以将一个任务拆解成很多的子任务(worker)来处理。gearman技术栈架构如下：</p><p><img src="/images/check_mk_6_1.png" alt></p><p>备注：黄色部分为Geaman提供，蓝色部分为用户自定义的应用程序，包括client和worker。</p><h1 id="gearman组成部分"><a href="#gearman组成部分" class="headerlink" title="gearman组成部分"></a>gearman组成部分</h1><p>一个gearman请求的处理过程涉及三个角色，如下：</p><p>（1）gearman client</p><p>提供gearman client API给应用程序调用。API可以使用C,PHP,PERL,MYSQL UDF等待呢个语言，它是请求的发起者。</p><p>（2）gearman job server</p><p>将客户端的请求分发到各个gearman worker的调度者，相当于中央控制器，但它不处理具体业务逻辑。gearmand一般监听的是4730端口（当然端口也可以指定为其他的）。</p><p>（3）gearman worker<br>提供gearman worker API给应用程序调用，具体负责客户端的请求，并将处理结果返回给客户端。</p><p>因为Client，Worker并不限制用一样的语言，所以有利于多语言多系统之间的集成。 甚至我们通过增加更多的Worker，可以很方便的实现应用程序的分布式负载均衡架构。</p><h1 id="gearman的高可用HA架构"><a href="#gearman的高可用HA架构" class="headerlink" title="gearman的高可用HA架构"></a>gearman的高可用HA架构</h1><p><img src="/images/check_mk_6_2.png" alt></p><p>如上图架构中所示，client/job server/worker均可以进行扩展。</p><h1 id="gearman在nagios-omd监控平台中的应用"><a href="#gearman在nagios-omd监控平台中的应用" class="headerlink" title="gearman在nagios/omd监控平台中的应用"></a>gearman在nagios/omd监控平台中的应用</h1><p><img src="/images/check_mk_6_3.png" alt></p><p>有了mod_gearman后，omd的工作过程为：</p><p>（1）nagios发起一轮的host/service检查</p><p>（2）mod_gearman NEB模块（会在nagios.cfg中配置broker_module）拦截检查请求</p><p>（3）mod_gearman将检查请求任务提交到gearmand的任务队列中</p><p>（4）mod_gearman_worker服务从gearmand的任务队列中获取任务，执行检查，并将检查结果写入到Check Results中</p><p>（5）mod_gearman从Check Results中获取检查结果，并将结果放入到nagios的队列中</p><p>（6）nagios读取队列的检查结果，并更新nagios状态</p><h1 id="nagios中配置使用gearmand"><a href="#nagios中配置使用gearmand" class="headerlink" title="nagios中配置使用gearmand"></a>nagios中配置使用gearmand</h1><p>需要在nagios.cfg中配置NEB代理，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broker_module=/omd/sites/mm/lib/mod_gearman/mod_gearman.o config=/omd/sites/mm/etc/mod-gearman/server.cfg</span><br></pre></td></tr></table></figure><p>这样后，nagios会将检查任务的执行直接交给了mod_gearman来处理。</p><p>学习资料参考于：<br><a href="http://gearman.org/" target="_blank" rel="noopener">http://gearman.org/</a><br><a href="https://labs.consol.de/nagios/mod-gearman/" target="_blank" rel="noopener">https://labs.consol.de/nagios/mod-gearman/</a></p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> check_mk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>check_mk系列（5）_自定义监控配置</title>
      <link href="/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="check-mk自定义监控配置方法"><a href="#check-mk自定义监控配置方法" class="headerlink" title="check_mk自定义监控配置方法"></a>check_mk自定义监控配置方法</h1><p>下面以创建一个统计磁盘状态的监控为例来说明，check_mk自定义监控的配置步骤为：</p><p>（1）在check_mk agent端增加采集脚本</p><p>在/usr/lib/check_mk_agent/plugins目录中自定义一个script脚本，并赋予可执行权限，假设为usr/lib/check_mk_agent/plugins/rapid.sh，其内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'&lt;&lt;&lt;rapid&gt;&gt;&gt;'</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF</span><br><span class="line">/dev/sda   1 Raw_Read_Error_Rate     0x002f   200   200   051    Pre-fail  Always       -       0</span><br><span class="line">/dev/sda   3 Spin_Up_Time            0x0027   129   127   021    Pre-fail  Always       -       6541</span><br><span class="line">/dev/sda   4 Start_Stop_Count        0x0032   100   100   000    Old_age   Always       -       251</span><br><span class="line">/dev/sda   5 Reallocated_Sector_Ct   0x0033   200   200   140    Pre-fail  Always       -       0</span><br><span class="line">/dev/sda   6 Temperature_Celsius     0x0022   106   098   000    Old_age   Always       -       41</span><br><span class="line">/dev/sdb   1 Raw_Read_Error_Rate     0x002f   200   200   051    Pre-fail  Always       -       0</span><br><span class="line">/dev/sdb   3 Spin_Up_Time            0x0027   129   127   021    Pre-fail  Always       -       6541</span><br><span class="line">/dev/sdb   4 Start_Stop_Count        0x0032   100   100   000    Old_age   Always       -       251</span><br><span class="line">/dev/sdb   5 Reallocated_Sector_Ct   0x0033   200   200   140    Pre-fail  Always       -       0</span><br><span class="line">/dev/sdb   6 Temperature_Celsius     0x0022   106   098   000    Old_age   Always       -       411</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>备注：</p><p>一定要注意的是，采集脚本的输出要以&lt;&lt;<xxxx>&gt;&gt;开头，该header将在check_mk的服务端标识该采集数据的来源。该采集脚本是模拟输出硬件磁盘的一些状态信息，每个设备都会有好多的指标及对应的数值。在agent端配置了采集脚本后，先在agent执行/usr/bin/check_mk_agent命令，看能够正常输出新增的采集，然后在check_mk的服务端执行./bin/check_mk -d HOSTNAME来查看新配置的采集脚本输出，若有输出，则说明采集脚本配置正确。</xxxx></p><p>另外我们不在agent端新增脚本，直接编辑/usr/bin/check_mk_agent脚本，将自己的采集程序加入到该脚本也是可以的，但是我们一般不会这么做哦。</p><p>（2）在服务端编写check脚本，用于解析agent端返回的值</p><p>在/opt/omd/sites/XXX/local/share/check_mk/checks目录下新建名称为rapid的文本文件（文件名必须要于agent端采集脚本的header相同），内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line">rapid_temp_default_values = (<span class="number">40</span>, <span class="number">60</span>)   <span class="comment">#监控的阈值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#称为inventory函数，info是agent端返回的header为rapid的文本值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inventory_rapid_temp</span><span class="params">(info)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> info:</span><br><span class="line">        disk = line[<span class="number">0</span>]</span><br><span class="line">        field = line[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> field == <span class="string">"Temperature_Celsius"</span>:</span><br><span class="line">            <span class="keyword">yield</span> disk, <span class="string">"rapid_temp_default_values"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#称为check函数，item为inventory函数返回值的第一个字段，parms为inventory函数返回的第二个字段</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_rapid_temp</span><span class="params">(item, params, info)</span>:</span></span><br><span class="line">    warn, crit = params</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> info:</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">0</span>] == item <span class="keyword">and</span> line[<span class="number">2</span>] == <span class="string">"Temperature_Celsius"</span>:</span><br><span class="line">            celsius = int(line[<span class="number">10</span>])</span><br><span class="line">            <span class="keyword">if</span> celsius &gt; crit:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>, <span class="string">"Temperature is %dC"</span> % celsius</span><br><span class="line">            <span class="keyword">elif</span> celsius &gt; warn:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>, <span class="string">"Temperature is %dC"</span> % celsius</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="string">"Temperature is %dC"</span> % celsius</span><br><span class="line"></span><br><span class="line"><span class="comment">#该部分是该自定义监控的声明，其中的temp值会被check函数的item替代</span></span><br><span class="line">check_info[<span class="string">"rapid.temp"</span>] = &#123;     </span><br><span class="line">    <span class="string">'check_function'</span>:            check_rapid_temp,</span><br><span class="line">    <span class="string">'inventory_function'</span>:        inventory_rapid_temp,</span><br><span class="line">    <span class="string">'service_description'</span>:       <span class="string">'RAPID drive %s'</span>,    <span class="comment">#%s是check函数的返回值的第二个字段，这个将作为check_mk上的服务名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：配置了如上内容，既可以在./bin/check_mk -L中有了rapid.temp的采集项</p><p>（3）测试验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bin/check_mk -L | grep rapid               <span class="comment">#查看检查项已经正确配置到check_mk</span></span><br><span class="line">./bin/check_mk --checks=rapid -I 10.8.18.53  <span class="comment">#向指定的机器发起rapid的采集，并存储到服务端中</span></span><br><span class="line">./bin/check_mk -nv 10.8.18.53                <span class="comment">#查看监控状态</span></span><br></pre></td></tr></table></figure><p>在check_mk页面上，点击到机器的WATO页面，会发现新增的服务被check_mk自动发现了，我们在页面上点击添加，并activate change即可。界面显示效果如下：</p><p><img src="/images/check_mk_5_1.png" alt></p><h1 id="自定义监控服务端脚本说明"><a href="#自定义监控服务端脚本说明" class="headerlink" title="自定义监控服务端脚本说明"></a>自定义监控服务端脚本说明</h1><p>check_mk服务端脚本有三部分组成：</p><p>（1）Inventory函数</p><p>（2）check函数</p><p>check函数接收三个参数，分别是items、检查参数、agent返回info。check函数返回值必须是一个元组，该元组的元素分别为：</p><pre><code>status code (0=OK, 1=WARN, 2=CRIT, 3=UNKNOWN)文本字符串，用来现在到check_mk或nagios的WEB界面上性能数据，该部分是可选的</code></pre><p>（3）check声明</p><p>是一个字典形式。</p><h1 id="为自定义监控加上性能数据"><a href="#为自定义监控加上性能数据" class="headerlink" title="为自定义监控加上性能数据"></a>为自定义监控加上性能数据</h1><p>（1）修改服务端脚本</p><p>为自定义监控加上性能数据，既可以在check_mk页面展示PNP4Nagios的可视化界面了。增加性能数据只需要修改服务端脚本即可，我们在上面的例子基础上，做如下修改即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line">rapid_temp_default_values = (<span class="number">40</span>, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inventory_rapid_temp</span><span class="params">(info)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> info:</span><br><span class="line">        disk = line[<span class="number">0</span>]</span><br><span class="line">        field = line[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> field == <span class="string">"Temperature_Celsius"</span>:</span><br><span class="line">            <span class="keyword">yield</span> disk, <span class="string">"rapid_temp_default_values"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_rapid_temp</span><span class="params">(item, params, info)</span>:</span></span><br><span class="line">    warn, crit = params</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> info:</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">0</span>] == item <span class="keyword">and</span> line[<span class="number">2</span>] == <span class="string">"Temperature_Celsius"</span>:</span><br><span class="line">            celsius = int(line[<span class="number">10</span>])</span><br><span class="line">            perfdata = [( <span class="string">"temp"</span>, celsius, warn, crit)]</span><br><span class="line">            <span class="keyword">if</span> celsius &gt; crit:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>, <span class="string">"Temperature is %dC"</span> % celsius, perfdata</span><br><span class="line">            <span class="keyword">elif</span> celsius &gt; warn:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>, <span class="string">"Temperature is %dC"</span> % celsius, perfdata</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="string">"Temperature is %dC"</span> % celsius, perfdata</span><br><span class="line"></span><br><span class="line">check_info[<span class="string">"rapid.temp"</span>] = &#123;</span><br><span class="line">    <span class="string">'check_function'</span>:            check_rapid_temp,</span><br><span class="line">    <span class="string">'inventory_function'</span>:        inventory_rapid_temp,</span><br><span class="line">    <span class="string">'service_description'</span>:       <span class="string">'RAPID drive %s'</span>,</span><br><span class="line">    <span class="string">'has_perfdata'</span>:              <span class="literal">True</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：需要两处修改，第一处在check声明时，通过has_perfdata指明有性能数据。第二处是在check函数的返回值增加第三个字段，填充性能数据即可。其中性能数据的python列表，列表中每一个元素是元组类型，每个元组类型的字段如下（其中只有name和value是必需的，其他都是可选的）：</p><p><img src="/images/check_mk_5_6.png" alt></p><p>举例来说：</p><p><img src="/images/check_mk_5_2.png" alt></p><p>（2）check_mk界面上验证效果</p><p>增加了性能数据，在check_mk的显示效果为：</p><p><img src="/images/check_mk_5_3.png" alt></p><p><img src="/images/check_mk_5_4.png" alt></p><p><img src="/images/check_mk_5_5.png" alt></p><p>学习资料参考于：<br><a href="http://blog.csdn.net/dingyingguidyg/article/details/22674779" target="_blank" rel="noopener">http://blog.csdn.net/dingyingguidyg/article/details/22674779</a><br><a href="http://mathias-kettner.de/checkmk_devel_agentbased.html" target="_blank" rel="noopener">http://mathias-kettner.de/checkmk_devel_agentbased.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> check_mk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>check_mk系列（4）_livestatus模块</title>
      <link href="/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89-livestatus%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89-livestatus%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="check-mk-livestatus简介"><a href="#check-mk-livestatus简介" class="headerlink" title="check_mk livestatus简介"></a>check_mk livestatus简介</h1><p>livestatus也是由mathias-kettner编写，livestatus是一个Nagios NEB模块，nagios daemon启动时，会将livestatus加载到nagios daemon进程中。简单来说，livestatus为用户提供了一个UNIX Socket，通过它，用户可以直接查询运行中的Nagios守护进程的状态信息。用户通过简单的查询语言，就可以得到即时的结果，该结果正是来自nagios进程所使用的内存中的数据结构区域。因为这种方式没有复制nagios的状态信息，也没有查询外部数据库，所以带来的开销非常小，而且这种方式没有任何延迟和数据过期的风险，所以不会带来阻塞nagios进程的风险。另外，通过livestatus，还可以获取到nagios的历史状态信息哦。</p><h1 id="使用livestatus作为数据来源的系统"><a href="#使用livestatus作为数据来源的系统" class="headerlink" title="使用livestatus作为数据来源的系统"></a>使用livestatus作为数据来源的系统</h1><p>使用livestatus作为数据来源的系统有：</p><p>（1）Check_MK Multisite</p><p>（2）NagVis</p><p>（3）NagiosBP</p><p>（4）Thruk</p><p>（5）CoffeeSaint</p><p>（6）RealOpInsight</p><p>（7）……</p><h1 id="livestatus的配置和使用"><a href="#livestatus的配置和使用" class="headerlink" title="livestatus的配置和使用"></a>livestatus的配置和使用</h1><p>（1）livestatus的配置</p><p>首先需要在nagios.cfg中配置livestatus的NEB，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broker_module=/omd/sites/XXXX/lib/mk-livestatus/livestatus.o num_client_threads=20 pnp_path=/omd/sites/XXXX/var/pnp4nagios/perfdata /omd/sites/XXXX/tmp/run/live</span><br></pre></td></tr></table></figure><p>其中/omd/sites/XXXX/tmp/run/live，即是livestatus提供的unix socket文件，通过该socket既可通过livestatus，获取到nagios的当前状态和历史状态信息。</p><p>（2）livestatus的使用</p><p>可以有很多方式与livestatus通信，其中使用shell命令最简单，这里以shell为例说明如何通过livestatus获取到nagios的status信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'GET hosts'</span> | nc -U /omd/sites/XXXX/tmp/run/live     <span class="comment">#获取nagios中hosts信息</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'GET services'</span> | nc -U /omd/sites/XXXX/tmp/run/live  <span class="comment">#获取nagios中services信息</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'GET  contacts'</span> | nc -U /omd/sites/XXXX/tmp/run/live <span class="comment">#获取nagios中contacts信息</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://mathias-kettner.com/checkmk_livestatus.html" target="_blank" rel="noopener">http://mathias-kettner.com/checkmk_livestatus.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> check_mk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>check_mk系列（3）_WATO说明</title>
      <link href="/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89-WATO%E8%AF%B4%E6%98%8E/"/>
      <url>/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89-WATO%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="WATO提供的配置模块"><a href="#WATO提供的配置模块" class="headerlink" title="WATO提供的配置模块"></a>WATO提供的配置模块</h1><p>原则上来说，我们可以修改/omd/sites/sgwlog/etc/check_mk目录下文件，来配置check_mk（比如增加host/service等等），但是这种方式非常不友好。其实check_mk的GUI页面上有WATO面板，可以通过它进行可视化地配置check_mk。</p><p>WATO提供的配置模块有：</p><p><img src="/images/check_mk_3_1.png" alt></p><p>（1）Hosts模块</p><p>在WATO的host面板中，New host表示在当前目录中新增一台host。New folder表示在当前目录中新增一个目录。New cluster表示在当前目录中新增一个集群。</p><p>（2）Host &amp; Service Parameters</p><p>rule的配置，很重要哦。</p><p>（3）Global Settings</p><p>（4）Monitoring Agents</p><h1 id="在check-mk增加host以及为host配置服务service监控"><a href="#在check-mk增加host以及为host配置服务service监控" class="headerlink" title="在check_mk增加host以及为host配置服务service监控"></a>在check_mk增加host以及为host配置服务service监控</h1><p>（1）添加host</p><p>在左侧WATO Configuration面板中，点击Hosts条目后，点击右侧Create new host，然后按照如下配置host信息：</p><p><img src="/images/check_mk_3_2.png" alt></p><p>（2）保存host信息并为host添加service监控</p><p>点击host信息下方的Save &amp; go to Services按钮，即可进入该host对应的services监控配置页面，效果如如下：</p><p><img src="/images/check_mk_3_3.png" alt></p><p>上图中Check_MK默认列出该host的所有服务，例如CPU负载、内存使用情况、磁盘可用空间等等，我们可以自主地选择一些服务，然后点击面板上方的Save manual check configuration按钮。</p><p>（3）让配置变更生效</p><p>点击Changes按钮，然后点击Activate Changes!按钮，即可生效check_mk中的所有变更。界面操作如下：</p><p><img src="/images/check_mk_3_4.png" alt></p><p><img src="/images/check_mk_3_5.png" alt></p><p>备注：在Check_mk中做任何配置变更，都需要经过这两个步骤，监控才能生效哦。</p><h1 id="WATO的Activate-Changes"><a href="#WATO的Activate-Changes" class="headerlink" title="WATO的Activate Changes!"></a>WATO的Activate Changes!</h1><p>在check_mk的WATO面板中修改任何配置，都需要点击Activate Changes!按钮，配置才会真正生效。如下图，Activate Changes!会生成新的配置，并让check_mk加载新的配置，从而生效监控变更。</p><p><img src="/images/check_mk_3_6.png" alt></p><h1 id="WATO的快照snapshot"><a href="#WATO的快照snapshot" class="headerlink" title="WATO的快照snapshot"></a>WATO的快照snapshot</h1><p>在WATO中每次点击Activate Changes!按钮时，check_mk都会对配置生成一个快照，我们可以借助于这些历史的快照来回滚对check_mk的配置。界面效果如下：</p><p><img src="/images/check_mk_3_7.png" alt></p><h1 id="check-mk的host管理"><a href="#check-mk的host管理" class="headerlink" title="check_mk的host管理"></a>check_mk的host管理</h1><p>check_mk的host管理有如下几个特点：</p><p>（1）通过目录层级的方式来管理host</p><p><img src="/images/check_mk_3_8.png" alt></p><p>（2）可以给host打tag标记</p><p>（3）check_mk为host自动检查可以监控的服务</p><h1 id="check-mk的服务自动发现auto-discovery机制"><a href="#check-mk的服务自动发现auto-discovery机制" class="headerlink" title="check_mk的服务自动发现auto discovery机制"></a>check_mk的服务自动发现auto discovery机制</h1><p>给定一个host，check_mk的auto discovery机制能自动检查出，该host上有哪些可以被监控的服务。其实原理很简单，个人理解主要有两点：</p><p>（1）check_mk-agent每次都会将采集到的所有信息返回给check_mk服务端，这样check_mk的服务端就可以知道host上有哪些服务了</p><p>（2）check_mk有一些检查插件，可以远程探测目标host的</p><p>也就是说，通过上面的两方面，check_mk就知道主机上有哪些服务了。我们可以通过./bin/check_mk -L来查看check_mk可以探测出哪些服务。</p><h1 id="rule-set"><a href="#rule-set" class="headerlink" title="rule set"></a>rule set</h1><p>rule set在WATO配置中是一个非常重要的概念，例如WATO中我们可以add host，add hostgroup，而某一个hostgroup包含哪些host，是由rule来控制的，比如我们让某个目录下的有指定tag的机器，组成一个hostgroup。那么后面我们有机器变更，由于rule的存在，就会自动会维护这个hostgroup信息。rule可以配置很多东西，比如什么服务的告警的接收人等等。rule的配置是通过WATO的Host &amp; Service Parameters来配置的。</p><p>我们通过Host &amp; Service Parameters的Used Rulesets来查看已经制定了哪些rule。</p><p>参考资料来源于：<br><a href="http://ithelp.ithome.com.tw/articles/10136521" target="_blank" rel="noopener">http://ithelp.ithome.com.tw/articles/10136521</a></p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> check_mk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>check_mk系列（2）_check_mk-agent</title>
      <link href="/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89-check-mk-agent/"/>
      <url>/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89-check-mk-agent/</url>
      
        <content type="html"><![CDATA[<h1 id="check-mk-agent简介"><a href="#check-mk-agent简介" class="headerlink" title="check_mk agent简介"></a>check_mk agent简介</h1><p>使用check_mk，需要在被监控主机上安装一个check_mk-agent rpm包。check_mk-agent rpm包会在主机上安装如下文件：</p><p><img src="/images/check_mk_2_1.png" alt></p><p>下面分别说明几个主要文件的用途：</p><p>（1）/usr/bin/check_mk_agent是check_mk agent的主程序，它是一个shell脚本。用来收集监控信息，将信息事先提取后，等待check_mk端来获取数据。</p><p>（2）/etc/xinetd.d/check_mk为xinetd下的服务配置文件，用于守护check_mk_agent进程，并使agent监听tcp 6556端口，用来和check_mk服务端建立TCP连接。</p><p>（3）/usr/bin/waitmax会被check_mk_agent shell脚本调用，waitmax主要用于容错处理，当agent执行一些命令或脚本采集数据时陷入僵死或长时间等待时，waitmax可以在超过一定的时间后强行终止程序。</p><p>（4）/usr/lib/check_mk_agent/plugins目录用于存放用户自定义的采集脚本。</p><p>备注：</p><p>（1）在被监控主机上，直接执行/usr/bin/check_mk_agent脚本，即可输出各种采集数据。我们可以读取/usr/bin/check_mk_agent脚本来了解每个采集项的获取方式，一般来说是读取/proc内存中的数值。</p><p>（2）可以使用telnet HOSTNAME 6556命令，连接任何一台安装有check_mk agent的机器，即可获取到check_mk agent的采集数据。</p><p>学习资料参考于：<br><a href="http://www.361way.com/check_mk-cs-data-interaction/4255.html" target="_blank" rel="noopener">http://www.361way.com/check_mk-cs-data-interaction/4255.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> check_mk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>check_mk系列（1）_介绍及基本原理</title>
      <link href="/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2018/01/30/check-mk%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="check-mk简介"><a href="#check-mk简介" class="headerlink" title="check_mk简介"></a>check_mk简介</h1><p>check_mk是一款通用的Nagios/Icinga数据采集插件，它采用了新的方法从操作系统和网络组件中收集数据，表现得比NRPE、check_by_ssh、NSClient和check_snmp更加优秀。</p><p><img src="/images/check_mk_1_1.png" alt></p><p>具体的工作控制流程如下：</p><p>（1）nagios每一次对所监控的主机每进行一次检查的时间间隔触发一个活动检查。这种主动检查将会触发check_mk插件</p><p>（2）check_mk通过TCP连接到目标主机。目标主机上的check_mk_agent检索有关该主机的所有相关数据，并将其以ASCII文本形式返回给服务器端(类似于zabbix的架构)</p><p>（3）check_mk提取performance数据直接返回给RRD</p><p>（4）check_mk提取相关数据，比较所设置的warning/critical阀值，然后返回这台主机通过Nagios的被动的服务检查的检查结果。</p><p>简单来说，使用check_mk作为监控基础实施的话，一般至少需要nagios、check_mk-server、check_mk-agent这三个组件。更简单来说，check_mk是nagios的一个被动检查的插件而已。我们在check_mk的GUI上配置一些监控策略，check_mk会自动生成nagios的配置。</p><p>如下为基于Nagios/check_mk的监控解决方案架构原理图：</p><p><img src="/images/check_mk_1_2.png" alt></p><p><img src="/images/check_mk_1_3.png" alt></p><h1 id="check-mk的版本"><a href="#check-mk的版本" class="headerlink" title="check_mk的版本"></a>check_mk的版本</h1><p>check_mk有两种版本，一个是Raw Edition，另一个是Enterprise Edition。其中Raw Edition版本是开源且免费的，Enterprise Edition版本有更多的组件及技术支持，是收费的。</p><p>check_mk包含的组件有：</p><p>（1）Configuration &amp; Check Engine</p><p>check_mk的数据采集等。</p><p>（2）Livestatus</p><p>一个nagios NEB模块，用户对外提供nagios内部状态信息。</p><p>（3）Multisite</p><p>check_mk的GUI界面，数据来源于Livestatus。我们通过check_mk Multisite去配置一些监控策略，会生成check_mk自身的一些本地配置。同时，check_mk会自动生成nagios的配置，然后由nagios来调度整个监控系统的运转。</p><p>（4）WATO</p><p>check_mk的配置面板，可以生成check_mk/nagios的配置。</p><p>（5）Notify</p><p>在nagios系统中，当报警发生时，nagios会调用用户自定义的报警插件来发出告警。然后在nagios + check_mk监控系统中，当报警发生时，nagios仅仅需要调用./bin/check_mk –notify命令以及附带一些命令参数即可。然后./bin/check_mk –notify会读取check_mk配置中的contact/contactgroup，并决定用什么方式来发出报警。详细内容参见<a href="http://mathias-kettner.com/checkmk_flexible_notifications.html，也就是说check_mk接管了Nagios的报警机制，当有告警事件发生时，nagios直接通知check_mk，然后具体的告警策略由check_mk来控制。" target="_blank" rel="noopener">http://mathias-kettner.com/checkmk_flexible_notifications.html，也就是说check_mk接管了Nagios的报警机制，当有告警事件发生时，nagios直接通知check_mk，然后具体的告警策略由check_mk来控制。</a></p><p>备注：简单来说，在nagios+check_mk监控系统中，所有告警也是由nagios主动发起的，只是说具体的报警策略由check_mk接管了。</p><p>（6）Business Intelligence</p><p>check_mk提供的BI统计报表系统。</p><p>（7）Mobile</p><p>check_mk的移动版，直接在浏览器中访问check_mk的网址，会自动切换到check_mk mobile版本。</p><p>（8）Event Console</p><p>Event Console是由mkeventd后台进程来控制的。</p><h1 id="check-mk的官网DEMO体验"><a href="#check-mk的官网DEMO体验" class="headerlink" title="check_mk的官网DEMO体验"></a>check_mk的官网DEMO体验</h1><pre><code>网址：http://demo.mathias-kettner.de/demo/check_mk/用户名：demo823或demo700密码：demo</code></pre><p>4.check_mk与远程主机交互方式</p><p><img src="/images/check_mk_1_4.png" alt></p><p>5.nagios与check_mk的结合</p><p>check_mk生成nagios配置时，会为每台host配置一个Check_MK服务，该服务会执行如下的check-mk command，该command会执行每台机器的预编译脚本（Check_MK是nagios的一个主动检查服务）。预编译脚本会与check_mk-agent通信，获取agent采集结果，check_mk拿到agent的采集结果后，会将结果回写给nagios的各个被动检查服务。</p><p><img src="/images/check_mk_1_5.png" alt></p><p>学习资料参考于：<br><a href="http://grass51.blog.51cto.com/4356355/994819" target="_blank" rel="noopener">http://grass51.blog.51cto.com/4356355/994819</a></p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> check_mk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nagios系列（8）_nagios闲杂知识</title>
      <link href="/2018/01/30/nagios%E7%B3%BB%E5%88%97%EF%BC%888%EF%BC%89-nagios%E9%97%B2%E6%9D%82%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/01/30/nagios%E7%B3%BB%E5%88%97%EF%BC%888%EF%BC%89-nagios%E9%97%B2%E6%9D%82%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="nagios的商业版本Naigos-XI"><a href="#nagios的商业版本Naigos-XI" class="headerlink" title="nagios的商业版本Naigos XI"></a>nagios的商业版本Naigos XI</h1><p>Naigos XI是Nagios的商业版本</p><p><img src="/images/nagios_8_1.png" alt></p><h1 id="nagios的一些闲杂知识"><a href="#nagios的一些闲杂知识" class="headerlink" title="nagios的一些闲杂知识"></a>nagios的一些闲杂知识</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/nagiostats <span class="comment">#可以打印出nagios的一些状态信息，比如状态文件路径、PID、主动被动检测次数等等</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nagios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nagios系列（7）_周边产品生态</title>
      <link href="/2018/01/30/nagios%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89-%E5%91%A8%E8%BE%B9%E4%BA%A7%E5%93%81%E7%94%9F%E6%80%81/"/>
      <url>/2018/01/30/nagios%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89-%E5%91%A8%E8%BE%B9%E4%BA%A7%E5%93%81%E7%94%9F%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>nagios不仅仅是一个监控软件，其实更多像一个监控的框架，形成了一个生态圈，以nagios为核心，衍生了很多围绕其开发的优秀的程序。Nagios通常由一个主程序(Nagios Core)、很多插件程序(Nagios-plugins)和四个可选的附件(NRPE、NSCA、 NSClient++和NDOUtils)组成。Nagios的监控工作都是通过插件实现的，因此，Nagios和Nagios-plugins是服务器端工作所必须的组件。四个可选的附件分别说明如下：</p><p>（1）NRPE</p><p>用来在监控的远程Linux/Unix主机上执行脚本插件以实现对这些主机资源的监控。check_nrpe插件：运行在监控主机上 ，NRPE daemon：运行在远程的linux主机上(通常就是被监控机) 。</p><p>（2）NSCA</p><p>用来让被监控的远程Linux/Unix主机主动将监控信息发送给Nagios服务器(这在冗余监控模式中特别要用到) 。</p><p>（3）NSClient++</p><p>用来监控 Windows主机时安装在Windows主机上的组件。</p><p>（4）NDOUtils</p><p>则用来将Nagios的配置信息和各event产生的数据存入数据库，以实现这些数据的快速检索和处理。这种方式比我们直接开发脚本，解析Nagios本地监控数据要高效得多。</p><p>这四个ADDON(附件)中，NRPE和NSClient++工作于客户端，NDOUtils工作于服务器端，而NSCA则需要同时安装在服务器端和客户端。</p><p>除了上述一些nagios附件，还有许多Nagios的周边衍生产品，如下：</p><p>（1）ICINGA</p><p>ICINGA，就是一个Nagios开发者独立出去成立的项目，新的开源项目完全兼容以前的Nagios应用程序及扩展功能。在ICINGA网站上，定义ICINGA是一个介于Nagios社区版和企业版间的产品，特别将致力于解决Nagios项目现在的问题。 </p><p>ICINGA的web界面做的不错，很多配置都和Nagios类似。 所以准确的说，这个是nagios的一个衍生品，和nagios并列的一个东西，并不完全是围绕nagios的一个产品。</p><p>（2）Centreon</p><p>Centreon作为nagios的分布式监控管理平台，其功能之强大，打造了Centreon在IT监控方面强势地位，它的底层使用Nagios监控软件，Nagios通过ndoutil模块将监控数据写入数据库，Centreon读取该数据并即时的展现监控信息，通过centreon可以简单地管理和配置所有Nagios，因此，完全可以使用centreon轻易的搭建企业级分布式IT基础运维监控系统。 可以简单理解，Centreon就是一个基于Nagios的Dashboard，有很多操作可以在web端完成。</p><p>（3）PNP4Nagios</p><p>PNP4Nagios是nagios的一个插件，增强Nagios的图表功能。PNP4Nagios同时也支持ICINGA。自从有了pnp4nagios，nagios与cacti在绘图展示上对比，也显得更加自信。说白了，PNP4Nagios是nagios与RRDtool粘合层或中间件，类似于NagiosGraph。</p><p>（4）Check_MK</p><p>Check_MK德国人写的，貌似德国制造都很精品。Check_MK也和Centreon有点类似，但是它有个更强大的地方是Check_MK有自己单独的数据采集客户端工具，配置也比较简单，当然同时也支持SNMP。Check_MK是开源的。</p><p>（5）Nconf</p><p>Nconf是一个Nagios web管理工具，可以实现web进行操作。不过有了check_mk的WATO ，估计这个也快要下岗了。</p><p>学习资料参考于：<br><a href="http://www.361way.com/nagios-framework/2884.html" target="_blank" rel="noopener">http://www.361way.com/nagios-framework/2884.html</a><br><a href="http://www.361way.com/distributed-monitoring-livestatus-multisite/2904.html" target="_blank" rel="noopener">http://www.361way.com/distributed-monitoring-livestatus-multisite/2904.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nagios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nagios系列（6）_事件代理机制NEB</title>
      <link href="/2018/01/30/nagios%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89-%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6NEB/"/>
      <url>/2018/01/30/nagios%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89-%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6NEB/</url>
      
        <content type="html"><![CDATA[<h1 id="NEB简介"><a href="#NEB简介" class="headerlink" title="NEB简介"></a>NEB简介</h1><p>NEB，中文名为Nagios Event Broker，全称为Nagios事件代理。Nagios NEB提供了NEB API，供用户编写NEB模块。NEB绝对是Nagios最强大的接口，我们能够通过编写很多的事件代理模块，来对Nagios的功能进行扩展。NEB提供了很多的事件类型，这些事件类型涵盖了在Nagios中发生的每一种事件类型。用户编写的NEB模块都可以注册某个或所有事件类型。当NEB对所有NEB模块完成初始化后，会等待匹配模块订阅类型的事件发生，当接收到一个匹配事件后，NEB将会向NEB模块提供该事件的信息。比如，如果某个NEB模块注册了EXTERNAL_COMMAND_DATA，每当有外部命令插入到命令文件的时候，NEB就会通知该NEB模块。</p><p><img src="/images/nagios_6_1.png" alt></p><h1 id="用户自定义NEB模块的过程和工作原理"><a href="#用户自定义NEB模块的过程和工作原理" class="headerlink" title="用户自定义NEB模块的过程和工作原理"></a>用户自定义NEB模块的过程和工作原理</h1><p>（1）nagios用户可以基于NEB API编写自己的NEB模块（一般用C语言编写），NEB模块需要向NEB注册要关注的事件类型以及事件发生后的回调函数。</p><p>（2）用户用C语言编写NEB模块完成后，需要编译链接成共享库so文件，然后在nagios.cfg中配置broker_moudle=xxx.so。</p><p>（3）nagios daemon进程在启动后，会将NEB模块加载到nagios进程中</p><p>（4）当nagios中发生了特定的事件，nagios的NEB会将事件通知给关注它的NEB模块，最终调用NEB模块所注册的回调函数。</p><h1 id="nagios中NEB的使用例子"><a href="#nagios中NEB的使用例子" class="headerlink" title="nagios中NEB的使用例子"></a>nagios中NEB的使用例子</h1><p>（1）check-mk livestatus NEB模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broker_module=/omd/sites/XXX/lib/mk-livestatus/livestatus.o num_client_threads=20 pnp_path=/omd/sites/XXX/var/pnp4nagios/perfdata /omd/sites/XXXX/tmp/run/live</span><br></pre></td></tr></table></figure><p>（2）mod_gearman NEB模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broker_module=/omd/sites/XXX/lib/mod_gearman/mod_gearman.o config=/omd/sites/XXX/etc/mod-gearman/server.cfg</span><br></pre></td></tr></table></figure><p>（3）npcd NEB模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broker_module=/omd/sites/XXX/lib/npcdmod.o config_file=/omd/sites/XXX/etc/pnp4nagios/npcd.cfg</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nagios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nagios系列（5）_nagios分布式监控</title>
      <link href="/2018/01/30/nagios%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89-nagios%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%91%E6%8E%A7/"/>
      <url>/2018/01/30/nagios%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89-nagios%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="nagios的分布式监控"><a href="#nagios的分布式监控" class="headerlink" title="nagios的分布式监控"></a>nagios的分布式监控</h1><p><img src="/images/nagios_5_1.png" alt></p><p>在上图例子中，在每个IDC做了一个中心节点 。在三个机房中的三个节点中，选择一个为主，另两个中心节点的监控数据通过send_nsca和submit_check_result提交数据到主节点 。而监控节点和监控机之间可以用nrpe、check_mk、nslient等等都可以。</p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nagios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nagios系列（4）_nagios GUI</title>
      <link href="/2018/01/30/nagios%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89-nagios-GUI/"/>
      <url>/2018/01/30/nagios%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89-nagios-GUI/</url>
      
        <content type="html"><![CDATA[<h1 id="监控dashboard上的选项的含义"><a href="#监控dashboard上的选项的含义" class="headerlink" title="监控dashboard上的选项的含义"></a>监控dashboard上的选项的含义</h1><p><img src="/images/nagios_4_1.png" alt></p><p>其中Status为监控项当前的状态，Last Check为上一次采集的时间，Duration表示目前的服务状态维持了多长的时间，Attempt和max_check_attempts是对应的，分母就是max_check_attempts，分子是当前已经检测了多少次。</p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nagios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nagios系列（3）_nagios配置</title>
      <link href="/2018/01/30/nagios%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89-nagios%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/01/30/nagios%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89-nagios%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="nagios配置中基本概念"><a href="#nagios配置中基本概念" class="headerlink" title="nagios配置中基本概念"></a>nagios配置中基本概念</h1><p>nagios配置中一些主要的概念有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">主机host</span><br><span class="line">主机组hostgroup</span><br><span class="line">服务service</span><br><span class="line">服务组servicegroup</span><br><span class="line">联系人contact</span><br><span class="line">联系人组contactgroup</span><br><span class="line">监控时间</span><br><span class="line">监控命令command</span><br><span class="line"></span><br><span class="line">定义监控哪些主机、主机组</span><br><span class="line">定义监控哪些服务、服务组</span><br><span class="line">定义监控通过哪些命令进行</span><br><span class="line">定义监控的时间段，什么时候触发监控</span><br><span class="line">定义出现问题时通知的联系人、联系人组</span><br></pre></td></tr></table></figure><p>备注：主机组、服务组、联系人组的配置方法参见<a href="http://www.361way.com/nagios-groups/2855.html文档" target="_blank" rel="noopener">http://www.361way.com/nagios-groups/2855.html文档</a></p><h1 id="nagios的配置文件"><a href="#nagios的配置文件" class="headerlink" title="nagios的配置文件"></a>nagios的配置文件</h1><p>nagios配置文件有：</p><p>（1）主配置文件${NAGIOS_HOME}/etc/nagios.cfg</p><p>它是nagios的主配置文件，Nagios后台进程启动时，会指定加载该文件。</p><p>（2）资源文件${NAGIOS_HOME}/etc/resource.cfg</p><p>资源文件可用于存储用户定义的宏。资源文件的主要目的是使用它们来存储敏感的配置信息（如密码）。</p><p>（3）CGI配置文件${NAGIOS_HOME}/etc/cgi.cfg</p><p>该配置文件用来控制相关cgi脚本，如果想在nagios的web监控界面执行cgi脚本，例如重启nagios进程、关闭nagios通知、停止nagios主机检测等，这时就需要配置cgi.cfg文件</p><p>（4）对象定义文件${NAGIOS_HOME} /etc/objects/*.cfg</p><p>对象定义文件用于定义主机、服务、主机组、联系人、联系人组以及命令等。我们可以在此定义所有要监视的内容，以及如何监视它们。 我们可以使用主配置文件nagios.cfg中的cfg_file和/或cfg_dir指令来指定一个或多个对象定义文件。对象配置文件有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hosts.cfg          #用来定义主机和主机组</span><br><span class="line">services.cfg       #用来定义服务和服务组</span><br><span class="line">templates.cfg      #为了不必重复定义一些配置对象，nagios引入了一个模板配置文件，将一些共性的属性定义成模板，以便于多次引用，例如host模板、service模板。这些配置是放入到templates.cfg文件中</span><br><span class="line">resource.cfg       #它是nagios的变量定义文件。例如变量$USER1$指定了安装nagios插件的路径，如果把插件安装在了其它路径，只需在这里配置即可。需要注意的是，变量必须先定义，然后才能在其它配置文件中进行引用</span><br><span class="line">commands.cfg       #用来定义命令</span><br><span class="line">contacts.cfg       #用来定义联系人和联系人组</span><br><span class="line">timeperiods.cfg    #用来定义监控时间段</span><br></pre></td></tr></table></figure><p>详细的配置文件如下：</p><p><img src="/images/nagios_3_1.png" alt></p><p>备注：当我们修改完nagios的配置文件后，可以执行命令./bin/nagios -v etc/nagios.cfg来检查配置文件是否正确。</p><h1 id="nagios各个配置文件的依赖关系以及被加载的进程图"><a href="#nagios各个配置文件的依赖关系以及被加载的进程图" class="headerlink" title="nagios各个配置文件的依赖关系以及被加载的进程图"></a>nagios各个配置文件的依赖关系以及被加载的进程图</h1><p><img src="/images/nagios_3_2.png" alt></p><h1 id="nagios的host-service配置样例"><a href="#nagios的host-service配置样例" class="headerlink" title="nagios的host/service配置样例"></a>nagios的host/service配置样例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">define host &#123;</span><br><span class="line">    use windows-server   </span><br><span class="line">    host_name host1</span><br><span class="line">    alias host1</span><br><span class="line">    address 10.25.14.51</span><br><span class="line">    check_interval 2</span><br><span class="line">    retry_interval 1</span><br><span class="line">    max_check_attempts 2</span><br><span class="line">    notification_interval 30</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define service &#123;</span><br><span class="line">    use local-service</span><br><span class="line">    host_name host1</span><br><span class="line">    service_description Memory Usage</span><br><span class="line">    check_command check_nrpe!CheckMem!ShowAll type=physical MinWarn=512M MinCrit=256M</span><br><span class="line">    check_interval 5</span><br><span class="line">    retry_interval 1</span><br><span class="line">    max_check_attempts 5</span><br><span class="line">    notification_interval 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="nagios的调度机制中涉及的一些配置参数"><a href="#nagios的调度机制中涉及的一些配置参数" class="headerlink" title="nagios的调度机制中涉及的一些配置参数"></a>nagios的调度机制中涉及的一些配置参数</h1><p>在nagios的调度机制中，涉及到一些概念：</p><p>（1）check_interval</p><p>表示的nagios检查的周期，是正常检测间隔。</p><p>（2）max_check_attempts</p><p>表示如果nagios在某个采集周期中，发现监控项是异常的，那么不会立即认为这个监控项是异常的，将其标记为SOFT state。然后继续去监控，会尝试最多max_check_attempts-1次采集。如果中间某次恢复正常，则认为服务恢复。如果max_check_attempts次采集均为异常，则认为这个监控项是异常的，将其标记为HARD state。</p><p>（3）retry_interval</p><p>在max_check_attempts次重试检查的过程中，每两次之间的时间间隔。</p><p>（4）notification_interval</p><p>当服务被任务是HARD state后，会发送报警通知。这个表示本次发出报警后，还间隔多长时间，才可以继续发送报警。</p><p>（5）interval_length</p><p>interval_length决定了上面check_interval，retry_interval，notification_interval等参数的单位。如果interval_length=60（interval_length的单位是秒），表示上面check_interval，retry_interval，notification_interval的单位是分钟。注意，interval_length默认值是60，一般不需要去修改这个选项。</p><p>（6）notification_options</p><p>该配置用来决定在什么时机发送告警，通常有如下选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d —— DOWN state时发出告警</span><br><span class="line">u —— UNREACHABLE state时发出告警</span><br><span class="line">r —— 收到OK state时发出告警</span><br><span class="line">n —— 任何状态都不会发出告警</span><br><span class="line">f —— nagios中有种flapping state，也就是一个监控项在正常和异常之间频繁切换，暂且译为“抖动”。f表示当监控项开始或结束抖动时，会发出告警</span><br><span class="line">s —— nagios支持“计划停服”设置，即允许设置一段时间用来停机或停服务，比如需要硬件升级或变更服务。s表示当计划停服开始或结束时，会发出告警</span><br></pre></td></tr></table></figure><p>如果不指定任何选项，则上面的所有情况都会发出告警。详细选项如下：</p><p><img src="/images/nagios_3_3.png" alt></p><p>结合如下两张图来理解上述的一些概念，其中“正常检测间隔”即check_interval，“重试检测间隔”即retry_interval。</p><p><img src="/images/nagios_3_4.png" alt></p><p><img src="/images/nagios_3_5.png" alt></p><p>学习资料来源于：<a href="http://sites.box293.com/nagios/guides/configurations-and-definitions/host-and-service-check-intervals" target="_blank" rel="noopener">http://sites.box293.com/nagios/guides/configurations-and-definitions/host-and-service-check-intervals</a></p><h1 id="nagios自定义插件编写"><a href="#nagios自定义插件编写" class="headerlink" title="nagios自定义插件编写"></a>nagios自定义插件编写</h1><p>nagios自定义插件编写如下：</p><p><img src="/images/nagios_3_6.png" alt></p><p>nagios插件可以用任何语言编写，自定义插件要满足两个特征：一是脚本必须有返回码（0是正常，1是警告，2是严重，3是未知）；二是脚本需要输出一段可读的文本，该文本会出现在nagios的GUI的监控状态中。</p><h1 id="nagios的告警等级"><a href="#nagios的告警等级" class="headerlink" title="nagios的告警等级"></a>nagios的告警等级</h1><p>所谓nagios_level，即我们通过nagios plugin检查数据时的返回值。其取值范围和含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;0&quot;，代表 &quot;OK&quot;，服务正常；</span><br><span class="line">&quot;1&quot;，代表 &quot;WARNNING&quot;，服务警告，一般 nagios plugin 命令中使用 -w 参数设置该阈值；</span><br><span class="line">&quot;2&quot;，代表 &quot;CRITICAL&quot;，服务危急，一般 nagios plugin 命令中使用 -c 参数设置该阈值；</span><br><span class="line">&quot;3&quot;，代表 &quot;UNKNOWN&quot;，未知状态，一般会在 timeout 等情况下出现。</span><br></pre></td></tr></table></figure><h1 id="nagios告警的配置"><a href="#nagios告警的配置" class="headerlink" title="nagios告警的配置"></a>nagios告警的配置</h1><p>（1）在command.cfg配置发送邮件、短信或微信报警的命令command</p><p>（2）在contact.cfg或contactgroup.cfg中配置联系人或联系人组，并关联到命令</p><p>（3）在host.cfg或service.cfg中定义host/service时，通过contact_groups指定联系人或联系人组，即有异常则向指定的联系人/联系人组发送告警。</p><h1 id="nagios-cfg的一些重要配置项"><a href="#nagios-cfg的一些重要配置项" class="headerlink" title="nagios.cfg的一些重要配置项"></a>nagios.cfg的一些重要配置项</h1><p>nagios.cfg的一些重要配置项有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">accept_passive_host_checks=1      #是否接收host的被动检查结果，即开启host的被动检查。1表示开启。</span><br><span class="line">accept_passive_service_checks=1   #是否接收service的被动检查结果，即开启service的被动检查。1表示开启。</span><br><span class="line">......</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nagios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nagios系列（2）_nagios安装</title>
      <link href="/2018/01/29/nagios%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89-nagios%E5%AE%89%E8%A3%85/"/>
      <url>/2018/01/29/nagios%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89-nagios%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="naigos及nagios-plugins的安装"><a href="#naigos及nagios-plugins的安装" class="headerlink" title="naigos及nagios plugins的安装"></a>naigos及nagios plugins的安装</h1><p>前提声明，本次nagios的测试安装环境是Red Hat Enterprise Linux Server release 6.8 (Santiago)和nagios-4.2.4，详细Nagios安装步骤如下：</p><p>（1）安装Apache httpd服务器</p><p>（2）安装Nagios core和Nagios Plugins</p><p>按照Nagios Core源码安装指导文档来安装就行了， 包括Nagios Core和Nagios官方Plugins（有50个左右的插件，除了官方提供的插件，还能找到非常多的插件，用户也可以自定义一些插件）</p><p>安装步骤说明：<a href="https://assets.nagios.com/downloads/nagioscore/docs/Installing_Nagios_Core_From_Source.pdf#_ga=1.238050824.967072329.1490596661或者https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/quickstart.html" target="_blank" rel="noopener">https://assets.nagios.com/downloads/nagioscore/docs/Installing_Nagios_Core_From_Source.pdf#_ga=1.238050824.967072329.1490596661或者https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/quickstart.html</a></p><p>备注：安装Nagios-plugins时，一般将安装的目录设置为nagios的安装目录</p><p>（3）启动nagios daemon和apache webserver</p><p>首先执行/etc/init.d/nagios start启动nagios后台服务，然后执行/etc/init.d/httpd start启动apache服务器。</p><p>（4）Nagios的测试</p><p>用浏览器打开<a href="http://ip:port/nagios即可访问测试。效果如下：" target="_blank" rel="noopener">http://ip:port/nagios即可访问测试。效果如下：</a></p><p><img src="/images/nagios_2_1.png" alt="nagios界面图"></p><h1 id="nagios安装后的目录结构"><a href="#nagios安装后的目录结构" class="headerlink" title="nagios安装后的目录结构"></a>nagios安装后的目录结构</h1><p>nagios安装后的目录结构图如下：</p><p><img src="/images/nagios_2_2.png" alt="nagios安装目录结构图"></p><p>（1）bin目录是nagios的主程序和状态统计工具</p><p>（2）etc目录是nagios的各种配置文件存放的目录</p><p>（3）libexec一般是nagios的插件存放目录，当然插件亦可以安装到其他的目录</p><p>（4）sbin存放的是一些cgi脚本，nagios web界面上的数据展示或操作，会通过cgi脚本来执行</p><p>（5）share存放的nagios web的一些元素，如php，css等</p><p>（6）var是nagios的日志和状态数据的存放的目录，例如status.dat中存放的nagios的采集的最近的监控数据，当nagios停掉后，该文件会被删除。status.dat会被cgi脚本读取分析并展示到nagios WEB页面上。retention.dat存放也是最近的监控数据，当nagios停掉后，该文件继续存在，当nagios启动时，会读取retention.dat中的数据。nagios.log以及archives/nagios-<em>-</em>.log是nagios的运行日志，里面有nagios的采集到数据的日志，nagios的历史数据展示就是从nagios.log日志文件中爬出来的。</p><p>备注：我们可以看到，单纯的nagios的WEB UI上只会显示最近的一次采集状态，无法看到历史的状态信息，也无法有趋势图展示，尽管nagios有历史报表功能，也是从nagios.log中爬出来的，比较简陋。所以nagios必须结合其他第三方nagios的周边组件，才能构建强大的监控系统，只有nagios是不行的哦。</p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nagios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nagios系列（1）_介绍及基本原理</title>
      <link href="/2018/01/29/nagios%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2018/01/29/nagios%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Nagios简介"><a href="#Nagios简介" class="headerlink" title="Nagios简介"></a>Nagios简介</h1><p>Nagios全名为（Nagios Ain’t Goona Insist on Saintood），最初项目名字是 NetSaint。它是一款免费的开源IT基础设施监控系统，其功能强大，灵活性强，能有效监控 Windows 、Linux、VMware 和 Unix 主机状态，交换机、路由器等网络设置等。一旦主机或服务状态出现异常时，会发出邮件或短信报警第一时间通知IT运营人员，在状态恢复后发出正常的邮件或短信通知。Nagios结构简单，可维护性强，越来越受中小企业青睐，以及运维和管理人员的使用。同时提供一个可选的基于浏览器的Web界面，方便管理人员查看系统的运行状态，网络状态、服务状态、日志信息，以及其他异常现象。</p><p>其实，nagios仅仅是一个调度和通知的框架，它必须借助一些插件或各种衍生品才能构建一个完整的IT监控系统。</p><h1 id="Nagios的架构"><a href="#Nagios的架构" class="headerlink" title="Nagios的架构"></a>Nagios的架构</h1><p>Nagios结构上来说， 可分为核心core和插件Plugins两个部分。</p><p>（1）Nagios core</p><p>Nagios的核心部分提供监控的处理、任务调度、下发指令等功能，也提供了很少的监控功能。</p><p>（2）Nagios Plugins</p><p>Nagios Core只是一个监控的框架，自身其实没有监控的能力。Nagios插件是Nagios Core的独立扩展，可以用来监视我们需要监控的对象。Nagios插件接收命令行参数，执行特定检查，然后将结果返回到Nagios Core。Nagios插件可以是二进制执行文件（用C，C ++等编写），也可以是一些执行脚本（shell，Perl，PHP等）。目前根据Nagios的插件的来源，分为两类：</p><p>A）Nagios官方Plugins</p><p>Nagios官方Plugins有大约50个插件，例如check_dig，check_log，check_tcp，check_load等等。官方Nagios插件是由官方Nagios团队开发和维护。</p><p>B）Nagios社区Plugins</p><p>Nagios社区中有数千个插件可以使用，可以监控的对象非常全面。另外，Nagios用户也可以自己开发插件。</p><h1 id="Nagios的不足"><a href="#Nagios的不足" class="headerlink" title="Nagios的不足"></a>Nagios的不足</h1><p>（1）只提供监控界面展示，提供很少的界面配置功能</p><p>（2）无后台管理功能，多条数据需要通过脚本添加</p><p>（3）权限管理功能很简单，不能满足多数业务的需要</p><p>（4）没有内置的报表的功能，需要其他的附件的支持</p><p>（5）不支持数据库，数据以file方式存储，数据不易维护，易丢失</p><p>（6）监控目标的添加，需要通过手工或Shell脚本支持</p><h1 id="Nagios的部署架构图"><a href="#Nagios的部署架构图" class="headerlink" title="Nagios的部署架构图"></a>Nagios的部署架构图</h1><p>Nagios的部署架构图如下：</p><p><img src="/images/nagios_1_1.png" alt="nagios部署架构图"></p><p>监控中心服务器需要部署nagios core进程以及httpd。被监控主机根据需要部署特定的Agent即可，也可以不部署Agent，通过check_by_ssh这样的插件直接登录目标主机上采集数据。</p><p>如下为nagios的内部原理架构图：</p><p><img src="/images/nagios_1_2.png" alt="nagios内部原理架构图"></p><p>备注：有上图中可以看出nagios在被动检查中，像nsca这样的插件会将结果是直接提交给nagios daemon，然后由nagios daemon写入到status.dat，然后再是nagios GUI分析status.dat进行展示的。</p><h1 id="nagios监控远程主机的方式"><a href="#nagios监控远程主机的方式" class="headerlink" title="nagios监控远程主机的方式"></a>nagios监控远程主机的方式</h1><p>（1）使用check_by_ssh插件</p><p>使用check_by_ssh插件登录远程服务器并执行采集插件，获取采集结果。但是如果我们要监控数百或数千台服务器，则可能会导致监控服务器自身的负载比较高，因为建立或释放SSH链接都会增加一定的系统的开销。</p><p>（2）使用NRPE插件</p><p>NRPE允许您在远程Linux/Unix主机上执行插件。如果我们需要监视远程主机上的本地资源/属性，如磁盘使用情况，CPU负载，内存使用情况等，这将非常有用。使用NRPE的插件的监控采集架构图如下：</p><p><img src="/images/nagios_1_3.png" alt="NRPE数据采集架构图"></p><p>（3）check_mk</p><p>参见OMD及check_mk部分。</p><h1 id="nagios的数据采集的主动模式和被动模式"><a href="#nagios的数据采集的主动模式和被动模式" class="headerlink" title="nagios的数据采集的主动模式和被动模式"></a>nagios的数据采集的主动模式和被动模式</h1><p>nagios在获取监控采集数据时，有主动和被动两种模式：</p><p>（1）主动模式（active check）</p><p><img src="/images/nagios_1_4.png" alt="主动采集模式"></p><p>在上图中，check_nrpe是一个二进制程序，NRPE是一个后台daemon，它们之间通过SSL连接。check_nrpe发给NRPE一个命令，比如check_disk，NRPE就执行这条命令对应的真实代码，这个真实代码在nrpe.cfg配置文件中定义。</p><p>（2）被动模式（passive check）</p><p><img src="/images/nagios_1_5.png" alt="被动采集模式"></p><p>被动模式则是在被监控机上面通过插件或脚本获取监控数据，然后将数据通过send_nsca发往监控机，最后监控机通过NSCA接收并解析数据，并传递给Nagios。这样做的一个很大的优势避免了被监控机的数量比较多时，一次轮询时间过长而导致监控反应延迟，这也是被动模式能承担更大监控量的关键。nagios的被动检查的详细过程如下：</p><pre><code>外部程序采集host或service的状态值外部程序将采集值写入到nagios的external command file（也即是/omd/sites/XXX/tmp/run/nagios.cmd）nagios daemon读取external command file中的状态值，并将其写入nagios的处理队列Queue中nagios周期性从Queue中读取信息（nagios此处是分不清是主动检查或被动检查结果，一视同仁，一样的处理方式），并处理（写入status.dat或报警）。</code></pre><p><img src="/images/nagios_1_6.png" alt></p><p>开启nagios的被动检查方式如下：</p><p>通过nagios.cfg的中accept_passive_service_checks/accept_passive_host_checks来开启被动检查，然后在host或service中指明passive_checks_enabled=1即可。</p><p>学习资料参考于：<br><a href="https://www.ibm.com/developerworks/cn/linux/1309_luojun_nagios/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/1309_luojun_nagios/index.html</a><br><a href="https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/toc.html" target="_blank" rel="noopener">https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/toc.html</a> (nagios core官方文档)</p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nagios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo搭建自己的Blog站点</title>
      <link href="/2018/01/28/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Blog%E7%AB%99%E7%82%B9/"/>
      <url>/2018/01/28/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Blog%E7%AB%99%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h1><p>Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。简单来说，我们在Hexo框架内编写MarkDown格式的文档，然后使用Hexo帮我们生产静态的WEB资源（如HTML/CSS/JS等）。使用这些静态WEB页面，我们就可以部署个人WEB站点。</p><p>Hexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。Hexo是类似于Jekyll，Octopress这样的东东哦，但Hexo目前比较流行。</p><h1 id="Hexo环境的搭建"><a href="#Hexo环境的搭建" class="headerlink" title="Hexo环境的搭建"></a>Hexo环境的搭建</h1><p>如下为在Windows环境搭建hexo环境的步骤：</p><p>（1）安装git工具</p><p>要将git bash工具一同安装上。</p><p>（2）安装node.js</p><p>安装node并配置PATH环境变量。</p><p>（3）安装Hexo</p><p>在Windows命令提示符中执行命令<code>npm install -g hexo-cli</code>即可。</p><p>备注：然后使用hexo new命令创建文章以及提交github等操作都是在git bash中进行。</p><h1 id="Hexo使用步骤"><a href="#Hexo使用步骤" class="headerlink" title="Hexo使用步骤"></a>Hexo使用步骤</h1><p>一般来说，使用hexo的步骤如下：</p><p>（1）使用hexo new创建一篇新文章</p><p>可以参见下面的&lt;&lt;使用Hexo new创建一篇新文章&gt;&gt;部分。</p><p>（2）使用编辑器打开<code>source</code>或<code>source/_posts</code>目录下新文章对应的MarkDown文件，然后编辑其内容并保存</p><p>（3）使用hexo server命令启动hexo http server服务器，然后在浏览器中输入<code>http://ip:4000</code>来预览文章内容</p><p>也可以使用<code>hexo server -p port --watch</code>来打开服务器，这样hexo server就会热加载最新的编辑内容，而不用每次编辑文件后就需要重启的hexo server。加上<code>--draft</code>选项可以将草稿文章也显示到页面上。</p><p>（4）使用hexo generate命令生成文档的静态WEB资源</p><p>（5）使用hexo deploy命令将静态资源（即mysitename/public目录下的内容）部署到Github pages免费空间中</p><p>（6）在浏览器中输入<code>http://username.github.io/</code>来查看文章内容</p><h1 id="使用Hexo-new创建一篇新文章"><a href="#使用Hexo-new创建一篇新文章" class="headerlink" title="使用Hexo new创建一篇新文章"></a>使用Hexo new创建一篇新文章</h1><p>命令格式为：<code>hexo new [layout] &lt;title&gt;</code>即可。这里的layout最好不要理解成布局的意思，个人觉得是新文章的类别。Hexo默认的有三种类别，分别是post、page和draft，下面分别介绍：</p><p>（1）post</p><p>使用hexo new不指定layout参数时，则会根据<code>/mysitename/_config.yml</code>中的<code>default_layout</code>参数来指定默认layout，一般来说默认是post。hexo new post会在<code>mysitenaem/source/_posts/</code>中创建一个markdown文件（使用scaffolds/post.md作为脚手架来创建markdown文件）。然后经过hexo generate生成静态文件后，会在”public/${year}/${month}/${day}/markdown文件tilte/“组成的目录中生成index.html文件，在浏览器中输入<code>http://ip:4000/2018/01/28/markdown文件title/</code>即可访问。</p><p>如使用<code>hexo new post &quot;wahaha&quot;</code>命令，表示创建一篇名称为wahaha的文章，然后用编辑器打开，修改tags/categories，为文章分类或打标签。</p><p>备注：这种就是使用最多的创建文章类型。</p><p>（2）draft</p><p>使用hexo new draft会在<code>mysitenaem/source/_drafts/</code>中创建一个markdown文件（使用scaffolds/draft.md作为脚手架来创建markdown文件），执行hexo generate命令时，并不会生成对应的html文件，我们把hexo new draft创建的文章称为草稿，也就是创建后并不会在站点中显示出来的文章。当然，我们可以使用<code>hexo generate --draft &amp;&amp; hexo server --draft</code>在本地预览草稿文章的效果。当我们需要将草稿正式发布时，可以使用<code>hexo publish draft &quot;文章标题&quot;</code>即可。</p><p>备注：当我们的一篇文章还没有彻底完善好或想作为私密文档的话，就可以使用该种类型。</p><p>（3）page</p><p>使用hexo new page title会在mysitenaem/source/中创建一个markdown文件（使用scaffolds/page.md作为脚手架来创建markdown文件），然后经过hexo generate生成静态文件后，会在”public/markdown文件tilte/“目录下生成index.html文件，在浏览器中输入<code>http://ip:4000/markdown文件title/</code>即可访问。</p><p>备注：当我们需要创建一篇拥有独立url路径的文章时，如“关于我（<code>http://ip:port/about</code>）”的页面时，就可以使用hexo new page啦。</p><p>（4）自定义</p><p>我们也可以自定义哦，若我们在scaffolds目录下新建一个wahaha.md的脚手架，然后我们就可以使用hexo new wahaha “title”来创建一篇文章。hexo new wahaha会在<code>mysitenaem/source/_posts/</code>中创建一个markdown文件（使用scaffolds/wahaha.md作为脚手架来创建markdown文件）。</p><h1 id="将项目部署到Github-Pages"><a href="#将项目部署到Github-Pages" class="headerlink" title="将项目部署到Github Pages"></a>将项目部署到Github Pages</h1><p>（1）在Github上创建“用户名.github.io”的仓库</p><p>（2）安装deployer-git</p><p>执行<code>npm install hexo-deployer-git --save</code>命令即可</p><p>（3）给hexo配置github pages属性</p><p>在<code>/blog/_config.yml</code>中修改deploy属性，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:wangjianno1/wangjianno1.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>（4）使用hexo deploy命令可以一键部署站点静态文件到Github pages</p><p>备注：hexo generate命令将我们编写的MarkDown等文件生成浏览器能直接识别的静态页面文件（包括html、js、css等等），使用hexo deploy是将这些静态文件提交到Github的“用户名.github.io”仓库中。</p><h1 id="Hexo中主题-theme-说明"><a href="#Hexo中主题-theme-说明" class="headerlink" title="Hexo中主题(theme)说明"></a>Hexo中主题(theme)说明</h1><p>创建Hexo主题非常容易，只需要在互联网上搜索hexo主题，然后将hexo主题对应的文件夹放置到mysitname/themes目录中，然后修改<code>mysitename/_config.yml</code>内的theme属性即可切换主题。</p><p>一般来说，Hexo的主题文件夹的结构如下：</p><p><img src="/images/hexo_1_1.png" alt="Hexo主题目录结构"></p><p>其中在主题的layout目录下，通常有index.ejs、page.ejs、post.ejs、category.ejs、tag.ejs以及layout.ejs等文件，其实这些文件类似于Python中使用Jiaja2规则编写的html模板文件类似。Hexo默认使用的内建Swig模板引擎，也可以使用其他的模板引擎，如EJS、Haml或Jade等。</p><p>layout.ejs是一个完整的html页面的模板文件，该模板中包含了导航条、底部footer、分类侧边栏以及标签侧边栏等元素，其中还有一个body变量。而index.ejs、page.ejs、post.ejs、category.ejs、tag.ejs就代表了html中主要内容部分，如index.ejs表示打开站点首页时，显示的文章列表部分（不包括导航条、底部footer、分类侧边栏以及标签侧边栏等元素），post.ejs表示具体某一篇文章的正文，category.ejs表示我们点击某个分类，显示该分类下所有文章列表的部分（不包括导航条、底部footer、分类侧边栏以及标签侧边栏等元素），tag.ejs表示我们点击某个标签，显示该标签下所有文章列表的部分（不包括导航条、底部footer、分类侧边栏以及标签侧边栏等元素）。而index.ejs、page.ejs、post.ejs、category.ejs、tag.ejs等就是用来填充layout.ejs文件中body变量的，从而能构成一个完整的html页面哦。</p><p>具体的模板的说明如下：</p><p><img src="/images/hexo_1_2.png" alt="模板说明"></p><h1 id="Hexo搭建个人站点的部署方案"><a href="#Hexo搭建个人站点的部署方案" class="headerlink" title="Hexo搭建个人站点的部署方案"></a>Hexo搭建个人站点的部署方案</h1><p>使用Hexo搭建个人站点有如下几种部署方案：</p><p>（1）直接使用hexo内置的http server来启动站点，即在博客项目中执行hexo server命令即可。</p><p>（2）使用hexo generate生成站点的静态页面文件（包括html、js、css等等），然后直接部署到web服务器（例如nginx/apache等等）中。</p><p>（3）部署到Github pages免费空间中，参见第4部分内容。</p><h1 id="使用Hexo的闲杂问题"><a href="#使用Hexo的闲杂问题" class="headerlink" title="使用Hexo的闲杂问题"></a>使用Hexo的闲杂问题</h1><p>（1）如何保存自己的Hexo生成的原始文件以及自己编写MarkDown文件呢？</p><p>可以在“用户名.github.io”仓库下新建一个非master分支，将Hexo的原始文件提交到该分支上（不能是master分支哦，因为master分支是用github pages的默认使用的分支哦）</p><p>（2）。。。</p><p>参考资料来源于：<br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建个人站点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django系列（9）_django中一些好用的特性及闲杂知识</title>
      <link href="/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%889%EF%BC%89-django%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7%E5%8F%8A%E9%97%B2%E6%9D%82%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%889%EF%BC%89-django%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7%E5%8F%8A%E9%97%B2%E6%9D%82%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="限定HTTP请求的Method"><a href="#限定HTTP请求的Method" class="headerlink" title="限定HTTP请求的Method"></a>限定HTTP请求的Method</h1><p>在view函数上加上如下的装饰器，就可以限制指定的HTTP请求的Method类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@require_http_methods(["GET", "POST"])</span></span><br><span class="line"><span class="meta">@require_GET()</span></span><br><span class="line"><span class="meta">@require_POST()</span></span><br></pre></td></tr></table></figure><h1 id="django-Shell"><a href="#django-Shell" class="headerlink" title="django Shell"></a>django Shell</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py shell</span><br></pre></td></tr></table></figure><h1 id="django-api框架设计"><a href="#django-api框架设计" class="headerlink" title="django api框架设计"></a>django api框架设计</h1><p>django-rest-framework</p><h1 id="django中日志配置"><a href="#django中日志配置" class="headerlink" title="django中日志配置"></a>django中日志配置</h1><p>在全局的settings.py中配置LOGGING变量。</p><h1 id="django项目目录布局的最佳实践"><a href="#django项目目录布局的最佳实践" class="headerlink" title="django项目目录布局的最佳实践"></a>django项目目录布局的最佳实践</h1><p>参见<a href="http://blog.tmackan.com/2016/09/12/2016-09-12/" target="_blank" rel="noopener">《Django项目布局最佳实践》</a></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python WEB开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django系列（8）_settings.py中一些配置说明</title>
      <link href="/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%888%EF%BC%89-settings-py%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%888%EF%BC%89-settings-py%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="ALLOWED-HOSTS"><a href="#ALLOWED-HOSTS" class="headerlink" title="ALLOWED_HOSTS"></a>ALLOWED_HOSTS</h1><p>ALLOWED_HOSTS是为了限定HTTP请求中的Host Header值，以防止黑客构造包来发送请求。只有HTTP请求的Host Header包含在ALLOWED_HOSTS列表中才被允许访问。强烈建议不要使用（<code>*</code>）通配符去配置。配置范例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALLOWED_HOSTS = [</span><br><span class="line">    <span class="string">'.example.com'</span>,</span><br><span class="line">    <span class="string">'10.16.20.86'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h1><p>DEBUG配置为True时，会暴露出一些出错信息或配置信息以方便调试。但是在上线的时候应该将其关掉，防止配置信息或者敏感出错信息泄露。</p><h1 id="INSTALLED-APPS"><a href="#INSTALLED-APPS" class="headerlink" title="INSTALLED_APPS"></a>INSTALLED_APPS</h1><p>一般在项目中我们会通过<code>python manage.py startapp appname</code>创建用户自定义的APP。如果创建了，则需要将其加入到INSTALLED_APPS 数组中才可以被访问到。INSTALLED_APPS中有默认的APP，用户可以将自己创建的APP，也配置到其中，举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># config your app here</span></span><br><span class="line">    <span class="string">'myappname1'</span>,</span><br><span class="line">    <span class="string">'myappname2'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python WEB开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django系列（7）_django在生产环境中的部署</title>
      <link href="/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89-django%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
      <url>/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89-django%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="直接启动django应用"><a href="#直接启动django应用" class="headerlink" title="直接启动django应用"></a>直接启动django应用</h1><p>执行命令<code>python manage.py runserver 192.168.65.239:8082</code>即可启动django应用。然而这种方式启动的django应用，一般是我们在开发django应用时候的启动方式，便于调试。在实际的生产环境中，我们一般不这样启动django应用哦。</p><p>备注：我们可以在django应用的前面，部署一个nginx作为反向代理，将请求转发给django应用，这种方式也能分布式部署django应用。但我们一般也不这样在生产环境中部署哦。</p><h1 id="使用uWSGI服务器部署django应用"><a href="#使用uWSGI服务器部署django应用" class="headerlink" title="使用uWSGI服务器部署django应用"></a>使用uWSGI服务器部署django应用</h1><p>原理图如下，</p><p><img src="/images/django_7_1.png" alt="uWSGI原理图"></p><p>使用uWSGI服务器部署django应用，步骤如下：</p><p>（1）安装uWSGI服务器</p><p>执行命令<code>pip install uwsgi</code>即可。</p><p>（2）编写uwsgi.ini文件</p><p>内容形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">chdir=/home/scslogsys</span><br><span class="line">module=scslogsys.wsgi:application</span><br><span class="line">#启动一个socket端口</span><br><span class="line">socket=192.168.65.239:8011</span><br><span class="line">#启动一个http端口</span><br><span class="line">#http=192.168.65.239:8011</span><br><span class="line">master=True</span><br><span class="line">pidfile=/tmp/project-master.pid</span><br><span class="line">vacuum=True</span><br><span class="line">max-requests=5000</span><br><span class="line">daemonize=/var/log/uwsgi/scslogsys.log</span><br></pre></td></tr></table></figure><p>备注：http和socket这两个任选一个就可以了。如果选择http，则uWSGI服务器启动后，可以直接对外提供http服务。如果选择socket，则uWSGI服务器启动后，是不能对外提供http服务的，这是需要nginx将请求转发过来后，才可以处理哦。</p><p>（3）启动uWSGI服务器</p><p>执行<code>uwsgi --ini uwsgi.ini</code>命令即可。其中uwsgi.ini文件是步骤（2）中编写的配置。</p><p>（4）安装并配置nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream scslogsys_backend_group</span><br><span class="line">&#123;</span><br><span class="line">    keepalive 16;</span><br><span class="line">    server 192.168.65.239:8011;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       8012;</span><br><span class="line">    server_name  192.168.65.239;</span><br><span class="line">    location / &#123;</span><br><span class="line">         include uwsgi_params;</span><br><span class="line">         uwsgi_pass scslogsys_backend_group;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）访问测试</p><p>直接访问<code>http://192.168.65.239:8012</code>即可。注意<code>http://192.168.65.239:8011</code>是访问不了的哦，除非uwsgi.ini配置的http即可。</p><h1 id="使用apache-mod-wsgi-django部署django应用"><a href="#使用apache-mod-wsgi-django部署django应用" class="headerlink" title="使用apache+mod_wsgi+django部署django应用"></a>使用apache+mod_wsgi+django部署django应用</h1><p>待研究</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python WEB开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django系列（6）_自带后台管理平台admin</title>
      <link href="/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89-%E8%87%AA%E5%B8%A6%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0admin/"/>
      <url>/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89-%E8%87%AA%E5%B8%A6%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0admin/</url>
      
        <content type="html"><![CDATA[<h1 id="django后台管理模块admin简介"><a href="#django后台管理模块admin简介" class="headerlink" title="django后台管理模块admin简介"></a>django后台管理模块admin简介</h1><p>admin是Django自带的一个功能强大的自动化后台数据管理界面。被授权的用户可直接在Admin中管理数据库。admin是Django自带的一个app，名称为django.contrib.admin。</p><h1 id="后台模块admin的使用"><a href="#后台模块admin的使用" class="headerlink" title="后台模块admin的使用"></a>后台模块admin的使用</h1><p>（1）创建后台用户</p><p>执行命令<code>python manage.py createsuperuser</code>创建后台管理用户，输入账号、密码和邮箱等信息。</p><p>（2）在app_name/admins.py中引入需要admin管理的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Record</span><br><span class="line"></span><br><span class="line">admin.site.register(Record)</span><br></pre></td></tr></table></figure><p>备注：该例子中引入的是Record模型。</p><p>（3）启动django应用并测试</p><p>打开<code>http://ip:port/admin</code>即可打开后台系统登录界面，输入第（1）步中创建的用户名和密码，即可登录到管理页面，效果图如下：</p><p><img src="/images/django_6_1.png" alt="django管理页面图"></p><p>备注：admin web管理页面默认是英文的，我们可以通过在setting.py中修改变量LANGUAGE_CODE= ‘zh_Hans’即可展示中文的管理页面了。</p><p>学习资料参考于：<br><a href="https://docs.djangoproject.com/en/1.11/intro/tutorial02/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/1.11/intro/tutorial02/</a></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python WEB开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django系列（5）_对MySQL数据库的配置和使用</title>
      <link href="/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89-%E5%AF%B9MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89-%E5%AF%B9MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Django项目中MySQL数据库的安装与配置"><a href="#Django项目中MySQL数据库的安装与配置" class="headerlink" title="Django项目中MySQL数据库的安装与配置"></a>Django项目中MySQL数据库的安装与配置</h1><p>（1）安装MySQL数据库</p><p>此处略过。</p><p>（2）安装Python包MySQLdb</p><p>执行<code>pip install mysql-python</code>命令即可。</p><p>若是安装过程有问题，可安装下述软件包，然后再行安装MySQLdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install python-setuptools</span><br><span class="line">yum install libmysqld-dev</span><br><span class="line">yum install libmysqlclient-dev</span><br><span class="line">yum install python-dev</span><br></pre></td></tr></table></figure><p>进入Python交互式命令行，输入<code>import MySQLdb</code>检测是否安装成功。</p><p>（3）在django工程中的settings.py中配置数据库</p><p>在settings.py文件中修改DATABASES字段如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'xblog'</span>,         <span class="comment">#数据库名称</span></span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'password'</span>,  <span class="comment">#安装mysql数据库时，输入的root用户的密码</span></span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，MySQL数据库的配置基本上是已经配置好了。</p><h1 id="Django项目中对MySQL数据库进行初始化"><a href="#Django项目中对MySQL数据库进行初始化" class="headerlink" title="Django项目中对MySQL数据库进行初始化"></a>Django项目中对MySQL数据库进行初始化</h1><p>（1）使用create database命令创建数据库</p><p>（2）在app中编写model</p><p>每一个model都是一个Python类，且继承自django.db.models.Model类，模型与数据库息息相关，一个模型对应一个数据库表（在设计model时，可想象成是在设计相应的数据库表）。model中每一个属性对应数据库表中的一个字段。在自定义app的目录中有models.py，我们可以将我们的model都编写到这个文件中，如下为一个model的范例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    url = models.URLField()    </span><br><span class="line">    title = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    title_zh = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    author = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    content_md = models.TextField()</span><br><span class="line">    content_html = models.TextField()</span><br><span class="line">    tags = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    views = models.IntegerField()</span><br><span class="line">    created = models.DateTimeField()</span><br><span class="line">    updated = models.DateTimeField()</span><br></pre></td></tr></table></figure><p>（3）生成数据库表</p><p>执行<code>python manage.py makemigrations app_name</code>命令（app_name可不写，表示对project下所有app有效），该命令会在app的migrations目录中生成一些Python文件，是用来和数据库交互的一些接口等。然后再执行命令<code>python manage.py migrate</code>就可以在DB中生成数据表了，这个命令才会真正地去操作数据库。当我们在models.py中增加或修改model等，都需要执行上面两个命令，才能在数据库中生效。</p><p>备注：执行<code>python manage.py migrate</code>命令后，django会自动生成数据库表名，生成的规则为“appname_modelname”,我们可以通过在model类中嵌入class Meta来修改。</p><h1 id="Django项目中常见增删改查操作"><a href="#Django项目中常见增删改查操作" class="headerlink" title="Django项目中常见增删改查操作"></a>Django项目中常见增删改查操作</h1><p>前提申明，我们在models.py定义了Student的model如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">()</span>:</span></span><br><span class="line">        name = models.CharFiled(max_length = <span class="number">30</span>)</span><br><span class="line">        age = models.IntegerFiled()</span><br></pre></td></tr></table></figure><p>现在详细的增删改查的方法如下所示：</p><p>（1）增加操作</p><p>法一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu1 = Student(name=<span class="string">"Aaron"</span>, age=<span class="number">23</span>)</span><br><span class="line">stu1.save()</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.objects.create(name=<span class="string">"Aaron"</span>, age=<span class="number">23</span>)</span><br></pre></td></tr></table></figure><p>（2）删除操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student.objects.all().delete()               <span class="comment">#删除表中所有数据</span></span><br><span class="line">Student.objects.get(name=<span class="string">'Aaron'</span>).delete()   <span class="comment">#删除name等于Aaron的数据</span></span><br><span class="line">Student.objects.filter(age=<span class="number">20</span>).delete()      <span class="comment">#删除age等于20的多条数据</span></span><br></pre></td></tr></table></figure><p>（3）修改操作</p><p>法一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu = Student.objects.get(name=<span class="string">'Aaron'</span>)</span><br><span class="line">stu.name = <span class="string">'Zhang'</span></span><br><span class="line">stu.save()</span><br></pre></td></tr></table></figure><p>法二（更新多个字段）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.objects.get(name=<span class="string">'Aaron'</span>).update(name=<span class="string">'Zhang'</span>, age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>法三（更新所有字段）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.objects.all().update(name=<span class="string">'Zhang'</span>)</span><br></pre></td></tr></table></figure><p>（4）查询操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Student.objects.all()                           <span class="comment">#查表中所有记录</span></span><br><span class="line">Student.objects.all().values()                  <span class="comment">#查询带字段名的所有记录，就是将所有记录以key-value的形式保存在字典中</span></span><br><span class="line">Student.objects.get(name=<span class="string">'Aaron'</span>)               <span class="comment">#查询单条记录，查询name字段是Aaron的这条数据，如果返回多条记录或查询结果为空，都会报异常，需结合try/except一起使用</span></span><br><span class="line">Student.objects.filter(name=<span class="string">'Aaron'</span>)            <span class="comment">#查询匹配条件的多条数据，查询name字段值为Aaron的所有匹配数据，括号中匹配条件可多个，以逗号分隔。注意filter与上面get方法的区别</span></span><br><span class="line">Student.objects.filter(name__contains=<span class="string">"A"</span>)      <span class="comment">#模糊查询，查询name字段中值包含A的记录</span></span><br><span class="line">Student.objects.order_by(<span class="string">'age'</span>)                 <span class="comment">#将字段内容排序后显示，根据Aaron字段的内容进行排序后输出结果</span></span><br><span class="line">Student.objects.order_by(<span class="string">'-age'</span>)                <span class="comment">#将字段内容逆序后显示，只需要加一个-号就可以达到逆序输出的效果</span></span><br><span class="line">Student.objects.filter(age=<span class="number">20</span>).order_by(<span class="string">"-age"</span>) <span class="comment">#多重查询，比如过滤后逆序输出</span></span><br><span class="line">Student.objects.filter(age=<span class="number">20</span>)[<span class="number">0</span>]               <span class="comment">#限制数据条数，[0]取第一条记录，[0:2]取前两条记录，切片不支持负数，可以使用上面先逆序排列后再输出达到这个效果</span></span><br></pre></td></tr></table></figure><h1 id="使用django工具管理数据库"><a href="#使用django工具管理数据库" class="headerlink" title="使用django工具管理数据库"></a>使用django工具管理数据库</h1><p>migration，翻为“迁移”，django会将每一次模型的model的变更记录到migration文件中。简单来说，在appname/migrations目录下有很多migration文件，我们可以理解每一个文件都对应了对数据的一次变更操作，而且我们就可以通过sqlmigrate工具将migration文件转换成原始的SQL语句。在Django中，关于数据库的操作有如下一些常用的命令：</p><p>（1）<code>python manage.py makemigrations</code></p><p>根据models.py中的定义的模型，生成appname/migrations下的Python文件。若是对某个model的局部进行修改，执行完makemigrations后，会生成一个新的Python文件，该Python文件只对应这个局部修改。所以当我们每次在修改model.py时，执行makemigrations命令，都会在appname/migrations下生成一些Python文件。</p><p>appname/migrations目录下的migration文件一般为0001_xxx.py,0002_xxx.py,0003_xxx.py….等，可以理解为每一次修改model，都会对应一个migration文件。</p><p>备注：<code>python manage.py makemigrations</code>后可以紧接着appname，表示只对指定app的model的变更来生成相应的migrations文件。</p><p>（2）将makemigrations生成的migration文件，应用到数据库上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>（3）清空数据库中表的内容，但表不会删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py flush</span><br></pre></td></tr></table></figure><p>（4）查看django项目中所有的app的migration文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py showmigrations</span><br></pre></td></tr></table></figure><p>（5）查看指定的migration文件对应的原始SQL语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py sqlmigrate appname migrationname</span><br></pre></td></tr></table></figure><p>举例来说，<code>python manage.py sqlmigrate appname 0002_auto_20171026_1045</code>表示查看名称为appname的APP的0002_auto_20171026_1045.py文件对应的原始SQL语句。</p><p>学习资料参考于：<br><a href="http://blog.csdn.net/ZCF1002797280/article/details/49559863" target="_blank" rel="noopener">http://blog.csdn.net/ZCF1002797280/article/details/49559863</a></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python WEB开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django系列（4）_模板template的使用</title>
      <link href="/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89-%E6%A8%A1%E6%9D%BFtemplate%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89-%E6%A8%A1%E6%9D%BFtemplate%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="django中模板引擎简介"><a href="#django中模板引擎简介" class="headerlink" title="django中模板引擎简介"></a>django中模板引擎简介</h1><p>目前django支持的模板引擎有：</p><p>（1）Django Template engine，是django自带的模板引擎</p><p>（2）jinja2</p><p>（3）其他第三方的模板引擎</p><h1 id="django中模板template的使用方法"><a href="#django中模板template的使用方法" class="headerlink" title="django中模板template的使用方法"></a>django中模板template的使用方法</h1><p>（1）模板template的配置</p><p>在myproject/settings.py中，配置TEMPLATES变量，格式和内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [],</span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>备注：</p><pre><code>BACKEND：配置django使用哪种模板引擎，目前支持django.template.backends.django.DjangoTemplates和django.template.backends.jinja2.Jinja2两种DIRS：配置django在哪些目录中查找模板，查找顺序和DIRS元组的元素顺序一致APP_DIRS：引擎是否在已安装APP（的目录）内查找模板源文件。配置为true或falseOPTIONS：传递给该模板引擎（backend）的其他参数。不同的引擎，可用的参数不一样</code></pre><p>（2）编写模板文件</p><p>如果我们使用django自带的模板引擎，我们可以使用django模板引擎的DTL语言来编写模板文件。模板文件的内容形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if latest_question_list %&#125;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">    &#123;% for question in latest_question_list %&#125;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;/polls/&#123;&#123; question.id &#125;&#125;/&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &lt;p&gt;No polls are available.&lt;/p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>（3）模板渲染并返回响应对象</p><p>模板渲染有两种方式：</p><p>A）普通常规方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> loader</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line">    template = loader.get_template(<span class="string">'polls/index.html'</span>)</span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">'latest_question_list'</span>: latest_question_list,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(template.render(context, request))</span><br></pre></td></tr></table></figure><p>备注：使用loader加载模板引擎，然后向模板填充数据，最终返回一个HttpResponse对象给客户端。</p><p>B）简单快捷方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line">    context = &#123;<span class="string">'latest_question_list'</span>: latest_question_list&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/index.html'</span>, context)</span><br></pre></td></tr></table></figure><p>备注：直接使用django.shortcuts.render函数即可。</p><p>学习资料参考于：<br><a href="https://docs.djangoproject.com/en/1.11/topics/templates/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/1.11/topics/templates/</a></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python WEB开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django系列（3）_view的开发</title>
      <link href="/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89-view%E7%9A%84%E5%BC%80%E5%8F%91/"/>
      <url>/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89-view%E7%9A%84%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>在django应用中，view是url路由后，所执行的回调函数。在django的view形式有两种，一种是view函数，一种是基于class的view。</p><h1 id="基础的view函数"><a href="#基础的view函数" class="headerlink" title="基础的view函数"></a>基础的view函数</h1><p>view函数是编写在app_name/views.py中的普通函数，然后再url路由中关联到该view函数即可。举例来说：</p><p>名称为getDetailInfo的view函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> polls.models <span class="keyword">import</span> Poll</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDetailInfo</span><span class="params">(request, poll_id)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = Poll.objects.get(pk=poll_id)</span><br><span class="line">    <span class="keyword">except</span> Poll.DoesNotExist:</span><br><span class="line">        <span class="keyword">raise</span> Http404(<span class="string">"Poll does not exist"</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;<span class="string">'poll'</span>: p&#125;)</span><br></pre></td></tr></table></figure><p>url路由规则的设定如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^detailinfo$'</span>, views.getDetailInfo, name=<span class="string">'getdetailinfo'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="基于class的高级view"><a href="#基于class的高级view" class="headerlink" title="基于class的高级view"></a>基于class的高级view</h1><p>开发基于class的高级view的步骤如下：</p><p>（1）开发基于class的高级view类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="comment">#balabala</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'http getmethod..'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="comment">#balabala</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'http post method..'</span>)</span><br></pre></td></tr></table></figure><p>备注：该view类继承django.views.View，当然也可以继承其他一些类，如django.views.generic.ListView。</p><p>（2）url路由绑定到view类</p><p>django的路由配置，是通过url映射到回调函数上，而不是类。但是基于class的View类提供了一个as_view()函数，as_view()会创建一个view实例并调用实例的dispatch()方法，然后由dispatch()将请求映射到具体的post或get等方法上。</p><p>举例来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^about/$'</span>, MyView.as_view(greeting=<span class="string">"HelloWorld!!!"</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="https://docs.djangoproject.com/en/1.11/topics/class-based-views/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/1.11/topics/class-based-views/</a></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python WEB开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django系列（2）_url路由配置</title>
      <link href="/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89-url%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89-url%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Django的url路由过程"><a href="#Django的url路由过程" class="headerlink" title="Django的url路由过程"></a>Django的url路由过程</h1><p>Django的url路由过程如下：</p><p>（1）django通过settings.py中ROOT_URLCONF参数来确定url根路由文件。一般都是project_name/project_name/urls.py。</p><p>（2）django在根路由文件中，读取urlpatterns变量（urlpatterns变量是包含了<code>django.conf.urls.url()</code>实例的list，每一个url实例是url和回调函数的映射）。</p><p>（3）django按照urlpatterns列表中元素的先后顺序进行匹配，直到第一个匹配的<code>django.conf.urls.url()</code>实例。</p><p>（4）匹配后，分两种情况，如果url()实例的回调部分是一个普通的view函数，则直接执行该函数即可。如果url()实例的回调部分是一个include定义的外部urlconf规则，那么会将url路由交给外部的urlconf继续路由处理。</p><p>备注：若没有匹配到任何路由，则会返回错误信息给用户。</p><h1 id="url路由配置举例"><a href="#url路由配置举例" class="headerlink" title="url路由配置举例"></a>url路由配置举例</h1><p>（1）基本的url路由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^index/$'</span>, views.getallhost, name=<span class="string">'main-view'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>（2）加载外部的url路由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^api/hostname/'</span>, include(<span class="string">'testapp.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>备注：在上述例子中，需要在testapp这个app中定义一个urls.py文件，然后在urls.py文件中定义urlpatterns变量。另外包含了include外部路由的url()对象，正则表达式部分一定要是斜杠(/)结尾哦。django会将http请求的url截断掉匹配的部分（上述例子中就会截断掉api/hostname/），然后将剩余的部分交给testapp.urls这个外部路由规则继续处理。举例来说，用户访问的url为<code>http://ip:port/api/hostname/update</code>，那么会截断掉api/hostname/部分，剩下的update交给testapp.urls来处理。</p><p>学习内容参考于：<br><a href="https://docs.djangoproject.com/en/1.11/topics/http/urls/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/1.11/topics/http/urls/</a></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python WEB开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django系列（1）_Django简介和安装使用</title>
      <link href="/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89-Django%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/01/28/Django%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89-Django%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Django简介"><a href="#Django简介" class="headerlink" title="Django简介"></a>Django简介</h1><p>Python下有许多款不同的Web框架。Python WEB框架通常包含WSGI Server和WEB Framework两个部分。WSGI Server其实就是HTTP Server，它主要实现WSGI协议，用来和WEB Framework对接，使得socket层对请求的处理与Framework层对请求的处理分离开来，这样Framework就不用关心底层的实现。Django是重量级选手中最有代表性的一位。许多网站和APP都基于Django。 Django是一个开放源代码的Web应用框架，由Python写成。Django遵守BSD版权，初次发布于2005年7月, 并于2008年9月发布了第一个正式版本1.0。Django的优势如下：</p><p>（1）快速web开发</p><p>Python web框架。</p><p>（2）大量内置应用</p><p>例如后台管理系统admin、用户认证系统auth、会话系统sessions等等。</p><p>（3）安全性高</p><p>提供表单验证、SQL注入、跨站点访问等支持。</p><p>（4）易于扩展</p><p>引入APP的概念，以APP来扩展WEB项目。</p><h1 id="Django内部工作流程"><a href="#Django内部工作流程" class="headerlink" title="Django内部工作流程"></a>Django内部工作流程</h1><p><img src="/images/django_1_4.png" alt="django工作流程图"></p><p>我的理解，上图中Request Middlewares，View Middlewares以及Response Middlewares其实就指的是各个中间件的process_request、process_view以及process_response等等函数。</p><pre><code>1.用户通过浏览器请求一个页面的url2.请求到达Request Middlewares（中间件），中间件对request做一些预处理或者直接response请求3.URLConf通过urls.py文件和请求的URL找到相应的View（视图）4.View Middlewares被访问，它同样可以对request做一些处理或者直接返回response5.调用View中的函数6.View中的方法可以选择性的通过Models访问底层的数据7.所有的Model-to-DB的交互都是通过manager完成的8.如果需要，Views可以使用一个特殊的Context（上下文处理器）9.Context被传给Template（存放前段文件）用来生成页面    a.Template使用Filters和Tags去渲染输出    b.输出被返回到View    c.HTTPResponse被发送到Response Middlewares    d.任何Response Middlewares都可以丰富response或者返回一个完全不同的response    e.Response返回到浏览器，呈现给用户</code></pre><h1 id="Django的安装"><a href="#Django的安装" class="headerlink" title="Django的安装"></a>Django的安装</h1><p>Django的安装有pip和源码安装两种方式（本次使用的是Django 1.11.2，Python环境是2.7.13），如下：</p><p>（1）pip</p><p>直接执行如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Django==1.11.2</span><br></pre></td></tr></table></figure><p>（2）源码安装</p><p>下载pytz 2017.2 版本；下载Django 1.11.2版本。分别解压，然后通过<code>python setup.py install</code>先安装pytz，再安装Django即可。二者被安装到lib/python2.7/site-packages目录中。</p><p>备注：使用<code>python -m django --version</code>命令查看是否安装成功</p><h1 id="创建Django-web-project"><a href="#创建Django-web-project" class="headerlink" title="创建Django web project"></a>创建Django web project</h1><p>安装完django之后，就拥有django-admin工具命令了，该工具可以用来创建项目、创建APP等等。可以执行执行<code>django-admin help</code>查看其支持的子命令。</p><p>（1）创建Django web项目</p><p>执行命令<code>django-admin startproject testproject</code>命令，创建一个名称为testproject的WEB项目。在当前目录自动生成如下目录结构：</p><p><img src="/images/django_1_1.png" alt="django工程目录结构"></p><p>其中各个文件的作用简单说明如下：</p><pre><code>manage.py   #与项目进行交互的命令工具集，例如启动服务器、数据库操作、Django Shell等等。可以执行python manage.py来查看其支持的子命令。例如python manage.py runserverwsgi.py     #Python应用和WEB服务器的通信协议urls.py     #url路由settings.py #项目的总配置文件，里面包括了数据库、web应用、时间等各种配置，非常重要__init__.py #包的__init__.py，说明我们的项目目录是一个python package，可以被import导入</code></pre><p>（2）启动web server</p><p>执行如下命令即可启动web server：</p><pre><code>cd testproject &amp;&amp; python manage.py runserver             #监听127.0.0.1:8000cd testproject &amp;&amp; python manage.py runserver 8080        #指定监听端口cd testproject &amp;&amp; python manage.py runserver realip:8080 #监听realip:8080</code></pre><p>（3）测试</p><p>在浏览器中输入<code>http://ip:port</code>即可访问。效果如下：</p><p><img src="/images/django_1_2.png" alt="django helloworld页面"></p><h1 id="在web-project中创建app"><a href="#在web-project中创建app" class="headerlink" title="在web project中创建app"></a>在web project中创建app</h1><p>创建app的过程大致为：</p><p>首先执行命令<code>python manage.py startapp testapp</code>创建一个名称为testapp的应用，然后添加应用名到setting中的INSTALLED_APPS里面，最后是编写app的具体的业务逻辑以及配置url路由等。</p><p>备注：Django官网演示的demo是将app目录和manage.py，以及project目录是同级，其实app的目录可以放到任何位置，所有怎么组织一个基于Django项目的目录结构是很灵活的。</p><p>自动生成如下的APP目录结构如下：</p><p><img src="/images/django_1_3.png" alt="django web app目录结构"></p><p>其中各个文件的作用简单说明如下：</p><pre><code>views.py  #view.py中定义了很多函数，这些函数是url路由请求的响应函数。每个函数最终返回的是html文件model.py  #定义数据库表，用来做ORM映射的admin.py  #用来给Djanjo内置的admin app来使用，用来做该APP的admin后台相关的操作tests.py  #用来做测试使用的</code></pre><h1 id="Django中project和app的区别"><a href="#Django中project和app的区别" class="headerlink" title="Django中project和app的区别"></a>Django中project和app的区别</h1><p>Django有project和app两个概念。project的范畴是整个项目工程，包含一些全局配置，这些配置构成一个全局的运行平台。app代表的是project一个相对独立的功能模块，业务逻辑都在各个app中。</p><h1 id="关于Django和Tornado的区别"><a href="#关于Django和Tornado的区别" class="headerlink" title="关于Django和Tornado的区别"></a>关于Django和Tornado的区别</h1><p>我们知道，Python WEB框架包括WSGI Server和WSGI APP两部分。Django的WSGI Server是基于wsgiref.simple_server而来的。而Tornado的WSGI Server是基于epoll IO复用技术从头实现的，是一套异步应用服务器。因此，从功能上来看，Django有大而全的特点；从处理并发上来看，Tornado支持异步server，有优异的并发处理能力。</p><p>wsgiref是Python自带的模块，第三方WSGI Server有werkzeug、gunicorn以及gevent等，如下是wsgiref用法的一个小例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    httpd = make_server(<span class="string">''</span>, <span class="number">9999</span>, application)</span><br><span class="line">    print(<span class="string">"Serving HTTP on port 9999..."</span>)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure><p>学习资料参考于：<br><a href="http://python.jobbole.com/85296/" target="_blank" rel="noopener">http://python.jobbole.com/85296/</a><br><a href="https://juejin.im/entry/58c613762f301e006bc6d700" target="_blank" rel="noopener">https://juejin.im/entry/58c613762f301e006bc6d700</a></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python WEB开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>山水美景</title>
      <link href="/2018/01/28/%E5%B1%B1%E6%B0%B4%E7%BE%8E%E6%99%AF/"/>
      <url>/2018/01/28/%E5%B1%B1%E6%B0%B4%E7%BE%8E%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="美丽山水"><a href="#美丽山水" class="headerlink" title="美丽山水"></a>美丽山水</h3><p><img src="/images/test.jpg" alt="山水画1"><br><img src="/images/test_1.jpg" alt="山水画2"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
